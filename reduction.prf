(reduction
 (to_topstate_TCC1 0
  (to_topstate_TCC1-1 nil 3699115446
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((cpure? def-decl "bool" IL nil)) nil
   (to_topstate subtype "IL.hole" "{K | IL.cpure?(K)}")))
 (to_topstate_TCC2 0
  (to_topstate_TCC2-1 nil 3699115446
   ("" (skeep*)
    (("" (ground)
      (("1" (skeep*)
        (("1" (rewrite refs_fill)
          (("1" (typepred "eS`redex") (("1" (grind) nil nil)) nil)
           ("2" (use contextPurefill)
            (("2" (typepred "eS`context")
              (("2" (typepred "eS`redex") (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite popdepth_fill)
          (("2" (rewrite vars_decompose)
            (("2" (typepred "eS`redex") (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (typepred "eS`redex")
        (("4" (rewrite popdepth_fill) (("4" (grind) nil nil)) nil))
        nil)
       ("5" (use contextPurefill)
        (("5" (typepred "eS`context")
          (("5" (typepred "eS`redex") (("5" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs_fill formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (contextPurefill formula-decl nil IL nil)
    (popdepth_fill formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_decompose formula-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (to_topstate subtype "IL.fill(eS`context, eS`redex)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES eS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < eS`stack`length) AND (FORALL i: IL.vars(IL.hole)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(IL.hole) < eS`stack`length) AND (IL.popDepth(A) + IL.popDepth(IL.hole) <= eS`stack`length) AND IL.contextPure?(A)}")))
 (to_topstate_TCC3 0
  (to_topstate_TCC3-1 nil 3699115446 ("" (subtype-tcc) nil nil) nil nil
   (to_topstate subtype
    "eS WITH [`context := IL.hole, `redex := IL.fill(eS`context, eS`redex)]"
    "topstate")))
 (variableReduce_TCC1 0
  (variableReduce_TCC1-1 nil 3705846888
   ("" (skeep* :preds? t)
    (("" (typepred "gS`redex") (("" (grind) nil nil)) nil)) nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "gS`redex"
    "{x | IExpression_adt.index(IL.x) < gS`stack`length}")))
 (variableReduce_TCC2 0
  (variableReduce_TCC2-1 nil 3705846888
   ("" (skeep* :preds? t)
    (("" (typepred "gS`redex")
      (("" (split)
        (("1" (skeep)
          (("1" (typepred "gS`stack")
            (("1" (typepred "get(gS`stack)(gS`redex)")
              (("1" (inst -5 "index(gS`redex)") (("1" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (typepred "get(gS`stack)(gS`redex)")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3" (skeep*)
          (("3" (inst -4 i)
            (("3" (typepred "get(gS`stack)(gS`redex)")
              (("3" (grind) nil nil)) nil))
            nil))
          nil)
         ("4" (typepred "get(gS`stack)(gS`redex)")
          (("4" (grind) nil nil)) nil)
         ("5" (typepred "get(gS`stack)(gS`redex)")
          (("5" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "IL.get(gS`stack)(gS`redex)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (letReduce_TCC1 0
  (letReduce_TCC1-1 nil 3646200513 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (letReduce subtype "expr" "(IExpression_adt.letexpr?)")))
 (letReduce_TCC2 0
  (letReduce_TCC2-1 nil 3646200513 ("" (grind :if-match all) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype "IExpression_adt.letrhs(expr)" "(IL.value?)")))
 (letReduce_TCC3 0
  (letReduce_TCC3-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (skeep :preds? t)
        (("" (expand push)
          (("" (expand add)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (typepred "stack") (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (push const-decl "Stack" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype "IL.push(IExpression_adt.letrhs(expr), stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(gS`domain))(S)}")))
 (letReduce_TCC4 0
  (letReduce_TCC4-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (skeep)
        (("1" (expand refs)
          (("1" (use pure_refs) (("1" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (expand vars -1)
          (("2" (expand drop -1)
            (("2" (expand push +)
              (("2" (expand popDepth +)
                (("2" (expand add +)
                  (("2" (assert)
                    (("2" (rewrite purePopDepth)
                      (("1" (inst -3 "i")
                        (("1" (split)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep* :preds? t)
        (("3" (expand popDepth + 1)
          (("3" (rewrite purePopDepth)
            (("1" (inst -5 i) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("4" (expand popDepth + 1)
        (("4" (rewrite purePopDepth)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil)
       ("5" (expand contextPure? +)
        (("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((refs def-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (pure_refs formula-decl nil IL nil)
    (push const-decl "Stack" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (purePopDepth formula-decl nil IL nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_contextPure formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype "IExpression_adt.pop(IExpression_adt.body(expr))"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < IL.push(IExpression_adt.letrhs(expr), stack)`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < IL.push(IExpression_adt.letrhs(expr), stack)`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= IL.push(IExpression_adt.letrhs(expr), stack)`length) AND IL.contextPure?(A)}")))
 (set_redex_correct 0
  (set_redex_correct-1 nil 3700921149
   ("" (skeep)
    (("" (typepred "gS`redex")
      (("" (case-replace "popDepth(u) = 0")
        (("1" (split)
          (("1" (typepred u) (("1" (grind) nil nil)) nil)
           ("2" (typepred u) (("2" (grind) nil nil)) nil)
           ("3" (skeep) (("3" (inst -5 i) (("3" (grind) nil nil)) nil))
            nil)
           ("4" (grind) nil nil)
           ("5" (typepred u) (("5" (grind) nil nil)) nil))
          nil)
         ("2" (typepred u) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (emptyset const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak))
 (updateReduce_TCC1 0
  (updateReduce_TCC1-1 nil 3646200513 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (updateReduce subtype "expr" "(IExpression_adt.update?)")))
 (updateReduce_TCC2 0
  (updateReduce_TCC10-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (inst -2 "index(target(expr))") (("" (grind) nil nil)) nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.ref(newref)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES newdomain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (updateReduce_TCC3 0
  (updateReduce_TCC11-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (inst -3 "index(lhs(expr))") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (updateReduce subtype "newstore" "Store(newdomain)")))
 (updateReduce_TCC4 0
  (updateReduce_TCC2-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (inst -5 "index(rhs(expr))") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.target(expr)"
    "{x | IExpression_adt.index(IL.x) < stack`length}")))
 (updateReduce_TCC5 0
  (updateReduce_TCC3-1 nil 3646200513
   ("" (ground)
    (("" (skeep* :preds? t)
      (("" (expand* every get)
        (("" (inst -11 "stack`length - 1 - index(target(expr))")
          (("1" (grind) nil nil)
           ("2" (inst -5 "index(target(expr))") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction
     nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (expr skolem-const-decl "{A |
        (FORALL i: refs(A)(i) IMPLIES gS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < gS`stack`length)
    AND (FORALL i:
           vars(gS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(gS`context) < gS`stack`length)
    AND (popDepth(A) + popDepth(gS`context) <= gS`stack`length)
    AND contextPure?(A)}" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (updateReduce subtype "IExpression_adt.lhs(expr)"
    "{x | IExpression_adt.index(IL.x) < stack`length}")))
 (updateReduce_TCC6 0
  (updateReduce_TCC4-1 nil 3646200513
   ("" (ground)
    (("" (skeep* :preds? t)
      (("" (expand* every get)
        (("" (inst -13 "stack`length-1-index(target(expr))")
          (("1" (grind) nil nil)
           ("2" (inst -7 "index(target(expr))") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (emptyset const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction
     nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (expr skolem-const-decl "{A |
        (FORALL i: refs(A)(i) IMPLIES gS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < gS`stack`length)
    AND (FORALL i:
           vars(gS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(gS`context) < gS`stack`length)
    AND (popDepth(A) + popDepth(gS`context) <= gS`stack`length)
    AND contextPure?(A)}" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (updateReduce subtype "IExpression_adt.rhs(expr)"
    "{x | IExpression_adt.index(IL.x) < stack`length}")))
 (updateReduce_TCC7 0
  (updateReduce_TCC7-1 "" 3710688528
   ("" (expand "get")
    (("" (skeep*)
      (("" (typepred "gS`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   nil shostak
   (updateReduce subtype "IExpression_adt.value(reduction.lval)"
    "below[store(oldref)`length]"))
  (updateReduce_TCC5-1 nil 3646200513
   ("" (expand "get")
    (("" (skeep*)
      (("" (typepred "gS`stack")
        (("" (grind)
          (("" (typepred "gS`redex")
            (("" (typepred gS)
              (("" (inst -3 "index(target(gS`redex))")
                (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil
   (updateReduce subtype "IExpression_adt.refindex(aval)"
    "(gS`domain)")))
 (updateReduce_TCC8 0
  (updateReduce_TCC6-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (expand* every get)
      (("" (inst -13 "stack`length-1-index(rhs(expr))")
        (("1" (grind) nil nil)
         ("2" (inst -7 "index(rhs(expr))") (("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (emptyset const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction
     nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (expr skolem-const-decl "{A |
        (FORALL i: refs(A)(i) IMPLIES gS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < gS`stack`length)
    AND (FORALL i:
           vars(gS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(gS`context) < gS`stack`length)
    AND (popDepth(A) + popDepth(gS`context) <= gS`stack`length)
    AND contextPure?(A)}" reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (updateReduce subtype "oldref" "(gS`domain)")))
 (updateReduce_TCC9 0
  (updateReduce_TCC7-1 nil 3646200513
   ("" (expand "get")
    (("" (skeep* :preds? t)
      (("" (expand every)
        (("" (skeep)
          (("" (inst -13 i)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil)
    (i skolem-const-decl "below(gS`stack`length)" reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction
     nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (add const-decl "(nonempty?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/"))
   nil
   (updateReduce subtype "IExpression_adt.value(lval)"
    "below[store(oldref)`length]")))
 (updateReduce_TCC10 0
  (updateReduce_TCC8-1 nil 3646200513
   ("" (skeep* :preds? t)
    (("" (typepred "gS`redex")
      (("" (split +)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil)
         ("5" (grind) nil nil))
        nil))
      nil))
    nil)
   ((updateRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (emptyset const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (updateReduce subtype "rval" "(IL.domainValue?(gS`domain))")))
 (updateReduce_TCC11 0
  (updateReduce_TCC9-1 nil 3646200513
   ("" (skeep*)
    (("" (typepred "gS`stack")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep :preds? t)
          (("2" (case-replace "x1 = newref")
            (("1" (replace -18)
              (("1" (assert)
                (("1" (case-replace "x2 = value(lval)")
                  (("1" (assert)
                    (("1" (expand every)
                      (("1" (inst -4 "stack`length-1-index(rhs(expr))")
                        (("1" (grind) nil nil)
                         ("2" (typepred "gS`redex")
                          (("2" (inst -2 "index(rhs(expr))")
                            (("2" (split -2)
                              (("1" (grind) nil nil)
                               ("2"
                                (assert)
                                (("2"
                                  (typepred gS)
                                  (("2"
                                    (expand updateRedex?)
                                    (("2"
                                      (assert)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (typepred "store(oldref)`seq(x2)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "store(x1)`seq(x2)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (expr skolem-const-decl "{A |
        (FORALL i: refs(A)(i) IMPLIES gS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < gS`stack`length)
    AND (FORALL i:
           vars(gS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(gS`context) < gS`stack`length)
    AND (popDepth(A) + popDepth(gS`context) <= gS`stack`length)
    AND contextPure?(A)}" reduction nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil))
   nil
   (updateReduce subtype "gS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(newdomain))(S)}")))
 (popit_TCC1 0
  (popit_TCC1-1 nil 3650126116 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (popit subtype "i - 1" "nat")))
 (popit_TCC2 0
  (popit_TCC2-1 nil 3650126116 ("" (termination-tcc) nil nil) nil nil
   (popit termination "popit(i - 1)" "nil")))
 (popit_pure_TCC1 0
  (popit_pure_TCC1-1 nil 3650252343
   ("" (skeep*)
    (("" (typepred A) (("" (use pure_refs) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure_refs formula-decl nil IL nil))
   nil
   (popit_pure_ subtype "A" "{B | (FORALL j: NOT IL.refs(B)(j))}")))
 (popit_pure_TCC2 0
  (popit_pure_TCC2-1 nil 3650252343
   ("" (skeep*)
    (("" (typepred "v(i - 1)(A)")
      (("1" (inst - "j") (("1" (grind) nil nil)) nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (pure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (popit_pure_ subtype "IExpression_adt.pop(v(i - 1)(A))"
    "{B | (FORALL j: NOT IL.refs(B)(j))}")))
 (popit_pure 0
  (popit_pure-1 nil 3650251073
   ("" (induct-and-simplify "i")
    (("" (typepred "A!1")
      (("" (use "pure_refs") (("" (ground) nil nil)) nil)) nil))
    nil)
   ((pure_refs formula-decl nil IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (popit def-decl "IExpression" reduction nil)
    (nat_induction formula-decl nil naturalnumbers nil))
   nil))
 (popit_refcount 0
  (popit_refcount-1 nil 3682268921
   ("" (induct-and-simplify "j") nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refcount def-decl "nat" IL nil)
    (popit def-decl "IExpression" reduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (popit_refs 0
  (popit_refs-1 nil 3682294639 ("" (induct-and-simplify "j") nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil)
    (popit def-decl "IExpression" reduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (popit_var_TCC1 0
  (popit_var_TCC1-1 nil 3650252343
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popit_var_ subtype "A"
    "{B | (FORALL j: IL.vars(B)(j) = IL.vars(A)(i + j))}")))
 (popit_var_TCC2 0
  (popit_var_TCC2-1 nil 3650252343
   ("" (recursive-judgement-tcc)
    (("1" (typepred "v!1(i!1 - 1)(A!1)") (("1" (grind) nil nil)) nil)
     ("2" (typepred "v!1(i!1 - 1)(A!1)") (("2" (grind) nil nil)) nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (drop const-decl "finite_set[nat]" IL nil) nil)
   nil
   (popit_var_ subtype "IExpression_adt.pop(v(i - 1)(A))"
    "{B | (FORALL j: IL.vars(B)(j) = IL.vars(A)(i + j))}")))
 (popit_var 0
  (popit_var-1 nil 3650251073 ("" (judgement-tcc) nil nil) nil nil))
 (popit_popDepth 0
  (popit_popDepth-1 nil 3650382470
   ("" (induct-and-simplify "i") nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil
    (popit def-decl "IExpression" reduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popit_var rec-application-judgement
     "{B | (FORALL j: vars(B)(j) = vars(A)(j + i))}" reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (popitContextPure_TCC1 0
  (popitContextPure_TCC1-1 nil 3650511560
   ("" (skeep*)
    (("" (typepred A)
      (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_contextPure formula-decl nil IL nil))
   nil (popitContextPure_ subtype "A" "(IL.contextPure?)")))
 (popitContextPure_TCC2 0
  (popitContextPure_TCC2-1 nil 3650511560
   ("" (skosimp*)
    (("" (typepred "v!1(i!1 - 1)(A!1)")
      (("1" (grind :if-match nil) nil nil)
       ("2" (grind :if-match nil) nil nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (popit_var rec-application-judgement
     "{B | (FORALL j: vars(B)(j) = vars(A)(j + i))}" reduction nil)
    (popit_pure rec-application-judgement
     "{B | (FORALL j: NOT refs(B)(j))}" reduction nil))
   nil
   (popitContextPure_ subtype "IExpression_adt.pop(v(i - 1)(A))"
    "(IL.contextPure?)")))
 (letApply_TCC1 0
  (letApply_TCC1-1 nil 3683776766
   ("" (skeep*) (("" (typepred "args") (("" (grind) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (letApply subtype "args" "(cons?[(IExpression_adt.variable?)])")))
 (letApply_TCC2 0
  (letApply_TCC2-1 nil 3683776766
   ("" (skeep*) (("" (typepred "args") (("" (grind) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil (letApply subtype "x" "(IExpression_adt.variable?)")))
 (letApply_TCC3 0
  (letApply_TCC3-1 nil 3683776766 ("" (skeep*) nil nil) nil nil
   (letApply subtype "x WITH [`index := IExpression_adt.index(x) + 1]"
    "(IExpression_adt.variable?)")))
 (letApply_TCC4 0
  (letApply_TCC4-1 nil 3705953715
   ("" (skeep* :preds? t)
    (("" (rewrite map_length)
      (("" (expand length -) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (letApply subtype
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: x WITH [(IExpression_adt.index) := IExpression_adt.index(x) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))"
    "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1}")))
 (letApply_TCC5 0
  (letApply_TCC5-1 nil 3683826670
   ("" (skeep*) (("" (typepred "args") (("" (grind) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (letApply subtype "args" "(cons?[(IExpression_adt.variable?)])")))
 (pure_letApply_TCC1 0
  (pure_letApply_TCC1-1 nil 3683813520
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (pure_letApply_ subtype "IExpression_adt.letexpr(arg1, B)"
    "(IL.pure?)")))
 (vars_letApply 0
  (vars_letApply-1 nil 3683816781
   ("" (induct "i")
    (("1" (grind) (("1" (expand "some") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skeep*)
      (("2" (expand "letApply" +)
        (("2" (inst?)
          (("2" (inst?)
            (("2" (expand "vars" + 1)
              (("2" (typepred "args")
                (("2" (grind)
                  (("1" (rewrite "some_nth")
                    (("1" (rewrite "some_nth")
                      (("1" (skeep)
                        (("1" (rewrite "map_nth_rw")
                          (("1" (inst + "i + 1")
                            (("1" (grind) nil nil)
                             ("2" (expand "length")
                              (("2"
                                (grind)
                                (("2"
                                  (typepred "i")
                                  (("2"
                                    (rewrite "map_length")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "i")
                            (("2" (rewrite "map_length") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 1 2 3)
                    (("2" (rewrite "some_nth")
                      (("2" (inst + 0) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (hide 1 3)
                    (("3" (rewrite "some_nth")
                      (("3" (rewrite "some_nth")
                        (("3" (skeep)
                          (("3" (inst + "i - 1")
                            (("1" (rewrite "map_nth_rw")
                              (("1"
                                (grind)
                                (("1"
                                  (expand "nth" -)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (expand "length" -)
                                  (("2"
                                    (typepred "i")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "map_length")
                              (("2"
                                (expand "length" -)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    nil
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[T]" countability "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_finite_union1 application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (map_length formula-decl nil more_map_props nil)
    (nth def-decl "T" list_props nil) nil nil nil
    (some_nth formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (letApply def-decl "IExpression" reduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (popdepth_letApply 0
  (popdepth_letApply-1 nil 3693281813 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (letApply def-decl "IExpression" reduction nil) nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (applyReduce_TCC1 0
  (applyReduce_TCC1-1 nil 3650158977 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (applyReduce subtype "expr" "(IExpression_adt.application?)")))
 (applyReduce_TCC2 0
  (applyReduce_TCC2-1 nil 3650158977
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce subtype "args"
    "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity}")))
 (applyReduce_TCC3 0
  (applyReduce_TCC3-2
   "partial proof for modified (9/25/16) applyReduce" 3683812442
   ("" (skeep*)
    (("" (ground)
      (("1" (skeep)
        (("1" (typepred "letApply(arity, args, body)")
          (("1" (rewrite "pure_refs") nil nil)) nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite "purePopDepth")
          (("2" (rewrite "vars_letApply")
            (("2" (ground)
              (("1" (typepred "expr")
                (("1" (inst -2 "i")
                  (("1" (ground)
                    (("1" (typepred "gS")
                      (("1" (expand "vars" +) (("1" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "def`body")
                (("2" (inst - "arity + i") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (typepred "letApply(arity, args, body)")
        (("3" (rewrite "purePopDepth")
          (("3" (assert)
            (("3" (typepred "gS`redex")
              (("3" (skeep*)
                (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (typepred "gS`redex")
        (("4" (rewrite popdepth_letApply)
          (("4" (lift-if)
            (("4" (ground)
              (("1" (typepred gS)
                (("1" (rewrite purePopDepth) (("1" (grind) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (use pure_contextPure) (("5" (grind) nil nil)) nil))
      nil))
    nil)
   ((pure_letApply rec-application-judgement "(pure?)" reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Definition type-eq-decl nil reduction nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (letApply def-decl "IExpression" reduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (vars_letApply formula-decl nil reduction nil)
    (popdepth_letApply formula-decl nil reduction nil)
    (pure_contextPure formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (applyReduce subtype "letApply(arity, args, body)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}"))
  (applyReduce_TCC3-1 nil 3650158977
   ("" (skosimp* :preds? t)
    (("" (expand "pushlist")
      ((""
        (lemma "every_nth"
         ("P" "(LAMBDA (y: {x | index(x) < stack!1`length}): TRUE)"))
        (("" (inst - "args!1")
          (("" (ground)
            (("" (rewrite "every_append")
              (("" (rewrite "every" +)
                (("" (skeep :preds? t)
                  (("" (expand "list2finseq")
                    ((""
                      (lemma
                       "map_nth_rw[{x | index(x) < stack!1`length}, (value?)]")
                      (("" (inst?)
                        (("1" (replace -1 :hide? t)
                          (("1" (expand "every" -12)
                            (("1" (expand "get")
                              (("1"
                                (inst? -12)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "map_length") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pushlist const-decl "Stack" reduction nil)
    (get const-decl "(value?)" IL nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (every_append formula-decl nil finseq_theorems nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (map_length formula-decl nil more_map_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nth def-decl "T" list_props nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (TRUE const-decl "bool" booleans nil)
    (every_nth formula-decl nil list_props nil)
    (Definition type-eq-decl nil reduction nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (applyRedex? const-decl "bool" IL nil))
   nil
   (applyReduce subtype "letApply(arity, args, body)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (ifReduce_TCC1 0
  (ifReduce_TCC1-1 nil 3650256151 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (ifReduce subtype "expr" "(IExpression_adt.ift?)")))
 (ifReduce_TCC2 0
  (ifReduce_TCC2-1 nil 3650256151 ("" (grind :if-match all) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "condition"
    "{x | IExpression_adt.index(IL.x) < stack`length}")))
 (ifReduce_TCC3 0
  (ifReduce_TCC3-1 nil 3650256151
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred gS)
        (("1" (lemma pure_refs) (("1" (grind) nil nil)) nil)) nil)
       ("2" (skeep*)
        (("2" (typepred gS)
          (("2" (typepred "gS`redex")
            (("2" (rewrite purePopDepth 2)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (skeep*)
        (("3" (typepred "gS`redex")
          (("3" (inst -3 i)
            (("3" (typepred gS)
              (("3" (rewrite purePopDepth 2)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (rewrite purePopDepth)
        (("1" (typepred "gS`redex") (("1" (grind) nil nil)) nil)
         ("2" (typepred gS) (("2" (grind) nil nil)) nil))
        nil)
       ("5" (use pure_contextPure)
        (("5" (typepred gS) (("5" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_refs formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (purePopDepth formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pure_contextPure formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "elseexpr"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (ifReduce_TCC4 0
  (ifReduce_TCC4-1 nil 3650256151
   ("" (ground)
    (("" (skeep*)
      (("" (ground)
        (("1" (lemma pure_refs)
          (("1" (typepred gS) (("1" (grind) nil nil)) nil)) nil)
         ("2" (skeep*)
          (("2" (rewrite purePopDepth)
            (("1" (typepred "gS`redex")
              (("1" (inst -2 i)
                (("1" (typepred gS) (("1" (grind) nil nil)) nil)) nil))
              nil)
             ("2" (typepred gS) (("2" (grind) nil nil)) nil))
            nil))
          nil)
         ("3" (rewrite purePopDepth)
          (("1" (skeep*)
            (("1" (typepred "gS`redex")
              (("1" (typepred gS) (("1" (grind) nil nil)) nil)) nil))
            nil)
           ("2" (typepred gS) (("2" (grind) nil nil)) nil))
          nil)
         ("4" (rewrite purePopDepth)
          (("1" (typepred "gS`redex") (("1" (grind) nil nil)) nil)
           ("2" (typepred gS) (("2" (grind) nil nil)) nil))
          nil)
         ("5" (use pure_contextPure)
          (("5" (typepred gS) (("5" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (iftRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "thenexpr"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (lookupReduce_TCC1 0
  (lookupReduce_TCC1-1 nil 3650257308 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (lookupReduce subtype "expr" "(IExpression_adt.lookup?)")))
 (lookupReduce_TCC2 0
  (lookupReduce_TCC2-1 nil 3650257308 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "avar"
    "{x | IExpression_adt.index(IL.x) < stack`length}")))
 (lookupReduce_TCC3 0
  (lookupReduce_TCC3-1 nil 3650257308 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (lookupReduce subtype "pos"
    "{x | IExpression_adt.index(IL.x) < stack`length}")))
 (lookupReduce_TCC4 0
  (lookupReduce_TCC4-1 nil 3650257308 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (lookupReduce subtype "IExpression_adt.refindex(aval)"
    "(gS`domain)")))
 (lookupReduce_TCC5 0
  (lookupReduce_TCC5-1 nil 3650257308
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((get const-decl "(value?)" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "IExpression_adt.value(pval)"
    "below[store(IExpression_adt.refindex(aval))`length]")))
 (lookupReduce_TCC6 0
  (lookupReduce_TCC6-1 nil 3650549580
   ("" (ground)
    (("" (skeep)
      (("" (skeep*)
        (("" (ground)
          (("1" (typepred "store(refindex(aval))`seq(value(pval))")
            (("1" (grind) nil nil)) nil)
           ("2" (typepred "store(refindex(aval))`seq(value(pval))")
            (("2" (grind) nil nil)) nil)
           ("3" (typepred "store(refindex(aval))`seq(value(pval))")
            (("3" (typepred "gS`redex")
              (("3" (skeep*)
                (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil))
              nil))
            nil)
           ("4" (typepred "store(refindex(aval))`seq(value(pval))")
            (("4" (typepred "gS`redex") (("4" (grind) nil nil)) nil))
            nil)
           ("5" (typepred "store(refindex(aval))`seq(value(pval))")
            (("5" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype
    "store(IExpression_adt.refindex(aval))`seq(IExpression_adt.value(pval))"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (newintReduce_TCC1 0
  (newintReduce_TCC1-1 nil 3650374461 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "expr"
    "{x: IExpression_adt.IExpression | IExpression_adt.newint?(x) OR IExpression_adt.newref?(x)}")))
 (newintReduce_TCC2 0
  (newintReduce_TCC2-1 nil 3650374461 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) nil
    nil (OR const-decl "[bool, bool -> bool]" booleans nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "gS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(sets[nat].add(newrefindex, domain)))(S)}")))
 (newintReduce_TCC3 0
  (newintReduce_TCC3-1 nil 3650374461
   ("" (ground) (("" (grind :if-match nil) nil nil)) nil)
   ((contextPure? def-decl "bool" IL nil) nil
    (emptyset const-decl "set" sets nil) nil
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (<= const-decl "bool" reals nil) nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "IExpression_adt.ref(newrefindex)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES sets[nat].add(newrefindex, domain)(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (newintReduce_TCC4 0
  (newintReduce_TCC4-1 nil 3650374461 ("" (subtype-tcc) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "newrefindex"
    "(sets[nat].add(newrefindex, domain))")))
 (newintReduce_TCC5 0
  (newintReduce_TCC5-1 nil 3650374461 ("" (grind) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "IExpression_adt.constant(0)"
    "(IL.domainValue?(sets[nat].add(newrefindex, domain)))")))
 (newrefReduce_TCC1 0
  (newrefReduce_TCC1-1 nil 3650374461 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "expr"
    "{x: IExpression_adt.IExpression | IExpression_adt.newint?(x) OR IExpression_adt.newref?(x)}")))
 (newrefReduce_TCC2 0
  (newrefReduce_TCC2-1 nil 3650374461
   ("" (ground)
    (("" (expand "every")
      (("" (skeep)
        (("" (skeep*)
          (("" (typepred "gS`stack") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "gS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(sets[nat].add(newrefindex, domain)))(S)}")))
 (newrefReduce_TCC3 0
  (newrefReduce_TCC3-1 nil 3650374461 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil (<= const-decl "bool" reals nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (refs def-decl "bool" IL nil) (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil) nil
    (emptyset const-decl "set" sets nil) nil
    (contextPure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "IExpression_adt.ref(newrefindex)"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES sets[nat].add(newrefindex, domain)(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < gS`stack`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < gS`stack`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= gS`stack`length) AND IL.contextPure?(A)}")))
 (newrefReduce_TCC4 0
  (newrefReduce_TCC4-1 nil 3650374461
   ("" (grind :if-match nil) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (add const-decl "(nonempty?)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "newrefindex"
    "(sets[nat].add(newrefindex, domain))")))
 (newrefReduce_TCC5 0
  (newrefReduce_TCC5-1 nil 3650374461 ("" (grind) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "IExpression_adt.nil"
    "(IL.domainValue?(sets[nat].add(newrefindex, domain)))")))
 (popReduce_TCC1 0
  (popReduce_TCC1-1 nil 3650374461 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (popReduce subtype "expr" "(IExpression_adt.pop?)")))
 (popReduce_TCC2 0
  (popReduce_TCC2-1 nil 3650374461
   ("" (ground)
    (("" (skeep*)
      (("" (typepred "gS`redex")
        (("" (typepred gS) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (popReduce subtype "stack" "neStack")))
 (popReduce_TCC3 0
  (popReduce_TCC3-1 nil 3650374461 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (emptyset const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pop const-decl "Stack" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popReduce subtype "IL.pop(stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(gS`domain))(S)}")))
 (popReduce_TCC4 0
  (popReduce_TCC4-1 nil 3650429664
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (skeep) (("1" (inst -2 i) (("1" (grind) nil nil)) nil))
        nil)
       ("2" (grind) nil nil)
       ("3" (skeep) (("3" (inst -4 i) (("3" (grind) nil nil)) nil))
        nil)
       ("4" (grind) nil nil) ("5" (grind) nil nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil) nil nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (goodstate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pop const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popReduce subtype "value"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES gS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < IL.pop(stack)`length) AND (FORALL i: IL.vars(gS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(gS`context) < IL.pop(stack)`length) AND (IL.popDepth(A) + IL.popDepth(gS`context) <= IL.pop(stack)`length) AND IL.contextPure?(A)}")))
 (make_redex_e_TCC1 0
  (make_redex_e_TCC1-1 nil 3701441369
   ("" (skeep)
    (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil))
    nil)
   ((pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (make_redex_e subtype "ctx" "{K | IL.cpure?(K)}")))
 (make_redex_e_TCC2 0
  (make_redex_e_TCC2-1 nil 3701441369
   ("" (skeep :preds? t)
    (("" (with-labels (typepred "t`redex") ((href hvar hcvar hsl hcp)))
      (("" (typepred "buildRedex(t`redex)")
        (("" (replace -1 (href hvar hcvar hsl hcp) :dir RL)
          (("" (rewrite popdepth_fill)
            (("" (split +)
              (("1" (rewrite refs_fill) (("1" (grind) nil nil)) nil)
               ("2" (skeep)
                (("2" (inst hvar "i - popDepth(ctx)")
                  (("1" (rewrite vars_decompose)
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("3" (skeep)
                (("3" (inst hvar i)
                  (("3" (rewrite vars_decompose)
                    (("3" (grind) nil nil)) nil))
                  nil))
                nil)
               ("4" (grind) nil nil)
               ("5" (use contextPurefill) (("5" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (emptyset const-decl "set" sets nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs_fill formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countability
     "sets_aux/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_decompose formula-decl nil IL nil)
    (contextPurefill formula-decl nil IL nil)
    (popdepth_fill formula-decl nil IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_e subtype "redex"
    "{A |      (FORALL i: IL.refs(A)(i) IMPLIES t`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < t`stack`length) AND (FORALL i: IL.vars(ctx)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(ctx) < t`stack`length) AND (IL.popDepth(A) + IL.popDepth(ctx) <= t`stack`length) AND IL.contextPure?(A)}")))
 (make_redex_e_TCC3 0
  (make_redex_e_TCC3-1 nil 3701441369
   ("" (skeep :preds? t)
    (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil))
    nil)
   ((pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_e subtype
    "(t:: estate) WITH [`context := ctx, `redex := redex]"
    "{eS | IL.pureRedex?(eS`redex)}")))
 (make_redex_e_idem_TCC1 0
  (make_redex_e_idem_TCC1-1 nil 3701441369 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (to_topstate const-decl "topstate" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_e_idem subtype "to_topstate(make_redex_e(t))"
    "{t: topstate | NOT IL.atom?(t`redex)}")))
 (make_redex_e_idem 0
  (make_redex_e_idem-1 nil 3701441443
   ("" (skeep :preds? t)
    (("" (expand make_redex_e)
      (("" (expand to_topstate)
        (("" (typepred "buildRedex(t`redex)")
          (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate const-decl "topstate" reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reduce_TCC1 0
  (reduce_TCC1-1 nil 3699115446
   ("" (skeep*)
    (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil))
    nil)
   ((pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "nS" "{gS | IExpression_adt.variable?(gS`redex)}")))
 (reduce_TCC2 0
  (reduce_TCC2-1 nil 3699115446
   ("" (skeep*)
    (("" (typepred "buildRedex(t`redex)")
      (("" (split -2)
        (("1" (ground)
          (("1" (typepred "t`redex") (("1" (grind) nil nil)) nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (topstate type-eq-decl nil reduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (estate type-eq-decl nil reduction nil)
    (Store type-eq-decl nil reduction nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.pureLetRedex?(gS`redex)}")))
 (reduce_TCC3 0
  (reduce_TCC3-1 nil 3699115446 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.applyRedex?(gS`redex)}")))
 (reduce_TCC4 0
  (reduce_TCC4-1 nil 3699115446 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.pureIftRedex?(gS`redex)}")))
 (reduce_TCC5 0
  (reduce_TCC5-1 nil 3699115446 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.updateRedex?(gS`redex)}")))
 (reduce_TCC6 0
  (reduce_TCC6-1 nil 3699115446 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.lookupRedex?(gS`redex)}")))
 (reduce_TCC7 0
  (reduce_TCC7-1 nil 3699115446 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.newintRedex?(gS`redex)}")))
 (reduce_TCC8 0
  (reduce_TCC8-1 nil 3699115446 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.newrefRedex?(gS`redex)}")))
 (reduce_TCC9 0
  (reduce_TCC9-1 nil 3705846888 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (estate type-eq-decl nil reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodstate type-eq-decl nil reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (topstate type-eq-decl nil reduction nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "topstate" reduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (reduce subtype "nS" "{gS | IL.popRedex?(gS`redex)}"))))

