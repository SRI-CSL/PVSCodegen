(reduction (to_topstate_TCC1 0 (to_topstate_TCC1-1 nil 3699115446 ("" (skeep*) (("" (grind) nil nil)) nil) ((cpure? def-decl "bool" IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (to_topstate subtype "IL.hole" "{K | IL.cpure?(reduction.K)}"))) (to_topstate_TCC2 0 (to_topstate_TCC2-1 nil 3699115446 ("" (skeep*) (("" (ground) (("1" (skeep*) (("1" (rewrite refs_fill) (("1" (typepred "eS`redex") (("1" (grind) nil nil)) nil) ("2" (use contextPurefill) (("2" (typepred "eS`context") (("2" (typepred "eS`redex") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (rewrite popdepth_fill) (("2" (rewrite vars_decompose) (("2" (typepred "eS`redex") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (typepred "eS`redex") (("4" (rewrite popdepth_fill) (("4" (grind) nil nil)) nil)) nil) ("5" (use contextPurefill) (("5" (typepred "eS`context") (("5" (typepred "eS`redex") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (refs_fill formula-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (contextPurefill formula-decl nil IL nil) (popdepth_fill formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars_decompose formula-decl nil IL nil) (emptyset const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (to_topstate subtype "IL.fill(reduction.eS`context, reduction.eS`redex)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.eS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.eS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(IL.hole)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(IL.hole)), reduction.eS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(IL.hole)), reduction.eS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (to_topstate_TCC3 0 (to_topstate_TCC3-1 nil 3699115446 ("" (subtype-tcc) nil nil) nil nil (to_topstate subtype "reduction.eS WITH [`context := IL.hole, `redex := IL.fill(reduction.eS`context, reduction.eS`redex)]" "topstate"))) (variableReduce_TCC1 0 (variableReduce_TCC1-1 nil 3705846888 ("" (skeep* :preds? t) (("" (typepred "gS`redex") (("" (grind) nil nil)) nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (singleton const-decl "(singleton?)" sets nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (variableReduce subtype "reduction.gS`redex" "{x | reals.<(IExpression_adt.index(IL.x), reduction.gS`stack`length)}"))) (variableReduce_TCC2 0 (variableReduce_TCC2-1 nil 3705846888 ("" (skeep* :preds? t) (("" (typepred "gS`redex") (("" (split) (("1" (skeep) (("1" (typepred "gS`stack") (("1" (typepred "get(gS`stack)(gS`redex)") (("1" (inst -5 "index(gS`redex)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "get(gS`stack)(gS`redex)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (skeep*) (("3" (inst -4 i) (("3" (typepred "get(gS`stack)(gS`redex)") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (typepred "get(gS`stack)(gS`redex)") (("4" (grind) nil nil)) nil) ("5" (typepred "get(gS`stack)(gS`redex)") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" finite_sets nil) (get const-decl "(value?)" IL nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (singleton const-decl "(singleton?)" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (variableReduce subtype "IL.get(reduction.gS`stack)(reduction.gS`redex)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (letReduce_TCC1 0 (letReduce_TCC1-1 nil 3646200513 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (letReduce subtype "reduction.expr" "(IExpression_adt.letexpr?)"))) (letReduce_TCC2 0 (letReduce_TCC2-1 nil 3646200513 ("" (grind :if-match all) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (value? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (letReduce subtype "IExpression_adt.letrhs(reduction.expr)" "(IL.value?)"))) (letReduce_TCC3 0 (letReduce_TCC3-1 nil 3646200513 ("" (skeep* :preds? t) (("" (expand every) (("" (skeep :preds? t) (("" (expand push) (("" (expand add) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (typepred "stack") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every const-decl "bool" finseq_theorems nil) (push const-decl "Stack" IL nil) (below type-eq-decl nil naturalnumbers nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (letReduce subtype "IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(reduction.gS`domain))(S)}"))) (letReduce_TCC4 0 (letReduce_TCC4-2 "" 3867343485 ("" (skeep* :preds? t) (("" (split) (("1" (skeep) (("1" (expand refs) (("1" (use pure_refs) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand vars -1) (("2" (expand drop -1) (("2" (expand push +) (("2" (expand popDepth +) (("2" (expand add +) (("2" (assert) (("2" (rewrite purePopDepth) (("1" (inst -6 i) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep* :preds? t) (("3" (expand popDepth + 1) (("3" (rewrite purePopDepth) (("1" (inst -7 i) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (expand popDepth + 1) (("4" (rewrite purePopDepth) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("5" (expand contextPure? +) (("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) nil shostak (letReduce subtype "IExpression_adt.pop(IExpression_adt.body(reduction.expr))" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)`length)) AND IL.contextPure?(reduction.A)}")) (letReduce_TCC4-1 nil 3646200513 ("" (skeep* :preds? t) (("" (split) (("1" (skeep) (("1" (expand refs) (("1" (use pure_refs) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand vars -1) (("2" (expand drop -1) (("2" (expand push +) (("2" (expand popDepth +) (("2" (expand add +) (("2" (assert) (("2" (rewrite purePopDepth) (("1" (inst -3 "i") (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep* :preds? t) (("3" (expand popDepth + 1) (("3" (rewrite purePopDepth) (("1" (inst -5 i) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (expand popDepth + 1) (("4" (rewrite purePopDepth) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("5" (expand contextPure? +) (("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ((refs def-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression type-decl nil IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureLetRedex? const-decl "bool" IL nil) (pure_refs formula-decl nil IL nil) (push const-decl "Stack" IL nil) (add const-decl "finseq[T]" more_finseq nil) (purePopDepth formula-decl nil IL nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (drop const-decl "finite_set[nat]" IL nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pure_contextPure formula-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (letReduce subtype "IExpression_adt.pop(IExpression_adt.body(reduction.expr))" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), IL.push(IExpression_adt.letrhs(reduction.expr), reduction.stack)`length)) AND IL.contextPure?(reduction.A)}"))) (set_redex_correct 0 (set_redex_correct-1 nil 3700921149 ("" (skeep) (("" (typepred "gS`redex") (("" (case-replace "popDepth(u) = 0") (("1" (split) (("1" (typepred u) (("1" (grind) nil nil)) nil) ("2" (typepred u) (("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (inst -5 i) (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (typepred u) (("5" (grind) nil nil)) nil)) nil) ("2" (typepred u) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (emptyset const-decl "set" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak)) (updateReduce_TCC1 0 (updateReduce_TCC1-1 nil 3646200513 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "reduction.expr" "(IExpression_adt.update?)"))) (updateReduce_TCC2 0 (updateReduce_TCC2-1 "" 3867343583 ("" (skeep* :preds? t) (("" (inst -5 "index(target(expr))") (("" (grind) nil nil)) nil)) nil) nil shostak (updateReduce subtype "IExpression_adt.target(reduction.expr)" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}")) (updateReduce_TCC10-1 nil 3646200513 ("" (skeep* :preds? t) (("" (inst -2 "index(target(expr))") (("" (grind) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (add const-decl "(nonempty?)" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" finite_sets nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.target(reduction.expr)" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}"))) (updateReduce_TCC3 0 (updateReduce_TCC11-1 nil 3646200513 ("" (skeep* :preds? t) (("" (inst -3 "index(lhs(expr))") (("" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (popDepth def-decl "nat" IL nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil) (N!1 skolem-const-decl "nat" reduction nil) (N!1 skolem-const-decl "nat" reduction nil) (N!1 skolem-const-decl "nat" reduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (N!1 skolem-const-decl "nat" reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (domain skolem-const-decl "finite_set[nat]" reduction nil) (N!1 skolem-const-decl "nat" reduction nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (N!1 skolem-const-decl "nat" reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.lhs(reduction.expr)" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}"))) (updateReduce_TCC4 0 (updateReduce_TCC2-1 nil 3646200513 ("" (skeep* :preds? t) (("" (inst -5 "index(rhs(expr))") (("" (grind) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" finite_sets nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.rhs(reduction.expr)" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}"))) (updateReduce_TCC5 0 (updateReduce_TCC5-1 "" 3867344668 ("" (expand "get") (("" (skeep*) (("" (typepred "gS`stack") (("" (grind) (("" (typepred "gS`redex") (("" (typepred gS) (("" (inst -3 "index(target(gS`redex))") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (updateReduce subtype "IExpression_adt.refindex(reduction.aval)" "(reduction.gS`domain)")) (updateReduce_TCC3-1 nil 3646200513 ("" (ground) (("" (skeep* :preds? t) (("" (expand* every get) (("" (inst -11 "stack`length - 1 - index(target(expr))") (("1" (grind) nil nil) ("2" (inst -5 "index(target(expr))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (add const-decl "(nonempty?)" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(reduction.aval)" "(reduction.gS`domain)"))) (updateReduce_TCC6 0 (updateReduce_TCC6-1 "" 3867345184 ("" (expand "get") (("" (skeep*) (("" (typepred "gS`stack") (("" (grind) (("" (typepred "gS`redex") (("" (typepred gS) (("" (inst -3 "index(target(gS`redex))") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (updateReduce subtype "reduction.oldref" "(reduction.gS`domain)")) (updateReduce_TCC4-1 nil 3646200513 ("" (ground) (("" (skeep* :preds? t) (("" (expand* every get) (("" (inst -13 "stack`length-1-index(target(expr))") (("1" (grind) nil nil) ("2" (inst -7 "index(target(expr))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (add const-decl "(nonempty?)" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "reduction.oldref" "(reduction.gS`domain)"))) (updateReduce_TCC7 0 (updateReduce_TCC7-1 "" 3710688528 ("" (expand "get") (("" (skeep*) (("" (typepred "gS`stack") (("" (grind) nil nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (updateReduce subtype "IExpression_adt.value(reduction.lval)" "below[store(oldref)`length]")) (updateReduce_TCC5-1 nil 3646200513 ("" (expand "get") (("" (skeep*) (("" (typepred "gS`stack") (("" (grind) (("" (typepred "gS`redex") (("" (typepred gS) (("" (inst -3 "index(target(gS`redex))") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (updateRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)) nil (updateReduce subtype "IExpression_adt.value(reduction.lval)" "below[store(oldref)`length]"))) (updateReduce_TCC8 0 (updateReduce_TCC6-1 nil 3646200513 ("" (skeep* :preds? t) (("" (expand* every get) (("" (inst -13 "stack`length-1-index(rhs(expr))") (("1" (grind) nil nil) ("2" (inst -7 "index(rhs(expr))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (every const-decl "bool" finseq_theorems nil) nil nil nil (finite_emptyset name-judgement "finite_set" finite_sets nil) nil (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (emptyset const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) nil nil (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) nil (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "reduction.rval" "(IL.domainValue?(reduction.gS`domain))"))) (updateReduce_TCC9 0 (updateReduce_TCC9-1 "" 3867289922 ("" (skeep*) (("" (lemma "finite_add[nat]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) nil shostak (updateReduce subtype "reduction.newdomain" "finite_set[nat]")) (updateReduce_TCC7-1 nil 3646200513 ("" (expand "get") (("" (skeep* :preds? t) (("" (expand every) (("" (skeep) (("" (inst -13 i) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_add formula-decl nil finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "reduction.newdomain" "finite_set[nat]"))) (updateReduce_TCC10 0 (updateReduce_TCC8-1 nil 3646200513 ("" (skeep* :preds? t) (("" (typepred "gS`redex") (("" (split +) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil) ((updateRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil) (add const-decl "(nonempty?)" sets nil) (emptyset const-decl "set" sets nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (get const-decl "(value?)" IL nil) (injective? const-decl "bool" functions nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "reduction.gS`stack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(reduction.newdomain))(S)}"))) (updateReduce_TCC11 0 (updateReduce_TCC11-1 "" 3867355824 ("" (skeep* :preds? t) (("" (typepred "gS`redex") (("" (split +) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil) nil shostak (updateReduce subtype "IExpression_adt.ref(reduction.newref)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.newdomain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}")) (updateReduce_TCC9-1 nil 3646200513 ("" (skeep*) (("" (typepred "gS`stack") (("" (split) (("1" (grind) nil nil) ("2" (skeep :preds? t) (("2" (case-replace "x1 = newref") (("1" (replace -18) (("1" (assert) (("1" (case-replace "x2 = value(lval)") (("1" (assert) (("1" (expand every) (("1" (inst -4 "stack`length-1-index(rhs(expr))") (("1" (grind) nil nil) ("2" (typepred "gS`redex") (("2" (inst -2 "index(rhs(expr))") (("2" (split -2) (("1" (grind) nil nil) ("2" (assert) (("2" (typepred gS) (("2" (expand updateRedex?) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "store(oldref)`seq(x2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "store(x1)`seq(x2)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((updateRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (emptyset const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil) (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.ref(reduction.newref)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.newdomain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3867209309 ("" (skeep*) (("" (typepred "gS`stack") (("" (split) (("1" (grind) nil nil) ("2" (skeep :preds? t) (("2" (case-replace "x1 = newref") (("1" (replace -18) (("1" (assert) (("1" (case-replace "x2 = value(lval)") (("1" (assert) (("1" (expand every) (("1" (inst -4 "stack`length-1-index(rhs(expr))") (("1" (grind) nil nil) ("2" (typepred "gS`redex") (("2" (inst -2 "index(rhs(expr))") (("2" (split -2) (("1" (grind) nil nil) ("2" (assert) (("2" (typepred gS) (("2" (expand updateredex?) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "store(oldref)`seq(x2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "store(x1)`seq(x2)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((updateRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (emptyset const-decl "set" sets nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (expr skolem-const-decl "{A |
        (FORALL i: refs(A)(i) IMPLIES gS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < gS`stack`length)
    AND (FORALL i:
           vars(gS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(gS`context) < gS`stack`length)
    AND (popDepth(A) + popDepth(gS`context) <= gS`stack`length)
    AND contextPure?(A)}" reduction nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (below type-eq-decl nil naturalnumbers nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (gS skolem-const-decl "{gS | updateRedex?(gS`redex)}" reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "reduction.newstore" "reduction.Store(reduction.newdomain)"))) (popit_TCC1 0 (popit_TCC1-1 nil 3650126116 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (popit subtype "(number_fields.-)(reduction.i, 1)" "nat"))) (popit_TCC2 0 (popit_TCC2-1 nil 3650126116 ("" (termination-tcc) nil nil) nil nil (popit termination "reduction.popit((number_fields.-)(reduction.i, 1))" "nil"))) (popit_pure_TCC1 0 (popit_pure_TCC1-1 nil 3650252343 ("" (skeep*) (("" (typepred A) (("" (use pure_refs) (("" (grind) nil nil)) nil)) nil)) nil) ((pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure_refs formula-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (popit_pure_ subtype "reduction.A" "{B | (FORALL j: (booleans.NOT)(IL.refs(reduction.B)(reduction.j)))}"))) (popit_pure_TCC2 0 (popit_pure_TCC2-1 nil 3650252343 ("" (skeep*) (("" (typepred "v(i - 1)(A)") (("1" (inst - "j") (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (popit_pure_ subtype "IExpression_adt.pop(reduction.v((number_fields.-)(reduction.i, 1))(reduction.A))" "{B | (FORALL j: (booleans.NOT)(IL.refs(reduction.B)(reduction.j)))}"))) (popit_pure 0 (popit_pure-1 nil 3650251073 ("" (induct-and-simplify "i") (("" (typepred "A!1") (("" (use "pure_refs") (("" (ground) nil nil)) nil)) nil)) nil) ((pure_refs formula-decl nil IL nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (pure? def-decl "bool" IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (popit def-decl "IExpression" reduction nil) (nat_induction formula-decl nil naturalnumbers nil)) nil)) (popit_refcount 0 (popit_refcount-1 nil 3682268921 ("" (induct-and-simplify "j") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount def-decl "nat" IL nil) (popit def-decl "IExpression" reduction nil) (nat_induction formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak)) (popit_refs 0 (popit_refs-1 nil 3682294639 ("" (induct-and-simplify "j") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (refs def-decl "bool" IL nil) (popit def-decl "IExpression" reduction nil) (nat_induction formula-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak)) (popit_var_TCC1 0 (popit_var_TCC1-1 nil 3650252343 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (popit_var_ subtype "reduction.A" "{B | (FORALL j: IL.vars(reduction.B)(reduction.j) = IL.vars(reduction.A)((number_fields.+)(reduction.i, reduction.j)))}"))) (popit_var_TCC2 0 (popit_var_TCC2-1 nil 3650252343 ("" (recursive-judgement-tcc) (("1" (typepred "v!1(i!1 - 1)(A!1)") (("1" (grind) nil nil)) nil) ("2" (typepred "v!1(i!1 - 1)(A!1)") (("2" (grind) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars def-decl "finite_set[nat]" IL nil) (drop const-decl "finite_set[nat]" IL nil)) nil (popit_var_ subtype "IExpression_adt.pop(reduction.v((number_fields.-)(reduction.i, 1))(reduction.A))" "{B | (FORALL j: IL.vars(reduction.B)(reduction.j) = IL.vars(reduction.A)((number_fields.+)(reduction.i, reduction.j)))}"))) (popit_var 0 (popit_var-1 nil 3650251073 ("" (judgement-tcc) nil nil) nil nil)) (popit_popDepth 0 (popit_popDepth-1 nil 3650382470 ("" (induct-and-simplify "i") nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" IL nil) (popit def-decl "IExpression" reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popit_var rec-application-judgement "{B | (FORALL j: vars(B)(j) = vars(A)(j + i))}" reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (popitContextPure_TCC1 0 (popitContextPure_TCC1-1 nil 3650511560 ("" (skeep*) (("" (typepred A) (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)) nil) ((pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure_contextPure formula-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (popitContextPure_ subtype "reduction.A" "(IL.contextPure?)"))) (popitContextPure_TCC2 0 (popitContextPure_TCC2-1 nil 3650511560 ("" (skosimp*) (("" (typepred "v!1(i!1 - 1)(A!1)") (("1" (grind :if-match nil) nil nil) ("2" (grind :if-match nil) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pure? def-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popit_var rec-application-judgement "{B | (FORALL j: vars(B)(j) = vars(A)(j + i))}" reduction nil) (popit_pure rec-application-judgement "{B | (FORALL j: NOT refs(B)(j))}" reduction nil)) nil (popitContextPure_ subtype "IExpression_adt.pop(reduction.v((number_fields.-)(reduction.i, 1))(reduction.A))" "(IL.contextPure?)"))) (letApply_TCC1 0 (letApply_TCC1-1 nil 3683776766 ("" (skeep*) (("" (typepred "args") (("" (grind) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (letApply subtype "reduction.args" "(list_adt[(IExpression_adt.variable?)].cons?)"))) (letApply_TCC2 0 (letApply_TCC2-1 nil 3683776766 ("" (skeep*) (("" (typepred "args") (("" (grind) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (letApply subtype "reduction.x" "(IExpression_adt.variable?)"))) (letApply_TCC3 0 (letApply_TCC3-1 nil 3683776766 ("" (skeep*) nil nil) nil nil (letApply subtype "reduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(reduction.x), 1)]" "(IExpression_adt.variable?)"))) (letApply_TCC4 0 (letApply_TCC4-1 nil 3705953715 ("" (skeep* :preds? t) (("" (rewrite map_length) (("" (expand length -) (("" (grind) nil nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map_length formula-decl nil more_map_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (letApply subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: reduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(reduction.x), 1)])(list_adt[(IExpression_adt.variable?)].cdr(reduction.args))" "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = (number_fields.-)(reduction.arity, 1)}"))) (letApply_TCC5 0 (letApply_TCC5-1 nil 3683826670 ("" (skeep*) (("" (typepred "args") (("" (grind) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (letApply subtype "reduction.args" "(list_adt[(IExpression_adt.variable?)].cons?)"))) (pure_letApply_TCC1 0 (pure_letApply_TCC1-1 nil 3683813520 ("" (recursive-judgement-tcc) nil nil) ((pure? def-decl "bool" IL nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pure_letApply_ subtype "IExpression_adt.letexpr(reduction.arg1, reduction.B)" "(IL.pure?)"))) (vars_letApply 0 (vars_letApply-1 nil 3683816781 ("" (induct "i") (("1" (grind) (("1" (expand "some") (("1" (grind) nil nil)) nil)) nil) ("2" (skeep*) (("2" (expand "letApply" +) (("2" (inst?) (("2" (inst?) (("2" (expand "vars" + 1) (("2" (typepred "args") (("2" (grind) (("1" (rewrite "some_nth") (("1" (rewrite "some_nth") (("1" (skeep) (("1" (rewrite "map_nth_rw") (("1" (inst + "i + 1") (("1" (grind) nil nil) ("2" (expand "length") (("2" (grind) (("2" (typepred "i") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1 2 3) (("2" (rewrite "some_nth") (("2" (inst + 0) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 1 3) (("3" (rewrite "some_nth") (("3" (rewrite "some_nth") (("3" (skeep) (("3" (inst + "i - 1") (("1" (rewrite "map_nth_rw") (("1" (grind) (("1" (expand "nth" -) (("1" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "length" -) (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (expand "length" -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (union const-decl "set" sets nil) (drop const-decl "finite_set[nat]" IL nil) (member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (map_nth_rw formula-decl nil more_map_props nil) (map_length formula-decl nil more_map_props nil) (nth def-decl "T" list_props nil) (i skolem-const-decl "below(length(map(LAMBDA x: x WITH [`index := 1 + index(x)])(cdr(args))))" reduction nil) (args skolem-const-decl "{args: list[(variable?)] | length(args) = 1 + j_1}" reduction nil) (j_1 skolem-const-decl "nat" reduction nil) (some_nth formula-decl nil finseq_theorems nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (i skolem-const-decl "below(length(args))" reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (some adt-def-decl "boolean" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (in_varlist const-decl "finite_set[nat]" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (letApply def-decl "IExpression" reduction nil) (vars def-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (IExpression type-decl nil IExpression_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (popdepth_letApply 0 (popdepth_letApply-1 nil 3693281813 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (letApply def-decl "IExpression" reduction nil) (popDepth def-decl "nat" IL nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (applyReduce_TCC1 0 (applyReduce_TCC1-1 nil 3650158977 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (applyRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (applyReduce subtype "reduction.expr" "(IExpression_adt.application?)"))) (applyReduce_TCC2 0 (applyReduce_TCC2-1 nil 3650158977 ("" (skeep*) (("" (assert) nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (applyReduce subtype "reduction.args" "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = reduction.arity}"))) (applyReduce_TCC3 0 (applyReduce_TCC3-2 "partial proof for modified (9/25/16) applyReduce" 3683812442 ("" (skeep*) (("" (ground) (("1" (skeep) (("1" (typepred "letApply(arity, args, body)") (("1" (rewrite "pure_refs") nil nil)) nil)) nil) ("2" (skeep*) (("2" (rewrite "purePopDepth") (("2" (rewrite "vars_letApply") (("2" (ground) (("1" (typepred "expr") (("1" (inst -2 "i") (("1" (ground) (("1" (typepred "gS") (("1" (expand "vars" +) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "def`body") (("2" (inst - "arity + i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "letApply(arity, args, body)") (("3" (rewrite "purePopDepth") (("3" (assert) (("3" (typepred "gS`redex") (("3" (skeep*) (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (typepred "gS`redex") (("4" (rewrite popdepth_letApply) (("4" (lift-if) (("4" (ground) (("1" (typepred gS) (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (use pure_contextPure) (("5" (grind) nil nil)) nil)) nil)) nil) ((pure_letApply rec-application-judgement "(pure?)" reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Definition type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (letApply def-decl "IExpression" reduction nil) (length def-decl "nat" list_props nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure_refs formula-decl nil IL nil) (purePopDepth formula-decl nil IL nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (in_varlist const-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (applyRedex? const-decl "bool" IL nil) (vars_letApply formula-decl nil reduction nil) (popdepth_letApply formula-decl nil reduction nil) (pure_contextPure formula-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (applyReduce subtype "reduction.letApply(reduction.arity, reduction.args, reduction.body)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}")) (applyReduce_TCC3-1 nil 3650158977 ("" (skosimp* :preds? t) (("" (expand "pushlist") (("" (lemma "every_nth" ("P" "(LAMBDA (y: {x | index(x) < stack!1`length}): TRUE)")) (("" (inst - "args!1") (("" (ground) (("" (rewrite "every_append") (("" (rewrite "every" +) (("" (skeep :preds? t) (("" (expand "list2finseq") (("" (lemma "map_nth_rw[{x | index(x) < stack!1`length}, (value?)]") (("" (inst?) (("1" (replace -1 :hide? t) (("1" (expand "every" -12) (("1" (expand "get") (("1" (inst? -12) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pushlist const-decl "Stack" reduction nil) (get const-decl "(value?)" IL nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (every_append formula-decl nil finseq_theorems nil) (map_nth_rw formula-decl nil more_map_props nil) (map_length formula-decl nil more_map_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (in_varlist const-decl "finite_set[nat]" IL nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth def-decl "T" list_props nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (TRUE const-decl "bool" booleans nil) (every_nth formula-decl nil list_props nil) (Definition type-eq-decl nil reduction nil) (pure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (applyRedex? const-decl "bool" IL nil)) nil (applyReduce subtype "reduction.letApply(reduction.arity, reduction.args, reduction.body)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (ifReduce_TCC1 0 (ifReduce_TCC1-1 nil 3650256151 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (ifReduce subtype "reduction.expr" "(IExpression_adt.ift?)"))) (ifReduce_TCC2 0 (ifReduce_TCC2-1 nil 3650256151 ("" (grind :if-match all) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureIftRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (condition adt-accessor-decl "[(ift?) -> (variable?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (gS!1 skolem-const-decl "{gS | pureIftRedex?(gS`redex)}" reduction nil) (iftRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (ifReduce subtype "reduction.condition" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}"))) (ifReduce_TCC3 0 (ifReduce_TCC3-1 nil 3650256151 ("" (skeep*) (("" (ground) (("1" (typepred gS) (("1" (lemma pure_refs) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep*) (("2" (typepred gS) (("2" (typepred "gS`redex") (("2" (rewrite purePopDepth 2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (typepred "gS`redex") (("3" (inst -3 i) (("3" (typepred gS) (("3" (rewrite purePopDepth 2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite purePopDepth) (("1" (typepred "gS`redex") (("1" (grind) nil nil)) nil) ("2" (typepred gS) (("2" (grind) nil nil)) nil)) nil) ("5" (use pure_contextPure) (("5" (typepred gS) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pure_refs formula-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (elseexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (iftRedex? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureIftRedex? const-decl "bool" IL nil) (purePopDepth formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (pure_contextPure formula-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (ifReduce subtype "reduction.elseexpr" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (ifReduce_TCC4 0 (ifReduce_TCC4-1 nil 3650256151 ("" (ground) (("" (skeep*) (("" (ground) (("1" (lemma pure_refs) (("1" (typepred gS) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep*) (("2" (rewrite purePopDepth) (("1" (typepred "gS`redex") (("1" (inst -2 i) (("1" (typepred gS) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred gS) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (rewrite purePopDepth) (("1" (skeep*) (("1" (typepred "gS`redex") (("1" (typepred gS) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred gS) (("2" (grind) nil nil)) nil)) nil) ("4" (rewrite purePopDepth) (("1" (typepred "gS`redex") (("1" (grind) nil nil)) nil) ("2" (typepred gS) (("2" (grind) nil nil)) nil)) nil) ("5" (use pure_contextPure) (("5" (typepred gS) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pure_contextPure formula-decl nil IL nil) (add const-decl "(nonempty?)" sets nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (purePopDepth formula-decl nil IL nil) (pure_refs formula-decl nil IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (iftRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (thenexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (pureIftRedex? const-decl "bool" IL nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (ifReduce subtype "reduction.thenexpr" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (lookupReduce_TCC1 0 (lookupReduce_TCC1-1 nil 3650257308 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (lookupRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (lookupReduce subtype "reduction.expr" "(IExpression_adt.lookup?)"))) (lookupReduce_TCC2 0 (lookupReduce_TCC2-2 "" 3867357568 ("" (skeep* :preds? t) (("" (grind :if-match nil) (("" (inst? -6) nil nil)) nil)) nil) nil shostak (lookupReduce subtype "reduction.avar" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}")) (lookupReduce_TCC2-1 nil 3650257308 ("" (grind) nil nil) ((lookupRedex? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (popDepth def-decl "nat" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (contextPure? def-decl "bool" IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (lookupReduce subtype "reduction.avar" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}"))) (lookupReduce_TCC3 0 (lookupReduce_TCC3-1 nil 3650257308 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (lookupRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (N!1 skolem-const-decl "nat" reduction nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (N!1 skolem-const-decl "nat" reduction nil) (below type-eq-decl nil naturalnumbers nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (gS!1 skolem-const-decl "{gS | lookupRedex?(gS`redex)}" reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (N!1 skolem-const-decl "nat" reduction nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (N!1 skolem-const-decl "nat" reduction nil) (N!1 skolem-const-decl "nat" reduction nil) (N!1 skolem-const-decl "nat" reduction nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (lookupReduce subtype "reduction.pos" "{x | reals.<(IExpression_adt.index(IL.x), reduction.stack`length)}"))) (lookupReduce_TCC4 0 (lookupReduce_TCC4-1 nil 3650257308 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (lookupRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (lookupReduce subtype "IExpression_adt.refindex(reduction.aval)" "(reduction.gS`domain)"))) (lookupReduce_TCC5 0 (lookupReduce_TCC5-1 nil 3650257308 ("" (skeep*) (("" (grind) nil nil)) nil) ((get const-decl "(value?)" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (lookupReduce subtype "IExpression_adt.value(reduction.pval)" "below[store(refindex(aval))`length]"))) (lookupReduce_TCC6 0 (lookupReduce_TCC6-1 nil 3650549580 ("" (ground) (("" (skeep) (("" (skeep*) (("" (ground) (("1" (typepred "store(refindex(aval))`seq(value(pval))") (("1" (grind) nil nil)) nil) ("2" (typepred "store(refindex(aval))`seq(value(pval))") (("2" (grind) nil nil)) nil) ("3" (typepred "store(refindex(aval))`seq(value(pval))") (("3" (typepred "gS`redex") (("3" (skeep*) (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "store(refindex(aval))`seq(value(pval))") (("4" (typepred "gS`redex") (("4" (grind) nil nil)) nil)) nil) ("5" (typepred "store(refindex(aval))`seq(value(pval))") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (gS skolem-const-decl "{gS | lookupRedex?(gS`redex)}" reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (emptyset const-decl "set" sets nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookupRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (lookupReduce subtype "reduction.store(IExpression_adt.refindex(reduction.aval))`seq(IExpression_adt.value(reduction.pval))" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (newintReduce_TCC1 0 (newintReduce_TCC1-1 nil 3650374461 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (newintRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newintReduce subtype "reduction.expr" "{x: IExpression_adt.IExpression | booleans.OR(IExpression_adt.newint?(x), IExpression_adt.newref?(x))}"))) (newintReduce_TCC2 0 (newintReduce_TCC2-2 "" 3867357675 ("" (skeep* :preds? t) (("" (lemma "finite_add[nat]") (("" (inst? -1) nil nil)) nil)) nil) nil shostak (newintReduce subtype "sets[nat].add(reduction.newrefindex, reduction.domain)" "finite_set[nat]")) (newintReduce_TCC2-1 nil 3650374461 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_add formula-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newintReduce subtype "sets[nat].add(reduction.newrefindex, reduction.domain)" "finite_set[nat]"))) (newintReduce_TCC3 0 (newintReduce_TCC3-2 "" 3867358104 ("" (skeep* :preds? t) (("" (expand "every") (("" (skeep* :preds? t) (("" (typepred "gS`stack") (("" (grind) nil nil)) nil)) nil)) nil)) nil) nil shostak (newintReduce subtype "reduction.gS`stack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(sets[nat].add(reduction.newrefindex, reduction.domain)))(S)}")) (newintReduce_TCC3-1 nil 3650374461 ("" (ground) (("" (grind :if-match nil) nil nil)) nil) ((every const-decl "bool" finseq_theorems nil) (newintRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (emptyset const-decl "set" sets nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newintReduce subtype "reduction.gS`stack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(sets[nat].add(reduction.newrefindex, reduction.domain)))(S)}"))) (newintReduce_TCC4 0 (newintReduce_TCC4-2 "" 3867358174 ("" (grind) nil nil) nil shostak (newintReduce subtype "IExpression_adt.ref(reduction.newrefindex)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), sets[nat].add(reduction.newrefindex, reduction.domain)(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}")) (newintReduce_TCC4-1 nil 3650374461 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (newintRedex? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (gS!1 skolem-const-decl "{gS | newintRedex?(gS`redex)}" reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (refs def-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (vars def-decl "finite_set[nat]" IL nil) (emptyset const-decl "set" sets nil) (contextPure? def-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popDepth def-decl "nat" IL nil)) nil (newintReduce subtype "IExpression_adt.ref(reduction.newrefindex)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), sets[nat].add(reduction.newrefindex, reduction.domain)(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (newintReduce_TCC5 0 (newintReduce_TCC5-1 nil 3867209309 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (add const-decl "(nonempty?)" sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newintReduce subtype "reduction.newrefindex" "(sets[nat].add(reduction.newrefindex, reduction.domain))"))) (newintReduce_TCC6 0 (newintReduce_TCC5-1 nil 3650374461 ("" (grind) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newintReduce subtype "IExpression_adt.constant(0)" "(IL.domainValue?(sets[nat].add(reduction.newrefindex, reduction.domain)))"))) (newrefReduce_TCC1 0 (newrefReduce_TCC1-1 nil 3650374461 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (newrefRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newrefReduce subtype "reduction.expr" "{x: IExpression_adt.IExpression | booleans.OR(IExpression_adt.newint?(x), IExpression_adt.newref?(x))}"))) (newrefReduce_TCC2 0 (newrefReduce_TCC2-2 "" 3867358268 ("" (skeep* :preds? t) (("" (lemma "finite_add[nat]") (("" (inst?) nil nil)) nil)) nil) nil shostak (newrefReduce subtype "sets[nat].add(reduction.newrefindex, reduction.domain)" "finite_set[nat]")) (newrefReduce_TCC2-1 nil 3650374461 ("" (ground) (("" (expand "every") (("" (skeep) (("" (skeep*) (("" (typepred "gS`stack") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_add formula-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newrefReduce subtype "sets[nat].add(reduction.newrefindex, reduction.domain)" "finite_set[nat]"))) (newrefReduce_TCC3 0 (newrefReduce_TCC3-1 nil 3650374461 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (newrefRedex? const-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil naturalnumbers nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newrefReduce subtype "reduction.gS`stack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(sets[nat].add(reduction.newrefindex, reduction.domain)))(S)}"))) (newrefReduce_TCC4 0 (newrefReduce_TCC4-1 nil 3650374461 ("" (grind :if-match nil) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (newrefRedex? const-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (refs def-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (vars def-decl "finite_set[nat]" IL nil) (emptyset const-decl "set" sets nil) (popDepth def-decl "nat" IL nil) (contextPure? def-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newrefReduce subtype "IExpression_adt.ref(reduction.newrefindex)" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), sets[nat].add(reduction.newrefindex, reduction.domain)(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.gS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), reduction.gS`stack`length)) AND IL.contextPure?(reduction.A)}"))) (newrefReduce_TCC5 0 (newrefReduce_TCC5-1 nil 3867209309 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (add const-decl "(nonempty?)" sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newrefReduce subtype "reduction.newrefindex" "(sets[nat].add(reduction.newrefindex, reduction.domain))"))) (newrefReduce_TCC6 0 (newrefReduce_TCC5-1 nil 3650374461 ("" (grind) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (newrefReduce subtype "IExpression_adt.nil" "(IL.domainValue?(sets[nat].add(reduction.newrefindex, reduction.domain)))"))) (popReduce_TCC1 0 (popReduce_TCC1-1 nil 3650374461 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (popReduce subtype "reduction.expr" "(IExpression_adt.pop?)"))) (popReduce_TCC2 0 (popReduce_TCC2-1 nil 3650374461 ("" (ground) (("" (skeep*) (("" (typepred "gS`redex") (("" (typepred gS) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (popReduce subtype "reduction.stack" "neStack"))) (popReduce_TCC3 0 (popReduce_TCC3-1 nil 3650374461 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (pop const-decl "Stack" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (popReduce subtype "IL.pop(reduction.stack)" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(reduction.gS`domain))(S)}"))) (popReduce_TCC4 0 (popReduce_TCC4-2 "" 3867358529 ("" (skeep* :preds? t) (("" (split) (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (inst -6 i) (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) nil shostak (popReduce subtype "reduction.value" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.pop(reduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), IL.pop(reduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), IL.pop(reduction.stack)`length)) AND IL.contextPure?(reduction.A)}")) (popReduce_TCC4-1 nil 3650429664 ("" (skeep* :preds? t) (("" (split) (("1" (skeep) (("1" (inst -2 i) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (inst -4 i) (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (value? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(gS`domain))(S)}" reduction nil) (gS skolem-const-decl "{gS | popRedex?(gS`redex)}" reduction nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (i skolem-const-decl "nat" reduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (drop const-decl "finite_set[nat]" IL nil) (emptyset const-decl "set" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" finite_sets nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (pop const-decl "Stack" IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (popReduce subtype "reduction.value" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.gS`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.pop(reduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.gS`context)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.gS`context)), IL.pop(reduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.gS`context)), IL.pop(reduction.stack)`length)) AND IL.contextPure?(reduction.A)}"))) (make_redex_e_TCC1 0 (make_redex_e_TCC1-1 nil 3701441369 ("" (skeep) (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil)) nil) ((pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (make_redex_e subtype "reduction.ctx" "{K | IL.cpure?(reduction.K)}"))) (make_redex_e_TCC2 0 (make_redex_e_TCC2-1 nil 3701441369 ("" (skeep :preds? t) (("" (with-labels (typepred "t`redex") ((href hvar hcvar hsl hcp))) (("" (typepred "buildRedex(t`redex)") (("" (replace -1 (href hvar hcvar hsl hcp) :dir RL) (("" (rewrite popdepth_fill) (("" (split +) (("1" (rewrite refs_fill) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst hvar "i - popDepth(ctx)") (("1" (rewrite vars_decompose) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst hvar i) (("3" (rewrite vars_decompose) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (use contextPurefill) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (pureReleaseRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (refs_fill formula-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" reduction nil) (ctx skolem-const-decl "IContext" reduction nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set" sigma_set sigma_set) (finite_emptyset name-judgement "finite_set" countable_props sets_aux) (finite_emptyset name-judgement "finite_set[nat]" countability sets_aux) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars_decompose formula-decl nil IL nil) (contextPurefill formula-decl nil IL nil) (popdepth_fill formula-decl nil IL nil) (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (fill def-decl "IExpression" IL nil) (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pureRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (make_redex_e subtype "reduction.redex" "{A |      (FORALL i: booleans.IMPLIES(IL.refs(reduction.A)(reduction.i), reduction.t`domain(reduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.A)(reduction.i), reals.<((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), reduction.t`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(reduction.ctx)(reduction.i), reals.<((number_fields.+)((number_fields.+)(reduction.i, IL.popDepth(reduction.A)), IL.popDepth(reduction.ctx)), reduction.t`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(reduction.A), IL.popDepth(reduction.ctx)), reduction.t`stack`length)) AND IL.contextPure?(reduction.A)}"))) (make_redex_e_TCC3 0 (make_redex_e_TCC3-1 nil 3701441369 ("" (skeep :preds? t) (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil)) nil) ((pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (make_redex_e subtype "(reduction.t:: reduction.estate) WITH [`context := reduction.ctx, `redex := reduction.redex]" "{eS | IL.pureRedex?(reduction.eS`redex)}"))) (make_redex_e_idem_TCC1 0 (make_redex_e_idem_TCC1-1 nil 3701441369 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (to_topstate const-decl "topstate" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (make_redex_e_idem subtype "reduction.to_topstate(reduction.make_redex_e(reduction.t))" "{t: reduction.topstate | (booleans.NOT)(IL.value?(t`redex))}"))) (make_redex_e_idem 0 (make_redex_e_idem-1 nil 3701441443 ("" (skeep :preds? t) (("" (expand make_redex_e) (("" (expand to_topstate) (("" (typepred "buildRedex(t`redex)") (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (to_topstate const-decl "topstate" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (reduce_TCC1 0 (reduce_TCC1-1 nil 3699115446 ("" (skeep*) (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil)) nil) ((pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IExpression_adt.variable?(reduction.gS`redex)}"))) (reduce_TCC2 0 (reduce_TCC2-1 nil 3699115446 ("" (skeep*) (("" (typepred "buildRedex(t`redex)") (("" (split -2) (("1" (ground) (("1" (typepred "t`redex") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.pureLetRedex?(reduction.gS`redex)}"))) (reduce_TCC3 0 (reduce_TCC3-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.applyRedex?(reduction.gS`redex)}"))) (reduce_TCC4 0 (reduce_TCC4-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.pureIftRedex?(reduction.gS`redex)}"))) (reduce_TCC5 0 (reduce_TCC5-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.updateRedex?(reduction.gS`redex)}"))) (reduce_TCC6 0 (reduce_TCC6-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.lookupRedex?(reduction.gS`redex)}"))) (reduce_TCC7 0 (reduce_TCC7-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.newintRedex?(reduction.gS`redex)}"))) (reduce_TCC8 0 (reduce_TCC8-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.newrefRedex?(reduction.gS`redex)}"))) (reduce_TCC9 0 (reduce_TCC9-1 nil 3705846888 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (value? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (reduce subtype "reduction.nS" "{gS | IL.popRedex?(reduction.gS`redex)}"))))
