(finite_set_theorems
 (is_finite_complement 0
  (is_finite_complement-1 nil 3649822891 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil))
   shostak))
 (nat_infinite 0
  (nat_infinite-1 nil 3649868850
   ("" (induct "n")
    (("1" (skeep)
      (("1" (typepred "f(0)") (("1" (propax) nil nil)) nil)) nil)
     ("2" (skeep :preds? t)
      (("2" (skeep :preds? t)
        (("2"
          (inst +
           "LAMBDA (i: nat): IF f(i + 1) = 0 THEN f(0) - 1 ELSE f(i + 1) - 1 ENDIF")
          (("1" (expand "injective?")
            (("1" (skeep)
              (("1" (apply (repeat (lift-if)))
                (("1" (ground)
                  (("1" (inst - "x1 + 1" "x2 + 1")
                    (("1" (ground) nil nil)) nil)
                   ("2" (inst - 0 "x2 + 1") (("2" (assert) nil nil))
                    nil)
                   ("3" (inst - 0 "x1 + 1") (("3" (assert) nil nil))
                    nil)
                   ("4" (inst - "x1 + 1" "x2 + 1")
                    (("4" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (TRUE const-decl "bool" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (below_finite 0
  (below_finite-1 nil 3705329631
   ("" (skeep)
    (("" (expand is_finite)
      (("" (inst?)
        (("" (inst 1 "LAMBDA (i: below(n)): i") (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (nat_fullset_infinite 0
  (nat_fullset_infinite-1 nil 3649868880
   ("" (expand "is_finite")
    (("" (skeep :preds? t)
      (("" (use "nat_infinite")
        (("" (inst + "f")
          (("" (ground)
            (("1" (grind) nil nil)
             ("2" (grind :if-match nil)
              (("2" (forward-chain -5) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nat_infinite formula-decl nil finite_set_theorems nil)
    (is_finite const-decl "bool" finite_sets nil))
   shostak))
 (pick_new_TCC1 0
  (pick_new_TCC1-1 nil 3649901266
   ("" (skeep :preds? t)
    (("" (use "is_finite_complement[nat]")
      (("" (ground)
        (("1" (use "nat_fullset_infinite") nil nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((is_finite_complement formula-decl nil finite_set_theorems nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (nat_fullset_infinite formula-decl nil finite_set_theorems nil))
   nil
   (pick_new subtype "LAMBDA j: complement(NS)(j)"
    "(nonempty?[nat])")))
 (pick_new_TCC2 0
  (pick_new_TCC2-1 nil 3649901266 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil))
   nil
   (pick_new subtype "(choose! j: complement(NS)(j))"
    "{j | NOT NS(j)}")))
 (least_out_rec_TCC1 0
  (least_out_rec_TCC1-1 nil 3649901266 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil))
   nil (least_out_rec subtype "pick_new(NS) - i" "naturalnumber")))
 (least_out_rec_TCC2 0
  (least_out_rec_TCC2-1 nil 3649901266 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<= const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil))
   nil (least_out_rec subtype "i + 1" "{i | i <= pick_new(NS)}")))
 (least_out_rec_TCC3 0
  (least_out_rec_TCC3-1 nil 3649901266 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (least_out_rec termination "least_out_rec(NS, i + 1)" "nil")))
 (least_out_TCC1 0
  (least_out_TCC1-1 nil 3649966189 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil))
   nil (least_out subtype "0" "{i | i <= pick_new(NS)}")))
 (Sigma_TCC1 0
  (Sigma_TCC1-1 nil 3698608718 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil (Sigma subtype "X" "(nonempty?[nat])")))
 (Sigma_TCC2 0
  (Sigma_TCC2-1 nil 3698608718
   ("" (skeep)
    (("" (rewrite "card_remove") (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (card_remove formula-decl nil finite_sets nil))
   nil (Sigma termination "Sigma(remove(choose(X), X), f)" "nil")))
 (list2finset_TCC1 0
  (list2finset_TCC1-1 nil 3652980080
   ("" (induct "LL")
    (("1" (use "finite_set_TCC1") (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (expand "list2set" +)
        (("2" (rewrite "finite_add") nil nil)) nil))
      nil))
    nil)
   ((finite_add formula-decl nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list_induction formula-decl nil list_adt nil)
    (list2set def-decl "set[T]" list2set nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil (list2finset subtype "list2set(LL)" "finite_set[T]")))
 (finite_set_induction 0
  (finite_set_induction-1 nil 3656130780
   ("" (skeep)
    (("" (measure-induct+ "card(X)" "X")
      (("" (case "nonempty?(x!1)")
        (("1" (inst? -4)
          (("1" (ground)
            (("1" (inst?)
              (("1" (rewrite "card_remove") (("1" (ground) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide -1 -3)
          (("2" (grind)
            (("2" (case "x!1 = emptyset")
              (("1" (assert) nil nil)
               ("2" (expand "emptyset")
                (("2" (apply-extensionality) (("2" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (emptyset const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (remove const-decl "set" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (nonempty? const-decl "bool" sets nil))
   shostak))
 (finite_nonzero_elts 0
  (finite_nonzero_elts-1 nil 3698607891
   ("" (skeep)
    (("" (case "subset?(nonzero_elts(f, X), X)")
      (("1" (forward-chain "finite_subset") nil nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_subset formula-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   shostak))
 (sigma_sigma_set_TCC1 0
  (sigma_sigma_set_TCC1-1 nil 3698607394
   ("" (skeep)
    (("" (expand "convergent?")
      (("" (ground)
        (("1" (use "countable_props[nat].finite_countable")
          (("1" (lemma "countable_props[nat].finite_countable")
            (("1" (inst? :polarity? t)
              (("1" (use "finite_nonzero_elts") nil nil)) nil))
            nil))
          nil)
         ("2" (expand "convergent?")
          (("2" (ground) (("2" (use "finite_nonzero_elts") nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((convergent? const-decl "bool" convergence_set "sigma_set/")
    (convergent? const-decl "bool" countable_convergence "sigma_set/")
    (finite_countable judgement-tcc nil countable_props "sets_aux/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (finite_nonzero_elts formula-decl nil finite_set_theorems nil))
   nil (sigma_sigma_set subtype "f" "(convergent?[nat](X))")))
 (sigma_sigma_set 0
  (sigma_sigma_set-1 nil 3698607396
   ("" (induct "X" :name "finite_set_induction")
    (("1" (grind :rewrites "sigma_empty") nil nil)
     ("2" (skeep*)
      (("2" (expand "Sigma" 1 1)
        (("2" (expand "nonempty?")
          (("2" (assert)
            (("2" (inst?)
              (("2" (rewrite "sigma_remove")
                (("2" (lift-if)
                  (("2" (ground) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep) (("3" (use "sigma_sigma_set_TCC1") nil nil)) nil))
      nil))
    nil)
   ((sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (nonempty? const-decl "bool" sets nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sigma_remove formula-decl nil sigma_set "sigma_set/")
    (choose const-decl "(p)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (sigma_empty formula-decl nil sigma_set "sigma_set/")
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (sigma const-decl "real" sigma_set "sigma_set/")
    (Sigma def-decl "nat" finite_set_theorems nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (convergent? const-decl "bool" convergence_set "sigma_set/"))
   shostak))
 (sigma_eq 0
  (sigma_eq-1 nil 3698699926
   ("" (induct "X" :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (inst -2 "f" "g")
        (("2" (ground)
          (("1" (expand Sigma 1) (("1" (grind) nil nil)) nil)
           ("2" (delete 2) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (choose const-decl "(p)" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nonempty? const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (sigma_zero 0
  (sigma_zero-1 nil 3699024578
   ("" (skeep*)
    (("" (lemma sigma_eq)
      (("" (inst -1 X f "lambda (x: nat): 0")
        (("" (ground)
          (("" (rewrite -1)
            (("" (rewrite sigma_sigma_set)
              (("" (rewrite "sigma_set[nat].sigma_zero") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sigma_eq formula-decl nil finite_set_theorems nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (sigma_zero formula-decl nil sigma_set "sigma_set/")
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (sigma_with 0
  (sigma_with-1 nil 3698699365
   ("" (induct "X" :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep*)
      (("2" (case "i = choose(X_1)")
        (("1" (expand Sigma 1)
          (("1" (lift-if)
            (("1" (assert)
              (("1" (delete -3)
                (("1" (rewrite -1)
                  (("1" (assert)
                    (("1" (rewrite -2)
                      (("1" (simplify)
                        (("1" (prop)
                          (("1" (grind) nil nil)
                           ("2" (use sigma_eq)
                            (("2" (ground)
                              (("2"
                                (skeep :preds? t)
                                (("2"
                                  (simplify)
                                  (("2"
                                    (delete 2 3)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand Sigma 2)
          (("2" (inst -2 "f" "g" "i" "j")
            (("2" (ground)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (grind) nil nil)
                   ("2" (rewrite -3)
                    (("2" (rewrite -1) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 3) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member const-decl "bool" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (sigma_eq formula-decl nil finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (/= const-decl "boolean" notequal nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak))
 (sigma_add 0
  (sigma_add-1 nil 3699021204
   ("" (skeep*)
    (("" (rewrite sigma_sigma_set)
      (("" (rewrite sigma_sigma_set)
        (("" (rewrite sigma_set[nat].sigma_remove)
          (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (convergent? const-decl "bool" convergence_set "sigma_set/")
    (sigma_remove formula-decl nil sigma_set "sigma_set/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (sigma_shift_TCC1 0
  (sigma_shift_TCC1-1 nil 3703620208 ("" (subtype-tcc) nil nil) nil nil
   (sigma_shift subtype "(LAMBDA i: X(i + 1))" "finite_set[nat]")))
 (sigma_shift 0
  (sigma_shift-1 nil 3703620209
   ("" (induct X :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (inst -3 f)
        (("2" (case-replace "choose(X_1) = 0")
          (("1" (assert)
            (("1" (expand remove)
              (("1" (expand member)
                (("1" (replace -4 :dir RL)
                  (("1" (use sigma_add)
                    (("1" (split -1)
                      (("1" (replace -1)
                        (("1" (expand remove)
                          (("1" (expand member)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand remove)
            (("2" (expand member)
              (("2" (assert)
                (("2" (expand Sigma + 1)
                  (("2" (expand nonempty?)
                    (("2" (assert)
                      (("2" (lemma sigma_add)
                        (("2"
                          (inst -1 _ "lambda i: f(1 + i)"
                           "choose(X_1) - 1")
                          (("2" (inst -1 "lambda i: X_1(1 + i)")
                            (("1" (split -1)
                              (("1"
                                (rewrite -1)
                                (("1"
                                  (expand* remove member)
                                  (("1"
                                    (replace -3)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (case-replace
                                         "(lambda i: NOT choose(X_1) = 1 + i AND X_1(1 + i)) = {y: nat | choose(X_1) - 1 /= y AND X_1(1 + y)}")
                                        (("1"
                                          (decompose-equality)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (expand is_finite)
                              (("2"
                                (skeep)
                                (("2"
                                  (inst
                                   1
                                   "N"
                                   "LAMBDA (i | X_1(1 + i)): f!1(1 + i)")
                                  (("2"
                                    (expand injective?)
                                    (("2"
                                      (skeep*)
                                      (("2"
                                        (inst -2 "1+x1" "1+x2")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep :preds? t)
        (("3" (expand is_finite)
          (("3" (skeep)
            (("3" (inst 1 "N" "LAMBDA (i | X(i + 1)): f(i + 1)")
              (("3" (expand injective?)
                (("3" (skeep*)
                  (("3" (inst -1 "x1+1" "x2+1") (("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (sigma_add formula-decl nil finite_set_theorems nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak)))

