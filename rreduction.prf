(rreduction
 (refcountExpr_popit 0
  (refcountExpr_popit-1 nil 3683904062
   ("" (skeep)
    (("" (expand "refcountExpr") (("" (rewrite "popit_refs") nil nil))
      nil))
    nil)
   ((refcountExpr const-decl "nat" rreduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popit_refs formula-decl nil reduction nil))
   shostak))
 (noDanglingRefs?_TCC1 0
  (noDanglingRefs?_TCC1-1 nil 3698761342 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (noDanglingRefs? subtype
    "(number_fields.-)((number_fields.-)(rreduction.rS`stack`length, rreduction.i), 1)"
    "below[rS`stack`length]")))
 (to_topstate_TCC1 0
  (to_topstate_TCC1-1 nil 3699126721
   ("" (subtype-tcc) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil
   (to_topstate subtype "IL.hole"
    "{K | booleans.AND(IL.cpure?(rreduction.K), preprocess.markc(sets[naturalnumbers.nat].emptyset)(rreduction.K) = rreduction.K)}")))
 (to_topstate_TCC2 0
  (to_topstate_TCC2-1 nil 3699126721
   ("" (skeep*)
    (("" (ground)
      (("1" (skeep*)
        (("1" (typepred "rS`context")
          (("1" (rewrite refs_fill)
            (("1" (typepred "rS`redex") (("1" (grind) nil nil)) nil)
             ("2" (typepred "rS`redex")
              (("2" (use contextPurefill) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite vars_decompose)
          (("2" (typepred "rS`redex")
            (("2" (rewrite popdepth_fill) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (rewrite popdepth_fill)
        (("4" (typepred "rS`redex") (("4" (grind) nil nil)) nil)) nil)
       ("5" (rewrite contextPurefill) nil nil)
       ("6" (rewrite mark_fill)
        (("6" (expand bumpn)
          (("6" (expand union)
            (("6" (expand member)
              (("6" (typepred "rS`context")
                (("6" (expand cvars 1 1)
                  (("6" (rewrite -2)
                    (("6" (expand cvars 1 2)
                      (("6" (expand emptyset)
                        (("6" (typepred "rS`redex")
                          (("6"
                            (case-replace
                             "{x: nat | cvars(rS`context)(x)} = cvars(rS`context)")
                            (("1" (grind) nil nil)
                             ("2" (grind-with-ext) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (contextPurefill formula-decl nil IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refs_fill formula-decl nil IL nil)
    (vars_decompose formula-decl nil IL nil)
    (popdepth_fill formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (mark_fill formula-decl nil preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (to_topstate subtype
    "IL.fill(rreduction.rS`context, rreduction.rS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(IL.hole)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(IL.hole)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(IL.hole)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(IL.hole))(rreduction.A) = rreduction.A)}")))
 (to_topstate_TCC3 0
  (to_topstate_TCC3-1 nil 3699126721
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (rewrite refs_fill)
              (("" (use contextPurefill)
                (("" (typepred "rS`context")
                  (("" (typepred "rS`redex") (("" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refs_fill formula-decl nil IL nil)
    (contextPurefill formula-decl nil IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (to_topstate subtype "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, IL.fill(rreduction.rS`context, rreduction.rS`redex))(i)}]")))
 (to_topstate_TCC4 0
  (to_topstate_TCC4-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil nil
   (to_topstate subtype
    "rreduction.rS WITH [`context := IL.hole, `redex := IL.fill(rreduction.rS`context, rreduction.rS`redex)]"
    "rtopstate")))
 (to_topstate_dangling 0
  (to_topstate_dangling-1 nil 3699296735
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand to_topstate)
          (("" (rewrite cvars_fill) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (below type-eq-decl nil naturalnumbers nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cvars_fill formula-decl nil preprocess nil))
   nil
   (to_topstate_dangling subtype
    "rreduction.to_topstate(rreduction.rS)"
    "(rreduction.noDanglingRefs?)")))
 (refcountStore_ref 0
  (refcountStore_ref-1 nil 3685183232
   ("" (skeep :preds? t)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (rewrite sigma_sigma_set)
          (("" (use "sigma_set[nat].sigma_gt_0")
            (("1" (ground)
              (("1" (grind) nil nil)
               ("2" (delete 2)
                (("2" (inst 1 "r")
                  (("2" (expand "refcountArray")
                    (("2"
                      (use "finseq_theorems[(IL.value?)].count_elem")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (use "finite_set_theorems.sigma_sigma_set_TCC1") nil
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (refcountArray const-decl "nat" rreduction nil)
    (sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    nil (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (count const-decl "nat" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (convergent? const-decl "bool" convergence_set "sigma_set/") nil
    nil (sigma_gt_0 formula-decl nil sigma_set "sigma_set/")
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcountArray_update_TCC1 0
  (refcountArray_update_TCC1-1 nil 3692674266
   ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil
   (refcountArray_update subtype "IExpression_adt.nil" "(IL.value?)")))
 (refcountArray_update 0
  (refcountArray_update-1 nil 3692674266
   ("" (skeep :preds? t)
    (("" (expand "refcountArray")
      (("" (use "finseq_theorems[(IL.value?)].count_update")
        (("1" (rewrite -1) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((refcountArray const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil))
   shostak))
 (store_update_TCC1 0
  (store_update_TCC1-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil
   (store_update subtype "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.rS`domain))")))
 (store_update_TCC2 0
  (store_update_TCC2-1 nil 3692717400 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (store_update subtype "rreduction.j" "below[rS`store(k)`length]")))
 (store_update 0
  (store_update-1 nil 3692717400
   ("" (skeep)
    (("" (case "r = k") (("1" (assert) nil nil) ("2" (assert) nil nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (refcountStore_update 0
  (refcountStore_update-2 "" 3714856402
   ("" (skeep)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (lemma sigma_with)
          ((""
            (inst -1 "rS`domain" _ _ "r"
             "refcountArray(rS`store WITH [(r)(seq)(j) := nil](r))(i)")
            (("1"
              (inst -1 "lambda (j_1: nat):
                   IF rS`domain(j_1) THEN refcountArray(rS`store(j_1))(i)
                   ELSE 0
                   ENDIF" "lambda (j_1: nat):
                  IF rS`domain(j_1)
                    THEN refcountArray(rS`store WITH [(r)(seq)(j) := nil](j_1))
                                      (i)
                  ELSE 0
                  ENDIF")
              (("1" (ground)
                (("1" (rewrite refcountArray_update)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (delete 2)
                  (("2" (apply-extensionality)
                    (("1" (delete 2)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1"
                            (case "(# length := rS`store(x!1)`length,
                                      seq
                                        := LAMBDA (x1: below[rS`store(x!1)`length]):
                                             IF x1 = j THEN nil
                                             ELSE rS`store(x!1)`seq(x1)
                                             ENDIF #) = rS`store(r) WITH [(seq)(j) := nil]")
                            (("1" (rewrite -1) nil nil)
                             ("2" (delete 2)
                              (("2"
                                (grind)
                                (("2" (grind-with-ext) nil nil))
                                nil))
                              nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil) nil nil
    (/= const-decl "boolean" notequal nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountArray_update formula-decl nil rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountArray const-decl "nat" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil) nil
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (allcount const-decl "nat" rreduction nil))
   shostak)
  (refcountStore_update-1 nil 3692670917
   ("" (skeep)
    (("" (expand "refcountStore")
      (("" (expand allcount)
        (("" (lemma sigma_with)
          ((""
            (inst -1 "rS`domain" _ _ "r"
             "refcountArray(rS`store WITH [(r)(seq)(j) := nil](r))(i)")
            (("1"
              (inst -1 "lambda (j_1: nat):
               IF rS`domain(j_1) THEN refcountArray(rS`store(j_1))(i)
               ELSE 0
               ENDIF" "lambda (j_1: nat):
              IF rS`domain(j_1)
                THEN refcountArray(rS`store WITH [(r)(seq)(j) := nil](j_1))
                                  (i)
              ELSE 0
              ENDIF")
              (("1" (ground)
                (("1" (rewrite refcountArray_update)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (delete 2)
                  (("2" (apply-extensionality)
                    (("1" (delete 2)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1"
                            (case "(# length := rS`store(x!1)`length,
                       seq
                         := LAMBDA (x1: below[rS`store(x!1)`length]):
                              IF x1 = j THEN nil
                              ELSE rS`store(x!1)`seq(x1)
                              ENDIF #) = rS`store(r) WITH [(seq)(j) := nil]")
                            (("1" (rewrite -1) nil nil)
                             ("2" (delete 2)
                              (("2"
                                (grind)
                                (("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountArray_update formula-decl nil rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountArray const-decl "nat" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcountStore_set 0
  (refcountStore_set-2 "" 3714871872
   ("" (skeep* :preds? t)
    (("" (expand refcountStore)
      (("" (expand allcount)
        (("" (lemma sigma_with)
          ((""
            (inst -1 dom "lambda (j_1: nat):
                 IF dom(j_1) THEN refcountArray(R(j_1))(i) ELSE 0 ENDIF"
             "lambda (j_1: nat):
                IF dom(j_1)
                  THEN refcountArray(R WITH [(r)`seq(j) := nv](j_1))(i)
                ELSE 0
                ENDIF" "r"
             "refcountArray(R(r) WITH [`seq(j) := nv])(i)")
            (("" (rewrite -1)
              (("1" (simplify)
                (("1" (expand refcountArray)
                  (("1" (rewrite count_update)
                    (("1" (simplify)
                      (("1"
                        (case-replace
                         "(ref?(nv) AND refindex(nv) = i) = refs(nv)(i)")
                        (("1"
                          (case-replace
                           "(ref?(R(r)`seq(j)) AND refindex(R(r)`seq(j)) = i) = refs(R(r)`seq(j))(i)")
                          (("1" (delete 2)
                            (("1" (typepred "R(r)`seq(j)")
                              (("1" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (delete 2)
                          (("2" (grind-with-ext) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 2)
                (("2" (apply-extensionality 1)
                  (("2" (delete 2)
                    (("2" (delete -1)
                      (("2" (case "dom(x!1)")
                        (("1" (lift-if)
                          (("1" (lift-if)
                            (("1" (ground)
                              (("1"
                                (case-replace
                                 "(# length := R(x!1)`length,
                             seq
                               := LAMBDA (x1: below[R(x!1)`length]):
                                    IF x1 = j THEN nv
                                    ELSE R(x!1)`seq(x1)
                                    ENDIF #) = R(r) WITH [`seq(j) := nv]")
                                (("1"
                                  (delete 2)
                                  (("1"
                                    (apply-extensionality)
                                    (("1"
                                      (delete 2)
                                      (("1" (grind-with-ext) nil nil))
                                      nil)
                                     ("2"
                                      (delete 2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil) nil
    nil nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (count_update formula-decl nil finseq_theorems nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil nil nil
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (Store type-eq-decl nil reduction nil)
    (domainValue? const-decl "bool" IL nil)
    (refcountArray const-decl "nat" rreduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (allcount const-decl "nat" rreduction nil))
   shostak)
  (refcountStore_set-1 nil 3699635559
   ("" (skeep* :preds? t)
    (("" (expand refcountStore)
      (("" (expand allcount)
        (("" (lemma sigma_with)
          ((""
            (inst -1 dom "lambda (j_1: nat):
               IF dom(j_1) THEN refcountArray(R(j_1))(i) ELSE 0 ENDIF"
             "lambda (j_1: nat):
              IF dom(j_1)
                THEN refcountArray(R WITH [(r)`seq(j) := nv](j_1))(i)
              ELSE 0
              ENDIF" "r" "refcountArray(R(r) WITH [`seq(j) := nv])(i)")
            (("" (rewrite -1)
              (("1" (simplify)
                (("1" (expand refcountArray)
                  (("1" (rewrite count_update)
                    (("1" (simplify)
                      (("1"
                        (case-replace
                         "(ref?(nv) AND refindex(nv) = i) = refs(nv)(i)")
                        (("1"
                          (case-replace
                           "(ref?(R(r)`seq(j)) AND refindex(R(r)`seq(j)) = i) = refs(R(r)`seq(j))(i)")
                          (("1" (delete 2)
                            (("1" (typepred "R(r)`seq(j)")
                              (("1" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (delete 2)
                          (("2" (grind-with-ext) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete 2)
                (("2" (apply-extensionality 1)
                  (("2" (delete 2)
                    (("2" (delete -1)
                      (("2" (case "dom(x!1)")
                        (("1" (lift-if)
                          (("1" (lift-if)
                            (("1" (ground)
                              (("1"
                                (case-replace
                                 "(# length := R(x!1)`length,
                       seq
                         := LAMBDA (x1: below[R(x!1)`length]):
                              IF x1 = j THEN nv
                              ELSE R(x!1)`seq(x1)
                              ENDIF #) = R(r) WITH [`seq(j) := nv]")
                                (("1"
                                  (delete 2)
                                  (("1"
                                    (apply-extensionality)
                                    (("1"
                                      (delete 2)
                                      (("1" (grind-with-ext) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (count_update formula-decl nil finseq_theorems nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (Store type-eq-decl nil reduction nil)
    (domainValue? const-decl "bool" IL nil)
    (refcountArray const-decl "nat" rreduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (allcount const-decl "nat" rreduction nil))
   shostak))
 (refcount_stack_outside_domain 0
  (refcount_stack_outside_domain-1 nil 3699029139
   ("" (skeep*)
    (("" (expand refcountStack)
      (("" (rewrite count_none_zero)
        (("" (skeep*)
          (("" (typepred "rS`stack") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_none_zero formula-decl nil finseq_theorems nil))
   shostak))
 (refcount_new_TCC1 0
  (refcount_new_TCC1-1 nil 3699027941 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil))
   nil (refcount_new subtype "rreduction.r" "(rreduction.dom1)")))
 (refcount_new_TCC2 0
  (refcount_new_TCC2-1 nil 3699027941 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil))
   nil (refcount_new subtype "rreduction.i" "(rreduction.dom1)")))
 (refcount_new 0
  (refcount_new-1 nil 3699027941
   ("" (skeep*)
    (("" (expand refcountStore)
      (("" (replace -1)
        (("" (expand allcount)
          (("" (lemma sigma_add)
            (("" (inst?)
              (("1" (inst -1 i)
                (("1" (ground)
                  (("1" (rewrite -1)
                    (("1" (expand add 2 1)
                      (("1" (rewrite remove_add_member)
                        (("1" (rewrite sigma_zero)
                          (("1" (skeep*)
                            (("1" (lift-if)
                              (("1"
                                (ground)
                                (("1"
                                  (rewrite -3 :dir RL)
                                  (("1"
                                    (expand refcountArray 1)
                                    (("1"
                                      (rewrite count_none_zero)
                                      (("1"
                                        (skeep*)
                                        (("1"
                                          (typepred
                                           "store(x)`seq(i_1)")
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    nil nil (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refcountArray const-decl "nat" rreduction nil)
    (domainValue? const-decl "bool" IL nil)
    (Store type-eq-decl nil reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (sigma_zero formula-decl nil finite_set_theorems nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (empty? const-decl "bool" sets nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (choose const-decl "(p)" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (sigma_add formula-decl nil finite_set_theorems nil))
   shostak))
 (refcount_stack_update_TCC1 0
  (refcount_stack_update_TCC1-1 nil 3700325321
   ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil
   (refcount_stack_update subtype "IExpression_adt.nil"
    "(IL.value?)")))
 (refcount_stack_update 0
  (refcount_stack_update-1 nil 3701113153
   ("" (skeep)
    (("" (typepred "rS`count(r)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (split)
              (("1" (use "count_elem[(value?)]")
                (("1" (grind) nil nil)) nil)
               ("2" (rewrite count_update)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (allcountStore_update_TCC1 0
  (allcountStore_update_TCC1-1 nil 3698768688
   ("" (skeep*)
    (("" (expand refcount)
      (("" (rewrite refcountStore_update)
        (("" (typepred "rS`count(i)")
          (("" (rewrite -1)
            (("" (expand refcount)
              (("" (lemma "refcountStore_ref") (("" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (allcountStore_update subtype
    "(number_fields.-)(rreduction.rS`count(rreduction.i), 1)"
    "{j_1 | j_1 = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq(rreduction.j) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.i)}")))
 (allcountStore_update_TCC2 0
  (allcountStore_update_TCC2-1 nil 3724502330
   ("" (skeep* :preds? t)
    (("" (typepred "rS`count(x)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (rewrite refcountStore_set)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (allcountStore_update subtype "rreduction.rS`count(rreduction.x)"
    "{j_1 | j_1 = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq(rreduction.j) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.x)}")))
 (allcountStore_update 0
  (allcountStore_update-1 nil 3698768688
   ("" (skeep*)
    ((""
      (name "rS2" "rS
                      WITH [`store(r)`seq(j) := nil,
                            `count(i) := rS`count(i) - 1]")
      (("1" (replace -1)
        (("1" (expand allcountStore)
          (("1" (expand allcount)
            (("1" (lemma sigma_with)
              (("1"
                (inst -1 "rS`domain"
                 "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF"
                 "lambda j: IF rS2`domain(j) THEN rS2`count(j) ELSE 0 ENDIF"
                 "i" "rS`count(i) - 1")
                (("1" (split -1)
                  (("1" (case-replace "rS2`domain = rS`domain")
                    (("1" (replace -2)
                      (("1" (typepred i) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (apply-extensionality)
                      (("2" (delete 2)
                        (("2" (lift-if)
                          (("2" (lift-if)
                            (("2" (lift-if)
                              (("2"
                                (case-replace "rS2`domain = rS`domain")
                                (("1"
                                  (simplify)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (typepred i) (("3" (grind) nil nil)) nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (delete -1)
                    (("2" (use refcountStore_ref)
                      (("2" (typepred "rS`count(i)")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "rS`count(i)")
        (("2" (delete 2)
          (("2" (skeep :preds? t)
            (("2" (typepred "rS`count(x)")
              (("2" (rewrite -1)
                (("2" (expand refcount)
                  (("2" (rewrite refcountStore_set)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (typepred "rS`count(i)")
        (("3" (delete 2)
          (("3" (use refcountStore_ref)
            (("3" (rewrite -2)
              (("3" (expand refcount)
                (("3" (assert)
                  (("3" (assert)
                    (("3" (rewrite refcountStore_update) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (allcount const-decl "nat" rreduction nil) nil nil
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (sigma_with formula-decl nil finite_set_theorems nil)
    (allcountStore const-decl "nat" rreduction nil)
    (/= const-decl "boolean" notequal nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (allcountStore_decrease_TCC1 0
  (allcountStore_decrease_TCC1-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil
   (allcountStore_decrease subtype "rreduction.r"
    "(rreduction.rS1`domain)")))
 (allcountStore_decrease_TCC2 0
  (allcountStore_decrease_TCC2-1 nil 3692982211
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil
   (allcountStore_decrease subtype "rreduction.r"
    "(rreduction.rS1`domain)")))
 (allcountStore_decrease 0
  (allcountStore_decrease-1 nil 3692982211
   ("" (skeep* :preds? t)
    (("" (expand allcountStore)
      (("" (expand allcount)
        (("" (rewrite sigma_sigma_set)
          (("" (rewrite sigma_sigma_set)
            (("" (lemma "sigma_set[nat].sigma_lt")
              (("" (inst -1 "rS`domain" _ _)
                ((""
                  (inst -1
                   "lambda j: IF rS1`domain(j) THEN rS1`count(j) ELSE 0 ENDIF"
                   "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF")
                  (("1" (ground)
                    (("1" (delete 2)
                      (("1" (skeep)
                        (("1" (inst -3 "t") (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst 1 s) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (use sigma_sigma_set_TCC1) nil nil)
                   ("3" (use sigma_sigma_set_TCC1) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((allcountStore const-decl "nat" rreduction nil)
    (sigma_sigma_set formula-decl nil finite_set_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma_lt formula-decl nil sigma_set "sigma_set/")
    (convergent? const-decl "bool" convergence_set "sigma_set/") nil
    nil (sigma const-decl "real" sigma_set "sigma_set/")
    (sigma const-decl "real" sigma_countable "sigma_set/")
    (limit const-decl "real" convergence_sequences "analysis/")
    (convergence const-decl "bool" convergence_sequences "analysis/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    nil (sigma def-decl "real" sigma "reals/")
    (O const-decl "T3" function_props nil)
    (denumerable_enumeration const-decl "[nat -> (X)]"
     denumerable_enumeration "sigma_set/")
    (finite_enumeration const-decl "[below[card(X)] -> (X)]"
     finite_enumeration "sigma_set/")
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/")
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_sigma_set_TCC1 subtype-tcc nil finite_set_theorems nil)
    (allcount const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref1_TCC1 0
  (decref1_TCC1-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (decref1 subtype "rreduction.s" "(rreduction.rS1`domain)")))
 (decref1_TCC2 0
  (decref1_TCC2-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype "rreduction.rS"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}")))
 (decref1_TCC3 0
  (decref1_TCC3-1 "" 3710692552
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (decref1 subtype "IExpression_adt.refindex(rreduction.subref)"
    "(rreduction.rS`domain)"))
  (decref1_TCC3-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype "IExpression_adt.refindex(rreduction.subref)"
    "(rreduction.rS`domain)")))
 (decref1_TCC4 0
  (decref1_TCC4-1 "" 3710692565
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (decref1 subtype "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]"))
  (decref1_TCC4-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (case-replace "newrS`store(r)`length = rS`store(r)`length")
      (("1" (grind) nil nil)
       ("2" (replace -7)
        (("2" (hide 3)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (simplify :let-reduce? t)
                  (("1" (assert)
                    (("1"
                      (typepred "v(rS
          WITH [(store)(r)(seq)(i - 1) := nil,
                (count)(refindex(subref))
                  := rS`count(refindex(subref)) - 1],
        refindex(subref), rS`store(refindex(subref))`length)")
                      (("1" (inst?) (("1" (assert) nil nil)) nil)
                       ("2" (hide 2) (("2" (grind) nil nil)) nil)
                       ("3" (hide 2)
                        (("3" (typepred "rS`count(refindex(subref))")
                          (("3" (rewrite -1)
                            (("3" (expand refcount)
                              (("3"
                                (split)
                                (("1"
                                  (lemma refcountStore_ref)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (split -1)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (hide-all-but (-1 1 -7))
                                              (("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite refcountStore_update)
                                  (("2"
                                    (hide-all-but (-1 1 -7))
                                    (("2" (grind-with-ext) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]")))
 (decref1_TCC5 0
  (decref1_TCC5-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil
   (decref1 subtype "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.rS`domain))")))
 (decref1_TCC6 0
  (decref1_TCC6-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (expand refcount)
      (("" (rewrite refcountStore_update)
        (("1" (typepred "rS`count(subrefindex)")
          (("1" (expand refcount)
            (("1" (split)
              (("1" (use refcountStore_ref)
                (("1" (grind-with-ext) nil nil) ("2" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (grind-with-ext) nil nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (rS skolem-const-decl "rstate" rreduction nil)
    (r skolem-const-decl "(rS`domain)" rreduction nil)
    (i skolem-const-decl "upto(rS`store(r)`length)" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype "rreduction.newsubrefcount"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq((number_fields.-)(rreduction.i, 1)) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.subrefindex)}")))
 (decref1_TCC7 0
  (decref1_TCC7-1 nil 3724502330
   ("" (skeep* :preds? t)
    (("" (typepred "rS`count(x)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (rewrite refcountStore_set)
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype "rreduction.rS`count(rreduction.x)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq((number_fields.-)(rreduction.i, 1)) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.x)}")))
 (decref1_TCC8 0
  (decref1_TCC7-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (decref1 subtype "rreduction.subrefindex"
    "(rreduction.newrS`domain)")))
 (decref1_TCC9 0
  (decref1_TCC8-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (decref1 subtype
    "rreduction.rS`store(rreduction.subrefindex)`length"
    "naturalnumbers.upto(rreduction.newrS`store(rreduction.subrefindex)`length)")))
 (decref1_TCC10 0
  (decref1_TCC9-1 "" 3710692786
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (case "allcountStore(newrS) < allcountStore(rS)")
        (("1" (grind) nil nil)
         ("2" (replace -12)
          (("2" (lemma allcountStore_update)
            (("2" (inst?)
              (("2" (inst?)
                (("2" (split -1)
                  (("1" (assert) nil nil)
                   ("2" (hide-all-but (1 -9 -10))
                    (("2" (grind-with-ext) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (< def-decl "bool" ordinals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (decref1 termination
    "rreduction.decref1(rreduction.newrS, rreduction.subrefindex, rreduction.rS`store(rreduction.subrefindex)`length)"
    "nil"))
  (decref1_TCC9-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (case "allcountStore(newrS) < allcountStore(rS)")
      (("1" (grind) nil nil)
       ("2" (replace*)
        (("2" (rewrite allcountStore_update)
          (("1" (assert) nil nil) ("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (value? const-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (allcountStore const-decl "nat" rreduction nil)
    (< def-decl "bool" ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 termination
    "rreduction.decref1(rreduction.newrS, rreduction.subrefindex, rreduction.rS`store(rreduction.subrefindex)`length)"
    "nil")))
 (decref1_TCC11 0
  (decref1_TCC10-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (decref1 subtype "rreduction.r" "(rreduction.newrS`domain)")))
 (decref1_TCC12 0
  (decref1_TCC11-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (simplify :let-reduce? t)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (assert)
              (("1"
                (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (typepred "rS`count(refindex(subref))")
                  (("3" (rewrite -1)
                    (("3" (expand refcount)
                      (("3" (use refcountStore_ref)
                        (("3" (skeep* :preds? t)
                          (("3" (typepred "rS`count(x)")
                            (("3" (rewrite -1)
                              (("3"
                                (expand refcount)
                                (("3"
                                  (rewrite refcountStore_set)
                                  (("1"
                                    (assert)
                                    (("1" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (typepred "rS`count(refindex(subref))")
                  (("4" (rewrite -1)
                    (("4" (expand refcount)
                      (("4" (split)
                        (("1" (use refcountStore_ref)
                          (("1" (split -1)
                            (("1" (grind) nil nil)
                             ("2" (grind-with-ext) nil nil))
                            nil))
                          nil)
                         ("2" (rewrite refcountStore_update)
                          (("2" (grind-with-ext) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (decref1 subtype "(number_fields.-)(rreduction.i, 1)"
    "naturalnumbers.upto(rreduction.newrS`store(rreduction.r)`length)")))
 (decref1_TCC13 0
  (decref1_TCC12-2 "" 3714665431
   ("" (skeep* :preds? t)
    ((""
      (case "allcountStore(newrS) <= allcountStore(rS) AND
              newrS`domain = rS`domain AND
               forall (s: (rS`domain)):
                 newrS`store(s)`length = rS`store(s)`length AND
                  newrS`count(s) <= rS`count(s) AND
                   (newrS`count(s) = 0 OR
                     newrS`store(s) = rS`store(s))")
      (("1" (typepred "v(newrS, r, i-1)")
        (("1" (flatten) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil)
         ("3" (flatten) (("3" (inst?) (("3" (grind) nil nil)) nil))
          nil)
         ("4" (grind) nil nil))
        nil)
       ("2" (delete 3)
        (("2" (lift-if)
          (("2" (split -)
            (("1" (flatten)
              (("1" (simplify :let-reduce? t)
                (("1"
                  (typepred "v(rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1],
               refindex(subref), rS`store(refindex(subref))`length)")
                  (("1" (replace -5 :dir rl)
                    (("1" (split)
                      (("1" (rewrite allcountstore_update)
                        (("1" (grind) nil nil)
                         ("2" (grind-with-ext) nil nil))
                        nil)
                       ("2" (propax) nil nil)
                       ("3" (skeep)
                        (("3" (inst?)
                          (("3" (simplify)
                            (("3" (flatten)
                              (("3"
                                (lift-if)
                                (("3"
                                  (simplify)
                                  (("3"
                                    (case-replace "s = r")
                                    (("1"
                                      (simplify)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil)
                   ("3" (typepred "rS`count(refindex(subref))")
                    (("3" (rewrite -1)
                      (("3" (expand refcount)
                        (("3" (split)
                          (("1" (use refcountstore_ref)
                            (("1" (split -1)
                              (("1"
                                (skeep* :preds? t)
                                (("1"
                                  (typepred "rS`count(x)")
                                  (("1"
                                    (rewrite -1)
                                    (("1"
                                      (expand refcount)
                                      (("1"
                                        (rewrite refcountStore_set)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind-with-ext) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind-with-ext) nil nil)
                           ("3" (hide 1)
                            (("3" (skeep* :preds? t)
                              (("3"
                                (typepred "rS`count(x)")
                                (("3"
                                  (rewrite -1)
                                  (("3"
                                    (expand refcount)
                                    (("3"
                                      (rewrite refcountStore_set)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (hide 2)
                    (("4" (typepred "rS`count(refindex(subref))")
                      (("4" (rewrite -1)
                        (("4" (expand refcount)
                          (("4" (split)
                            (("1" (use refcountStore_ref)
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (rewrite refcountStore_update)
                              (("2" (grind-with-ext) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (grind) nil nil) ("6" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (replace -1 :hide? t) (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (i skolem-const-decl "upto(rS`store(r)`length)" rreduction nil)
    (r skolem-const-decl "(rS`domain)" rreduction nil)
    (rS skolem-const-decl "rstate" rreduction nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (/= const-decl "boolean" notequal nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   shostak
   (decref1 termination
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "nil"))
  (decref1_TCC12-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (case "allcountStore(newrS) <= allcountStore(rS)")
      (("1" (grind) nil nil)
       ("2" (delete 3)
        (("2" (lift-if)
          (("2" (split)
            (("1" (flatten)
              (("1"
                (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (rewrite allcountStore_update)
                  (("1" (grind) nil nil)
                   ("2" (grind-with-ext) nil nil))
                  nil)
                 ("2" (grind) nil nil)
                 ("3" (typepred "rS`count(refindex(subref))")
                  (("3" (rewrite -1)
                    (("3" (expand refcount)
                      (("3" (split)
                        (("1" (use refcountStore_ref)
                          (("1" (grind-with-ext) nil nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (rewrite refcountStore_update)
                          (("2" (grind-with-ext) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4" (grind) nil nil) ("5" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((OR const-decl "[bool, bool -> bool]" booleans nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 termination
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "nil"))
  (decref1_TCC12-1 "" 3710693184
   ("" (skeep* :preds? t)
    (("" (case "ref?(subref)")
      (("1" (assert)
        (("1" (case "allcountStore(newrS) < allcountStore(rS)")
          (("1" (grind) nil nil)
           ("2" (hide 2)
            (("2"
              (typepred "v(rS
           WITH [(store)(r)(seq)(i - 1) := nil,
                 (count)(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
              (("1" (replace -11 :dir RL)
                (("1" (rewrite allcountStore_update)
                  (("1" (assert) nil nil)
                   ("2" (grind-with-ext) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil)
               ("3" (typepred "rS`count(refindex(subref))")
                (("3" (replace -1)
                  (("3" (expand refcount)
                    (("3" (split)
                      (("1" (use refcountStore_ref)
                        (("1" (split)
                          (("1" (assert) nil nil)
                           ("2" (grind-with-ext) nil nil))
                          nil))
                        nil)
                       ("2" (rewrite refcountStore_update)
                        (("2" (grind-with-ext) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert) (("2" (replace -7) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   nil shostak
   (decref1 termination
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "nil")))
 (decref1_TCC14 0
  (decref1_TCC13-2 "" 3714668347
   ("" (skeep* :preds? t)
    ((""
      (case "allcountStore(newrS) <= allcountStore(rS) AND
              newrS`domain = rS`domain AND
               forall (s: (rS`domain)):
                 newrS`store(s)`length = rS`store(s)`length AND
                  newrS`count(s) <= rS`count(s) AND
                   (newrS`count(s) = 0 OR
                     newrS`store(s) = rS`store(s))")
      (("1" (typepred "v(newrS, r, i-1)")
        (("1" (flatten)
          (("1" (split)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (skeep :preds? t)
              (("3" (inst?)
                (("1" (flatten)
                  (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (hide-all-but (1 -1 2)) (("2" (grind) nil nil)) nil))
          nil)
         ("3" (flatten) (("3" (inst?) (("3" (grind) nil nil)) nil))
          nil)
         ("4" (grind) nil nil))
        nil)
       ("2" (delete 3)
        (("2" (lift-if)
          (("2" (split -)
            (("1" (flatten)
              (("1" (simplify :let-reduce? t)
                (("1"
                  (typepred "v(rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1],
               refindex(subref), rS`store(refindex(subref))`length)")
                  (("1" (replace -5 :dir rl)
                    (("1" (split)
                      (("1" (rewrite allcountstore_update)
                        (("1" (grind) nil nil)
                         ("2" (grind-with-ext) nil nil))
                        nil)
                       ("2" (propax) nil nil)
                       ("3" (skeep)
                        (("3" (inst?)
                          (("3" (simplify)
                            (("3" (flatten)
                              (("3"
                                (lift-if)
                                (("3"
                                  (simplify)
                                  (("3"
                                    (case-replace "s = r")
                                    (("1"
                                      (simplify)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil)
                   ("3" (typepred "rS`count(refindex(subref))")
                    (("3" (rewrite -1)
                      (("3" (expand refcount)
                        (("3" (split)
                          (("1" (use refcountstore_ref)
                            (("1" (split -1)
                              (("1"
                                (skeep* :preds? t)
                                (("1"
                                  (typepred "rS`count(x)")
                                  (("1"
                                    (rewrite -1)
                                    (("1"
                                      (expand refcount)
                                      (("1"
                                        (rewrite refcountStore_set)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind-with-ext) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind-with-ext) nil nil)
                           ("3" (hide 1)
                            (("3" (skeep* :preds? t)
                              (("3"
                                (typepred "rS`count(x)")
                                (("3"
                                  (rewrite -1)
                                  (("3"
                                    (expand refcount)
                                    (("3"
                                      (rewrite refcountStore_set)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (hide 2)
                    (("4" (typepred "rS`count(refindex(subref))")
                      (("4" (rewrite -1)
                        (("4" (expand refcount)
                          (("4" (split)
                            (("1" (use refcountStore_ref)
                              (("1"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (rewrite refcountStore_set)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (grind) nil nil) ("6" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (replace -1 :hide? t) (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (i skolem-const-decl "upto(rS`store(r)`length)" rreduction nil)
    (r skolem-const-decl "(rS`domain)" rreduction nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (/= const-decl "boolean" notequal nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (newrS skolem-const-decl "rstate" rreduction nil)
    (rS skolem-const-decl "rstate" rreduction nil)
    (s skolem-const-decl "(rS`domain)" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   shostak
   (decref1 subtype
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}"))
  (decref1_TCC13-1 nil 3702839528
   ("" (skeep* :preds? t)
    ((""
      (case "allcountStore(newrS) <= allcountStore(rS) AND
       newrS`domain = rS`domain AND
        forall (s: (rS`domain)):
          newrS`store(s)`length = rS`store(s)`length AND
           newrS`count(s) <= rS`count(s) AND
            (newrS`count(s) = 0 OR
              newrS`store(s) = rS`store(s))")
      (("1" (typepred "v(newrS, r, i-1)")
        (("1" (flatten)
          (("1" (split)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (skeep :preds? t)
              (("3" (inst?)
                (("1" (flatten)
                  (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (hide-all-but (1 -1 2)) (("2" (grind) nil nil)) nil))
          nil)
         ("3" (flatten) (("3" (inst?) (("3" (grind) nil nil)) nil))
          nil)
         ("4" (grind) nil nil))
        nil)
       ("2" (delete 3)
        (("2" (lift-if)
          (("2" (split -)
            (("1" (flatten)
              (("1" (simplify :let-reduce? t)
                (("1"
                  (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                  (("1" (replace -5 :dir RL)
                    (("1" (split)
                      (("1" (rewrite allcountStore_update)
                        (("1" (grind) nil nil)
                         ("2" (grind-with-ext) nil nil))
                        nil)
                       ("2" (propax) nil nil)
                       ("3" (skeep)
                        (("3" (inst?)
                          (("3" (simplify)
                            (("3" (flatten)
                              (("3"
                                (lift-if)
                                (("3"
                                  (simplify)
                                  (("3"
                                    (case-replace "s = r")
                                    (("1"
                                      (simplify)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil)
                   ("3" (typepred "rS`count(refindex(subref))")
                    (("3" (rewrite -1)
                      (("3" (expand refcount)
                        (("3" (split)
                          (("1" (use refcountStore_ref)
                            (("1" (split -1)
                              (("1" (grind) nil nil)
                               ("2" (grind-with-ext) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (rewrite refcountStore_update)
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (grind) nil nil) ("5" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((OR const-decl "[bool, bool -> bool]" booleans nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}"))
  (decref1_TCC13-1 "" 3710693976
   ("" (skeep* :preds? t)
    (("" (case "ref?(subref)")
      (("1" (assert)
        (("1" (simplify :let-reduce? t)
          (("1"
            (typepred "v(rS
           WITH [(store)(r)(seq)(i - 1) := nil,
                 (count)(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (rewrite allcountStore_update)
              (("1" (assert)
                (("1" (skeep)
                  (("1" (inst -3 s)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (replace -13 :dir RL)
                          (("1" (assert)
                            (("1" (lift-if)
                              (("1"
                                (assert)
                                (("1"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (typepred "v(newrS, r, i - 1)")
                                        (("1"
                                          (inst -3 s)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 3)
                                          (("2" (grind) nil nil))
                                          nil)
                                         ("3"
                                          (case-replace
                                           "newrS`store(r)`length = rS`store(r)`length")
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (reveal *)
                                            (("2"
                                              (inst -1 r)
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (reveal *)
                                      (("2"
                                        (inst -1 r)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (replace -16 :dir RL)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (typepred
                                                           "v(newrS, r, i - 1)")
                                                          (("1"
                                                            (inst -3 s)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (hide-all-but
                                                                       (-4
                                                                        -9
                                                                        1))
                                                                      (("1"
                                                                        (grind)
                                                                        (("1"
                                                                          (grind)
                                                                          (("1"
                                                                            (name-replace
                                                                             a
                                                                             "newrS`count(s)")
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (name-replace
                                                                                 b
                                                                                 "v(newrS, r, i - 1)`count(s)")
                                                                                (("1"
                                                                                  (assert)
                                                                                  (("1"
                                                                                    (name-replace
                                                                                     c
                                                                                     "rS`count(s)")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      (("1"
                                                                                        (generalize
                                                                                         a
                                                                                         a
                                                                                         nat)
                                                                                        (("1"
                                                                                          (generalize
                                                                                           b
                                                                                           b
                                                                                           nat)
                                                                                          (("1"
                                                                                            (generalize
                                                                                             c
                                                                                             c
                                                                                             nat)
                                                                                            (("1"
                                                                                              (grind)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide 5)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil)
             ("2" (lift-if) (("2" (assert) nil nil)) nil)
             ("3" (hide 3)
              (("3" (typepred "rS`count(refindex(subref))")
                (("3" (rewrite -1)
                  (("3" (expand refcount)
                    (("3" (split)
                      (("1" (use refcountStore_ref)
                        (("1" (split -1)
                          (("1" (assert) nil nil)
                           ("2" (grind-with-ext) nil nil))
                          nil))
                        nil)
                       ("2" (rewrite refcountStore_update)
                        (("2" (grind-with-ext) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (typepred "v(newrS, r, i - 1)")
          (("1" (assert)
            (("1" (skeep)
              (("1" (inst?)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (flatten) (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace -7) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (decref1 subtype
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}")))
 (decref1_TCC15 0
  (decref1_TCC14-2 "" 3714544812 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak
   (decref1 subtype "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]"))
  (decref1_TCC14-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (expand refcount)
      (("" (rewrite refcountStore_update)
        (("1" (typepred "rS`count(subrefindex)")
          (("1" (expand refcount)
            (("1" (assert)
              (("1" (use refcountStore_ref)
                (("1" (split)
                  (("1" (assert) nil nil)
                   ("2" (hide-all-but (1 -10 -11))
                    (("2" (grind-with-ext) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but (1 -10 -11))
          (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (decref1 subtype "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]")))
 (decref1_TCC16 0
  (decref1_TCC15-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1 subtype "rreduction.rS"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}")))
 (decref1_induction_TCC1 0
  (decref1_induction_TCC1-1 nil 3702839528 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil))
   nil
   (decref1_induction subtype "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.rS`domain))")))
 (decref1_induction_TCC2 0
  (decref1_induction_TCC2-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (typepred "rS`store(r)`seq(i)") (("" (grind) nil nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1_induction subtype
    "IExpression_adt.refindex(rreduction.rS`store(rreduction.r)`seq(rreduction.i))"
    "(rreduction.rS`domain)")))
 (decref1_induction_TCC3 0
  (decref1_induction_TCC3-1 nil 3702839528
   ("" (skeep* :preds? t)
    (("" (typepred "rS`count(refindex(rS`store(r)`seq(i)))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (split)
            (("1" (use refcountStore_ref)
              (("1" (grind-with-ext) nil nil)) nil)
             ("2" (rewrite refcountStore_update)
              (("2" (grind-with-ext) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (typepred "rS`store(r)`seq(i)") (("2" (grind) nil nil))
        nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1_induction subtype
    "(number_fields.-)(rreduction.rS`count(IExpression_adt.refindex(rreduction.rS`store(rreduction.r)`seq(rreduction.i))), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq(rreduction.i) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(IExpression_adt.refindex(rreduction.rS`store(rreduction.r)`seq(rreduction.i)))}")))
 (decref1_induction_TCC4 0
  (decref1_induction_TCC4-1 nil 3724502330
   ("" (skeep* :preds? t)
    (("" (typepred "rS`count(x)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (rewrite refcountStore_set)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1_induction subtype "rreduction.rS`count(rreduction.x)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq(rreduction.i) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.x)}")))
 (decref1_induction 0
  (decref1_induction-2 "" 3710691615
   ("" (skeep)
    (("" (measure-induct+ "allcountStore(rS)" ("rS"))
      (("" (skeep)
        (("" (generalize i i "upto(x!1`store(r)`length)" 1)
          (("" (induct i)
            (("1" (expand decref1 1) (("1" (propax) nil nil)) nil)
             ("2" (skeep)
              (("2" (expand decref1 1)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (name-replace "rS" "x!1")
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1"
                              (name-replace "idx"
                               "refindex(rS`store(r)`seq(jt))")
                              (("1"
                                (name-replace
                                 "rS2"
                                 "rS
                                  WITH [`store(r)`seq(jt) := nil,
                                        `count(idx) := rS`count(idx) - 1]")
                                (("1"
                                  (case
                                   "allcountStore(rS2) < allcountStore(rS)")
                                  (("1"
                                    (case
                                     "P(decref1(rS2, idx, rS`store(idx)`length))")
                                    (("1"
                                      (inst? :where +)
                                      (("1"
                                        (split)
                                        (("1" (propax) nil nil)
                                         ("2" (assert) nil nil)
                                         ("3"
                                          (typepred
                                           "decref1(rS2, idx, rS`store(idx)`length)")
                                          (("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand idx)
                                      (("2"
                                        (expand rS)
                                        (("2"
                                          (typepred
                                           "x!1`store(r)`seq(jt)")
                                          (("2"
                                            (expand domainValue?)
                                            (("2"
                                              (prop)
                                              (("2"
                                                (case "P(rS2)")
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand rS2)
                                                  (("2"
                                                    (expand idx)
                                                    (("2"
                                                      (delete 2)
                                                      (("2"
                                                        (delete 2)
                                                        (("2"
                                                          (delete -8)
                                                          (("2"
                                                            (inst?)
                                                            (("2"
                                                              (split)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (expand
                                                                 rS)
                                                                (("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (expand
                                                                 rS)
                                                                (("3"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("4"
                                                                (expand
                                                                 rS)
                                                                (("4"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (expand idx)
                                      (("3"
                                        (expand rS2)
                                        (("3"
                                          (expand idx)
                                          (("3"
                                            (assert)
                                            (("3"
                                              (lift-if)
                                              (("3" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4"
                                      (expand idx)
                                      (("4"
                                        (typepred
                                         "rS`store(r)`seq(jt)")
                                        (("4"
                                          (expand domainValue?)
                                          (("4"
                                            (prop)
                                            (("4" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand rS2)
                                    (("2"
                                      (expand idx)
                                      (("2"
                                        (use allcountStore_update)
                                        (("2"
                                          (split -1)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (hide-all-but (1 -1))
                                            (("2"
                                              (grind-with-ext)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand idx)
                                  (("2"
                                    (delete 2)
                                    (("2"
                                      (typepred
                                       "rS`count(refindex(rS`store(r)`seq(jt)))")
                                      (("1"
                                        (rewrite -1)
                                        (("1"
                                          (expand refcount)
                                          (("1"
                                            (skeep :preds? t)
                                            (("1"
                                              (rewrite
                                               refcountStore_set)
                                              (("1"
                                                (typepred
                                                 "rS`count(x)")
                                                (("1"
                                                  (rewrite -1)
                                                  (("1"
                                                    (expand refcount)
                                                    (("1"
                                                      (hide-all-but
                                                       (1 2))
                                                      (("1"
                                                        (grind)
                                                        (("1"
                                                          (typepred
                                                           "rS`store(r)`seq(jt)")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred
                                         "rS`store(r)`seq(jt)")
                                        (("2"
                                          (expand domainValue?)
                                          (("2"
                                            (prop)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (assert) nil nil)
                                       ("4" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide 2)
                                  (("3"
                                    (typepred "rS`count(idx)")
                                    (("1"
                                      (rewrite -1)
                                      (("1"
                                        (expand refcount)
                                        (("1"
                                          (split)
                                          (("1"
                                            (use refcountStore_ref)
                                            (("1"
                                              (split -1)
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (expand idx)
                                                (("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (grind-with-ext)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (rewrite
                                             refcountStore_update)
                                            (("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (grind-with-ext)
                                                (("2"
                                                  (expand idx)
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand idx)
                                      (("2"
                                        (typepred
                                         "rS`store(r)`seq(jt)")
                                        (("2"
                                          (hide 2)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (assert)
                                  (("4" (grind) nil nil))
                                  nil)
                                 ("5" (grind) nil nil))
                                nil)
                               ("2" (assert) nil nil)
                               ("3" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((upto_induction formula-decl nil bounded_nat_inductions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (/= const-decl "boolean" notequal nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil
    (below type-eq-decl nil naturalnumbers nil) nil nil
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil) nil nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1 def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak)
  (decref1_induction-1 nil 3702845439
   ("" (skeep)
    (("" (measure-induct+ "allcountStore(rS)" ("rS"))
      (("" (skeep)
        (("" (generalize i i "upto(x!1`store(r)`length)" 1)
          (("" (induct i)
            (("1" (expand decref1 1) (("1" (propax) nil nil)) nil)
             ("2" (skeep)
              (("2" (expand decref1 1)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (name-replace "rS" "x!1")
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1"
                              (name-replace "idx"
                               "refindex(rS`store(r)`seq(jt))")
                              (("1"
                                (name-replace
                                 "rS2"
                                 "rS
                          WITH [`store(r)`seq(jt) := nil,
                                `count(idx) := rS`count(idx) - 1]")
                                (("1"
                                  (case
                                   "allcountStore(rS2) < allcountStore(rS)")
                                  (("1"
                                    (case
                                     "P(decref1(rS2, idx, rS`store(idx)`length))")
                                    (("1"
                                      (inst? :where +)
                                      (("1"
                                        (split)
                                        (("1" (propax) nil nil)
                                         ("2" (propax) nil nil)
                                         ("3"
                                          (typepred
                                           "decref1(rS2, idx, rS`store(idx)`length)")
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand idx)
                                        (("2"
                                          (expand rS)
                                          (("2"
                                            (typepred
                                             "x!1`store(r)`seq(jt)")
                                            (("1"
                                              (expand domainValue?)
                                              (("1" (prop) nil nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (case "P(rS2)")
                                      (("1"
                                        (inst?)
                                        (("1" (prop) nil nil))
                                        nil)
                                       ("2"
                                        (expand rS2)
                                        (("2"
                                          (expand idx)
                                          (("2"
                                            (delete 2)
                                            (("2"
                                              (delete 2)
                                              (("2"
                                                (delete -6)
                                                (("2"
                                                  (inst?)
                                                  (("2"
                                                    (split)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("3"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("4"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (expand idx)
                                      (("3"
                                        (typepred
                                         "rS`store(r)`seq(jt)")
                                        (("3"
                                          (expand domainValue?)
                                          (("3" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand rS2)
                                    (("2"
                                      (expand idx)
                                      (("2"
                                        (use allcountStore_update)
                                        (("2"
                                          (split -1)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (hide-all-but (1 -1))
                                            (("2"
                                              (grind-with-ext)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand idx)
                                  (("2"
                                    (delete 2)
                                    (("2"
                                      (typepred
                                       "rS`count(refindex(rS`store(r)`seq(jt)))")
                                      (("1"
                                        (rewrite -1)
                                        (("1"
                                          (expand refcount)
                                          (("1"
                                            (split)
                                            (("1"
                                              (use refcountStore_ref)
                                              (("1"
                                                (split -1)
                                                (("1" (grind) nil nil)
                                                 ("2"
                                                  (hide-all-but (1 -1))
                                                  (("2"
                                                    (grind-with-ext)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (rewrite
                                               refcountStore_update)
                                              (("2"
                                                (hide-all-but (1 -1))
                                                (("2"
                                                  (grind-with-ext)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred
                                         "rS`store(r)`seq(jt)")
                                        (("2"
                                          (expand domainValue?)
                                          (("2" (prop) nil nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil)
                                       ("4" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (decref1 def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refcountStore_update formula-decl nil rreduction nil)
    (refcountStore_ref formula-decl nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (allcountStore_update formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil))
   shostak))
 (decref_TCC1 0
  (decref_TCC1-1 nil 3692915538
   ("" (lemma decref1_induction)
    (("" (inst -1 noDanglingRefs?)
      (("" (split -1)
        (("1" (skeep* :preds? t)
          (("1" (typepred "decref1(rS, r, i)")
            (("1" (assert)
              (("1" (split)
                (("1" (propax) nil nil)
                 ("2" (inst? -7) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 2)
          (("2" (skeep* :preds? t)
            (("2" (expand noDanglingRefs?) (("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (pred type-eq-decl nil defined_types nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (allcountStore const-decl "nat" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (decref1 def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     rreduction nil)
    (decref1_induction formula-decl nil rreduction nil))
   nil
   (decref subtype
    "rreduction.decref1(rreduction.rS, rreduction.r, rreduction.i)"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, booleans.AND((FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s)))))), rreduction.noDanglingRefs?(rreduction.rS1))))}")))
 (decref1_chk_TCC1 0
  (decref1_chk_TCC1-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil (decref1_chk subtype "rreduction.s" "(rreduction.rS1`domain)")))
 (decref1_chk_TCC2 0
  (decref1_chk_TCC2-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil))
   nil
   (decref1_chk subtype "IExpression_adt.refindex(rreduction.x)"
    "(rreduction.rS`domain)")))
 (decref1_chk_TCC3 0
  (decref1_chk_TCC3-1 nil 3706028126 ("" (subtype-tcc) nil nil) nil nil
   (decref1_chk subtype
    "rreduction.rS`store(IExpression_adt.refindex(rreduction.x))`length"
    "naturalnumbers.upto(rreduction.rS`store(IExpression_adt.refindex(rreduction.x))`length)")))
 (decref1_chk_TCC4 0
  (decref1_chk_TCC4-1 nil 3706028126 ("" (subtype-tcc) nil nil) nil nil
   (decref1_chk subtype "rreduction.rS"
    "{rS1 | booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s)))))))}")))
 (decref1_chk_ndr 0
  (decref1_chk_ndr-1 nil 3706037470
   ("" (skeep* :preds? t)
    (("" (expand decref1_chk)
      (("" (split)
        (("1" (flatten)
          (("1"
            (case-replace "decref1(rS, refindex(x),
                              rS`store(refindex(x))`length) = decref(rS, refindex(x),
                              rS`store(refindex(x))`length)")
            (("1" (assert) nil nil)
             ("2" (expand decref) (("2" (propax) nil nil)) nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (decref1 def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (allcountStore const-decl "nat" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref1_chk_ndr subtype
    "rreduction.decref1_chk(rreduction.rS, rreduction.x)"
    "(rreduction.noDanglingRefs?)")))
 (stack_update_correct 0
  (stack_update_correct-1 nil 3700487299
   ("" (skeep* :preds? t)
    (("" (typepred "rS`stack")
      (("" (expand every)
        (("" (skeep*) (("" (inst -1 i_1) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (letApply_TCC1 0
  (letApply_TCC1-1 nil 3699206216 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (letApply subtype "(number_fields.-)(rreduction.arity, 1)" "nat"))
  (pure_letApply_TCC1-1 nil 3699206216
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (letApply subtype "(number_fields.-)(rreduction.arity, 1)" "nat")))
 (letApply_TCC2 0
  (letApply_TCC2-1 nil 3699206216 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (letApply subtype "rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)"))
  (pure_letApply_TCC2-1 nil 3699206216
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (letApply subtype "rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)")))
 (letApply_TCC3 0
  (letApply_TCC3-1 nil 3699206216 ("" (subtype-tcc) nil nil) nil nil
   (letApply subtype "rreduction.x" "(IExpression_adt.variable?)")))
 (letApply_TCC4 0
  (letApply_TCC4-1 nil 3699206216 ("" (subtype-tcc) nil nil) nil nil
   (letApply subtype
    "rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)]"
    "(IExpression_adt.variable?)")))
 (letApply_TCC5 0
  (letApply_TCC5-1 nil 3699206216
   ("" (skeep*)
    (("" (rewrite map_length)
      (("" (typepred args)
        (("" (grind)
          (("" (expand length -2) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil
   (letApply subtype
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)])(list_adt[(IExpression_adt.variable?)].cdr(rreduction.args))"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = (number_fields.-)(rreduction.arity, 1)}")))
 (letApply_TCC6 0
  (letApply_TCC6-1 nil 3699206216 ("" (termination-tcc) nil nil) nil
   nil
   (letApply termination
    "rreduction.letApply((number_fields.-)(rreduction.arity, 1), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)])(list_adt[(IExpression_adt.variable?)].cdr(rreduction.args)), rreduction.A)"
    "nil")))
 (letApply_TCC7 0
  (letApply_TCC7-1 nil 3699206216
   ("" (subtype-tcc) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil))
   nil
   (letApply subtype "rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)")))
 (pure_letApply_TCC1 0
  (pure_letApply_TCC1-1 nil 3699206216
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (pure_letApply_ subtype
    "IExpression_adt.letexpr(rreduction.arg1, IExpression_adt.release(IExpression_adt.variable(0, booleans.TRUE), rreduction.B))"
    "(IL.pure?)")))
 (pure_letApply_TCC2 0
  (pure_letApply_TCC2-1 nil 3699206216
   ("" (recursive-judgement-tcc) nil nil)
   ((pure? def-decl "bool" IL nil)) nil
   (pure_letApply_ subtype
    "IExpression_adt.letexpr(rreduction.arg1, rreduction.B)"
    "(IL.pure?)")))
 (bump_varlist_TCC1 0
  (bump_varlist_TCC1-1 nil 3699274146 ("" (subtype-tcc) nil nil) nil
   nil
   (bump_varlist subtype "rreduction.y"
    "(IExpression_adt.variable?)")))
 (bump_varlist_TCC2 0
  (bump_varlist_TCC2-1 nil 3699274146 ("" (subtype-tcc) nil nil) nil
   nil
   (bump_varlist subtype
    "rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.y), 1)]"
    "(IExpression_adt.variable?)")))
 (bump_varlist 0
  (bump_varlist-1 nil 3699274147
   ("" (skeep*)
    (("" (expand in_varlist)
      (("" (apply-extensionality 1)
        (("1" (delete 2)
          (("1" (rewrite some_map)
            (("1" (expand bump)
              (("1" (expand bumpn)
                (("1" (expand o)
                  (("1" (rewrite some_nth)
                    (("1" (rewrite some_nth)
                      (("1" (iff)
                        (("1" (ground)
                          (("1" (grind) nil nil)
                           ("2" (skeep*) (("2" (grind) nil nil)) nil)
                           ("3" (skeep*) (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 2)
          (("2"
            (case-replace "{i |
              some[(variable?)](lambda (v: (variable?)): index(v) = i)(L)} = in_varlist(L)")
            (("1" (grind) nil nil)
             ("2" (expand in_varlist) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)
    (O const-decl "T3" function_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (vars_letApply 0
  (vars_letApply-1 nil 3699282159
   ("" (induct i)
    (("1" (skeep* :preds? t)
      (("1" (expand letApply)
        (("1" (case "args = null")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (expand letApply 1)
        (("2" (expand vars 1 2)
          (("2" (expand vars 1 3)
            (("2" (expand vars 1 4)
              (("2" (expand drop)
                (("2" (expand add)
                  (("2" (expand member)
                    (("2" (expand union)
                      (("2" (expand member)
                        (("2" (expand in_varlist 1)
                          (("2" (name "hd" "car(args)")
                            (("2" (name "tl" "cdr(args)")
                              (("2"
                                (case-replace "args = cons(hd, tl)")
                                (("1"
                                  (simplify)
                                  (("1"
                                    (expand some)
                                    (("1"
                                      (typepred hd)
                                      (("1"
                                        (expand vars 1 1)
                                        (("1"
                                          (expand singleton 1)
                                          (("1"
                                            (rewrite -5)
                                            (("1"
                                              (rewrite bump_varlist)
                                              (("1"
                                                (expand bump)
                                                (("1"
                                                  (expand bumpn)
                                                  (("1"
                                                    (expand
                                                     in_varlist
                                                     1)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (bump_varlist formula-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil) nil
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil) nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (letApply def-decl "IExpression" rreduction nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (popdepth_letApply 0
  (popdepth_letApply-1 nil 3699282706
   ("" (induct i)
    (("1" (skeep :preds? t) (("1" (grind) nil nil)) nil)
     ("2" (skeep* :preds? t) (("2" (grind) nil nil)) nil)
     ("3" (grind) nil nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (letApply def-decl "IExpression" rreduction nil) nil
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (mark_letApply_cons_TCC1 0
  (mark_letApply_cons_TCC1-1 nil 3699212334 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) nil
   (mark_letApply_cons subtype
    "list_adt[(IExpression_adt.variable?)].cons(rreduction.x, rreduction.L)"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = (number_fields.+)(1, list_props[(IExpression_adt.variable?)].length(rreduction.L))}")))
 (mark_letApply_cons_TCC2 0
  (mark_letApply_cons_TCC2-1 nil 3699212334
   ("" (skeep*) (("" (rewrite map_length) nil nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (map_length formula-decl nil more_map_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil
   (mark_letApply_cons subtype
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.y), 1)])(rreduction.L)"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = list_props[(IExpression_adt.variable?)].length(rreduction.L)}")))
 (mark_letApply_cons 0
  (mark_letApply_cons-1 nil 3699212334
   ("" (skeep*)
    (("" (expand letApply 1 1)
      (("" (rewrite vars_mark)
        (("1" (lift-if)
          (("1" (ground)
            (("1" (expand mark 2 1)
              (("1" (decompose-equality)
                (("1" (expand mark)
                  (("1" (expand markv)
                    (("1" (expand union)
                      (("1" (expand drop)
                        (("1" (expand member)
                          (("1" (expand vars 1 1)
                            (("1" (expand add)
                              (("1"
                                (expand member)
                                (("1"
                                  (rewrite vars_letApply)
                                  (("1"
                                    (expand in_varlist)
                                    (("1"
                                      (rewrite some_map)
                                      (("1"
                                        (expand o)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (lift-if)
                                              (("1" (ground) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand vars 1 1)
                  (("2" (expand add)
                    (("2" (expand mark 1 1)
                      (("2" (decompose-equality)
                        (("2" (expand markv)
                          (("2" (lift-if)
                            (("2" (ground)
                              (("2"
                                (expand union)
                                (("2"
                                  (expand bump)
                                  (("2"
                                    (expand bumpn)
                                    (("2"
                                      (expand member)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand mark 1 1)
              (("2" (decompose-equality)
                (("2" (expand mark)
                  (("2" (expand markv)
                    (("2" (expand union)
                      (("2" (expand drop)
                        (("2" (expand member)
                          (("2" (rewrite vars_letApply 1)
                            (("2" (expand in_varlist 1)
                              (("2"
                                (rewrite some_map 1)
                                (("2"
                                  (expand o)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite map_length) nil nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letApply def-decl "IExpression" rreduction nil)
    (map_length formula-decl nil more_map_props nil)
    (mark def-decl "IExpression" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (vars_letApply formula-decl nil rreduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (some_map formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "T3" function_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil) nil
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (vars_mark formula-decl nil preprocess nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (mark_letApply 0
  (mark_letApply-6 "" 3714852783
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 "L")
      (("" (flatten)
        (("" (skeep*)
          (("" (case-replace "L = null")
            (("1" (expand length 1)
              (("1" (expand letApply 1)
                (("1" (use mark_repeat)
                  (("1" (split -1)
                    (("1" (propax) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (name "hd" "car(L)")
              (("1" (name "tl" "cdr(L)")
                (("1" (case-replace "L = cons(hd, tl)")
                  (("1" (expand length 2)
                    (("1" (rewrite mark_letApply_cons)
                      (("1" (rewrite vars_mark)
                        (("1" (expand letApply 2 4)
                          (("1" (expand markvars 2)
                            (("1" (simplify)
                              (("1"
                                (rewrite vars_letApply)
                                (("1"
                                  (rewrite vars_letApply)
                                  (("1"
                                    (rewrite markvars_bump)
                                    (("1"
                                      (rewrite markvars_varlist)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (name
                                           "u"
                                           "NOT (in_varlist(map(lambda x: x WITH [`index := 1 + index(x)])
                                                (tl))
                                            (0)
                                   OR vars(mark(emptyset)(A))(length(tl)))")
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (case-replace "u = TRUE")
                                              (("1"
                                                (decompose-equality 2)
                                                (("1"
                                                  (lift-if)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (flatten 1)
                                                        (("1"
                                                          (inst
                                                           -3
                                                           "map(LAMBDA y: y WITH [`index := 1 + index(y)])(tl)")
                                                          (("1"
                                                            (rewrite
                                                             map_length)
                                                            (("1"
                                                              (split
                                                               -3)
                                                              (("1"
                                                                (inst?
                                                                 -1)
                                                                (("1"
                                                                  (split
                                                                   -1)
                                                                  (("1"
                                                                    (rewrite
                                                                     -1)
                                                                    (("1"
                                                                      (split)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (split
                                                                           1)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (case-replace
                                                                               "unmarkvar(hd) = variable(index(hd), FALSE)")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (hide-all-but
                                                                                   1)
                                                                                  (("1"
                                                                                    (grind-with-ext)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (hide
                                                                               3)
                                                                              (("2"
                                                                                (assert)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   vars_mark)
                                                                                  (("2"
                                                                                    (inst
                                                                                     -4
                                                                                     "1+index(hd)+length(tl)"
                                                                                     _)
                                                                                    (("2"
                                                                                      (inst
                                                                                       -4
                                                                                       "index(hd)")
                                                                                      (("2"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (case-replace
                                                                             "variable(index(hd), TRUE) = markvar(hd)")
                                                                            (("2"
                                                                              (hide-all-but
                                                                               1)
                                                                              (("2"
                                                                                (grind-with-ext)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (hide
                                                                     4)
                                                                    (("2"
                                                                      (skeep)
                                                                      (("2"
                                                                        (inst
                                                                         -5
                                                                         i
                                                                         "j-1")
                                                                        (("1"
                                                                          (split
                                                                           -5)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (propax)
                                                                            nil
                                                                            nil)
                                                                           ("3"
                                                                            (expand
                                                                             in_varlist)
                                                                            (("3"
                                                                              (rewrite
                                                                               some_map)
                                                                              (("3"
                                                                                (rewrite
                                                                                 some_nth)
                                                                                (("3"
                                                                                  (rewrite
                                                                                   some_nth)
                                                                                  (("3"
                                                                                    (skeep)
                                                                                    (("3"
                                                                                      (inst
                                                                                       1
                                                                                       "i!1+1")
                                                                                      (("1"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil)
                                                                                       ("2"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("3"
                                                                    (hide
                                                                     4)
                                                                    (("3"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (hide
                                                                 4)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case-replace
                                                 "u = FALSE")
                                                (("1"
                                                  (decompose-equality
                                                   2)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (split 1)
                                                          (("1"
                                                            (flatten 1)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (grind-with-ext)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (flatten
                                                                 1)
                                                                (("2"
                                                                  (rewrite
                                                                   vars_mark)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split 4)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (grind-with-ext)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (inst
                                                     -3
                                                     "map(LAMBDA x: x WITH [`index := 1 + index(x)])(tl)")
                                                    (("2"
                                                      (split -3)
                                                      (("1"
                                                        (inst? -1)
                                                        (("1"
                                                          (inst? -1)
                                                          (("1"
                                                            (rewrite
                                                             map_length)
                                                            (("1"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (hide
                                                                 2)
                                                                (("2"
                                                                  (skeep)
                                                                  (("2"
                                                                    (inst
                                                                     -5
                                                                     i
                                                                     "j - 1")
                                                                    (("1"
                                                                      (split
                                                                       -5)
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("3"
                                                                        (expand
                                                                         in_varlist)
                                                                        (("3"
                                                                          (rewrite
                                                                           some_map)
                                                                          (("3"
                                                                            (assert)
                                                                            (("3"
                                                                              (expand
                                                                               o)
                                                                              (("3"
                                                                                (rewrite
                                                                                 some_nth)
                                                                                (("3"
                                                                                  (rewrite
                                                                                   some_nth)
                                                                                  (("3"
                                                                                    (skeep
                                                                                     -2)
                                                                                    (("3"
                                                                                      (inst
                                                                                       1
                                                                                       "i!1+1")
                                                                                      (("1"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil)
                                                                                       ("2"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       in_varlist)
                                                                      (("2"
                                                                        (rewrite
                                                                         some_map)
                                                                        (("2"
                                                                          (rewrite
                                                                           some_nth)
                                                                          (("2"
                                                                            (skeep
                                                                             -2)
                                                                            (("2"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (hide
                                                                 2)
                                                                (("3"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (rewrite
                                                           map_length)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (rewrite map_length)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (rewrite map_length) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite map_length) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind-with-ext) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mark def-decl "IExpression" preprocess nil)
    (letApply def-decl "IExpression" rreduction nil)
    (emptyset const-decl "set" sets nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mark_repeat formula-decl nil preprocess nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    nil (vars_mark formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil rreduction nil)
    (markvars_bump formula-decl nil preprocess nil) nil nil
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (map_length formula-decl nil more_map_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (some_nth formula-decl nil finseq_theorems nil)
    (nth def-decl "T" list_props nil) nil nil
    (below type-eq-decl nil naturalnumbers nil) nil
    (O const-decl "T3" function_props nil)
    (some_map formula-decl nil finseq_theorems nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (markvars_varlist formula-decl nil preprocess nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (mark_letApply_cons formula-decl nil rreduction nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak)
  (mark_letApply-5 "" 3699274034
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 "L")
      (("" (flatten)
        (("" (skeep*)
          (("" (case-replace "L = null")
            (("1" (expand length 1)
              (("1" (expand letApply 1)
                (("1" (use mark_repeat)
                  (("1" (split -1)
                    (("1" (propax) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (name "hd" "car(L)")
              (("1" (name "tl" "cdr(L)")
                (("1" (case-replace "L = cons(hd, tl)")
                  (("1" (expand length 2)
                    (("1" (rewrite mark_letApply_cons)
                      (("1" (rewrite vars_mark)
                        (("1" (expand letApply 2 4)
                          (("1" (expand markvars 2)
                            (("1" (simplify)
                              (("1"
                                (rewrite vars_letApply)
                                (("1"
                                  (rewrite vars_letApply)
                                  (("1"
                                    (rewrite markvars_bump)
                                    (("1"
                                      (rewrite markvars_varlist)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (name
                                           "u"
                                           "NOT (in_varlist(map(lambda x: x WITH [`index := 1 + index(x)])
                             (tl))
                         (0)
                OR vars(mark(emptyset)(A))(length(tl)))")
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (case-replace "u = TRUE")
                                              (("1"
                                                (decompose-equality 3)
                                                (("1"
                                                  (lift-if)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (flatten 1)
                                                          (("1"
                                                            (split 1)
                                                            (("1"
                                                              (grind-with-ext)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (flatten
                                                               1)
                                                              (("2"
                                                                (rewrite
                                                                 vars_mark
                                                                 -1)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (split 4)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind-with-ext)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (decompose-equality)
                                                  (("2"
                                                    (inst
                                                     -3
                                                     " map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2"
                                                      (split -3)
                                                      (("1"
                                                        (rewrite
                                                         map_length)
                                                        (("1"
                                                          (rewrite -1)
                                                          (("1"
                                                            (rewrite
                                                             bump_varlist)
                                                            (("1"
                                                              (hide-all-but
                                                               (1 -4))
                                                              (("1"
                                                                (skeep*)
                                                                (("1"
                                                                  (expand
                                                                   bump)
                                                                  (("1"
                                                                    (expand
                                                                     bumpn)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (inst
                                                                         -4
                                                                         "i"
                                                                         "j-1")
                                                                        (("1"
                                                                          (expand
                                                                           in_varlist)
                                                                          (("1"
                                                                            (expand
                                                                             some
                                                                             -4)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         map_length)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case-replace
                                                 "u = FALSE")
                                                (("1"
                                                  (decompose-equality
                                                   2)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (split 1)
                                                          (("1"
                                                            (flatten 1)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (grind-with-ext)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (flatten
                                                                 1)
                                                                (("2"
                                                                  (rewrite
                                                                   vars_mark)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split 4)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (grind-with-ext)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (inst
                                                     -3
                                                     "map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2"
                                                      (split -3)
                                                      (("1"
                                                        (rewrite
                                                         map_length)
                                                        (("1"
                                                          (rewrite -1)
                                                          (("1"
                                                            (hide-all-but
                                                             (1 -4))
                                                            (("1"
                                                              (skeep*)
                                                              (("1"
                                                                (rewrite
                                                                 bump_varlist)
                                                                (("1"
                                                                  (expand
                                                                   bump)
                                                                  (("1"
                                                                    (expand
                                                                     bumpn)
                                                                    (("1"
                                                                      (inst
                                                                       -3
                                                                       "i"
                                                                       "j - 1")
                                                                      (("1"
                                                                        (expand
                                                                         in_varlist)
                                                                        (("1"
                                                                          (expand
                                                                           some
                                                                           -3)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         map_length)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (rewrite map_length)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (rewrite map_length) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite map_length) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind-with-ext) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (mark_letApply_cons formula-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (markvars_varlist formula-decl nil preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump_varlist formula-decl nil rreduction nil)
    (map_length formula-decl nil more_map_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (markvar const-decl "(variable?)" preprocess nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (markvars_bump formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil rreduction nil)
    (vars_mark formula-decl nil preprocess nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (TRUE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (mark_repeat formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (letApply def-decl "IExpression" rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak)
  (mark_letApply-4 "" 3699215143
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 "L")
      (("" (flatten)
        (("" (skeep*)
          (("" (case-replace "L = null")
            (("1" (expand length 1)
              (("1" (expand letApply 1)
                (("1" (use mark_repeat) (("1" (postpone) nil nil))
                  nil))
                nil))
              nil)
             ("2" (postpone) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-3 "" 3699209434
   ("" (measure-induct "length(L)" "L")
    (("" (skolem 1 ("L"))
      (("" (flatten)
        (("" (skeep*)
          (("" (expand letApply 1)
            (("" (lift-if)
              (("" (split)
                (("1" (use mark_repeat) (("1" (postpone) nil nil)) nil)
                 ("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-2 "" 3698756834
   ("" (measure-induct+ "length(L)" ("L"))
    (("" (name-replace "L" "x!1")
      (("" (skeep*)
        (("" (expand letApply 1)
          (("" (lift-if)
            (("" (split)
              (("1" (use mark_repeat)
                (("1" (flatten)
                  (("1" (split -1)
                    (("1" (propax) nil nil)
                     ("2" (skeep*)
                      (("2" (inst -4 i) (("2" (grind) nil nil)) nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (name "hd" "car(L)")
                (("1" (name "tl" "cdr(L)")
                  (("1" (case-replace "L = cons(hd, tl)")
                    (("1" (flatten)
                      (("1" (lift-if)
                        (("1" (lift-if)
                          (("1" (rewrite vars_letApply)
                            (("1" (rewrite vars_letApply)
                              (("1"
                                (expand markvars 2)
                                (("1"
                                  (simplify)
                                  (("1"
                                    (rewrite markvars_bump)
                                    (("1"
                                      (rewrite markvars_varlist)
                                      (("1"
                                        (rewrite vars_mark)
                                        (("1"
                                          (expand length 2 1)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand mark 3 1)
                                                (("1"
                                                  (decompose-equality
                                                   3)
                                                  (("1"
                                                    (expand mark 1 1)
                                                    (("1"
                                                      (expand
                                                       markv
                                                       1
                                                       1)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (split 1)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (split
                                                                   1)
                                                                  (("1"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (expand
                                                                       union
                                                                       -1)
                                                                      (("2"
                                                                        (expand
                                                                         drop
                                                                         -1)
                                                                        (("2"
                                                                          (expand
                                                                           vars
                                                                           -1)
                                                                          (("2"
                                                                            (expand
                                                                             add
                                                                             -1)
                                                                            (("2"
                                                                              (expand
                                                                               member)
                                                                              (("2"
                                                                                (expand
                                                                                 length
                                                                                 -1)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   vars_letApply)
                                                                                  (("1"
                                                                                    (expand
                                                                                     in_varlist)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       some_map)
                                                                                      (("1"
                                                                                        (expand
                                                                                         o)
                                                                                        (("1"
                                                                                          (rewrite
                                                                                           vars_mark)
                                                                                          (("1"
                                                                                            (grind)
                                                                                            (("1"
                                                                                              (inst?
                                                                                               -4)
                                                                                              (("1"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (rewrite
                                                                                     map_length)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   2)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (expand
                                                                       union
                                                                       2)
                                                                      (("1"
                                                                        (expand
                                                                         drop
                                                                         2)
                                                                        (("1"
                                                                          (expand
                                                                           vars
                                                                           2)
                                                                          (("1"
                                                                            (expand
                                                                             length
                                                                             2)
                                                                            (("1"
                                                                              (expand
                                                                               add
                                                                               2)
                                                                              (("1"
                                                                                (expand
                                                                                 member
                                                                                 2)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   vars_letApply)
                                                                                  (("1"
                                                                                    (expand
                                                                                     in_varlist)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       some_map)
                                                                                      (("1"
                                                                                        (expand
                                                                                         o)
                                                                                        (("1"
                                                                                          (rewrite
                                                                                           vars_mark)
                                                                                          (("1"
                                                                                            (grind)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind-with-ext)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand vars 1 1)
                                                    (("2"
                                                      (expand add 1 1)
                                                      (("2"
                                                        (expand
                                                         mark
                                                         1
                                                         1)
                                                        (("2"
                                                          (decompose-equality
                                                           1)
                                                          (("1"
                                                            (expand
                                                             markv)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (split)
                                                                (("1"
                                                                  (expand
                                                                   length
                                                                   1)
                                                                  (("1"
                                                                    (expand
                                                                     union
                                                                     1)
                                                                    (("1"
                                                                      (expand
                                                                       member
                                                                       1)
                                                                      (("1"
                                                                        (expand
                                                                         bump
                                                                         1)
                                                                        (("1"
                                                                          (expand
                                                                           bumpn
                                                                           1)
                                                                          (("1"
                                                                            (rewrite
                                                                             vars_letApply)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             length
                                                             1)
                                                            (("2"
                                                              (inst
                                                               -2
                                                               "map(lambda x: x WITH [(index) := 1 + index(x)])(tl)")
                                                              (("2"
                                                                (inst?
                                                                 -2)
                                                                (("2"
                                                                  (inst?
                                                                   -2)
                                                                  (("2"
                                                                    (split
                                                                     -2)
                                                                    (("1"
                                                                      (rewrite
                                                                       map_length)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (rewrite
                                                                       map_length)
                                                                      (("2"
                                                                        (expand
                                                                         length
                                                                         -2)
                                                                        (("2"
                                                                          (skeep*)
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (rewrite
                                                                       map_length)
                                                                      (("3"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (expand length 1)
                                                (("2"
                                                  (split 1)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand mark 3 1)
                                                      (("1"
                                                        (decompose-equality)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (expand mark 1 1)
                                                      (("2"
                                                        (decompose-equality)
                                                        (("1"
                                                          (expand
                                                           mark
                                                           1
                                                           1)
                                                          (("1"
                                                            (expand
                                                             markv)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (lift-if)
                                                                  (("1"
                                                                    (split)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (split
                                                                         1)
                                                                        (("1"
                                                                          (grind-with-ext)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (expand
                                                                             union
                                                                             -1)
                                                                            (("2"
                                                                              (expand
                                                                               drop
                                                                               -1)
                                                                              (("2"
                                                                                (expand
                                                                                 member
                                                                                 -1)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   vars_letApply)
                                                                                  (("1"
                                                                                    (expand
                                                                                     in_varlist)
                                                                                    (("1"
                                                                                      (rewrite
                                                                                       some_map)
                                                                                      (("1"
                                                                                        (expand
                                                                                         o)
                                                                                        (("1"
                                                                                          (rewrite
                                                                                           vars_mark)
                                                                                          (("1"
                                                                                            (split
                                                                                             -1)
                                                                                            (("1"
                                                                                              (propax)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (inst?
                                                                                               -6)
                                                                                              (("2"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil))
                                                                                              nil)
                                                                                             ("3"
                                                                                              (propax)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (rewrite
                                                                                     map_length)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (expand
                                                                         union
                                                                         1)
                                                                        (("2"
                                                                          (expand
                                                                           drop
                                                                           1)
                                                                          (("2"
                                                                            (expand
                                                                             member)
                                                                            (("2"
                                                                              (rewrite
                                                                               vars_letApply)
                                                                              (("2"
                                                                                (expand
                                                                                 in_varlist)
                                                                                (("2"
                                                                                  (rewrite
                                                                                   some_map
                                                                                   1)
                                                                                  (("2"
                                                                                    (expand
                                                                                     o)
                                                                                    (("2"
                                                                                      (split
                                                                                       2)
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (grind)
                                                                                          nil
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (grind-with-ext)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (rewrite
                                                           vars_letApply)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (inst?
                                                                   -5)
                                                                  (("1"
                                                                    (inst?
                                                                     -5)
                                                                    (("1"
                                                                      (split
                                                                       -5)
                                                                      (("1"
                                                                        (rewrite
                                                                         map_length)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (rewrite
                                                                         map_length)
                                                                        (("2"
                                                                          (split
                                                                           -3)
                                                                          (("1"
                                                                            (expand
                                                                             in_varlist)
                                                                            (("1"
                                                                              (rewrite
                                                                               some_map)
                                                                              (("1"
                                                                                (expand
                                                                                 o)
                                                                                (("1"
                                                                                  (rewrite
                                                                                   some_nth)
                                                                                  (("1"
                                                                                    (grind)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (postpone)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("3"
                                                                        (postpone)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (postpone)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (postpone)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (postpone) nil nil)
                               ("3" (postpone) nil nil))
                              nil)
                             ("2" (postpone) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (postpone) nil nil))
                    nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (mark_letApply-1 nil 3693496107
   ("" (induct "L")
    (("1" (grind)
      (("1" (lemma "mark_idem")
        (("1" (inst?) (("1" (postpone) nil nil)) nil)) nil)
       ("2" (postpone) nil nil) ("3" (postpone) nil nil))
      nil)
     ("2" (postpone) nil nil))
    nil)
   nil shostak))
 (mark_letApply_weak 0
  (mark_letApply_weak-1 nil 3699274870
   ("" (skeep*)
    (("" (use mark_letApply)
      (("" (split -1)
        (("1" (propax) nil nil)
         ("2" (skeep*) (("2" (grind) nil nil)) nil)
         ("3" (skeep*) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((mark_letApply formula-decl nil rreduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (release_marked_correct_redex 0
  (release_marked_correct_redex-1 nil 3701113253
   ("" (skeep)
    (("" (typepred "rS`redex")
      (("" (split 3)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil)
         ("5" (grind) nil nil)
         ("6" (expand mark 1)
          (("6" (decompose-equality 1) (("6" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (release_marked_correct_count 0
  (release_marked_correct_count-1 nil 3701114067
   ("" (skeep)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (release_marked_TCC1 0
  (release_marked_TCC1-1 nil 3699016249
   ("" (skeep*)
    (("" (ground)
      (("1" (expand refs)
        (("1" (typepred "rS`redex") (("1" (propax) nil nil)) nil)) nil)
       ("2" (expand vars)
        (("2" (expand popDepth)
          (("2" (typepred "rS`redex")
            (("2" (skeep)
              (("2" (inst -2 i) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("3" (expand popDepth 1 1)
        (("3" (typepred "rS`redex") (("3" (propax) nil nil)) nil)) nil)
       ("4" (expand popDepth 1 1)
        (("4" (typepred "rS`redex") (("4" (propax) nil nil)) nil)) nil)
       ("5" (expand contextPure?) (("5" (propax) nil nil)) nil)
       ("6" (expand mark)
        (("6" (typepred "rS`redex")
          (("6" (replace -6)
            (("6" (decompose-equality 1)
              (("6" (expand markv)
                (("6" (lift-if)
                  (("6" (ground)
                    (("1" (expand union)
                      (("1" (typepred x) (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind-with-ext) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refs def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_variable_extensionality formula-decl nil
     IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (release_marked subtype
    "IExpression_adt.release(rreduction.x, rreduction.rS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}")))
 (release_marked_TCC2 0
  (release_marked_TCC2-1 nil 3699016249
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (expand refs 1 2) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (release_marked subtype "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, IExpression_adt.release(rreduction.x, rreduction.rS`redex))(i)}]")))
 (pure_count_keep 0
  (pure_count_keep-1 nil 3700328221
   ("" (skeep*)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (use pure_refs)
              (("" (assert)
                (("" (lift-if)
                  (("" (ground)
                    (("" (use pure_refs) (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (applyReduce_correct_redex_TCC1 0
  (applyReduce_correct_redex_TCC1-1 nil 3700325321
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil))
   nil
   (applyReduce_correct_redex subtype "rreduction.grS`redex"
    "(IExpression_adt.application?)")))
 (applyReduce_correct_redex_TCC2 0
  (applyReduce_correct_redex_TCC2-1 nil 3700325321
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil))
   nil
   (applyReduce_correct_redex subtype
    "IExpression_adt.args(rreduction.grS`redex)"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = rreduction.arity}")))
 (applyReduce_correct_redex 0
  (applyReduce_correct_redex-1 nil 3700326018
   (""
    (with-labels (skeep* :preds? t)
     ((err arity_pos a_pure vars_a apr arity_len obj)))
    (("" (simplify :let-reduce? t)
      (("" (split obj)
        (("1" (skeep)
          (("1" (use pure_refs)
            (("1" (use pure_letApply)
              (("1" (grind) nil nil)
               ("2" (use pure_mark) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (with-labels (skeep) ((ivars obj)))
          (("2" (rewrite popdepth_letApply)
            (("2" (lift-if)
              (("2" (rewrite vars_letApply)
                (("2" (rewrite vars_mark)
                  (("2" (split ivars)
                    (("1" (typepred "grS`redex")
                      (("1" (rewrite purePopDepth)
                        (("1" (rewrite purePopDepth)
                          (("1" (rewrite purePopDepth)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil))
                            nil)
                           ("2" (use pure_mark) (("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep*)
          (("3" (rewrite purePopDepth)
            (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
             ("2" (use pure_letApply)
              (("2" (rewrite pure_mark) nil nil)) nil))
            nil))
          nil)
         ("4" (rewrite purePopDepth)
          (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
           ("2" (use pure_letApply) (("2" (rewrite pure_mark) nil nil))
            nil))
          nil)
         ("5" (use pure_contextPure)
          (("5" (use pure_letApply)
            (("1" (grind) nil nil) ("2" (rewrite pure_mark) nil nil))
            nil))
          nil)
         ("6" (use mark_letApply_weak)
          (("6" (replace arity_len)
            (("6" (rewrite mark_letApply_weak)
              (("6"
                (with-labels
                 (case-replace
                  "markvars(cvars(grS`context))(args(grS`redex)) = args(grS`redex)")
                 ((mva)))
                (("6" (typepred "grS`redex")
                  (("6" (apply-eta "grS`redex" "(application?)")
                    (("6" (replace -1 :dir RL)
                      (("6" (expand mark -)
                        (("6" (delete obj)
                          (("6" (simplify)
                            (("6" (decompose-equality -7) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mark_letApply_weak formula-decl nil rreduction nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (IExpression_application_eta formula-decl nil IExpression_adt nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (pure_contextPure formula-decl nil IL nil)
    (vars_mark formula-decl nil preprocess nil) nil
    (applyRedex? const-decl "bool" IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (vars_letApply formula-decl nil rreduction nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil) nil
    nil (pure_mark formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (letApply def-decl "IExpression" rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil) (pure_refs formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (applyReduce_correct_count 0
  (applyReduce_correct_count-1 nil 3700328153
   ("" (skeep*)
    (("" (use pure_count_keep)
      (("" (split)
        (("1" (propax) nil nil) ("2" (grind) nil nil)
         ("3" (use pure_letApply) (("3" (rewrite pure_mark) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pure_count_keep formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (letApply def-decl "IExpression" rreduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (pure_letApply recursive-judgement-axiom nil rreduction nil) nil
    (pure_mark formula-decl nil preprocess nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (applyRedex? const-decl "bool" IL nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (pure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (applyReduce_TCC1 0
  (applyReduce_TCC1-1 nil 3676345135 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (injective? const-decl "bool" functions nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce subtype "rreduction.expr"
    "(IExpression_adt.application?)")))
 (applyReduce_TCC2 0
  (applyReduce_TCC2-1 nil 3676345135
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce subtype "rreduction.args"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = rreduction.arity}")))
 (applyReduce_TCC3 0
  (applyReduce_TCC3-1 nil 3676345135
   ("" (skeep*)
    (("" (use applyReduce_correct_redex)
      (("" (split -1)
        (("1" (grind) nil nil)
         ("2" (typepred grS) (("2" (propax) nil nil)) nil)
         ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   ((applyReduce_correct_redex formula-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce subtype
    "rreduction.letApply(rreduction.arity, rreduction.args, preprocess.mark(sets[naturalnumbers.nat].emptyset)(rreduction.body))"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (applyReduce_TCC4 0
  (applyReduce_TCC4-1 nil 3676345135
   ("" (skeep*)
    (("" (use applyReduce_correct_count)
      (("" (split -1)
        (("1" (propax) nil nil) ("2" (grind) nil nil)
         ("3" (typepred grS) (("3" (propax) nil nil)) nil)
         ("4" (grind) nil nil))
        nil))
      nil))
    nil)
   ((applyReduce_correct_count formula-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.letApply(rreduction.arity, rreduction.args, preprocess.mark(sets[naturalnumbers.nat].emptyset)(rreduction.body)))(i)}]")))
 (ifReduce_correct_redex_then_TCC1 0
  (ifReduce_correct_redex_then_TCC1-1 nil 3700339138
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil))
   nil
   (ifReduce_correct_redex_then subtype "rreduction.grS`redex"
    "(IExpression_adt.ift?)")))
 (ifReduce_correct_redex_then 0
  (ifReduce_correct_redex_then-1 nil 3701115301
   ("" (skeep)
    (("" (simplify :let-reduce? t)
      (("" (typepred "grS`redex")
        (("" (split)
          (("1" (skeep) (("1" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("3" (skeep)
            (("3" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("4" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("5" (use pure_contextPure) (("5" (grind) nil nil)) nil)
           ("6" (apply-eta "grS`redex" "(ift?)")
            (("6" (replace -1 :dir RL)
              (("6" (simplify)
                (("6" (expand mark -)
                  (("6" (decompose-equality -7)
                    (("6" (use eq_mark_release_set)
                      (("6" (split -1)
                        (("1" (expand release_set)
                          (("1" (assert) nil nil)) nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (purePopDepth formula-decl nil IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (pure_contextPure formula-decl nil IL nil)
    (eq_mark_release_set formula-decl nil preprocess nil)
    (release_set def-decl "IExpression" preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_correct_redex_else 0
  (ifReduce_correct_redex_else-1 nil 3701115555
   ("" (skeep)
    (("" (simplify :let-reduce? t)
      (("" (typepred "grS`redex")
        (("" (split)
          (("1" (skeep) (("1" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("3" (skeep)
            (("3" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("4" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("5" (use pure_contextPure) (("5" (grind) nil nil)) nil)
           ("6" (apply-eta "grS`redex" "(ift?)")
            (("6" (replace -1 :dir RL)
              (("6" (simplify)
                (("6" (expand mark -)
                  (("6" (decompose-equality -7)
                    (("6" (delete -2)
                      (("6" (use eq_mark_release_set)
                        (("6" (split -1)
                          (("1" (expand release_set)
                            (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (purePopDepth formula-decl nil IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (pure_contextPure formula-decl nil IL nil)
    (eq_mark_release_set formula-decl nil preprocess nil)
    (release_set def-decl "IExpression" preprocess nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_correct_count_then 0
  (ifReduce_correct_count_then-1 nil 3700339138
   ("" (skeep*) (("" (use pure_count_keep) (("" (grind) nil nil)) nil))
    nil)
   ((pure_count_keep formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pure? def-decl "bool" IL nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_correct_count_else 0
  (ifReduce_correct_count_else-1 nil 3700339177
   ("" (skeep*) (("" (use pure_count_keep) (("" (grind) nil nil)) nil))
    nil)
   ((pure_count_keep formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pure? def-decl "bool" IL nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_correct_indexing 0
  (ifReduce_correct_indexing-1 nil 3700339192
   ("" (skeep*)
    (("" (case "vars(grS`redex)(index(condition(grS`redex)))")
      (("1" (typepred "grS`redex")
        (("1" (rewrite purePopDepth)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_correct_release_marked 0
  (ifReduce_correct_release_marked-1 nil 3700339362
   ("" (with-labels (skeep*) ((iftr mrk obj)))
    ((""
      (with-labels (typepred "grS`redex")
       ((hdom hvar hcvar hlen hpure hmark)))
      (("" (apply-eta "grS`redex" "(ift?)")
        (("" (replace -1 :dir RL)
          (("" (simplify)
            (("" (expand mark)
              ((""
                (with-labels (decompose-equality hmark)
                 ((hmark1 hmark2 hmark3)))
                (("" (replace hmark1 mrk :dir RL)
                  (("" (expand markv)
                    (("" (hide-all-but (mrk obj))
                      (("" (expand union)
                        (("" (expand member) (("" (ground) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (ifReduce_TCC1 0
  (ifReduce_TCC1-1 nil 3683858380 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (ifReduce subtype "rreduction.expr" "(IExpression_adt.ift?)")))
 (ifReduce_TCC2 0
  (ifReduce_TCC2-1 nil 3683858380
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "grS`redex")
        (("1" (inst -2 "index(condition)")
          (("1" (ground)
            (("1" (typepred "grS")
              (("1" (expand pureIftRedex?)
                (("1" (expand iftRedex?)
                  (("1" (flatten)
                    (("1" (rewrite purepopDepth)
                      (("1" (rewrite purepopDepth)
                        (("1" (rewrite purepopDepth)
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred grS) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`redex")
        (("2" (case "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (rewrite -1)
            (("1" (hide-all-but (-6 -7 -8))
              (("1" (grind)
                (("1" (decompose-equality -1)
                  (("1" (rewrite -1 :dir RL) (("1" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (decompose-equality -1)
                  (("2" (rewrite -1 :dir RL) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil)
       ("3" (typepred "grS`redex")
        (("3"
          (case-replace
           "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (hide-all-but (-7 -8 -9))
            (("1" (ground)
              (("1" (grind)
                (("1" (decompose-equality -1)
                  (("1" (rewrite -1 :dir RL) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (iftRedex? const-decl "bool" IL nil)
    (purePopDepth formula-decl nil IL nil)
    (pure? def-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (release_set def-decl "IExpression" preprocess nil)
    (FALSE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "rreduction.condition"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN IL.popDepth(rreduction.elseexpr) ELSE IL.popDepth(rreduction.thenexpr) ENDIF), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN rreduction.grS`stack`length ELSE rreduction.grS`stack`length ENDIF), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}"))
  (ifReduce_TCC2-2 "" 3699283733
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "grS`redex")
        (("1" (inst -2 "index(condition)")
          (("1" (ground)
            (("1" (typepred "grS")
              (("1" (expand pureIftRedex?)
                (("1" (expand iftRedex?)
                  (("1" (rewrite purePopDepth 2)
                    (("1" (rewrite purePopDepth 2)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "grS`redex")
              (("2"
                (case-replace
                 "grS`redex = ift(condition, thenexpr, elseexpr)")
                (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`redex")
        (("2" (case "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (rewrite -1)
            (("1" (expand mark -6)
              (("1" (expand markv -6)
                (("1" (expand union -6)
                  (("1" (expand member)
                    (("1" (decompose-equality -6)
                      (("1" (replace -1 -10 :dir RL)
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil)
       ("3" (expand member)
        (("3" (typepred "grS`redex")
          (("3"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -7)
              (("1" (decompose-equality -7)
                (("1" (expand markv -1)
                  (("1" (replace -1 -11 :dir RL)
                    (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (iftRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (purePopDepth formula-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (release_set def-decl "IExpression" preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (ifReduce subtype "rreduction.condition"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN IL.popDepth(rreduction.elseexpr) ELSE IL.popDepth(rreduction.thenexpr) ENDIF), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN rreduction.grS`stack`length ELSE rreduction.grS`stack`length ENDIF), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}")))
 (ifReduce_TCC3 0
  (ifReduce_TCC3-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS")
        (("" (inst -3 "index(condition)")
          (("" (expand vars) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (iftRedex? const-decl "bool" IL nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (empty? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "rreduction.condition"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (ifReduce_TCC4 0
  (ifReduce_TCC4-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (hide-all-but (1 -1 -7 -10 -14))
            (("1" (grind) nil nil)) nil)
           ("2" (hide-all-but (1 -2 -7 -10 -14))
            (("2" (skeep*)
              (("2" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("4" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil)
           ("6"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -7)
              (("1" (decompose-equality -7)
                (("1"
                  (case-replace
                   "difference(vars(thenexpr), union(vars(elseexpr), cvars(grS`context))) = emptyset")
                  (("1" (grind) nil nil)
                   ("2" (hide-all-but (1 -3))
                    (("2" (use eq_mark_release_set)
                      (("2" (split -1)
                        (("1" (grind-with-ext) nil nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (eq_mark_release_set formula-decl nil preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "rreduction.elseexpr"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (ifReduce_TCC5 0
  (ifReduce_TCC5-1 nil 3683858380
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "grS`redex")
        (("" (typepred "grS")
          (("" (expand "pureIftRedex?")
            (("" (expand "iftRedex?")
              (("" (typepred "grS`count(x1)")
                (("" (rewrite -1)
                  (("" (expand refcount)
                    (("" (expand refcountExpr)
                      (("" (expand refs 2 1)
                        (("" (flatten)
                          (("" (use pure_refs)
                            (("" (ground)
                              ((""
                                (lift-if)
                                ((""
                                  (ground)
                                  ((""
                                    (use pure_refs)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.elseexpr)(i)}]")))
 (ifReduce_TCC6 0
  (ifReduce_TCC6-1 nil 3683858380
   ("" (skeep*)
    (("" (typepred "grS")
      (("" (typepred "grS`redex")
        (("" (ground)
          (("1" (hide-all-but (1 -1 -7 -10 -12))
            (("1" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("3" (skeep*)
            (("3" (rewrite purePopDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil)
           ("4" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("5" (rewrite pure_contextPure) (("5" (grind) nil nil)) nil)
           ("6"
            (case-replace
             "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (expand mark -7)
              (("1" (decompose-equality -7)
                (("1"
                  (case-replace
                   "difference(vars(elseexpr), union(vars(thenexpr), cvars(grS`context))) = emptyset")
                  (("1" (grind) nil nil)
                   ("2" (lemma eq_mark_release_set)
                    (("2" (grind-with-ext) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (difference const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (pure_contextPure formula-decl nil IL nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (eq_mark_release_set formula-decl nil preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (release_set def-decl "IExpression" preprocess nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "rreduction.thenexpr"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (ifReduce_TCC7 0
  (ifReduce_TCC7-1 nil 3698757037
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "grS`redex")
        (("" (typepred "grS")
          (("" (expand "pureIftRedex?")
            (("" (expand "iftRedex?")
              (("" (typepred "grS`count(x1)")
                (("" (rewrite -1)
                  (("" (expand refcount)
                    (("" (expand refcountExpr)
                      (("" (expand refs 3 1)
                        (("" (flatten)
                          (("" (use pure_refs)
                            (("" (ground)
                              ((""
                                (lift-if)
                                ((""
                                  (ground)
                                  ((""
                                    (use pure_refs)
                                    (("" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.thenexpr)(i)}]")))
 (setRedex_TCC1 0
  (setRedex_TCC1-1 nil 3698784150
   ("" (skeep*)
    (("" (typepred "rS")
      (("" (grind)
        (("1" (typepred "rS`redex") (("1" (grind) nil nil)) nil)
         ("2" (typepred "rS`redex")
          (("2" (inst -3 "i!1") (("2" (grind) nil nil)) nil)) nil)
         ("3" (typepred "vv") (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (setRedex subtype "rreduction.vv"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}")))
 (setRedex_TCC2 0
  (setRedex_TCC2-2 "" 3714696103
   ("" (skeep*)
    (("" (expand refcount)
      (("" (typepred "rS`count(refindex(vv))")
        (("" (rewrite -1)
          (("" (expand refcount)
            (("" (expand refcountexpr)
              (("" (typepred "rS`redex")
                (("" (typepred rS)
                  (("" (rewrite pure_refs) (("" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (setRedex subtype
    "(number_fields.+)(rreduction.rS`count(IExpression_adt.refindex(rreduction.vv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(IExpression_adt.refindex(rreduction.vv))}"))
  (setRedex_TCC2-1 nil 3714529219 ("" (subtype-tcc) nil nil)
   ((refcount const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pure_refs formula-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (setRedex subtype
    "(number_fields.+)(rreduction.rS`count(IExpression_adt.refindex(rreduction.vv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(IExpression_adt.refindex(rreduction.vv))}")))
 (setRedex_TCC3 0
  (setRedex_TCC3-1 nil 3724502330
   ("" (skeep* :preds? t)
    (("" (typepred "rS`count(x)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (grind)
            (("" (grind)
              (("" (use pure_refs) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_refs formula-decl nil IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (setRedex subtype "rreduction.rS`count(rreduction.x)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(rreduction.x)}")))
 (setRedex_TCC4 0
  (setRedex_TCC3-1 nil 3698784150
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (typepred "rS`redex")
        (("3" (skeep) (("3" (inst -3 i) (("3" (grind) nil nil)) nil))
          nil))
        nil)
       ("4" (typepred "rS`redex") (("4" (grind) nil nil)) nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (setRedex subtype "rreduction.vv"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}")))
 (setRedex_TCC5 0
  (setRedex_TCC4-1 nil 3698784150
   ("" (skeep* :preds? t)
    (("" (typepred "rS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (use pure_refs) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (pure_refs formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (setRedex subtype "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(i)}]")))
 (lookupRedex_arrayvalue_index_TCC1 0
  (lookupRedex_arrayvalue_index_TCC1-1 nil 3701021413
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil))
   nil
   (lookupRedex_arrayvalue_index subtype "rreduction.grS`redex"
    "(IExpression_adt.lookup?)")))
 (lookupRedex_arrayvalue_index 0
  (lookupRedex_arrayvalue_index-1 nil 3701115715
   ("" (skeep) (("" (typepred "grS`redex") (("" (grind) nil nil)) nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (lookupRedex_position_index 0
  (lookupRedex_position_index-1 nil 3701115726
   ("" (skeep) (("" (typepred "grS`redex") (("" (grind) nil nil)) nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (lookupReduce_TCC1 0
  (lookupReduce_TCC1-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "rreduction.expr"
    "(IExpression_adt.lookup?)")))
 (lookupReduce_TCC2 0
  (lookupReduce_TCC2-1 nil 3693417317
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(avar)")
        (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "rreduction.avar"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (lookupReduce_TCC3 0
  (lookupReduce_TCC3-1 nil 3693417317
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS)
        (("" (inst -3 "index(pos)") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "rreduction.pos"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (lookupReduce_TCC4 0
  (lookupReduce_TCC4-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (lookupReduce subtype "IExpression_adt.refindex(rreduction.aval)"
    "(rreduction.grS`domain)")))
 (lookupReduce_TCC5 0
  (lookupReduce_TCC5-1 nil 3693417317 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (lookupReduce subtype "IExpression_adt.value(rreduction.pval)"
    "below[store(refindex(aval))`length]")))
 (lookupReduce_TCC6 0
  (lookupReduce_TCC6-1 nil 3693417317
   ("" (skeep*)
    (("" (ground)
      (("1" (expand setRedex)
        (("1" (simplify)
          (("1" (typepred "grS`redex")
            (("1" (typepred grS)
              (("1" (inst -3 "index(avar)")
                (("1" (typepred "rval") (("1" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand setRedex)
        (("2" (simplify)
          (("2" (expand member)
            (("2" (typepred "rval") (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil)
       ("3" (expand setRedex)
        (("3" (expand member)
          (("3" (typepred "grS`redex")
            (("3" (case-replace "grS`redex = lookup(avar, pos)")
              (("1" (expand mark -7)
                (("1" (decompose-equality -7)
                  (("1" (replace -1 -10 :dir RL)
                    (("1" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (grind-with-ext) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (get const-decl "(value?)" IL nil)
    (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}" rreduction
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (nonempty? const-decl "bool" sets nil)
    (IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "rreduction.avar"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IL.popDepth(rreduction.setRedex(rreduction.grS, rreduction.rval)`redex)), rreduction.setRedex(rreduction.grS, rreduction.rval)`stack`length), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}")))
 (lookupReduce_TCC7 0
  (lookupReduce_TCC7-1 nil 3693417317
   ("" (skeep*) (("" (typepred "grS") (("" (grind) nil nil)) nil)) nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil) (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce subtype "rreduction.grS"
    "{rS | IL.pure?(rreduction.rS`redex)}")))
 (newintReduce_TCC1 0
  (newintReduce_TCC1-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "rreduction.expr"
    "{x: IExpression_adt.IExpression | booleans.OR(IExpression_adt.newint?(x), IExpression_adt.newref?(x))}")))
 (newintReduce_TCC2 0
  (newintReduce_TCC2-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (N!2 skolem-const-decl "nat" rreduction nil)
    (nonempty? const-decl "bool" sets nil)
    (x!1 skolem-const-decl "nat" rreduction nil)
    (grS!1 skolem-const-decl "{grS | newintRedex?(grS`redex)}"
     rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (size!1 skolem-const-decl "nat" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil))
   nil
   (newintReduce subtype "rreduction.grS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.newdomain))(S)}")))
 (newintReduce_TCC3 0
  (newintReduce_TCC3-1 nil 3699020624
   ("" (skeep*)
    (("" (grind)
      (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil)
       ("2" (typepred "grS`redex")
        (("2" (inst -3 "i!1") (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (refs def-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars def-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "IExpression_adt.ref(rreduction.newrefredex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (newintReduce_TCC4 0
  (newintReduce_TCC4-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "rreduction.newrefredex"
    "(rreduction.newdomain)")))
 (newintReduce_TCC5 0
  (newintReduce_TCC5-1 nil 3699020624 ("" (subtype-tcc) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "IExpression_adt.constant(0)"
    "(IL.domainValue?(rreduction.newdomain))")))
 (newintReduce_TCC6 0
  (newintReduce_TCC6-1 nil 3699020624
   ("" (skeep*)
    (("" (expand refcount)
      (("" (expand refcountExpr)
        (("" (expand refs)
          (("" (rewrite refcount_stack_outside_domain)
            (("1" (lemma refcount_new)
              (("1" (inst -1 domain newdomain newrefredex store _)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (rewrite -1)
                      (("1" (expand refcountArray)
                        (("1" (rewrite count_none_zero)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (ground)
                    (("1" (grind) nil nil)
                     ("2" (skeep*)
                      (("2" (typepred "store(x1)`seq(x2)")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (refs def-decl "bool" IL nil)
    (refcount_new formula-decl nil rreduction nil)
    (size skolem-const-decl "nat" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (newdomain skolem-const-decl "non_empty_finite_set[nat]" rreduction
     nil)
    (member const-decl "bool" sets nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (store skolem-const-decl "Store(grS`domain)" rreduction nil)
    (domain skolem-const-decl "finite_set[nat]" rreduction nil)
    (grS skolem-const-decl "{grS | newintRedex?(grS`redex)}" rreduction
     nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcount_stack_outside_domain formula-decl nil rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce subtype "1"
    "{j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.store WITH [(rreduction.newrefredex) |-> (# length := rreduction.size, seq := (LAMBDA (i: naturalnumbers.below(rreduction.size)): IExpression_adt.constant(0)) #)], rreduction.grS`stack, IExpression_adt.ref(rreduction.newrefredex))(rreduction.newrefredex)}")))
 (newrefReduce_TCC1 0
  (newrefReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (injective? const-decl "bool" functions nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "rreduction.expr"
    "{x: IExpression_adt.IExpression | booleans.OR(IExpression_adt.newint?(x), IExpression_adt.newref?(x))}")))
 (newrefReduce_TCC2 0
  (newrefReduce_TCC2-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (least_out_rec def-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil)
    (N!2 skolem-const-decl "nat" rreduction nil)
    (nonempty? const-decl "bool" sets nil)
    (x!1 skolem-const-decl "nat" rreduction nil)
    (grS!1 skolem-const-decl "{grS | newrefRedex?(grS`redex)}"
     rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (size shared-adt-accessor-decl
          "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]"
          IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (size!1 skolem-const-decl "nat" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil))
   nil
   (newrefReduce subtype "rreduction.grS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.newdomain))(S)}")))
 (newrefReduce_TCC3 0
  (newrefReduce_TCC3-1 nil 3699031813
   ("" (skeep*)
    (("" (ground)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind)
        (("3" (typepred "grS`redex")
          (("3" (inst -3 "i!1") (("3" (grind) nil nil)) nil)) nil))
        nil)
       ("4" (grind)
        (("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)) nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) (refs def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil)
    (popDepth def-decl "nat" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "IExpression_adt.ref(rreduction.newrefredex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (newrefReduce_TCC4 0
  (newrefReduce_TCC4-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "rreduction.newrefredex"
    "(rreduction.newdomain)")))
 (newrefReduce_TCC5 0
  (newrefReduce_TCC5-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.newdomain))")))
 (newrefReduce_TCC6 0
  (newrefReduce_TCC6-1 nil 3699031813
   ("" (skeep*)
    (("" (expand refcount)
      (("" (expand refcountExpr)
        (("" (expand refs)
          (("" (rewrite refcount_stack_outside_domain)
            (("1" (use refcount_new)
              (("1" (ground)
                (("1" (rewrite -1)
                  (("1" (expand refcountArray)
                    (("1" (rewrite count_none_zero)
                      (("1" (skeep*) (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (delete 2)
                (("2" (ground)
                  (("1" (skeep*) (("1" (grind) nil nil)) nil)
                   ("2" (skeep*)
                    (("2" (typepred "store(x1)`seq(x2)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (refs def-decl "bool" IL nil)
    (refcount_new formula-decl nil rreduction nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (newdomain skolem-const-decl "non_empty_finite_set[nat]" rreduction
     nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size skolem-const-decl "nat" rreduction nil)
    (store skolem-const-decl "Store(grS`domain)" rreduction nil)
    (domain skolem-const-decl "finite_set[nat]" rreduction nil)
    (grS skolem-const-decl "{grS | newrefRedex?(grS`redex)}" rreduction
     nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (refcountArray const-decl "nat" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (count const-decl "nat" finseq_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (refcount_stack_outside_domain formula-decl nil rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce subtype "1"
    "{j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.store WITH [(rreduction.newrefredex) |-> (# length := rreduction.size, seq := (LAMBDA (i: naturalnumbers.below(rreduction.size)): IExpression_adt.nil) #)], rreduction.grS`stack, IExpression_adt.ref(rreduction.newrefredex))(rreduction.newrefredex)}")))
 (popReduce_TCC1 0
  (popReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (popReduce subtype "rreduction.expr" "(IExpression_adt.pop?)")))
 (popReduce_TCC2 0
  (popReduce_TCC2-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (popReduce subtype "rreduction.stack" "neStack")))
 (popReduce_TCC3 0
  (popReduce_TCC3-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pop const-decl "Stack" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popReduce subtype "IL.pop(rreduction.stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S)}")))
 (popReduce_TCC4 0
  (popReduce_TCC4-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (ground)
      (("1" (skeep) (("1" (inst -2 i) (("1" (grind) nil nil)) nil))
        nil)
       ("2" (grind) nil nil)
       ("3" (skeep) (("3" (inst -4 i) (("3" (grind) nil nil)) nil))
        nil)
       ("4" (grind) nil nil) ("5" (grind) nil nil)
       ("6" (grind) nil nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (value? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pop const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popReduce subtype "rreduction.body"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.pop(rreduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), IL.pop(rreduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), IL.pop(rreduction.stack)`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (popReduce_TCC5 0
  (popReduce_TCC5-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (expand refcountStack)
              (("" (case-replace "grS`redex = pop(body)")
                (("1" (expand refs 2 1)
                  (("1"
                    (case-replace
                     "grS`stack = add(stack(stack`length - 1), pop(stack))")
                    (("1" (rewrite count_add)
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (expand noDanglingRefs?)
                            (("1" (inst -13 0)
                              (("1"
                                (split -13)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (expand add 1)
                      (("2" (expand pop 1)
                        (("2" (replace -12)
                          (("2" (hide-all-but (-6 -14 1))
                            (("2" (grind-with-ext) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind-with-ext) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountStack const-decl "nat" rreduction nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_add formula-decl nil finseq_theorems nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (grS skolem-const-decl
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (pop const-decl "Stack" IL nil) (neStack type-eq-decl nil IL nil)
    (> const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, IL.pop(rreduction.stack), rreduction.body)(i)}]")))
 (release_reduce_redex_correct_TCC1 0
  (release_reduce_redex_correct_TCC1-1 nil 3700485765
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil))
   nil
   (release_reduce_redex_correct subtype "rreduction.grS`redex"
    "(IExpression_adt.release?)")))
 (release_reduce_redex_correct 0
  (release_reduce_redex_correct-1 nil 3700485765
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (split)
        (("1" (skeep) (("1" (grind) nil nil)) nil)
         ("2" (skeep) (("2" (grind) nil nil)) nil)
         ("3" (skeep) (("3" (grind) nil nil)) nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (apply-eta "grS`redex" "(release?)")
          (("6" (replace -1 :dir RL)
            (("6" (simplify)
              (("6" (expand mark -)
                (("6" (decompose-equality -7) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression_release_eta formula-decl nil IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (releaseReduce_TCC1 0
  (releaseReduce_TCC1-1 nil 3699031813 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype "rreduction.grS`redex"
    "(IExpression_adt.release?)")))
 (releaseReduce_TCC2 0
  (releaseReduce_TCC2-2 "" 3714763278
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (replace -11 :hide? t)
        (("" (assert)
          (("" (inst -2 "index(rvar(grS`redex))")
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (releaseReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[stack`length]"))
  (releaseReduce_TCC2-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (split)
        (("1" (expand pureReleaseRedex?)
          (("1" (expand releaseRedex?)
            (("1" (flatten)
              (("1" (assert)
                (("1" (expand refs -1) (("1" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil) ("3" (grind) nil nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (expand pureReleaseRedex?)
          (("6" (expand releaseRedex?)
            (("6" (flatten)
              (("6" (assert)
                (("6" (expand mark -6)
                  (("6" (decompose-equality -6) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[stack`length]")))
 (releaseReduce_TCC3 0
  (releaseReduce_TCC3-1 "" 3710694054
   ("" (skeep* :preds? t)
    (("" (expand every)
      (("" (inst?)
        (("" (typepred "grS`redex")
          (("" (inst -2 "index(rvar(grS`redex))")
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (x skolem-const-decl "nonneg_int" rreduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (releaseReduce subtype
    "rreduction.stack`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1))"
    "(IL.domainValue?(rreduction.grS`domain))"))
  (releaseReduce_TCC3-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred stack)
      (("" (grind)
        (("" (typepred "grS`redex")
          (("" (inst -2 "index(rvar(grS`redex))")
            (("" (typepred grS) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype
    "rreduction.stack`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (releaseReduce_TCC4 0
  (releaseReduce_TCC4-1 "" 3710694082
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(rvar(grS`redex))") (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (releaseReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[grS`stack`length]"))
  (releaseReduce_TCC4-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(refindex(vx))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (split)
            (("1" (expand refcountStack)
              (("1" (use "count_elem[(value?)]")
                (("1" (split)
                  (("1" (assert) nil nil)
                   ("2" (inst 1 "grS`stack`length-x-1")
                    (("1" (assert) nil nil)
                     ("2" (typepred "grS`redex")
                      (("2" (inst -2 "index(rvar(grS`redex))")
                        (("2" (split -2)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand refcountStack)
              (("2" (rewrite count_update)
                (("1" (expand refcountExpr)
                  (("1" (expand pureReleaseRedex?)
                    (("1" (expand releaseRedex?)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (expand refs 1 1)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "grS`redex")
                  (("2" (inst -2 "index(rvar(grS`redex))")
                    (("2" (grind) nil nil)) nil))
                  nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand every)
        (("2" (inst?)
          (("1" (grind) nil nil)
           ("2" (typepred "grS`redex")
            (("2" (inst -2 "index(rvar(grS`redex))")
              (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[grS`stack`length]")))
 (releaseReduce_TCC5 0
  (releaseReduce_TCC5-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`redex")
      (("" (typepred "grS") (("" (ground) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (releaseReduce subtype "IExpression_adt.nil" "(IL.value?)")))
 (releaseReduce_TCC6 0
  (releaseReduce_TCC6-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (ground)
        (("1" (skeep*) (("1" (grind) nil nil)) nil)
         ("2" (skeep*) (("2" (grind) nil nil)) nil)
         ("3" (skeep*) (("3" (grind) nil nil)) nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6"
          (case-replace
           "grS`redex = release(rvar(grS`redex), rexpr(grS`redex))")
          (("1" (expand mark -7)
            (("1" (simplify) (("1" (decompose-equality -7) nil nil))
              nil))
            nil)
           ("2" (grind-with-ext) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (IExpression_release_extensionality formula-decl nil
     IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype "IExpression_adt.rexpr(rreduction.grS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (releaseReduce_TCC7 0
  (releaseReduce_TCC7-1 nil 3699031813
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype "IExpression_adt.refindex(rreduction.vx)"
    "(rreduction.grS`domain)")))
 (releaseReduce_TCC8 0
  (releaseReduce_TCC8-1 nil 3699031813
   ("" (skeep*)
    (("" (typepred "grS`count(refindex(vx))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (replace-eta "grS`redex" "(release?)")
            (("1" (replace-eta "grS`redex" "(release?)" t)
              (("1" (replace -1 :dir RL)
                (("1" (simplify)
                  (("1" (expand refcountStack)
                    (("1" (rewrite count_update)
                      (("1" (split)
                        (("1"
                          (lemma
                           "finseq_theorems[(value?)].count_elem")
                          (("1" (inst?)
                            (("1" (inst?)
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (inst 1 "grS`stack`length - x - 1")
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (typepred "grS`redex")
                                    (("2"
                                      (inst
                                       -2
                                       "index(rvar(grS`redex))")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (typepred "grS`redex")
                        (("2" (inst -2 "index(rvar(grS`redex))")
                          (("2" (grind) nil nil)) nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`stack")
        (("2" (grind)
          (("1" (typepred "grS`redex")
            (("1" (delete 2 3)
              (("1" (apply-eta "grS`redex" "(release?)")
                (("1" (replace -1 :dir RL)
                  (("1" (inst -3 "index(rvar(grS`redex))")
                    (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (delete 2 3 4)
            (("2" (typepred "grS`redex")
              (("2" (apply-eta "grS`redex" "(release?)")
                (("2" (replace -1 :dir RL)
                  (("2" (inst -3 "index(rvar(grS`redex))")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (typepred "grS`redex")
            (("3" (apply-eta "grS`redex" "(release?)")
              (("3" (replace -1 :dir RL)
                (("3" (inst -3 "index(rvar(grS`redex))")
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_update formula-decl nil finseq_theorems nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (x skolem-const-decl "nonneg_int" rreduction nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStack const-decl "nat" rreduction nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_release_eta formula-decl nil IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype
    "(number_fields.-)(rreduction.grS`count(IExpression_adt.refindex(rreduction.vx)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), rreduction.x)) := IExpression_adt.nil], IExpression_adt.rexpr(rreduction.grS`redex))(IExpression_adt.refindex(rreduction.vx))}")))
 (releaseReduce_TCC9 0
  (releaseReduce_TCC9-1 nil 3724502330
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (rewrite count_update)
              (("1" (assert) (("1" (grind) nil nil)) nil)
               ("2" (typepred "grS`redex")
                (("2" (inst -2 x) (("2" (grind) nil nil)) nil)) nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count_update formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count const-decl "nat" finseq_theorems nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (markv const-decl "(variable?)" preprocess nil)
    (union const-decl "set" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype "rreduction.grS`count(rreduction.x)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), rreduction.x)) := IExpression_adt.nil], IExpression_adt.rexpr(rreduction.grS`redex))(rreduction.x)}")))
 (releaseReduce_TCC10 0
  (releaseReduce_TCC9-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (lift-if)
          (("" (ground)
            (("" (inst -7 i)
              (("" (ground)
                (("1" (apply-eta "grS`redex" "(release?)")
                  (("1" (replace -1 :dir RL) (("1" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (IExpression_release_eta formula-decl nil IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (releaseRedex? const-decl "bool" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype
    "rreduction.grS WITH [`stack`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)) := IExpression_adt.nil, `count(IExpression_adt.refindex(rreduction.vx)) := (number_fields.-)(rreduction.grS`count(IExpression_adt.refindex(rreduction.vx)), 1), `redex := IExpression_adt.rexpr(rreduction.grS`redex)]"
    "(rreduction.noDanglingRefs?)")))
 (releaseReduce_TCC11 0
  (releaseReduce_TCC10-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (inst -2 "index(rvar(grS`redex))")
        (("" (assert)
          (("" (split -2) (("1" (grind) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype
    "rreduction.grS`store(IExpression_adt.refindex(rreduction.vx))`length"
    "naturalnumbers.upto(rreduction.grS`store(IExpression_adt.refindex(rreduction.vx))`length)")))
 (releaseReduce_TCC12 0
  (releaseReduce_TCC11-1 nil 3699031813
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (ground)
        (("1" (skeep*) (("1" (grind) nil nil)) nil)
         ("2" (skeep*) (("2" (grind) nil nil)) nil)
         ("3" (skeep*) (("3" (grind) nil nil)) nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (apply-eta "grS`redex" "(release?)")
          (("6" (replace -1 :dir RL)
            (("6" (expand mark -7)
              (("6" (decompose-equality -7) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression_release_eta formula-decl nil IExpression_adt nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype "IExpression_adt.rexpr(rreduction.grS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (releaseReduce_TCC11-1 "" 3710694880
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (expand pureReleaseRedex?)
        (("" (expand releaseRedex?)
          (("" (flatten)
            (("" (assert)
              (("" (split +)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil) ("4" (grind) nil nil)
                 ("5" (expand mark -6)
                  (("5" (decompose-equality -6) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak
   (releaseReduce subtype "IExpression_adt.rexpr(rreduction.grS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (releaseReduce_TCC13 0
  (releaseReduce_TCC12-1 nil 3699276705
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (grS skolem-const-decl
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, IExpression_adt.rexpr(rreduction.grS`redex))(i)}]"))
  (releaseReduce_TCC12-1 "" 3710694913
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak
   (releaseReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, IExpression_adt.rexpr(rreduction.grS`redex))(i)}]")))
 (variableReduce_TCC1 0
  (variableReduce_TCC1-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (popDepth def-decl "nat" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.expr"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (variableReduce_TCC2 0
  (variableReduce_TCC2-1 "" 3710694963
   ("" (skeep* :preds? t)
    (("" (expand get)
      (("" (expand every)
        (("" (inst? -8)
          (("" (inst -2 "index(expr)") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((get const-decl "(value?)" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (expr skolem-const-decl "{A |
        (FORALL i: refs(A)(i) IMPLIES grS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length)
    AND (FORALL i:
           vars(grS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(grS`context) < grS`stack`length)
    AND (popDepth(A) + popDepth(grS`context) <= grS`stack`length)
    AND contextPure?(A) AND (mark(cvars(grS`context))(A) = A)}"
          rreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (grS skolem-const-decl "{grS | variable?(grS`redex)}" rreduction
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (variableReduce subtype "IL.get(rreduction.stack)(rreduction.expr)"
    "(IL.domainValue?(rreduction.grS`domain))"))
  (variableReduce_TCC2-1 nil 3705857843
   ("" (skeep* :preds? t)
    (("" (typepred "stack")
      (("" (expand every)
        (("" (inst -1 "stack`length-1-index(expr)")
          (("1" (grind) nil nil)
           ("2" (inst -2 "index(expr)") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (markv const-decl "(variable?)" preprocess nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (singleton const-decl "(singleton?)" sets nil)
    (get const-decl "(value?)" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "IL.get(rreduction.stack)(rreduction.expr)"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (variableReduce_TCC3 0
  (variableReduce_TCC3-1 nil 3714529219 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil))
   nil
   (variableReduce subtype "rreduction.grS`redex"
    "(IExpression_adt.variable?)")))
 (variableReduce_TCC4 0
  (variableReduce_TCC4-2 "" 3714545539
   ("" (skeep* :preds? t)
    (("" (inst -4 "index(expr)") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (variableReduce subtype "rreduction.expr"
    "(IExpression_adt.variable?)"))
  (variableReduce_TCC4-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount +)
          (("" (expand refcountStack)
            (("" (rewrite count_update)
              (("1" (grind) nil nil)
               ("2" (inst -5 "index(expr)") (("2" (grind) nil nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.expr"
    "(IExpression_adt.variable?)"))
  (variableReduce_TCC4-1 nil 3705857843
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (split +)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil)
         ("5" (grind) nil nil) ("6" (grind) nil nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (get const-decl "(value?)" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.expr"
    "(IExpression_adt.variable?)")))
 (variableReduce_TCC5 0
  (variableReduce_TCC5-1 "" 3710694981
   ("" (skeep* :preds? t)
    (("" (inst -4 "index(expr)") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (variableReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(rreduction.expr))"
    "below[grS`stack`length]"))
  (variableReduce_TCC5-1 nil 3705857843
   ("" (skeep* :preds? t)
    (("" (inst -4 "index(expr)") (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(rreduction.expr))"
    "below[grS`stack`length]")))
 (variableReduce_TCC6 0
  (variableReduce_TCC6-1 nil 3705848866 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (variableReduce subtype "IExpression_adt.nil" "(IL.value?)")))
 (variableReduce_TCC7 0
  (variableReduce_TCC7-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (variableReduce_TCC8 0
  (variableReduce_TCC8-1 nil 3705857843
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (rewrite count_update)
              (("1" (assert) (("1" (grind) nil nil)) nil)
               ("2" (inst -5 "index(expr)") (("2" (grind) nil nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count_update formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (get const-decl "(value?)" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (refcountStack const-decl "nat" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(rreduction.expr))) := IExpression_adt.nil], rreduction.value)(i)}]")))
 (variableReduce_TCC9 0
  (variableReduce_TCC9-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (mark def-decl "IExpression" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (variableReduce_TCC10 0
  (variableReduce_TCC10-1 nil 3705848866 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (variableReduce subtype "IExpression_adt.refindex(rreduction.value)"
    "(rreduction.grS`domain)")))
 (variableReduce_TCC11 0
  (variableReduce_TCC11-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(refindex(value))")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (get const-decl "(value?)" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype
    "(number_fields.+)(rreduction.grS`count(IExpression_adt.refindex(rreduction.value)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(IExpression_adt.refindex(rreduction.value))}"))
  (variableReduce_TCC11-1 "" 3710695100
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(refindex(value))")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak
   (variableReduce subtype
    "(number_fields.+)(rreduction.grS`count(IExpression_adt.refindex(rreduction.value)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(IExpression_adt.refindex(rreduction.value))}")))
 (variableReduce_TCC12 0
  (variableReduce_TCC12-1 nil 3724502330
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.grS`count(rreduction.x)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(rreduction.x)}")))
 (variableReduce_TCC13 0
  (variableReduce_TCC12-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (mark def-decl "IExpression" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (singleton const-decl "(singleton?)" sets nil)
    (popDepth def-decl "nat" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (grS skolem-const-decl "{grS | variable?(grS`redex)}" rreduction
     nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (variableReduce_TCC12-1 "" 3710695144
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (split +)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil)
         ("5" (grind) nil nil) ("6" (grind) nil nil))
        nil))
      nil))
    nil)
   nil shostak
   (variableReduce subtype "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (variableReduce_TCC14 0
  (variableReduce_TCC13-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (markv const-decl "(variable?)" preprocess nil)
    (singleton const-decl "(singleton?)" sets nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(i)}]"))
  (variableReduce_TCC13-1 "" 3710695164
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   nil shostak
   (variableReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(i)}]")))
 (letReduce_TCC1 0
  (letReduce_TCC1-1 nil 3699107903 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype "rreduction.expr" "(IExpression_adt.letexpr?)")))
 (letReduce_TCC2 0
  (letReduce_TCC2-1 nil 3699107903 ("" (grind) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (value? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype "IExpression_adt.letrhs(rreduction.expr)"
    "(IL.value?)")))
 (letReduce_TCC3 0
  (letReduce_TCC3-1 nil 3699107903
   ("" (skeep*)
    (("" (typepred "stack")
      (("" (expand every)
        (("" (expand push)
          (("" (expand add)
            (("" (skeep :preds? t)
              (("" (lift-if)
                (("" (split)
                  (("1" (flatten)
                    (("1" (typepred "expr")
                      (("1" (expand domainValue?)
                        (("1" (flatten)
                          (("1" (inst? -1)
                            (("1" (split)
                              (("1" (propax) nil nil)
                               ("2"
                                (apply-eta expr "(letexpr?)")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (push const-decl "Stack" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype
    "IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S)}")))
 (letReduce_TCC4 0
  (letReduce_TCC4-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (skeep)
        (("1" (expand refs -1)
          (("1" (use pure_refs) (("1" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (skeep* :preds? t)
        (("2" (expand popDepth +)
          (("2" (expand push +)
            (("2" (expand add +)
              (("2" (inst -4 i)
                (("2" (split)
                  (("1" (rewrite purePopDepth +)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep)
        (("3" (inst -4 i)
          (("3" (split)
            (("1" (expand popDepth + 1)
              (("1" (rewrite purePopDepth +)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("4" (expand popDepth + 1)
        (("4" (rewrite purePopDepth +)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil)
       ("5" (expand contextPure?)
        (("5" (use pure_contextPure) (("5" (grind) nil nil)) nil)) nil)
       ("6" (expand mark +)
        (("6" (decompose-equality)
          (("6" (apply-eta "expr" "(letexpr?)")
            (("6" (replace -1 :dir RL)
              (("6" (assert)
                (("6" (expand mark -)
                  (("6" (decompose-equality -7)
                    (("6" (case "vars(body(expr))(0)")
                      (("1" (assert) nil nil)
                       ("2" (assert)
                        (("2"
                          (case "top_releases(release(variable(0, TRUE),
              mark(bump(cvars(grS`context)))(body(expr))))
       = top_releases(body(expr))")
                          (("1" (expand top_releases -1 1)
                            (("1" (rewrite top_releases_mark)
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refs def-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (pure_refs formula-decl nil IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (purePopDepth formula-decl nil IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (push const-decl "Stack" IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (top_releases def-decl "nat" preprocess nil)
    (top_releases_mark formula-decl nil preprocess nil)
    (TRUE const-decl "bool" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype
    "IExpression_adt.pop(IExpression_adt.body(rreduction.expr))"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (letReduce_TCC5 0
  (letReduce_TCC5-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (expand refcountExpr)
              (("" (case-replace "refs(pop(body(expr)))(x1) = FALSE")
                (("1" (expand push)
                  (("1" (rewrite count_add) (("1" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (expand refs)
                  (("2" (use pure_refs) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure_refs formula-decl nil IL nil)
    (push const-decl "Stack" IL nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (count const-decl "nat" finseq_theorems nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count_add formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refcountStack const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack), IExpression_adt.pop(IExpression_adt.body(rreduction.expr)))(i)}]")))
 (count_copy_TCC1 0
  (count_copy_TCC1-1 nil 3699369652 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (injective? const-decl "bool" functions nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil
   (count_copy subtype "IExpression_adt.refindex(rreduction.r)"
    "(rreduction.dom)")))
 (count_copy_TCC2 0
  (count_copy_TCC2-1 nil 3699369652
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (count_copy subtype "(number_fields.-)(rreduction.i, 1)"
    "naturalnumbers.upto(rreduction.V`length)")))
 (count_copy_TCC3 0
  (count_copy_TCC3-1 nil 3699369652 ("" (termination-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil
   (count_copy termination
    "rreduction.count_copy(rreduction.dom, rreduction.ncnt, rreduction.V, (number_fields.-)(rreduction.i, 1))"
    "nil")))
 (count_copy_TCC4 0
  (count_copy_TCC4-1 nil 3699369652 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (count_copy subtype "(number_fields.-)(rreduction.i, 1)"
    "below[length(V)]")))
 (count_copy_def_TCC1 0
  (count_copy_def_TCC1-1 nil 3699369652 ("" (subtype-tcc) nil nil) nil
   nil
   (count_copy_def subtype "rreduction.V`length"
    "naturalnumbers.upto(rreduction.V`length)")))
 (count_copy_def 0
  (count_copy_def-1 nil 3699371811
   ("" (skeep*)
    ((""
      (case "forall (j: nat): j <= V`length IMPLIES forall (cnt: [(dom) -> nat]): count_copy(dom, cnt, V, j)(i) = cnt(i) + count((lambda u: ref?(u) and refindex(u) = i), (# `length := j, `seq := (LAMBDA (k: below(j)): V`seq(k)) #))")
      (("1" (inst -1 "V`length")
        (("1" (simplify)
          (("1" (inst -1 "cnt")
            (("1" (rewrite -1)
              (("1" (expand refcountArray)
                (("1"
                  (case-replace "(# `length := V`length,
               `seq := lambda (k: below(V`length)): V`seq(k) #) = V")
                  (("1" (grind-with-ext) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (induct j)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (skolem 1 "cnt2")
            (("2" (delete 2)
              (("2" (simplify)
                (("2" (split -1)
                  (("1" (expand count_copy 1)
                    (("1" (rewrite -1)
                      (("1"
                        (name "Z" "(# `length := j_1,
                `seq := lambda (k: below(j_1)): V`seq(k) #)")
                        (("1" (replace -1)
                          (("1"
                            (case-replace "(# `length := 1 + j_1,
                 `seq := lambda (k: below(1 + j_1)): V`seq(k) #) = add(V`seq(j_1), Z)")
                            (("1" (rewrite count_add)
                              (("1"
                                (lift-if)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (simplify)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete 2)
                              (("2"
                                (expand add)
                                (("2"
                                  (delete -2)
                                  (("2"
                                    (replace -1 :dir RL)
                                    (("2"
                                      (simplify)
                                      (("2"
                                        (apply-extensionality 1)
                                        (("2"
                                          (delete 2)
                                          (("2"
                                            (lift-if 1)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (grind) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind)
                        (("2" (grind)
                          (("2" (grind)
                            (("2" (grind)
                              (("2"
                                (typepred "V`seq(j_1)")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil) ("4" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (grind) nil nil))
        nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count const-decl "nat" finseq_theorems nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountArray const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (count_add formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil) nil nil)
   shostak))
 (updateRedex_target_index_TCC1 0
  (updateRedex_target_index_TCC1-1 nil 3701021413
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil))
   nil
   (updateRedex_target_index subtype "rreduction.grS`redex"
    "(IExpression_adt.update?)")))
 (updateRedex_target_index 0
  (updateRedex_target_index-1 nil 3701115744
   ("" (skeep) (("" (typepred "grS`redex") (("" (grind) nil nil)) nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (updateRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateRedex_lhs_index 0
  (updateRedex_lhs_index-1 nil 3701115767
   ("" (skeep) (("" (typepred "grS`redex") (("" (grind) nil nil)) nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (updateRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateRedex_rhs_index 0
  (updateRedex_rhs_index-1 nil 3701115794
   ("" (skeep) (("" (typepred "grS`redex") (("" (grind) nil nil)) nil))
    nil)
   ((goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (updateRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (maybe_clear_stack_at_TCC1 0
  (maybe_clear_stack_at_TCC1-1 nil 3706028126
   ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype
    "(number_fields.-)((number_fields.-)(rreduction.newStack`length, 1), rreduction.i)"
    "below[newStack`length]")))
 (maybe_clear_stack_at_TCC2 0
  (maybe_clear_stack_at_TCC2-1 nil 3706028126
   ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype
    "(number_fields.-)((number_fields.-)(rreduction.S`length, 1), rreduction.i)"
    "below[S`length]")))
 (maybe_clear_stack_at_TCC3 0
  (maybe_clear_stack_at_TCC3-1 nil 3706028126
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype
    "(number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)"
    "below[S`length]")))
 (maybe_clear_stack_at_TCC4 0
  (maybe_clear_stack_at_TCC4-1 nil 3706028126
   ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype "IExpression_adt.nil" "(IL.value?)")))
 (maybe_clear_stack_at_TCC5 0
  (maybe_clear_stack_at_TCC5-1 nil 3706028126
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype
    "rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)) := IExpression_adt.nil]"
    "{newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)}")))
 (maybe_clear_stack_at_TCC6 0
  (maybe_clear_stack_at_TCC7-2 "" 3714766523
   ("" (skeep* :preds? t)
    (("" (expand "every")
      (("" (expand get) (("" (replace -8) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (maybe_clear_stack_at subtype
    "IExpression_adt.refindex(rreduction.v)" "(rreduction.dom)"))
  (maybe_clear_stack_at_TCC7-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(v))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (split)
            (("1" (expand refcountStack)
              (("1" (use "count_elem[(value?)]")
                (("1" (split)
                  (("1" (assert) nil nil)
                   ("2" (expand get)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)
                   ("3" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand refcountStack)
              (("2" (rewrite count_update)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil) ("3" (propax) nil nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype
    "IExpression_adt.refindex(rreduction.v)" "(rreduction.dom)")))
 (maybe_clear_stack_at_TCC7 0
  (maybe_clear_stack_at_TCC8-1 "" 3710695262
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(v))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (split)
            (("1" (expand "refcountStack")
              (("1" (use "count_elem[(value?)]")
                (("1" (split)
                  (("1" (assert) nil nil)
                   ("2" (expand get)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)
                   ("3" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand "refcountStack")
              (("2" (rewrite count_update)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil) ("3" (propax) nil nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refcountStack const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil))
   shostak
   (maybe_clear_stack_at subtype
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(IExpression_adt.refindex(rreduction.v))}"))
  (maybe_clear_stack_at_TCC8-1 nil 3706034968
   ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(IExpression_adt.refindex(rreduction.v))}")))
 (maybe_clear_stack_at_TCC8 0
  (maybe_clear_stack_at_TCC6-2 "" 3714766340
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(v))")
      (("1" (rewrite -1)
        (("1" (use "count_elem[(value?)]")
          (("1" (split -1)
            (("1" (assert)
              (("1" (expand "count")
                (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil))
              nil)
             ("2" (expand get)
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)
             ("3" (propax) nil nil))
            nil)
           ("2" (assert) (("2" (hide 2) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil)
       ("3" (propax) nil nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (injective? const-decl "bool" functions nil)
    (get const-decl "(value?)" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (count const-decl "nat" finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (maybe_clear_stack_at subtype
    "(rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)) := IExpression_adt.nil], rreduction.cnt WITH [(IExpression_adt.refindex(rreduction.v)) |-> (number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)])"
    "{((newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)), (newcnt: [i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.newStack, rreduction.A)(i)}])) | FORALL (i: naturalnumbers.below(rreduction.S`length)): booleans.IMPLIES(IExpression_adt.ref?(newStack`seq((number_fields.-)((number_fields.-)(newStack`length, 1), i))), booleans.AND(IExpression_adt.ref?(rreduction.S`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), i))), ))}"))
  (maybe_clear_stack_at_TCC6-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(v))")
      (("1" (rewrite -1)
        (("1" (expand refcount)
          (("1" (split)
            (("1" (expand refcountStack)
              (("1" (use "count_elem[(value?)]")
                (("1" (split -1)
                  (("1" (assert) nil nil)
                   ("2" (expand get)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)
                   ("3" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (expand refcountStack)
              (("2" (rewrite count_update)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil) ("3" (propax) nil nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (every const-decl "bool" finseq_theorems nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (injective? const-decl "bool" functions nil)
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refcountStack const-decl "nat" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil))
   nil
   (maybe_clear_stack_at subtype
    "(rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)) := IExpression_adt.nil], rreduction.cnt WITH [(IExpression_adt.refindex(rreduction.v)) |-> (number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)])"
    "{((newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)), (newcnt: [i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.newStack, rreduction.A)(i)}])) | FORALL (i: naturalnumbers.below(rreduction.S`length)): booleans.IMPLIES(IExpression_adt.ref?(newStack`seq((number_fields.-)((number_fields.-)(newStack`length, 1), i))), booleans.AND(IExpression_adt.ref?(rreduction.S`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), i))), ))}")))
 (maybe_clear_stack_at_TCC9 0
  (maybe_clear_stack_at_TCC10-1 nil 3706034968
   ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype "rreduction.S"
    "{newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)}")))
 (maybe_clear_stack_at_TCC10 0
  (maybe_clear_stack_at_TCC11-1 nil 3714529219
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (Stack type-eq-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (maybe_clear_stack_at subtype "(rreduction.S, rreduction.cnt)"
    "{((newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)), (newcnt: [i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.newStack, rreduction.A)(i)}])) | FORALL (i: naturalnumbers.below(rreduction.S`length)): booleans.IMPLIES(IExpression_adt.ref?(newStack`seq((number_fields.-)((number_fields.-)(newStack`length, 1), i))), booleans.AND(IExpression_adt.ref?(rreduction.S`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), i))), ))}")))
 (update_store_TCC1 0
  (update_store_TCC1-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Store type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (update_store subtype "IExpression_adt.refindex(rreduction.ov)"
    "(rreduction.dom)")))
 (update_store_TCC2 0
  (update_store_TCC2-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(ov))")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (case "refcountStore(dom, str)(refindex(ov)) > 0")
            (("1" (assert) nil nil)
             ("2" (hide 2)
              (("2" (expand refcountStore)
                (("2" (expand allcount)
                  (("2" (lemma sigma_add)
                    (("2" (inst -1 "dom" _ r)
                      (("2" (inst?)
                        (("1" (split)
                          (("1" (rewrite -1)
                            (("1" (expand refcountArray 1 1)
                              (("1"
                                (use "count_elem[(value?)]")
                                (("1"
                                  (split)
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (inst?)
                                    (("2" (assert) nil nil))
                                    nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand member)
                            (("2" (propax) nil nil)) nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (allcount const-decl "nat" rreduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (count_elem formula-decl nil finseq_theorems nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (refcountArray const-decl "nat" rreduction nil)
    (ov skolem-const-decl "(domainValue?(dom))" rreduction nil)
    (dom skolem-const-decl "finite_set[nat]" rreduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_add formula-decl nil finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountStore const-decl "nat" rreduction nil)
    (> const-decl "bool" reals nil))
   nil
   (update_store subtype
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.ov)), 1)"
    "nat")))
 (update_store_TCC3 0
  (update_store_TCC3-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Store type-eq-decl nil reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (update_store subtype "IExpression_adt.refindex(rreduction.nv)"
    "(rreduction.dom)")))
 (update_store_TCC4 0
  (update_store_TCC4-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred "cnt(refindex(nv))")
      (("" (replace -11)
        (("" (lift-if)
          (("" (lift-if)
            (("" (assert)
              (("" (rewrite -1)
                (("" (split +)
                  (("1" (flatten)
                    (("1" (split +)
                      (("1" (flatten)
                        (("1" (replace -1 :dir RL)
                          (("1" (typepred "cnt(refindex(nv))")
                            (("1" (rewrite -1)
                              (("1"
                                (case-replace
                                 "str WITH [(r)`seq(i) := nv] = str")
                                (("1"
                                  (decompose-equality)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (decompose-equality)
                                          (("1"
                                            (decompose-equality)
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (replace*)
                                                      (("1"
                                                        (hide-all-but
                                                         (1 -4 -3 -13))
                                                        (("1"
                                                          (grind-with-ext)
                                                          (("1"
                                                            (grind)
                                                            (("1"
                                                              (grind-with-ext)
                                                              (("1"
                                                                (apply-eta
                                                                 "nv"
                                                                 "(ref?)")
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   :dir
                                                                   RL)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (hide
                                                                       -1)
                                                                      (("1"
                                                                        (grind-with-ext)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (expand refcount)
                          (("2" (rewrite refcountStore_set)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (expand refcount)
                      (("2" (rewrite refcountStore_set)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (IExpression_ref_eta formula-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (refs def-decl "bool" IL nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (injective? const-decl "bool" functions nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil
   (update_store subtype
    "(number_fields.+)(rreduction.cnt1(IExpression_adt.refindex(rreduction.nv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str WITH [(rreduction.r)`seq(rreduction.i) := rreduction.nv], rreduction.S, rreduction.A)(IExpression_adt.refindex(rreduction.nv))}")))
 (update_store_TCC5 0
  (update_store_TCC5-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (replace -10)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (assert)
              (("1" (lift-if)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (typepred "cnt(refindex(ov))")
                      (("1" (rewrite -1)
                        (("1" (expand refcount)
                          (("1" (replace -1)
                            (("1" (assert)
                              (("1"
                                (rewrite refcountStore_set)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "cnt(x1)")
                      (("2" (rewrite -1)
                        (("2" (expand refcount)
                          (("2" (rewrite refcountStore_set)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (split)
            (("1" (flatten) nil nil)
             ("2" (flatten)
              (("2" (typepred "cnt(x1)")
                (("2" (rewrite -1)
                  (("2" (expand refcount)
                    (("2" (rewrite refcountStore_set)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refcount const-decl "nat" rreduction nil)
    (Stack type-eq-decl nil IL nil)
    (Store type-eq-decl nil reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (injective? const-decl "bool" functions nil)
    (refs def-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refcountStore_set formula-decl nil rreduction nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (update_store subtype "rreduction.cnt1"
    "[i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str WITH [(rreduction.r)`seq(rreduction.i) := rreduction.nv], rreduction.S, rreduction.A)(i)}]")))
 (updateReduce_TCC1 0
  (updateReduce_TCC1-1 nil 3714529219
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (split)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "rreduction.grS`redex"
    "{A: (IExpression_adt.update?) | booleans.AND(reals.<(IExpression_adt.index(IExpression_adt.target(A)), rreduction.stack`length), booleans.AND(reals.<(IExpression_adt.index(IExpression_adt.lhs(A)), rreduction.stack`length), reals.<(IExpression_adt.index(IExpression_adt.rhs(A)), rreduction.stack`length)))}")))
 (updateReduce_TCC2 0
  (updateReduce_TCC2-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (typepred "grS`redex")
      (("" (split)
        (("1" (grind) nil nil) ("2" (grind) nil nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.target(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (updateReduce_TCC3 0
  (updateReduce_TCC3-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype
    "IL.get(rreduction.stack)(IExpression_adt.target(rreduction.expr))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (updateReduce_TCC4 0
  (updateReduce_TCC4-1 "" 3706018643 ("" (skeep* :preds? t) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (updateReduce subtype "IExpression_adt.lhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (updateReduce_TCC4-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (domainValue? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil
   (updateReduce subtype "IExpression_adt.lhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (updateReduce_TCC5 0
  (updateReduce_TCC5-1 nil 3714529219
   ("" (skeep* :preds? t)
    (("" (expand every -9)
      (("" (inst -9 "stack`length - 1 - index(lhs(expr))")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (grS skolem-const-decl
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (expr skolem-const-decl "{A: (update?) |
   index(target(A)) < stack`length AND
    index(lhs(A)) < stack`length AND index(rhs(A)) < stack`length}"
          rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype
    "IL.get(rreduction.stack)(IExpression_adt.lhs(rreduction.expr))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (updateReduce_TCC6 0
  (updateReduce_TCC6-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (expand every -9)
      (("" (inst -9 "stack`length - 1 - index(lhs(expr))")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.rhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (updateReduce_TCC6-1 "" 3706018675 ("" (skeep* :preds? t) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (updateReduce subtype "IExpression_adt.rhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (updateReduce_TCC6-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred stack)
      (("" (expand* every get) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil
   (updateReduce subtype "IExpression_adt.rhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (updateReduce_TCC7 0
  (updateReduce_TCC7-1 nil 3714529219
   ("" (skeep* :preds? t)
    (("" (expand every -11)
      (("" (inst -11 "stack`length - 1 - index(rhs(expr))")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((every const-decl "bool" finseq_theorems nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (grS skolem-const-decl
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (expr skolem-const-decl "{A: (update?) |
   index(target(A)) < stack`length AND
    index(lhs(A)) < stack`length AND index(rhs(A)) < stack`length}"
          rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype
    "IL.get(rreduction.stack)(IExpression_adt.rhs(rreduction.expr))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (updateReduce_TCC8 0
  (updateReduce_TCC8-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (expand every -11)
      (("" (inst -11 "stack`length - 1 - index(rhs(expr))")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.refindex(rreduction.aval)"
    "(rreduction.grS`domain)"))
  (updateReduce_TCC8-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred stack)
      (("" (expand* every get) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (domainValue? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil))
   nil
   (updateReduce subtype "IExpression_adt.refindex(rreduction.aval)"
    "(rreduction.grS`domain)")))
 (updateReduce_TCC9 0
  (updateReduce_TCC9-2 "" 3714786059
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountexpr)
            (("" (replace -16)
              (("" (replace -15) (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (updateReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.stack, rreduction.expr)(i)}]"))
  (updateReduce_TCC9-1 "" 3706030420
   ("" (skeep* :preds? t)
    (("" (expand every) (("" (grind) nil nil)) nil)) nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (updateReduce subtype "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.stack, rreduction.expr)(i)}]")))
 (updateReduce_TCC10 0
  (updateReduce_TCC10-2 "" 3714546743 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (updateReduce subtype "IExpression_adt.target(rreduction.expr)"
    "{x: (IExpression_adt.variable?) | reals.<(IExpression_adt.index(x), rreduction.nstack`length)}"))
  (updateReduce_TCC10-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred "grS`count(x1)") (("" (assert) nil nil)) nil)) nil)
   ((get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.target(rreduction.expr)"
    "{x: (IExpression_adt.variable?) | reals.<(IExpression_adt.index(x), rreduction.nstack`length)}"))
  (updateReduce_TCC10-1 nil 3699107903 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "IExpression_adt.target(rreduction.expr)"
    "{x: (IExpression_adt.variable?) | reals.<(IExpression_adt.index(x), rreduction.nstack`length)}")))
 (updateReduce_TCC11 0
  (updateReduce_TCC11-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.oldref"
    "(rreduction.grS`domain)")))
 (updateReduce_TCC12 0
  (updateReduce_TCC12-1 nil 3699107903
   ("" (skeep* :preds? t)
    (("" (case "domainValue?(grS`domain)(grS`store(oldref)`seq(x1))")
      (("1" (expand "domainValue?")
        (("1" (assert)
          (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`store(oldref)`seq(x1)")
        (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.grS`store(rreduction.oldref)"
    "finseq[(domainValue?(newdomain))]")))
 (updateReduce_TCC13 0
  (updateReduce_TCC13-2 "" 3714547029 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (updateReduce subtype "rreduction.newref" "(rreduction.newdomain)"))
  (updateReduce_TCC13-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (case "domainValue?(grS`domain)(grS`store(oldref)`seq(x1))")
      (("1" (expand domainValue?)
        (("1" (assert)
          (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (typepred "grS`store(oldref)`seq(x1)")
        (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.newref" "(rreduction.newdomain)"))
  (updateReduce_TCC13-1 "" 3710695340
   ("" (skeep* :preds? t)
    (("" (typepred "grS`store(oldref)`seq(x1)") (("" (grind) nil nil))
      nil))
    nil)
   nil shostak
   (updateReduce subtype "rreduction.newref"
    "(rreduction.newdomain)")))
 (updateReduce_TCC14 0
  (updateReduce_TCC14-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce subtype "rreduction.copied`length"
    "naturalnumbers.upto(rreduction.copied`length)"))
  (updateReduce_TCC14-1 nil 3699107903 ("" (grind) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (value? const-decl "bool" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil))
   nil
   (updateReduce subtype "rreduction.copied`length"
    "naturalnumbers.upto(rreduction.copied`length)")))
 (updateReduce_TCC15 0
  (updateReduce_TCC15-1 nil 3714529219
   ("" (skeep* :preds? t)
    (("" (rewrite count_copy_def)
      (("1" (lift-if)
        (("1" (split +)
          (("1" (flatten)
            (("1" (replace -1)
              (("1" (expand refcount +)
                (("1" (assert)
                  (("1" (expand "refcountExpr")
                    (("1" (expand refs)
                      (("1"
                        (case-replace
                         "refcountArray(copied)(newref) = 0")
                        (("1"
                          (case-replace
                           "refcountStack(nnstack)(newref) = 0")
                          (("1" (assert)
                            (("1" (expand refcountstore)
                              (("1"
                                (expand allcount)
                                (("1"
                                  (rewrite sigma_zero)
                                  (("1"
                                    (skeep* :preds? t)
                                    (("1"
                                      (expand refcountarray)
                                      (("1"
                                        (rewrite count_none_zero)
                                        (("1"
                                          (skeep* :preds? t)
                                          (("1"
                                            (case-replace "x = newref")
                                            (("1"
                                              (typepred
                                               "grS`store(oldref)`seq(i)")
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (typepred
                                               "grS`store(x)`seq(i)")
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil)
                                               ("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand refcountstack)
                            (("2" (rewrite count_none_zero)
                              (("2"
                                (skeep* :preds? t)
                                (("2"
                                  (typepred nnstack)
                                  (("2"
                                    (expand every)
                                    (("2"
                                      (inst?)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand refcountarray 1)
                          (("2" (rewrite count_none_zero)
                            (("2" (skeep :preds? t)
                              (("2"
                                (typepred "grS`store(oldref)`seq(i)")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "nncount(x1)")
              (("2" (rewrite -1)
                (("2" (expand refcount)
                  (("2" (expand refcountexpr)
                    (("2" (expand refs)
                      (("2" (assert)
                        (("2" (expand refcountstore +)
                          (("2" (expand allcount)
                            (("2" (lemma sigma_add)
                              (("2"
                                (inst -1 newdomain _ newref)
                                (("2"
                                  (inst?)
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (rewrite -1)
                                      (("1"
                                        (case "newdomain(newref)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (case-replace
                                             "nstore(newref) = copied")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (case-replace
                                                 "remove(newref, newdomain) = grS`domain")
                                                (("1"
                                                  (use sigma_eq)
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (skeep*
                                                       :preds?
                                                       t)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (case
                                                           "newdomain(x)")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but (1 -))
                                                  (("2"
                                                    (replace*)
                                                    (("2"
                                                      (rewrite
                                                       remove_add_member
                                                       +)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((count_copy_def formula-decl nil rreduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (refcountStack const-decl "nat" rreduction nil)
    (refcountStore const-decl "nat" rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma_zero formula-decl nil finite_set_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (head const-decl "T" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (count const-decl "nat" finseq_theorems nil)
    (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (injective? const-decl "bool" functions nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (allcount const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (sigma_add formula-decl nil finite_set_theorems nil)
    (newdomain skolem-const-decl "non_empty_finite_set[nat]" rreduction
     nil)
    (grS skolem-const-decl
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (newref skolem-const-decl "{n | NOT grS`domain(n)}" rreduction nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (sigma_eq formula-decl nil finite_set_theorems nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype
    "rreduction.count_copy(rreduction.newdomain, rreduction.nncount WITH [(rreduction.newref) |-> 1], rreduction.copied, rreduction.copied`length)"
    "[i: (rreduction.newdomain) -> {j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.nstore, rreduction.nnstack, IExpression_adt.ref(rreduction.newref))(i)}]")))
 (updateReduce_TCC16 0
  (updateReduce_TCC16-2 "" 3714548825
   ("" (skeep* :preds? t)
    (("" (split +)
      (("1" (hide-all-but (1 -34)) (("1" (grind) nil nil)) nil)
       ("2" (skeep :preds? t)
        (("2" (replace -40)
          (("2" (replace -36)
            (("2" (lift-if)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (replace -40)
                    (("1" (typepred "grS`store(oldref)`seq(x2)")
                      (("1" (expand domainValue?)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (typepred "grS`store(x1)`seq(x2)")
                    (("2" (expand domainValue?) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (updateReduce subtype "rreduction.nstore"
    "reduction.Store(rreduction.newdomain)"))
  (updateReduce_TCC16-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (rewrite count_copy_def)
      (("1" (lift-if)
        (("1" (split +)
          (("1" (flatten)
            (("1" (replace -1)
              (("1" (expand refcount +)
                (("1" (assert)
                  (("1" (expand refcountExpr)
                    (("1" (expand refs)
                      (("1"
                        (case-replace
                         "refcountArray(copied)(newref) = 0")
                        (("1"
                          (case-replace
                           "refcountStack(nnstack)(newref) = 0")
                          (("1" (assert)
                            (("1" (expand refcountStore)
                              (("1"
                                (expand allcount)
                                (("1"
                                  (rewrite sigma_zero)
                                  (("1"
                                    (skeep* :preds? t)
                                    (("1"
                                      (expand refcountArray)
                                      (("1"
                                        (rewrite count_none_zero)
                                        (("1"
                                          (skeep* :preds? t)
                                          (("1"
                                            (case-replace "x = newref")
                                            (("1"
                                              (typepred
                                               "grS`store(oldref)`seq(i)")
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (typepred
                                               "grS`store(x)`seq(i)")
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil)
                                               ("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand refcountStack)
                            (("2" (rewrite count_none_zero)
                              (("2"
                                (skeep* :preds? t)
                                (("2"
                                  (typepred nnstack)
                                  (("2"
                                    (expand every)
                                    (("2"
                                      (inst?)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand refcountArray 1)
                          (("2" (rewrite count_none_zero)
                            (("2" (skeep :preds? t)
                              (("2"
                                (typepred "grS`store(oldref)`seq(i)")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "nncount(x1)")
              (("2" (rewrite -1)
                (("2" (expand refcount)
                  (("2" (expand refcountExpr)
                    (("2" (expand refs)
                      (("2" (assert)
                        (("2" (expand refcountStore +)
                          (("2" (expand allcount)
                            (("2" (lemma sigma_add)
                              (("2"
                                (inst -1 newdomain _ newref)
                                (("2"
                                  (inst?)
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (rewrite -1)
                                      (("1"
                                        (case "newdomain(newref)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (case-replace
                                             "nstore(newref) = copied")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (case-replace
                                                 "remove(newref, newdomain) = grS`domain")
                                                (("1"
                                                  (use sigma_eq)
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (skeep*
                                                       :preds?
                                                       t)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (case
                                                           "newdomain(x)")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but (1 -))
                                                  (("2"
                                                    (replace*)
                                                    (("2"
                                                      (rewrite
                                                       remove_add_member
                                                       +)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sigma_eq formula-decl nil finite_set_theorems nil)
    (remove_add_member formula-decl nil sets_lemmas nil)
    (sigma_add formula-decl nil finite_set_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (refcountArray const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_none_zero formula-decl nil finseq_theorems nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (injective? const-decl "bool" functions nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (remove const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (remove_preserves_bounded application-judgement
     "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     countability "sets_aux/")
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (below type-eq-decl nil naturalnumbers nil)
    (sigma_zero formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (refcountStore const-decl "nat" rreduction nil)
    (refcountStack const-decl "nat" rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (count_copy_def formula-decl nil rreduction nil))
   nil
   (updateReduce subtype "rreduction.nstore"
    "reduction.Store(rreduction.newdomain)")))
 (updateReduce_TCC17 0
  (updateReduce_TCC17-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "IExpression_adt.value(rreduction.lval)"
    "naturalnumbers.below(rreduction.nstore(rreduction.newref)`length)")))
 (updateReduce_TCC18 0
  (updateReduce_TCC18-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.rval"
    "(IL.domainValue?(rreduction.newdomain))")))
 (updateReduce_TCC19 0
  (updateReduce_TCC19-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil))
   nil
   (updateReduce subtype "rreduction.nnstack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.newdomain))(S)}")))
 (updateReduce_TCC20 0
  (updateReduce_TCC20-2 "" 3714550945
   ("" (skeep* :preds? t)
    (("" (split +)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep)
        (("3" (typepred "grS`redex")
          (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil))
        nil)
       ("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (refs def-decl "bool" IL nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (updateReduce subtype "IExpression_adt.ref(rreduction.newref)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (updateReduce_TCC20-1 nil 3714529219 ("" (subtype-tcc) nil nil) nil
   nil
   (updateReduce subtype "IExpression_adt.ref(rreduction.newref)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (updateReduce_TCC21 0
  (updateReduce_TCC21-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (inst?)
          (("1"
            (typepred
             "maybe_clear_stack_at(grS`domain, grS`store, nstack, expr, ncount,
                            target(expr))")
            (("1"
              (typepred
               "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))")
              (("1" (inst -1 i)
                (("1" (inst -2 i)
                  (("1" (replace* -34 -39 :dir RL)
                    (("1" (assert)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (split -)
                                  (("1"
                                    (expand cvars -)
                                    (("1"
                                      (expand vars -)
                                      (("1"
                                        (expand add -1)
                                        (("1"
                                          (expand member)
                                          (("1"
                                            (typepred "grS`redex")
                                            (("1"
                                              (expand mark -)
                                              (("1"
                                                (decompose-equality -6)
                                                (("1"
                                                  (expand popDepth +)
                                                  (("1"
                                                    (expand bumpn)
                                                    (("1"
                                                      (case-replace
                                                       "i=index(rhs(grS`redex))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (replace -32)
                                                          (("1"
                                                            (replace
                                                             -4
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        (("2"
                                                          (case-replace
                                                           "i = index(lhs(grS`redex))")
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (replace
                                                             -32)
                                                            (("2"
                                                              (replace
                                                               -1
                                                               :dir
                                                               RL)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((noDanglingRefs? const-decl "bool" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i skolem-const-decl "below(nnstack`length)" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnstack skolem-const-decl "{newStack: Stack |
   every(domainValue?(grS`domain))(newStack) AND
    newStack`length = nstack`length}" rreduction nil)
    (nstack skolem-const-decl "{newStack: Stack |
   every(domainValue?(grS`domain))(newStack) AND
    newStack`length = stack`length}" rreduction nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (grS skolem-const-decl
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (get const-decl "(value?)" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype
    "rreduction.grS WITH [`redex := IExpression_adt.ref(rreduction.newref), `domain := rreduction.newdomain, `store := rreduction.nnstore, `count := rreduction.nnnncount, `stack := rreduction.nnstack]"
    "(rreduction.noDanglingRefs?)")))
 (updateReduce_TCC22 0
  (updateReduce_TCC22-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "IExpression_adt.value(rreduction.lval)"
    "below[grS`store(oldref)`length]")))
 (updateReduce_TCC23 0
  (updateReduce_TCC23-1 nil 3714529219 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.oldref"
    "(rreduction.grS`domain)")))
 (updateReduce_TCC24 0
  (updateReduce_TCC24-1 nil 3714529219 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(IExpression_adt.target(rreduction.expr)))"
    "below[nstack`length]")))
 (updateReduce_TCC25 0
  (updateReduce_TCC25-1 nil 3714529219 ("" (subtype-tcc) nil nil)
   ((get const-decl "(value?)" IL nil)
    (value? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (updateReduce subtype "IExpression_adt.nil" "(IL.value?)")))
 (updateReduce_TCC26 0
  (updateReduce_TCC26-1 nil 3706028126 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil))
   nil
   (updateReduce subtype
    "rreduction.nstack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(IExpression_adt.target(rreduction.expr)))) := IExpression_adt.nil]"
    "{S: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S), S`length = rreduction.stack`length)}")))
 (updateReduce_TCC27 0
  (updateReduce_TCC27-1 nil 3699369652
   ("" (skeep* :preds? t)
    (("" (replace -32)
      (("" (replace -36)
        (("" (expand refcount)
          (("" (expand refcountStack)
            (("" (rewrite count_update)
              (("1" (replace -33)
                (("1" (expand maybe_clear_stack_at +)
                  (("1" (assert)
                    (("1" (typepred "grS`count(x1)")
                      (("1" (expand refcount)
                        (("1" (assert)
                          (("1" (expand get)
                            (("1" (assert)
                              (("1"
                                (case-replace "marked(rhs(expr))")
                                (("1"
                                  (assert)
                                  (("1"
                                    (case-replace
                                     "ref?((stack`seq(stack`length - 1 - index(rhs(expr)))))")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (rewrite count_update)
                                        (("1"
                                          (replace -25)
                                          (("1"
                                            (case-replace
                                             "x1 = refindex(aval)")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (case-replace
                                                 "refindex(rval) = refindex(aval)")
                                                (("1"
                                                  (hide-all-but
                                                   (-1 3 -3 -31 -35))
                                                  (("1"
                                                    (replace
                                                     -4
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (hide -4)
                                                      (("1"
                                                        (case-replace
                                                         "rval = ref(refindex(rval))")
                                                        (("1"
                                                          (grind-with-ext)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (grind-with-ext)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  (("2"
                                                    (replace -4)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (expand
                                                         refcountStack)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (case-replace
                                                 "x1 = refindex(rval)")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (replace -2)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (expand refcountStack)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (replace -24)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (replace -26)
                                                    (("2"
                                                      (hide-all-but
                                                       (5 -28))
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (rewrite -1)
                                    (("2"
                                      (expand refcountStack)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replace -22)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (hide-all-but
                                               (5 -24 -26))
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcount const-decl "nat" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (count_update formula-decl nil finseq_theorems nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (value? const-decl "bool" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (refcountStore const-decl "nat" rreduction nil)
    (allcount const-decl "nat" rreduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (refcountArray const-decl "nat" rreduction nil)
    (count const-decl "nat" finseq_theorems nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (IExpression_ref_extensionality formula-decl nil IExpression_adt
     nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (get const-decl "(value?)" IL nil)
    (refcountStack const-decl "nat" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.ncount"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.nnstack, rreduction.aval)(i)}]"))
  (updateReduce_TCC27-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (typepred "ncount(x1)")
      (("" (rewrite -1)
        (("" (expand refcount)
          (("" (expand refcountExpr)
            (("" (assert)
              (("" (expand refs)
                (("" (lift-if)
                  (("" (split)
                    (("1" (flatten)
                      (("1" (replace -1)
                        (("1" (expand refcountStack)
                          (("1" (replace -37)
                            (("1" (rewrite count_update)
                              (("1"
                                (case-replace
                                 "nstack`seq(stack`length-1-index(target(expr))) = aval")
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (expand refcountStack)
                        (("2" (replace -36)
                          (("2" (rewrite count_update)
                            (("1"
                              (case-replace
                               "nstack`seq(stack`length - 1 - index(target(expr))) = aval")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (refcountExpr const-decl "nat" rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (count const-decl "nat" finseq_theorems nil)
    (count def-decl "nat" finseq_theorems nil)
    (finseqtolist def-decl "list[T]" finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (head const-decl "T" finseq_theorems nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (count_update formula-decl nil finseq_theorems nil)
    (refcountStack const-decl "nat" rreduction nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil))
   nil
   (updateReduce subtype "rreduction.ncount"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.nnstack, rreduction.aval)(i)}]")))
 (updateReduce_TCC28 0
  (updateReduce_TCC28-3 "" 3714803882
   ("" (skeep* :preds? t)
    (("" (split +)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skeep)
        (("3" (typepred "grS`redex")
          (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil))
        nil)
       ("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (value? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (popDepth def-decl "nat" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (refs def-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (markv const-decl "(variable?)" preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (updateReduce subtype "rreduction.aval"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (updateReduce_TCC28-2 "" 3714551441
   ("" (skeep* :preds? t)
    (("" (lemma decref1_chk_ndr)
      (("" (inst?) (("" (postpone) nil nil)) nil)) nil))
    nil)
   nil shostak
   (updateReduce subtype "rreduction.aval"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (updateReduce_TCC28-1 nil 3714529219 ("" (subtype-tcc) nil nil) nil
   nil
   (updateReduce subtype "rreduction.aval"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (updateReduce_TCC29 0
  (updateReduce_TCC29-1 nil 3706028126
   ("" (skeep* :preds? t)
    (("" (lemma decref1_chk_ndr)
      (("" (inst?)
        (("1" (hide 5)
          (("1" (expand noDanglingRefs?)
            (("1" (skeep* :preds? t)
              (("1" (assert)
                (("1" (expand popDepth)
                  (("1" (expand bumpn)
                    (("1" (inst?)
                      (("1"
                        (typepred
                         "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))")
                        (("1" (inst -1 i)
                          (("1" (replace -35 :dir RL)
                            (("1" (assert)
                              (("1"
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (split -)
                                    (("1"
                                      (typepred "grS`redex")
                                      (("1"
                                        (replace -31)
                                        (("1"
                                          (replace -6 + :dir RL)
                                          (("1"
                                            (case-replace
                                             "i = index(rhs(grS`redex))")
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (case-replace
                                               "i = index(lhs(grS`redex))")
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (case-replace
                                                 "i = index(target(grS`redex))")
                                                (("1" (grind) nil nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (replace -37)
                                  (("2"
                                    (split)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lift-if)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 5)
          (("2" (split)
            (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil))
              nil)
             ("2" (skeep) (("2" (assert) (("2" (grind) nil nil)) nil))
              nil)
             ("3" (skeep)
              (("3" (typepred "grS`redex")
                (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil))
              nil)
             ("4" (assert)
              (("4" (typepred "grS`redex") (("4" (grind) nil nil))
                nil))
              nil)
             ("5" (grind) nil nil) ("6" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((decref1_chk_ndr judgement-tcc nil rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (newstore skolem-const-decl "Store(grS`domain)" rreduction nil)
    (nncount skolem-const-decl "[i: (grS`domain) ->
   {j | j = refcount(grS`domain, newstore, nnstack, aval)(i)}]"
     rreduction nil)
    (grS skolem-const-decl
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     rreduction nil)
    (aval skolem-const-decl "(domainValue?(grS`domain))" rreduction
     nil)
    (stack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil)
    (nnstack skolem-const-decl
     "{S: Stack | every(domainValue?(grS`domain))(S) AND S`length = stack`length}"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype
    "rreduction.decref1_chk(rreduction.grS WITH [`redex := rreduction.aval, `store := rreduction.newstore, `stack := rreduction.nnstack, `count := rreduction.nncount], rreduction.oldvalue)"
    "(rreduction.noDanglingRefs?)")))
 (updateReduce_TCC30 0
  (updateReduce_TCC30-1 nil 3699369652 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce subtype "rreduction.grS WITH [error := booleans.TRUE]"
    "(rreduction.noDanglingRefs?)")))
 (variableReduce_ndr 0
  (variableReduce_ndr-1 nil 3705848866
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (inst -2 i)
          (("1" (expand variableReduce)
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (case-replace
                   "popDepth(get(grS`stack)(grS`redex)) = 0")
                  (("1" (expand bumpn)
                    (("1" (case-replace "popDepth(grS`redex) = 0")
                      (("1" (assert)
                        (("1" (grind)
                          (("1" (typepred "grS`redex")
                            (("1" (expand mark)
                              (("1"
                                (expand markv)
                                (("1"
                                  (replace -6 2 :dir RL)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (typepred "get(grS`stack)(grS`redex)")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand variableReduce) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i skolem-const-decl "below(variableReduce(D)(grS)`stack`length)"
       rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND variable?(grS`redex)}" rreduction
     nil)
    (D skolem-const-decl "Defs" rreduction nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (variableReduce_ndr subtype
    "rreduction.variableReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (letReduce_ndr 0
  (letReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand push)
        (("" (expand add)
          (("" (expand noDanglingRefs?)
            (("" (skeep :preds? t)
              (("" (lift-if)
                (("" (split)
                  (("1" (flatten)
                    (("1" (case-replace "i = 0")
                      (("1" (typepred "grS`redex")
                        (("1" (expand cvars 2)
                          (("1" (rewrite cvars_pure 2)
                            (("1" (replace -6 2 :dir RL)
                              (("1"
                                (expand* pureLetRedex? letRedex?)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand mark +)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (inst -3 "i-1")
                      (("1" (assert)
                        (("1" (expand cvars 3 1)
                          (("1" (expand popDepth +)
                            (("1" (rewrite purePopDepth +)
                              (("1"
                                (case-replace
                                 "popDepth(grS`redex) = 0")
                                (("1"
                                  (expand bumpn)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand pureLetRedex?)
                                      (("1"
                                        (expand letRedex?)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand cvars -)
                                              (("1"
                                                (expand union)
                                                (("1"
                                                  (expand member)
                                                  (("1"
                                                    (split)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (expand*
                                                       bumpn
                                                       drop)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (rewrite
                                                           cvars_pure)
                                                          (("2"
                                                            (case-replace
                                                             "popDepth(letrhs(grS`redex)) = 0")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cvars_pure formula-decl nil preprocess nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (i skolem-const-decl "below(1 + grS`stack`length)" rreduction nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND pureLetRedex?(grS`redex)}"
     rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (purePopDepth formula-decl nil IL nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (union const-decl "set" sets nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (push const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (letReduce_ndr subtype
    "rreduction.letReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (applyReduce_ndr 0
  (applyReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand applyReduce)
          (("" (simplify)
            (("" (inst -2 i)
              (("" (split -2)
                (("1" (delete 3)
                  (("1" (ground)
                    (("1" (rewrite cvars_pure)
                      (("1" (rewrite vars_letApply)
                        (("1" (rewrite vars_mark)
                          (("1" (expand applyRedex?)
                            (("1"
                              (case-replace
                               "grS`redex = application(fun(grS`redex), args(grS`redex))")
                              (("1"
                                (expand cvars -4)
                                (("1"
                                  (expand vars -4)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind-with-ext) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use pure_letApply)
                        (("2" (use pure_mark)
                          (("2" (typepred "D`seq(fun(grS`redex))`body")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (case-replace "popDepth(grS`redex) = 0")
                    (("1" (rewrite purePopDepth 2)
                      (("1" (simplify) (("1" (propax) nil nil)) nil)
                       ("2" (use pure_letApply)
                        (("2" (use pure_mark)
                          (("2" (typepred "D`seq(fun(grS`redex))`body")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("3" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (i skolem-const-decl "below(applyReduce(D)(grS)`stack`length)"
       rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND applyRedex?(grS`redex)}"
     rreduction nil)
    (D skolem-const-decl "Defs" rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (purePopDepth formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (letApply def-decl "IExpression" rreduction nil)
    (length def-decl "nat" list_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (cvars_pure formula-decl nil preprocess nil)
    (vars_mark formula-decl nil preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars_letApply formula-decl nil rreduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (applyReduce_ndr subtype
    "rreduction.applyReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (ifReduce_ndr 0
  (ifReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (expand noDanglingRefs?)
        (("" (simplify)
          (("" (ground)
            (("1" (skeep* :preds? t)
              (("1" (inst -4 i)
                (("1" (expand release_marked)
                  (("1" (simplify)
                    (("1" (split -4)
                      (("1" (typepred "grS`redex")
                        (("1" (delete -1 -2 -3 -4 -5)
                          (("1"
                            (case-replace
                             "grS`redex = ift(condition(grS`redex), thenexpr(grS`redex), elseexpr(grS`redex))")
                            (("1" (expand mark -2)
                              (("1"
                                (simplify)
                                (("1"
                                  (decompose-equality -2)
                                  (("1"
                                    (expand cvars -5)
                                    (("1"
                                      (expand vars -5)
                                      (("1"
                                        (expand cvars 1 1)
                                        (("1"
                                          (rewrite cvars_pure 1)
                                          (("1"
                                            (expand add 1)
                                            (("1"
                                              (expand member 1)
                                              (("1"
                                                (expand popDepth 2 1)
                                                (("1"
                                                  (rewrite
                                                   purePopDepth
                                                   2)
                                                  (("1"
                                                    (expand bumpn)
                                                    (("1"
                                                      (case
                                                       "vars(elseexpr(grS`redex))(i)")
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (replace
                                                         -3
                                                         1
                                                         :dir
                                                         RL)
                                                        (("2"
                                                          (rewrite
                                                           vars_release_set)
                                                          (("2"
                                                            (rewrite
                                                             vars_mark)
                                                            (("2"
                                                              (expand
                                                               union
                                                               1)
                                                              (("2"
                                                                (expand
                                                                 difference
                                                                 1)
                                                                (("2"
                                                                  (expand
                                                                   member
                                                                   1)
                                                                  (("2"
                                                                    (expand
                                                                     add
                                                                     -5)
                                                                    (("2"
                                                                      (expand
                                                                       union
                                                                       -5)
                                                                      (("2"
                                                                        (expand
                                                                         member)
                                                                        (("2"
                                                                          (split
                                                                           -5)
                                                                          (("1"
                                                                            (expand
                                                                             markv
                                                                             -2)
                                                                            (("1"
                                                                              (expand
                                                                               union
                                                                               -2)
                                                                              (("1"
                                                                                (expand
                                                                                 member)
                                                                                (("1"
                                                                                  (replace
                                                                                   -2
                                                                                   2
                                                                                   :dir
                                                                                   RL)
                                                                                  (("1"
                                                                                    (simplify)
                                                                                    (("1"
                                                                                      (simplify)
                                                                                      (("1"
                                                                                        (lift-if
                                                                                         2)
                                                                                        (("1"
                                                                                          (grind)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil
                                                                            nil)
                                                                           ("3"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind-with-ext) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand popDepth 2 1)
                        (("2" (rewrite purePopDepth 2)
                          (("1" (rewrite purePopDepth -1)
                            (("1" (grind) nil nil)) nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (skeep* :preds? t)
              (("2" (expand release_marked 2)
                (("2" (expand cvars 2 1)
                  (("2" (rewrite cvars_pure 2)
                    (("1" (expand release_marked 3)
                      (("1" (simplify)
                        (("1" (expand popDepth 3 1)
                          (("1" (rewrite purePopDepth 3)
                            (("1" (inst -3 i)
                              (("1"
                                (rewrite purePopDepth -3)
                                (("1"
                                  (expand release_marked -2)
                                  (("1"
                                    (simplify)
                                    (("1"
                                      (expand bumpn)
                                      (("1"
                                        (expand add 2)
                                        (("1"
                                          (expand member)
                                          (("1"
                                            (expand release_marked -1)
                                            (("1"
                                              (simplify)
                                              (("1"
                                                (split -3)
                                                (("1"
                                                  (typepred
                                                   "grS`redex")
                                                  (("1"
                                                    (delete
                                                     -1
                                                     -2
                                                     -3
                                                     -4
                                                     -5)
                                                    (("1"
                                                      (case-replace
                                                       "grS`redex = ift(condition(grS`redex), thenexpr(grS`redex), elseexpr(grS`redex))")
                                                      (("1"
                                                        (simplify)
                                                        (("1"
                                                          (expand
                                                           mark
                                                           -2)
                                                          (("1"
                                                            (decompose-equality
                                                             -2)
                                                            (("1"
                                                              (case
                                                               "vars(thenexpr(grS`redex))(i)")
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (replace
                                                                 -2
                                                                 1
                                                                 :dir
                                                                 RL)
                                                                (("2"
                                                                  (rewrite
                                                                   vars_release_set)
                                                                  (("2"
                                                                    (rewrite
                                                                     vars_mark)
                                                                    (("2"
                                                                      (expand
                                                                       union
                                                                       1)
                                                                      (("2"
                                                                        (expand
                                                                         difference
                                                                         1)
                                                                        (("2"
                                                                          (expand
                                                                           member)
                                                                          (("2"
                                                                            (expand
                                                                             cvars
                                                                             -5)
                                                                            (("2"
                                                                              (expand
                                                                               vars
                                                                               -5)
                                                                              (("2"
                                                                                (expand
                                                                                 add
                                                                                 -5)
                                                                                (("2"
                                                                                  (expand
                                                                                   union
                                                                                   -5)
                                                                                  (("2"
                                                                                    (expand
                                                                                     member)
                                                                                    (("2"
                                                                                      (split
                                                                                       -5)
                                                                                      (("1"
                                                                                        (replace
                                                                                         -2
                                                                                         3
                                                                                         :dir
                                                                                         RL)
                                                                                        (("1"
                                                                                          (expand
                                                                                           markv)
                                                                                          (("1"
                                                                                            (lift-if
                                                                                             3)
                                                                                            (("1"
                                                                                              (expand
                                                                                               union
                                                                                               3)
                                                                                              (("1"
                                                                                                (expand
                                                                                                 member)
                                                                                                (("1"
                                                                                                  (grind)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil)
                                                                                       ("3"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind-with-ext)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (propax) nil nil)
                                                 ("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but (1 -4))
                                  (("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "rstate" rreduction nil)
    (i skolem-const-decl
       "below(release_marked(grS WITH [`redex := thenexpr(grS`redex)])
                    (condition(grS`redex))`stack`length)" rreduction
       nil)
    (IExpression_ift_extensionality formula-decl nil IExpression_adt
     nil)
    (difference const-decl "set" sets nil)
    (release_set def-decl "IExpression" preprocess nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (purePopDepth formula-decl nil IL nil)
    (vars_release_set formula-decl nil preprocess nil)
    (get const-decl "(value?)" IL nil)
    (empty? const-decl "bool" sets nil)
    (vars_mark formula-decl nil preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (release_marked const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND pureIftRedex?(grS`redex)}"
     rreduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl
       "below(release_marked(grS WITH [`redex := elseexpr(grS`redex)])
                    (condition(grS`redex))`stack`length)" rreduction
       nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (ifReduce_ndr subtype
    "rreduction.ifReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (lookupReduce_ndr 0
  (lookupReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (split 2)
        (("1" (flatten)
          (("1" (expand noDanglingRefs?)
            (("1" (skeep* :preds? t)
              (("1" (inst -8 i)
                (("1" (split -8)
                  (("1" (expand release_marked 1)
                    (("1" (expand cvars 1 1)
                      (("1" (expand setRedex 1)
                        (("1" (simplify)
                          (("1" (expand release_marked 2)
                            (("1" (expand popDepth 2 1)
                              (("1"
                                (expand setRedex 2)
                                (("1"
                                  (simplify)
                                  (("1"
                                    (case-replace
                                     "popDepth(grS`store
                         (refindex(get(grS`stack)
                                      (arrayvalue(grS`redex))))`seq
                         (value(get(grS`stack)(position(grS`redex))))) = 0")
                                    (("1"
                                      (expand bumpn)
                                      (("1"
                                        (expand release_marked -9)
                                        (("1"
                                          (simplify)
                                          (("1"
                                            (expand setRedex -9)
                                            (("1"
                                              (simplify)
                                              (("1"
                                                (typepred "grS`redex")
                                                (("1"
                                                  (delete
                                                   -1
                                                   -2
                                                   -3
                                                   -4
                                                   -5)
                                                  (("1"
                                                    (case-replace
                                                     "grS`redex = lookup(arrayvalue(grS`redex), position(grS`redex))")
                                                    (("1"
                                                      (simplify)
                                                      (("1"
                                                        (expand
                                                         mark
                                                         -2)
                                                        (("1"
                                                          (decompose-equality
                                                           -2)
                                                          (("1"
                                                            (replace
                                                             -1
                                                             1
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (expand
                                                               markv)
                                                              (("1"
                                                                (lift-if
                                                                 1)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (grind-with-ext)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (typepred
                                       "grS`store
                   (refindex(get(grS`stack)(arrayvalue(grS`redex))))`seq
                   (value(get(grS`stack)(position(grS`redex))))")
                                      (("1"
                                        (hide-all-but (1 -1))
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand release_marked 2)
                    (("2" (expand popDepth 2 1)
                      (("2" (expand setRedex 2)
                        (("2" (simplify)
                          (("2"
                            (typepred "grS`store
                         (refindex(get(grS`stack)
                                      (arrayvalue(grS`redex))))`seq
                         (value(get(grS`stack)(position(grS`redex))))")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (delete 2 3)
                    (("3" (expand release_marked -7)
                      (("3" (expand setRedex -7)
                        (("3" (simplify) (("3" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 2 3)
                  (("2" (expand release_marked -1)
                    (("2" (expand setRedex -1)
                      (("2" (simplify) (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "rstate" rreduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (IExpression_lookup_extensionality formula-decl nil IExpression_adt
     nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (release_marked const-decl "rstate" rreduction nil)
    (pure? def-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND lookupRedex?(grS`redex)}"
     rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "below(release_marked(setRedex(grS,
                              grS`store
                                  (refindex(get
                                            (grS`stack)
                                            (arrayvalue(grS`redex))))`seq
                                  (value(get
                                         (grS`stack)
                                         (position(grS`redex))))))
                    (arrayvalue(grS`redex))`stack`length)" rreduction
       nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (lookupReduce_ndr subtype
    "rreduction.lookupReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (newintReduce_ndr 0
  (newintReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      (("" (expand noDanglingRefs?) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((newintReduce const-decl "rstate" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (emptyset const-decl "set" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newintReduce_ndr subtype
    "rreduction.newintReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (newrefReduce_ndr 0
  (newrefReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce) (("" (grind) nil nil)) nil)) nil)
   ((newrefReduce const-decl "rstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (popDepth def-decl "nat" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (newrefReduce_ndr subtype
    "rreduction.newrefReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (popReduce_ndr 0
  (popReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (skeep* :preds? t)
        (("" (expand popReduce)
          (("" (expand pop)
            (("" (inst -2 "i+1")
              (("1" (assert)
                (("1" (expand popRedex?)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand cvars -2 1)
                        (("1" (split)
                          (("1" (grind) nil nil)
                           ("2" (expand bumpn)
                            (("2"
                              (case-replace "popDepth(grS`redex) = 1")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(popReduce(D)(grS)`stack`length)"
       rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (grS skolem-const-decl
     "{grS | noDanglingRefs?(grS) AND popRedex?(grS`redex)}" rreduction
     nil)
    (D skolem-const-decl "Defs" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (popReduce_ndr subtype
    "rreduction.popReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (releaseReduce_ndr 0
  (releaseReduce_ndr-1 nil 3699648459
   ("" (skeep* :preds? t)
    (("" (expand releaseReduce)
      (("" (split 2)
        (("1" (bash) nil nil)
         ("2" (flatten)
          (("2" (expand noDanglingRefs?)
            (("2" (skeep* :preds? t)
              (("2" (inst -3 i) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (releaseRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce_ndr subtype
    "rreduction.releaseReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (make_redex_TCC1 0
  (make_redex_TCC1-1 nil 3701197360
   ("" (skeep)
    (("" (split)
      (("1" (grind)
        (("1" (typepred "t`redex")
          (("1" (typepred "buildRedex(t`redex)")
            (("1" (replace -1 - :dir RL)
              (("1" (rewrite contextPurefill) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (typepred "t`redex")
        (("2" (typepred "buildRedex(t`redex)")
          (("2" (replace -1 - :dir RL)
            (("2" (rewrite mark_fill)
              (("2" (lemma fill_mark_inj)
                (("2" (inst?)
                  (("2" (split -1)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (contextPurefill formula-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (mark_fill formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (fill_mark_inj formula-decl nil preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex subtype "rreduction.ctx"
    "{K | booleans.AND(IL.cpure?(rreduction.K), preprocess.markc(sets[naturalnumbers.nat].emptyset)(rreduction.K) = rreduction.K)}")))
 (make_redex_TCC2 0
  (make_redex_TCC2-1 nil 3701197360
   ("" (with-labels (skeep :preds? t) ((ttop rdef cdef obj)))
    (("" (rewrite rdef)
      (("" (rewrite cdef)
        ((""
          (with-labels (typepred "t`redex")
           ((href hvar hcvar hsl hcp hmark)))
          ((""
            (with-labels (typepred "buildRedex(t`redex)")
             ((hfill hpurered)))
            (("" (replace hfill - :dir RL)
              (("" (rewrite popdepth_fill)
                (("" (rewrite refs_fill)
                  (("" (rewrite contextPurefill)
                    (("" (rewrite mark_fill)
                      (("" (use fill_mark_inj)
                        (("" (split obj)
                          (("1" (propax) nil nil)
                           ("2" (skeep)
                            (("2"
                              (inst hvar
                               "i - popDepth(buildRedex(t`redex)`1)")
                              (("1"
                                (rewrite vars_decompose)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("3" (skeep)
                            (("3" (inst hvar i)
                              (("3"
                                (rewrite vars_decompose)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (grind) nil nil) ("5" (grind) nil nil)
                           ("6" (split -1)
                            (("1" (hide-all-but (obj ttop -1))
                              (("1"
                                (case-replace
                                 "union(cvars(buildRedex(t`redex)`1),
                   bumpn(cvars(t`context),
                         popDepth(buildRedex(t`redex)`1))) = cvars(buildRedex(t`redex)`1)")
                                (("1" (grind) nil nil)
                                 ("2" (grind-with-ext) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (refs_fill formula-decl nil IL nil)
    (mark_fill formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" rreduction nil)
    (t skolem-const-decl "{t: rtopstate | NOT value?(t`redex)}"
     rreduction nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_decompose formula-decl nil IL nil)
    (member const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (fill_mark_inj formula-decl nil preprocess nil)
    (contextPurefill formula-decl nil IL nil)
    (popdepth_fill formula-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex subtype "rreduction.redex"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.t`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.t`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.ctx)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.ctx)), rreduction.t`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.ctx)), rreduction.t`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.ctx))(rreduction.A) = rreduction.A)}")))
 (make_redex_TCC3 0
  (make_redex_TCC3-1 nil 3701197360
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "t`count(x1)")
        (("" (rewrite -1)
          (("" (expand refcount)
            (("" (expand refcountExpr)
              (("" (typepred "buildRedex(t`redex)")
                (("" (replace -1 1 :dir RL)
                  (("" (rewrite refs_fill) (("" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((refcountExpr const-decl "nat" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (refs_fill formula-decl nil IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex subtype "(rreduction.t:: rreduction.rstate)`count"
    "[i: (rreduction.t`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.t`domain, rreduction.t`store, rreduction.t`stack, rreduction.redex)(i)}]")))
 (make_redex_TCC4 0
  (make_redex_TCC4-1 nil 3701197360
   ("" (skeep :preds? t)
    (("" (typepred "buildRedex(t`redex)") (("" (grind) nil nil)) nil))
    nil)
   ((pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex subtype
    "(rreduction.t:: rreduction.rstate) WITH [`context := rreduction.ctx, `redex := rreduction.redex]"
    "{rS | IL.pureRedex?(rreduction.rS`redex)}")))
 (to_topstate_make_redex 0
  (to_topstate_make_redex-1 nil 3706457889
   ("" (skeep* :preds? t)
    (("" (decompose-equality 2)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil)
       ("4" (expand* to_topstate make_redex)
        (("4" (typepred "buildRedex(t`redex)") (("4" (propax) nil nil))
          nil))
        nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (make_redex_idem_TCC1 0
  (make_redex_idem_TCC1-1 nil 3701442113 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_idem subtype
    "rreduction.to_topstate(rreduction.make_redex(rreduction.t))"
    "{t: rreduction.rtopstate | }")))
 (make_redex_idem 0
  (make_redex_idem-1 nil 3701442114
   ("" (skeep :preds? t)
    (("" (expand make_redex)
      (("" (expand to_topstate)
        (("" (typepred "buildRedex(t`redex)")
          (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (make_redex_ndr 0
  (make_redex_ndr-1 nil 3701197360
   ("" (skeep :preds? t)
    (("" (expand noDanglingRefs?)
      (("" (expand make_redex)
        (("" (skeep)
          (("" (inst?)
            (("1" (assert)
              (("1" (typepred "buildRedex(t`redex)")
                (("1" (replace -1 - :dir RL)
                  (("1" (rewrite cvars_fill) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred i) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (cvars_fill formula-decl nil preprocess nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (t skolem-const-decl
     "{t: rtopstate | noDanglingRefs?(t) AND NOT value?(t`redex)}"
     rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "below(make_redex(t)`stack`length)" rreduction
       nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_ndr subtype "rreduction.make_redex(rreduction.t)"
    "(rreduction.noDanglingRefs?)")))
 (reduce_TCC1 0
  (reduce_TCC1-1 nil 3699648459
   ("" (skeep)
    (("" (lemma make_redex_ndr)
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((make_redex_ndr judgement-tcc nil rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (t skolem-const-decl "rtopstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.make_redex(rreduction.t)"
     "(rreduction.noDanglingRefs?)")))
 (reduce_TCC2 0
  (reduce_TCC2-1 nil 3699648459
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IExpression_adt.variable?(rreduction.grS`redex)}")))
 (reduce_TCC3 0
  (reduce_TCC3-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IL.pureLetRedex?(rreduction.grS`redex)}")))
 (reduce_TCC4 0
  (reduce_TCC4-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IL.applyRedex?(rreduction.grS`redex)}")))
 (reduce_TCC5 0
  (reduce_TCC5-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))
 (reduce_TCC6 0
  (reduce_TCC6-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | booleans.AND(IL.updateRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (reduce_TCC7 0
  (reduce_TCC7-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))
 (reduce_TCC8 0
  (reduce_TCC8-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IL.newintRedex?(rreduction.grS`redex)}")))
 (reduce_TCC9 0
  (reduce_TCC9-1 nil 3699648459
   ("" (skeep :preds? t) (("" (grind) nil nil)) nil)
   ((rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))
 (reduce_TCC10 0
  (reduce_TCC10-1 nil 3699648459
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (case "pureRedex?(nS`redex)")
        (("1" (grind) nil nil)
         ("2" (typepred "make_redex(t)") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | booleans.AND(IL.popRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (reduce_TCC11 0
  (reduce_TCC11-1 nil 3705848866
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (case "pureRedex?(nS`redex)")
        (("1" (grind) nil nil)
         ("2" (typepred "make_redex(t)") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reduce subtype "rreduction.nS"
     "{grS | booleans.AND(IL.pureReleaseRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (reduce_ndr 0
  (reduce_ndr-2 nil 3705860166
   ("" (skeep :preds? t)
    (("" (expand reduce)
      (("" (case "noDanglingRefs?(to_topstate(grS))")
        (("1" (split)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2"
              (case "noDanglingRefs?(make_redex(to_topstate(grS)))")
              (("1" (name-replace rS "make_redex(to_topstate(grS))")
                (("1" (split)
                  (("1" (flatten)
                    (("1" (use variableReduce_ndr)
                      (("1" (split)
                        (("1" (propax) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (flatten)
                        (("1" (use letReduce_ndr)
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (use applyReduce_ndr)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (use ifReduce_ndr)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (typepred "updateReduce(D)(rS)")
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (use lookupReduce_ndr)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (use newintReduce_ndr)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (use
                                                   newrefReduce_ndr)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (use
                                                       popReduce_ndr)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (case
                                                       "pureReleaseRedex?(rS`redex)")
                                                      (("1"
                                                        (use
                                                         releaseReduce_ndr)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (case
                                                         "pureRedex?(rS`redex)")
                                                        (("1"
                                                          (expand
                                                           pureRedex?)
                                                          (("1"
                                                            (prop)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("3"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("4"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("5"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("6"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("7"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("8"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("9"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (expand rS)
                                                          (("2"
                                                            (typepred
                                                             "make_redex(to_topstate(grS))")
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma make_redex_ndr) (("2" (inst?) nil nil)) nil)
               ("3" (propax) nil nil))
              nil))
            nil))
          nil)
         ("2" (lemma to_topstate_dangling) (("2" (inst?) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (reduce const-decl "rstate" rreduction nil)
    (to_topstate_dangling judgement-tcc nil rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (pureRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (variableReduce_ndr judgement-tcc nil rreduction nil)
    (rS skolem-const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letReduce_ndr judgement-tcc nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (letReduce const-decl "rstate" rreduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (applyReduce_ndr judgement-tcc nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (ifReduce_ndr judgement-tcc nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (release_marked const-decl "rstate" rreduction nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (lookupReduce_ndr judgement-tcc nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintReduce_ndr judgement-tcc nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefReduce_ndr judgement-tcc nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popReduce_ndr judgement-tcc nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseReduce_ndr judgement-tcc nil rreduction nil)
    (grS skolem-const-decl "{grS | noDanglingRefs?(grS)}" rreduction
     nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil))
   nil
   (reduce_ndr subtype
    "rreduction.reduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (reduce_ndr-1 nil 3701438337
   ("" (skeep :preds? t)
    (("" (expand reduce)
      (("" (case "noDanglingRefs?(to_topstate(grS))")
        (("1" (split)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2"
              (case "noDanglingRefs?(make_redex(to_topstate(grS)))")
              (("1" (name-replace rS "make_redex(to_topstate(grS))")
                (("1" (split)
                  (("1" (flatten)
                    (("1" (use letReduce_ndr) (("1" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (flatten)
                        (("1" (use applyReduce_ndr)
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (use ifReduce_ndr)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (typepred "updateReduce(D)(rS)")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (use lookupReduce_ndr)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (use newintReduce_ndr)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (use newrefReduce_ndr)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (use popReduce_ndr)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (case
                                                   "pureReleaseRedex?(rS`redex)")
                                                  (("1"
                                                    (use
                                                     releaseReduce_ndr)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (case
                                                     "pureRedex?(rS`redex)")
                                                    (("1"
                                                      (expand
                                                       pureRedex?)
                                                      (("1"
                                                        (prop)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand rS)
                                                      (("2"
                                                        (typepred
                                                         "make_redex(to_topstate(grS))")
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (expand
                                                           to_topstate)
                                                          (("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand to_topstate) (("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (lemma make_redex_ndr)
                (("2" (inst?)
                  (("2" (split)
                    (("1" (propax) nil nil)
                     ("2" (expand to_topstate) (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (split)
                (("1" (propax) nil nil)
                 ("2" (expand to_topstate) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma to_topstate_dangling) (("2" (inst?) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (reduce const-decl "rstate" rreduction nil)
    (to_topstate_dangling judgement-tcc nil rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (letReduce_ndr judgement-tcc nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyReduce_ndr judgement-tcc nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (ifReduce_ndr judgement-tcc nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (lookupReduce_ndr judgement-tcc nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintReduce_ndr judgement-tcc nil rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefReduce_ndr judgement-tcc nil rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popReduce_ndr judgement-tcc nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseReduce_ndr judgement-tcc nil rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil))
   nil
   (reduce_ndr subtype
    "rreduction.reduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))))

