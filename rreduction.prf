(|rreduction|
 (|refcountExpr_popit| 0
  (|refcountExpr_popit-1| NIL 3683904062
   ("" (SKEEP)
    (("" (EXPAND "refcountExpr") (("" (REWRITE "popit_refs") NIL NIL)) NIL))
    NIL)
   ((|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|popit_refs| FORMULA-DECL NIL |reduction| NIL))
   SHOSTAK))
 (|noDanglingRefs?_TCC1| 0
  (|noDanglingRefs?_TCC1-1| NIL 3698761342 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) NIL
   (|noDanglingRefs?| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.rS`stack`length, rreduction.i), 1)"
    "below[rS`stack`length]")))
 (|to_topstate_TCC1| 0
  (|to_topstate_TCC1-1| NIL 3699126721
   ("" (SUBTYPE-TCC) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
   ((|cpure?| DEF-DECL "bool" IL NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL))
   NIL
   (|to_topstate| SUBTYPE "IL.hole"
    "{K | booleans.AND(IL.cpure?(rreduction.K), preprocess.markc(sets[naturalnumbers.nat].emptyset)(rreduction.K) = rreduction.K)}")))
 (|to_topstate_TCC2| 0
  (|to_topstate_TCC2-1| NIL 3699126721
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (SKEEP*)
        (("1" (TYPEPRED "rS`context")
          (("1" (REWRITE REFS_FILL)
            (("1" (TYPEPRED "rS`redex") (("1" (GRIND) NIL NIL)) NIL)
             ("2" (TYPEPRED "rS`redex")
              (("2" (USE CONTEXTPUREFILL) (("2" (GRIND) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("2" (SKEEP*)
        (("2" (REWRITE VARS_DECOMPOSE)
          (("2" (TYPEPRED "rS`redex")
            (("2" (REWRITE POPDEPTH_FILL) (("2" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL)
       ("4" (REWRITE POPDEPTH_FILL)
        (("4" (TYPEPRED "rS`redex") (("4" (GRIND) NIL NIL)) NIL)) NIL)
       ("5" (REWRITE CONTEXTPUREFILL) NIL NIL)
       ("6" (REWRITE MARK_FILL)
        (("6" (EXPAND BUMPN)
          (("6" (EXPAND UNION)
            (("6" (EXPAND MEMBER)
              (("6" (TYPEPRED "rS`context")
                (("6" (EXPAND CVARS 1 1)
                  (("6" (REWRITE -2)
                    (("6" (EXPAND CVARS 1 2)
                      (("6" (EXPAND EMPTYSET)
                        (("6" (TYPEPRED "rS`redex")
                          (("6"
                            (CASE-REPLACE
                             "{x: nat | cvars(rS`context)(x)} = cvars(rS`context)")
                            (("1" (GRIND) NIL NIL)
                             ("2" (GRIND-WITH-EXT) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|contextPurefill| FORMULA-DECL NIL IL NIL)
    (|refs_fill| FORMULA-DECL NIL IL NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|vars_decompose| FORMULA-DECL NIL IL NIL)
    (|popdepth_fill| FORMULA-DECL NIL IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|mark_fill| FORMULA-DECL NIL |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|to_topstate| SUBTYPE "IL.fill(rreduction.rS`context, rreduction.rS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(IL.hole)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(IL.hole)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(IL.hole)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(IL.hole))(rreduction.A) = rreduction.A)}")))
 (|to_topstate_TCC3| 0
  (|to_topstate_TCC3-1| NIL 3699126721
   ("" (SKEEP*)
    (("" (TYPEPRED "rS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR)
            (("" (REWRITE REFS_FILL)
              (("" (USE CONTEXTPUREFILL)
                (("" (TYPEPRED "rS`context")
                  (("" (TYPEPRED "rS`redex") (("" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refs_fill| FORMULA-DECL NIL IL NIL)
    (|contextPurefill| FORMULA-DECL NIL IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|to_topstate| SUBTYPE "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, IL.fill(rreduction.rS`context, rreduction.rS`redex))(i)}]")))
 (|to_topstate_TCC4| 0
  (|to_topstate_TCC4-1| NIL 3699126721 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|to_topstate| SUBTYPE
    "rreduction.rS WITH [`context := IL.hole, `redex := IL.fill(rreduction.rS`context, rreduction.rS`redex)]"
    "rtopstate")))
 (|to_topstate_dangling| 0
  (|to_topstate_dangling-1| NIL 3699296735
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (EXPAND TO_TOPSTATE)
          (("" (REWRITE CVARS_FILL) (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|cvars_fill| FORMULA-DECL NIL |preprocess| NIL))
   NIL
   (|to_topstate_dangling| SUBTYPE "rreduction.to_topstate(rreduction.rS)"
    "(rreduction.noDanglingRefs?)")))
 (|refcountStore_ref| 0
  (|refcountStore_ref-1| NIL 3685183232
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND "refcountStore")
      (("" (EXPAND ALLCOUNT)
        (("" (REWRITE SIGMA_SIGMA_SET)
          (("" (USE "sigma_set[nat].sigma_gt_0")
            (("1" (GROUND)
              (("1" (GRIND) NIL NIL)
               ("2" (DELETE 2)
                (("2" (INST 1 "r")
                  (("2" (EXPAND "refcountArray")
                    (("2" (USE "finseq_theorems[(IL.value?)].count_elem")
                      (("2" (GRIND) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (USE "finite_set_theorems.sigma_sigma_set_TCC1") NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_sigma_set| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_sigma_set_TCC1| SUBTYPE-TCC NIL |finite_set_theorems| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|nonzero_elts| CONST-DECL "set[T]" |convergence_set| "sigma_set/")
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|surjective?| CONST-DECL "bool" |functions| NIL)
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|finite_enumeration| CONST-DECL "[below[card(X)] -> (X)]"
     |finite_enumeration| "sigma_set/")
    (|denumerable_enumeration| CONST-DECL "[nat -> (X)]"
     |denumerable_enumeration| "sigma_set/")
    (O CONST-DECL "T3" |function_props| NIL)
    (|sigma| DEF-DECL "real" |sigma| "reals/")
    (|series| CONST-DECL "sequence[real]" |series| "series/")
    (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL)
    (|convergence| CONST-DECL "bool" |convergence_sequences| "analysis/")
    (|limit| CONST-DECL "real" |convergence_sequences| "analysis/")
    (|sigma| CONST-DECL "real" |sigma_countable| "sigma_set/")
    (|sigma| CONST-DECL "real" |sigma_set| "sigma_set/")
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|sigma_gt_0| FORMULA-DECL NIL |sigma_set| "sigma_set/")
    (|i| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|convergent?| CONST-DECL "bool" |convergence_set| "sigma_set/")
    (|allcount| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK))
 (|refcountArray_update_TCC1| 0
  (|refcountArray_update_TCC1-1| NIL 3692674266 ("" (SUBTYPE-TCC) NIL NIL)
   ((|value?| CONST-DECL "bool" IL NIL)) NIL
   (|refcountArray_update| SUBTYPE "IExpression_adt.nil" "(IL.value?)")))
 (|refcountArray_update| 0
  (|refcountArray_update-1| NIL 3692674266
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND "refcountArray")
      (("" (USE "finseq_theorems[(IL.value?)].count_update")
        (("1" (REWRITE -1) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|store_update_TCC1| 0
  (|store_update_TCC1-1| NIL 3692717400 ("" (SUBTYPE-TCC) NIL NIL)
   ((|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL))
   NIL
   (|store_update| SUBTYPE "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.rS`domain))")))
 (|store_update_TCC2| 0
  (|store_update_TCC2-1| NIL 3692717400 ("" (SUBTYPE-TCC) NIL NIL)
   ((|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|store_update| SUBTYPE "rreduction.j" "below[rS`store(k)`length]")))
 (|store_update| 0
  (|store_update-1| NIL 3692717400
   ("" (SKEEP)
    (("" (CASE "r = k") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL))
   SHOSTAK))
 (|refcountStore_update| 0
  (|refcountStore_update-2| "" 3714856402
   ("" (SKEEP)
    (("" (EXPAND "refcountStore")
      (("" (EXPAND ALLCOUNT)
        (("" (LEMMA SIGMA_WITH)
          ((""
            (INST -1 "rS`domain" _ _ "r"
             "refcountArray(rS`store WITH [(r)(seq)(j) := nil](r))(i)")
            (("1"
              (INST -1 "lambda (j_1: nat):
                   IF rS`domain(j_1) THEN refcountArray(rS`store(j_1))(i)
                   ELSE 0
                   ENDIF"
               "lambda (j_1: nat):
                  IF rS`domain(j_1)
                    THEN refcountArray(rS`store WITH [(r)(seq)(j) := nil](j_1))
                                      (i)
                  ELSE 0
                  ENDIF")
              (("1" (GROUND)
                (("1" (REWRITE REFCOUNTARRAY_UPDATE)
                  (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
                 ("2" (DELETE 2)
                  (("2" (APPLY-EXTENSIONALITY)
                    (("1" (DELETE 2)
                      (("1" (LIFT-IF)
                        (("1" (GROUND)
                          (("1"
                            (CASE "(# length := rS`store(x!1)`length,
                                      seq
                                        := LAMBDA (x1: below[rS`store(x!1)`length]):
                                             IF x1 = j THEN nil
                                             ELSE rS`store(x!1)`seq(x1)
                                             ENDIF #) = rS`store(r) WITH [(seq)(j) := nil]")
                            (("1" (REWRITE -1) NIL NIL)
                             ("2" (DELETE 2)
                              (("2" (GRIND) (("2" (GRIND-WITH-EXT) NIL NIL))
                                NIL))
                              NIL)
                             ("3" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL))
                    NIL))
                  NIL)
                 ("3" (GRIND) NIL NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|x!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|r| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountArray_update| FORMULA-DECL NIL |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK)
  (|refcountStore_update-1| NIL 3692670917
   ("" (SKEEP)
    (("" (EXPAND "refcountStore")
      (("" (EXPAND ALLCOUNT)
        (("" (LEMMA SIGMA_WITH)
          ((""
            (INST -1 "rS`domain" _ _ "r"
             "refcountArray(rS`store WITH [(r)(seq)(j) := nil](r))(i)")
            (("1"
              (INST -1 "lambda (j_1: nat):
               IF rS`domain(j_1) THEN refcountArray(rS`store(j_1))(i)
               ELSE 0
               ENDIF"
               "lambda (j_1: nat):
              IF rS`domain(j_1)
                THEN refcountArray(rS`store WITH [(r)(seq)(j) := nil](j_1))
                                  (i)
              ELSE 0
              ENDIF")
              (("1" (GROUND)
                (("1" (REWRITE REFCOUNTARRAY_UPDATE)
                  (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
                 ("2" (DELETE 2)
                  (("2" (APPLY-EXTENSIONALITY)
                    (("1" (DELETE 2)
                      (("1" (LIFT-IF)
                        (("1" (GROUND)
                          (("1"
                            (CASE "(# length := rS`store(x!1)`length,
                       seq
                         := LAMBDA (x1: below[rS`store(x!1)`length]):
                              IF x1 = j THEN nil
                              ELSE rS`store(x!1)`seq(x1)
                              ENDIF #) = rS`store(r) WITH [(seq)(j) := nil]")
                            (("1" (REWRITE -1) NIL NIL)
                             ("2" (DELETE 2)
                              (("2" (GRIND) (("2" (GRIND-WITH-EXT) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL))
                    NIL))
                  NIL)
                 ("3" (GRIND) NIL NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountArray_update| FORMULA-DECL NIL |rreduction| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK))
 (|refcountStore_set| 0
  (|refcountStore_set-3| "" 3715506034
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNTSTORE)
      (("" (EXPAND ALLCOUNT)
        (("" (LEMMA SIGMA_WITH)
          ((""
            (INST -1 "dom" "lambda (j_1: nat):
                   IF dom(j_1) THEN refcountArray(R(j_1))(i) ELSE 0 ENDIF"
             "lambda (j_1: nat):
                  IF dom(j_1)
                    THEN refcountArray(R WITH [(r)`seq(j) := nv](j_1))(i)
                  ELSE 0
                  ENDIF"
             "r" "refcountArray(R(r) WITH [`seq(j) := nv])(i)")
            (("" (REWRITE -1)
              (("1" (SIMPLIFY)
                (("1" (EXPAND REFCOUNTARRAY)
                  (("1" (REWRITE COUNT_UPDATE)
                    (("1" (SIMPLIFY)
                      (("1"
                        (CASE-REPLACE
                         "(ref?(nv) AND refindex(nv) = i) = refs(nv)(i)")
                        (("1"
                          (CASE-REPLACE
                           "(ref?(R(r)`seq(j)) AND refindex(R(r)`seq(j)) = i) = refs(R(r)`seq(j))(i)")
                          (("1" (DELETE 2)
                            (("1" (TYPEPRED "R(r)`seq(j)")
                              (("1" (GRIND-WITH-EXT) NIL NIL)) NIL))
                            NIL))
                          NIL)
                         ("2" (DELETE 2) (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (DELETE 2)
                (("2" (APPLY-EXTENSIONALITY 1)
                  (("2" (DELETE 2)
                    (("2" (DELETE -1)
                      (("2" (CASE "dom(x!1)")
                        (("1" (LIFT-IF)
                          (("1" (LIFT-IF)
                            (("1" (GROUND)
                              (("1"
                                (CASE-REPLACE "(# length := R(x!1)`length,
                                   seq
                                     := LAMBDA (x1: below[R(x!1)`length]):
                                          IF x1 = j THEN nv
                                          ELSE R(x!1)`seq(x1)
                                          ENDIF #) = R(r) WITH [`seq(j) := nv]")
                                (("1" (DELETE 2)
                                  (("1" (APPLY-EXTENSIONALITY)
                                    (("1" (DELETE 2)
                                      (("1" (GRIND-WITH-EXT) NIL NIL)) NIL)
                                     ("2" (DELETE 2) (("2" (GRIND) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (GRIND) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nv| SKOLEM-CONST-DECL "(domainValue?(dom))" |rreduction| NIL)
    (|dom| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (N!1 SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (N!1 SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|j| SKOLEM-CONST-DECL "below(R(r)`length)" |rreduction| NIL)
    (|x!2| SKOLEM-CONST-DECL "below[R(x!1)`length]" |rreduction| NIL)
    (|x!2| SKOLEM-CONST-DECL "below[R(x!1)`length]" |rreduction| NIL)
    (|x!2| SKOLEM-CONST-DECL "below[R(x!1)`length]" |rreduction| NIL)
    (|x!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|r| SKOLEM-CONST-DECL "(dom)" |rreduction| NIL)
    (R SKOLEM-CONST-DECL "Store(dom)" |rreduction| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK)
  (|refcountStore_set-2| "" 3714871872
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNTSTORE)
      (("" (EXPAND ALLCOUNT)
        (("" (LEMMA SIGMA_WITH)
          ((""
            (INST -1 DOM "lambda (j_1: nat):
                 IF dom(j_1) THEN refcountArray(R(j_1))(i) ELSE 0 ENDIF"
             "lambda (j_1: nat):
                IF dom(j_1)
                  THEN refcountArray(R WITH [(r)`seq(j) := nv](j_1))(i)
                ELSE 0
                ENDIF"
             "r" "refcountArray(R(r) WITH [`seq(j) := nv])(i)")
            (("" (REWRITE -1)
              (("1" (SIMPLIFY)
                (("1" (EXPAND REFCOUNTARRAY)
                  (("1" (REWRITE COUNT_UPDATE)
                    (("1" (SIMPLIFY)
                      (("1"
                        (CASE-REPLACE
                         "(ref?(nv) AND refindex(nv) = i) = refs(nv)(i)")
                        (("1"
                          (CASE-REPLACE
                           "(ref?(R(r)`seq(j)) AND refindex(R(r)`seq(j)) = i) = refs(R(r)`seq(j))(i)")
                          (("1" (DELETE 2)
                            (("1" (TYPEPRED "R(r)`seq(j)")
                              (("1" (GRIND-WITH-EXT) NIL NIL)) NIL))
                            NIL))
                          NIL)
                         ("2" (DELETE 2) (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (DELETE 2)
                (("2" (APPLY-EXTENSIONALITY 1)
                  (("2" (DELETE 2)
                    (("2" (DELETE -1)
                      (("2" (CASE "dom(x!1)")
                        (("1" (LIFT-IF)
                          (("1" (LIFT-IF)
                            (("1" (GROUND)
                              (("1"
                                (CASE-REPLACE "(# length := R(x!1)`length,
                             seq
                               := LAMBDA (x1: below[R(x!1)`length]):
                                    IF x1 = j THEN nv
                                    ELSE R(x!1)`seq(x1)
                                    ENDIF #) = R(r) WITH [`seq(j) := nv]")
                                (("1" (DELETE 2)
                                  (("1" (APPLY-EXTENSIONALITY)
                                    (("1" (DELETE 2)
                                      (("1" (GRIND-WITH-EXT) NIL NIL)) NIL)
                                     ("2" (DELETE 2) (("2" (GRIND) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (GRIND) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) NIL NIL
    NIL NIL (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    NIL NIL NIL NIL NIL NIL NIL
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK)
  (|refcountStore_set-1| NIL 3699635559
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNTSTORE)
      (("" (EXPAND ALLCOUNT)
        (("" (LEMMA SIGMA_WITH)
          ((""
            (INST -1 DOM "lambda (j_1: nat):
               IF dom(j_1) THEN refcountArray(R(j_1))(i) ELSE 0 ENDIF"
             "lambda (j_1: nat):
              IF dom(j_1)
                THEN refcountArray(R WITH [(r)`seq(j) := nv](j_1))(i)
              ELSE 0
              ENDIF"
             "r" "refcountArray(R(r) WITH [`seq(j) := nv])(i)")
            (("" (REWRITE -1)
              (("1" (SIMPLIFY)
                (("1" (EXPAND REFCOUNTARRAY)
                  (("1" (REWRITE COUNT_UPDATE)
                    (("1" (SIMPLIFY)
                      (("1"
                        (CASE-REPLACE
                         "(ref?(nv) AND refindex(nv) = i) = refs(nv)(i)")
                        (("1"
                          (CASE-REPLACE
                           "(ref?(R(r)`seq(j)) AND refindex(R(r)`seq(j)) = i) = refs(R(r)`seq(j))(i)")
                          (("1" (DELETE 2)
                            (("1" (TYPEPRED "R(r)`seq(j)")
                              (("1" (GRIND-WITH-EXT) NIL NIL)) NIL))
                            NIL))
                          NIL)
                         ("2" (DELETE 2) (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (DELETE 2)
                (("2" (APPLY-EXTENSIONALITY 1)
                  (("2" (DELETE 2)
                    (("2" (DELETE -1)
                      (("2" (CASE "dom(x!1)")
                        (("1" (LIFT-IF)
                          (("1" (LIFT-IF)
                            (("1" (GROUND)
                              (("1"
                                (CASE-REPLACE "(# length := R(x!1)`length,
                       seq
                         := LAMBDA (x1: below[R(x!1)`length]):
                              IF x1 = j THEN nv
                              ELSE R(x!1)`seq(x1)
                              ENDIF #) = R(r) WITH [`seq(j) := nv]")
                                (("1" (DELETE 2)
                                  (("1" (APPLY-EXTENSIONALITY)
                                    (("1" (DELETE 2)
                                      (("1" (GRIND-WITH-EXT) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK))
 (|refcount_stack_outside_domain| 0
  (|refcount_stack_outside_domain-1| NIL 3699029139
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNTSTACK)
      (("" (REWRITE COUNT_NONE_ZERO)
        (("" (SKEEP*) (("" (TYPEPRED "rS`stack") (("" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL))
   SHOSTAK))
 (|refcount_new_TCC1| 0
  (|refcount_new_TCC1-1| NIL 3699027941 ("" (SUBTYPE-TCC) NIL NIL)
   ((|member| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|refcount_new| SUBTYPE "rreduction.r" "(rreduction.dom1)")))
 (|refcount_new_TCC2| 0
  (|refcount_new_TCC2-1| NIL 3699027941 ("" (SUBTYPE-TCC) NIL NIL)
   ((|member| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|refcount_new| SUBTYPE "rreduction.i" "(rreduction.dom1)")))
 (|refcount_new| 0
  (|refcount_new-2| "" 3715519219
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNTSTORE)
      (("" (REPLACE -1)
        (("" (EXPAND ALLCOUNT)
          (("" (LEMMA SIGMA_ADD)
            (("" (INST?)
              (("1" (INST -1 "i")
                (("1" (GROUND)
                  (("1" (REWRITE -1)
                    (("1" (EXPAND ADD 2 1)
                      (("1" (REWRITE REMOVE_ADD_MEMBER)
                        (("1" (REWRITE SIGMA_ZERO)
                          (("1" (SKEEP*)
                            (("1" (LIFT-IF)
                              (("1" (GROUND)
                                (("1" (REWRITE -3 :DIR RL)
                                  (("1" (EXPAND REFCOUNTARRAY 1)
                                    (("1" (REWRITE COUNT_NONE_ZERO)
                                      (("1" (SKEEP*)
                                        (("1" (TYPEPRED "store(x)`seq(i_1)")
                                          (("1" (GRIND) NIL NIL)) NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (GRIND) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|dom1| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (|dom| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|i| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|sigma_zero| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|remove_add_member| FORMULA-DECL NIL |sets_lemmas| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL))
   SHOSTAK)
  (|refcount_new-1| NIL 3699027941
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNTSTORE)
      (("" (REPLACE -1)
        (("" (EXPAND ALLCOUNT)
          (("" (LEMMA SIGMA_ADD)
            (("" (INST?)
              (("1" (INST -1 I)
                (("1" (GROUND)
                  (("1" (REWRITE -1)
                    (("1" (EXPAND ADD 2 1)
                      (("1" (REWRITE REMOVE_ADD_MEMBER)
                        (("1" (REWRITE SIGMA_ZERO)
                          (("1" (SKEEP*)
                            (("1" (LIFT-IF)
                              (("1" (GROUND)
                                (("1" (REWRITE -3 :DIR RL)
                                  (("1" (EXPAND REFCOUNTARRAY 1)
                                    (("1" (REWRITE COUNT_NONE_ZERO)
                                      (("1" (SKEEP*)
                                        (("1" (TYPEPRED "store(x)`seq(i_1)")
                                          (("1" (GRIND) NIL NIL)) NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (GRIND) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL NIL
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL) NIL
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|sigma_zero| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|remove_add_member| FORMULA-DECL NIL |sets_lemmas| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|choose| CONST-DECL "(p)" |sets| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL))
   SHOSTAK))
 (|refcount_stack_update_TCC1| 0
  (|refcount_stack_update_TCC1-1| NIL 3700325321 ("" (SUBTYPE-TCC) NIL NIL)
   ((|value?| CONST-DECL "bool" IL NIL)) NIL
   (|refcount_stack_update| SUBTYPE "IExpression_adt.nil" "(IL.value?)")))
 (|refcount_stack_update| 0
  (|refcount_stack_update-1| NIL 3701113153
   ("" (SKEEP)
    (("" (TYPEPRED "rS`count(r)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTSTACK)
            (("" (SPLIT)
              (("1" (USE "count_elem[(value?)]") (("1" (GRIND) NIL NIL)) NIL)
               ("2" (REWRITE COUNT_UPDATE)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|allcountStore_update_TCC1| 0
  (|allcountStore_update_TCC1-1| NIL 3698768688
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (REWRITE REFCOUNTSTORE_UPDATE)
        (("" (TYPEPRED "rS`count(i)")
          (("" (REWRITE -1)
            (("" (EXPAND REFCOUNT)
              (("" (LEMMA "refcountStore_ref") (("" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|allcountStore_update| SUBTYPE
    "(number_fields.-)(rreduction.rS`count(rreduction.i), 1)"
    "{j_1 | j_1 = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq(rreduction.j) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.i)}")))
 (|allcountStore_update| 0
  (|allcountStore_update-2| "" 3715519433
   ("" (SKEEP*)
    ((""
      (NAME "rS2" "rS
                             WITH [`store(r)`seq(j) := nil,
                                   `count(i) := rS`count(i) - 1]")
      (("1" (REPLACE -1)
        (("1" (EXPAND ALLCOUNTSTORE)
          (("1" (EXPAND ALLCOUNT)
            (("1" (LEMMA SIGMA_WITH)
              (("1"
                (INST -1 "rS`domain"
                 "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF"
                 "lambda j: IF rS2`domain(j) THEN rS2`count(j) ELSE 0 ENDIF"
                 "i" "rS`count(i) - 1")
                (("1" (SPLIT -1)
                  (("1" (CASE-REPLACE "rS2`domain = rS`domain")
                    (("1" (REPLACE -2)
                      (("1" (TYPEPRED "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL)
                   ("2" (DELETE 2)
                    (("2" (APPLY-EXTENSIONALITY)
                      (("2" (DELETE 2)
                        (("2" (LIFT-IF)
                          (("2" (LIFT-IF)
                            (("2" (LIFT-IF)
                              (("2" (CASE-REPLACE "rS2`domain = rS`domain")
                                (("1" (SIMPLIFY) (("1" (PROPAX) NIL NIL)) NIL)
                                 ("2" (GRIND) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("3" (TYPEPRED "i") (("3" (GRIND) NIL NIL)) NIL))
                  NIL)
                 ("2" (DELETE 2)
                  (("2" (DELETE -1)
                    (("2" (USE REFCOUNTSTORE_REF)
                      (("2" (TYPEPRED "rS`count(i)") (("2" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "rS`count(i)")
        (("2" (DELETE 2)
          (("2" (USE REFCOUNTSTORE_REF)
            (("2" (REWRITE -2)
              (("2" (EXPAND REFCOUNT)
                (("2" (SPLIT 1)
                  (("1" (GRIND) NIL NIL)
                   ("2" (USE REFCOUNTSTORE_UPDATE) (("2" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|i| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK)
  (|allcountStore_update-1| NIL 3698768688
   ("" (SKEEP*)
    ((""
      (NAME "rS2" "rS
                      WITH [`store(r)`seq(j) := nil,
                            `count(i) := rS`count(i) - 1]")
      (("1" (REPLACE -1)
        (("1" (EXPAND ALLCOUNTSTORE)
          (("1" (EXPAND ALLCOUNT)
            (("1" (LEMMA SIGMA_WITH)
              (("1"
                (INST -1 "rS`domain"
                 "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF"
                 "lambda j: IF rS2`domain(j) THEN rS2`count(j) ELSE 0 ENDIF"
                 "i" "rS`count(i) - 1")
                (("1" (SPLIT -1)
                  (("1" (CASE-REPLACE "rS2`domain = rS`domain")
                    (("1" (REPLACE -2)
                      (("1" (TYPEPRED I) (("1" (ASSERT) NIL NIL)) NIL)) NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL)
                   ("2" (DELETE 2)
                    (("2" (APPLY-EXTENSIONALITY)
                      (("2" (DELETE 2)
                        (("2" (LIFT-IF)
                          (("2" (LIFT-IF)
                            (("2" (LIFT-IF)
                              (("2" (CASE-REPLACE "rS2`domain = rS`domain")
                                (("1" (SIMPLIFY) (("1" (PROPAX) NIL NIL)) NIL)
                                 ("2" (GRIND) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("3" (TYPEPRED I) (("3" (GRIND) NIL NIL)) NIL))
                  NIL)
                 ("2" (DELETE 2)
                  (("2" (DELETE -1)
                    (("2" (USE REFCOUNTSTORE_REF)
                      (("2" (TYPEPRED "rS`count(i)") (("2" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "rS`count(i)")
        (("2" (DELETE 2)
          (("2" (USE REFCOUNTSTORE_REF)
            (("2" (REWRITE -2)
              (("2" (EXPAND REFCOUNT)
                (("2" (SPLIT 1)
                  (("1" (GRIND) NIL NIL)
                   ("2" (USE REFCOUNTSTORE_UPDATE) (("2" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_with| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL) NIL NIL
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|allcountStore_decrease_TCC1| 0
  (|allcountStore_decrease_TCC1-1| NIL 3692982211 ("" (SUBTYPE-TCC) NIL NIL)
   ((|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|allcountStore_decrease| SUBTYPE "rreduction.r"
    "(rreduction.rS1`domain)")))
 (|allcountStore_decrease_TCC2| 0
  (|allcountStore_decrease_TCC2-1| NIL 3692982211 ("" (SUBTYPE-TCC) NIL NIL)
   ((|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|allcountStore_decrease| SUBTYPE "rreduction.r"
    "(rreduction.rS1`domain)")))
 (|allcountStore_decrease| 0
  (|allcountStore_decrease-1| NIL 3692982211
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND ALLCOUNTSTORE)
      (("" (EXPAND ALLCOUNT)
        (("" (REWRITE SIGMA_SIGMA_SET)
          (("" (REWRITE SIGMA_SIGMA_SET)
            (("" (LEMMA "sigma_set[nat].sigma_lt")
              (("" (INST -1 "rS`domain" _ _)
                ((""
                  (INST -1
                   "lambda j: IF rS1`domain(j) THEN rS1`count(j) ELSE 0 ENDIF"
                   "lambda j: IF rS`domain(j) THEN rS`count(j) ELSE 0 ENDIF")
                  (("1" (GROUND)
                    (("1" (DELETE 2)
                      (("1" (SKEEP)
                        (("1" (INST -3 "t") (("1" (GRIND) NIL NIL)) NIL)) NIL))
                      NIL)
                     ("2" (INST 1 S) (("2" (GRIND) NIL NIL)) NIL))
                    NIL)
                   ("2" (USE SIGMA_SIGMA_SET_TCC1) NIL NIL)
                   ("3" (USE SIGMA_SIGMA_SET_TCC1) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_sigma_set| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|sigma_lt| FORMULA-DECL NIL |sigma_set| "sigma_set/")
    (|convergent?| CONST-DECL "bool" |convergence_set| "sigma_set/")
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|rS1| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|real_minus_real_is_real| APPLICATION-JUDGEMENT "real" |reals| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|sigma| CONST-DECL "real" |sigma_set| "sigma_set/")
    (|sigma| CONST-DECL "real" |sigma_countable| "sigma_set/")
    (|limit| CONST-DECL "real" |convergence_sequences| "analysis/")
    (|convergence| CONST-DECL "bool" |convergence_sequences| "analysis/")
    (|abs| CONST-DECL "{n: nonneg_real | n >= m AND n >= -m}" |real_defs| NIL)
    (|series| CONST-DECL "sequence[real]" |series| "series/")
    (|sigma| DEF-DECL "real" |sigma| "reals/")
    (O CONST-DECL "T3" |function_props| NIL)
    (|denumerable_enumeration| CONST-DECL "[nat -> (X)]"
     |denumerable_enumeration| "sigma_set/")
    (|finite_enumeration| CONST-DECL "[below[card(X)] -> (X)]"
     |finite_enumeration| "sigma_set/")
    (|bijective?| CONST-DECL "bool" |functions| NIL)
    (|surjective?| CONST-DECL "bool" |functions| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|nonzero_elts| CONST-DECL "set[T]" |convergence_set| "sigma_set/")
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|sigma_sigma_set_TCC1| SUBTYPE-TCC NIL |finite_set_theorems| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|decref1_TCC1| 0
  (|decref1_TCC1-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL))
   NIL (|decref1| SUBTYPE "rreduction.s" "(rreduction.rS1`domain)")))
 (|decref1_TCC2| 0
  (|decref1_TCC2-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|decref1| SUBTYPE "rreduction.rS"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}")))
 (|decref1_TCC3| 0
  (|decref1_TCC3-1| "" 3710692552
   ("" (SKEEP* :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|decref1| SUBTYPE "IExpression_adt.refindex(rreduction.subref)"
    "(rreduction.rS`domain)"))
  (|decref1_TCC3-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| SUBTYPE "IExpression_adt.refindex(rreduction.subref)"
    "(rreduction.rS`domain)")))
 (|decref1_TCC4| 0
  (|decref1_TCC4-1| "" 3710692565
   ("" (SKEEP* :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|decref1| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]"))
  (|decref1_TCC4-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (CASE-REPLACE "newrS`store(r)`length = rS`store(r)`length")
      (("1" (GRIND) NIL NIL)
       ("2" (REPLACE -7)
        (("2" (HIDE 3)
          (("2" (LIFT-IF)
            (("2" (SPLIT)
              (("1" (FLATTEN)
                (("1" (SIMPLIFY :LET-REDUCE? T)
                  (("1" (ASSERT)
                    (("1"
                      (TYPEPRED "v(rS
          WITH [(store)(r)(seq)(i - 1) := nil,
                (count)(refindex(subref))
                  := rS`count(refindex(subref)) - 1],
        refindex(subref), rS`store(refindex(subref))`length)")
                      (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)
                       ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)
                       ("3" (HIDE 2)
                        (("3" (TYPEPRED "rS`count(refindex(subref))")
                          (("3" (REWRITE -1)
                            (("3" (EXPAND REFCOUNT)
                              (("3" (SPLIT)
                                (("1" (LEMMA REFCOUNTSTORE_REF)
                                  (("1" (ASSERT)
                                    (("1" (INST?)
                                      (("1" (ASSERT)
                                        (("1" (INST?)
                                          (("1" (SPLIT -1)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (HIDE-ALL-BUT (-1 1 -7))
                                              (("2" (GRIND-WITH-EXT) NIL NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                                  (("2" (HIDE-ALL-BUT (-1 1 -7))
                                    (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("4" (GRIND) NIL NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (PROPAX) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]")))
 (|decref1_TCC5| 0
  (|decref1_TCC5-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL))
   NIL
   (|decref1| SUBTYPE "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.rS`domain))")))
 (|decref1_TCC6| 0
  (|decref1_TCC6-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNT)
      (("" (REWRITE REFCOUNTSTORE_UPDATE)
        (("1" (TYPEPRED "rS`count(subrefindex)")
          (("1" (EXPAND REFCOUNT)
            (("1" (SPLIT)
              (("1" (USE REFCOUNTSTORE_REF)
                (("1" (GRIND-WITH-EXT) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL)
         ("2" (GRIND-WITH-EXT) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL "upto(rS`store(r)`length)" |rreduction| NIL)
    (|r| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| SUBTYPE "rreduction.newsubrefcount"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq((number_fields.-)(rreduction.i, 1)) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(rreduction.subrefindex)}")))
 (|decref1_TCC7| 0
  (|decref1_TCC7-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|decref1| SUBTYPE "rreduction.subrefindex" "(rreduction.newrS`domain)")))
 (|decref1_TCC8| 0
  (|decref1_TCC8-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|decref1| SUBTYPE "rreduction.rS`store(rreduction.subrefindex)`length"
    "naturalnumbers.upto(rreduction.newrS`store(rreduction.subrefindex)`length)")))
 (|decref1_TCC9| 0
  (|decref1_TCC9-1| "" 3710692786
   ("" (SKEEP* :PREDS? T)
    (("" (ASSERT)
      (("" (CASE "allcountStore(newrS) < allcountStore(rS)")
        (("1" (GRIND) NIL NIL)
         ("2" (REPLACE -12)
          (("2" (LEMMA ALLCOUNTSTORE_UPDATE)
            (("2" (INST?)
              (("2" (INST?)
                (("2" (SPLIT -1)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (HIDE-ALL-BUT (1 -9 -10))
                    (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|decref1| TERMINATION
    "rreduction.decref1(rreduction.newrS, rreduction.subrefindex, rreduction.rS`store(rreduction.subrefindex)`length)"
    "NIL"))
  (|decref1_TCC9-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (CASE "allcountStore(newrS) < allcountStore(rS)")
      (("1" (GRIND) NIL NIL)
       ("2" (REPLACE*)
        (("2" (REWRITE ALLCOUNTSTORE_UPDATE)
          (("1" (ASSERT) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (< DEF-DECL "bool" |ordinals| NIL) (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| TERMINATION
    "rreduction.decref1(rreduction.newrS, rreduction.subrefindex, rreduction.rS`store(rreduction.subrefindex)`length)"
    "NIL")))
 (|decref1_TCC10| 0
  (|decref1_TCC10-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|decref1| SUBTYPE "rreduction.r" "(rreduction.newrS`domain)")))
 (|decref1_TCC11| 0
  (|decref1_TCC11-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (SIMPLIFY :LET-REDUCE? T)
      (("" (LIFT-IF)
        (("" (SPLIT)
          (("1" (FLATTEN)
            (("1" (ASSERT)
              (("1"
                (TYPEPRED "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
                 ("3" (TYPEPRED "rS`count(refindex(subref))")
                  (("3" (REWRITE -1)
                    (("3" (EXPAND REFCOUNT)
                      (("3" (SPLIT)
                        (("1" (USE REFCOUNTSTORE_REF)
                          (("1" (GRIND-WITH-EXT) NIL NIL)) NIL)
                         ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                          (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("4" (GRIND) NIL NIL))
                NIL))
              NIL))
            NIL)
           ("2" (GRIND) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "naturalnumbers.upto(rreduction.newrS`store(rreduction.r)`length)")))
 (|decref1_TCC12| 0
  (|decref1_TCC12-2| "" 3714665431
   ("" (SKEEP* :PREDS? T)
    ((""
      (CASE "allcountStore(newrS) <= allcountStore(rS) AND
              newrS`domain = rS`domain AND
               forall (s: (rS`domain)):
                 newrS`store(s)`length = rS`store(s)`length AND
                  newrS`count(s) <= rS`count(s) AND
                   (newrS`count(s) = 0 OR
                     newrS`store(s) = rS`store(s))")
      (("1" (TYPEPRED "v(newrS, r, i-1)")
        (("1" (FLATTEN) (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)
         ("3" (FLATTEN) (("3" (INST?) (("3" (GRIND) NIL NIL)) NIL)) NIL)
         ("4" (GRIND) NIL NIL))
        NIL)
       ("2" (DELETE 3)
        (("2" (LIFT-IF)
          (("2" (SPLIT -)
            (("1" (FLATTEN)
              (("1" (SIMPLIFY :LET-REDUCE? T)
                (("1"
                  (TYPEPRED "v(rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1],
               refindex(subref), rS`store(refindex(subref))`length)")
                  (("1" (REPLACE -5 :DIR RL)
                    (("1" (SPLIT)
                      (("1" (REWRITE ALLCOUNTSTORE_UPDATE)
                        (("1" (GRIND) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL))
                        NIL)
                       ("2" (PROPAX) NIL NIL)
                       ("3" (SKEEP)
                        (("3" (INST?)
                          (("3" (SIMPLIFY)
                            (("3" (FLATTEN)
                              (("3" (LIFT-IF)
                                (("3" (SIMPLIFY)
                                  (("3" (CASE-REPLACE "s = r")
                                    (("1" (SIMPLIFY) (("1" (GRIND) NIL NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL)
                   ("3" (TYPEPRED "rS`count(refindex(subref))")
                    (("3" (REWRITE -1)
                      (("3" (EXPAND REFCOUNT)
                        (("3" (SPLIT)
                          (("1" (USE REFCOUNTSTORE_REF)
                            (("1" (SPLIT -1)
                              (("1" (GRIND) NIL NIL)
                               ("2" (GRIND-WITH-EXT) NIL NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL)
                           ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                            (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (FLATTEN)
              (("2" (REPLACE -1 :HIDE? T) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)
       ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL "upto(rS`store(r)`length)" |rreduction| NIL)
    (|r| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|decref1| TERMINATION
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "NIL"))
  (|decref1_TCC12-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (CASE "allcountStore(newrS) <= allcountStore(rS)")
      (("1" (GRIND) NIL NIL)
       ("2" (DELETE 3)
        (("2" (LIFT-IF)
          (("2" (SPLIT)
            (("1" (FLATTEN)
              (("1"
                (TYPEPRED "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                (("1" (REWRITE ALLCOUNTSTORE_UPDATE)
                  (("1" (GRIND) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL)) NIL)
                 ("2" (GRIND) NIL NIL)
                 ("3" (TYPEPRED "rS`count(refindex(subref))")
                  (("3" (REWRITE -1)
                    (("3" (EXPAND REFCOUNT)
                      (("3" (SPLIT)
                        (("1" (USE REFCOUNTSTORE_REF)
                          (("1" (GRIND-WITH-EXT) NIL NIL)
                           ("2" (GRIND) NIL NIL))
                          NIL)
                         ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                          (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL))
                NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| TERMINATION
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "NIL"))
  (|decref1_TCC12-1| "" 3710693184
   ("" (SKEEP* :PREDS? T)
    (("" (CASE "ref?(subref)")
      (("1" (ASSERT)
        (("1" (CASE "allcountStore(newrS) < allcountStore(rS)")
          (("1" (GRIND) NIL NIL)
           ("2" (HIDE 2)
            (("2"
              (TYPEPRED "v(rS
           WITH [(store)(r)(seq)(i - 1) := nil,
                 (count)(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
              (("1" (REPLACE -11 :DIR RL)
                (("1" (REWRITE ALLCOUNTSTORE_UPDATE)
                  (("1" (ASSERT) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                NIL)
               ("2" (GRIND) NIL NIL)
               ("3" (TYPEPRED "rS`count(refindex(subref))")
                (("3" (REPLACE -1)
                  (("3" (EXPAND REFCOUNT)
                    (("3" (SPLIT)
                      (("1" (USE REFCOUNTSTORE_REF)
                        (("1" (SPLIT)
                          (("1" (ASSERT) NIL NIL)
                           ("2" (GRIND-WITH-EXT) NIL NIL))
                          NIL))
                        NIL)
                       ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                        (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("4" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (ASSERT) (("2" (REPLACE -7) (("2" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|decref1| TERMINATION
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "NIL")))
 (|decref1_TCC13| 0
  (|decref1_TCC13-2| "" 3714668347
   ("" (SKEEP* :PREDS? T)
    ((""
      (CASE "allcountStore(newrS) <= allcountStore(rS) AND
              newrS`domain = rS`domain AND
               forall (s: (rS`domain)):
                 newrS`store(s)`length = rS`store(s)`length AND
                  newrS`count(s) <= rS`count(s) AND
                   (newrS`count(s) = 0 OR
                     newrS`store(s) = rS`store(s))")
      (("1" (TYPEPRED "v(newrS, r, i-1)")
        (("1" (FLATTEN)
          (("1" (SPLIT)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
             ("3" (SKEEP :PREDS? T)
              (("3" (INST?)
                (("1" (FLATTEN) (("1" (INST?) (("1" (GRIND) NIL NIL)) NIL))
                  NIL)
                 ("2" (GRIND) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (FLATTEN)
          (("2" (HIDE-ALL-BUT (1 -1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)
         ("3" (FLATTEN) (("3" (INST?) (("3" (GRIND) NIL NIL)) NIL)) NIL)
         ("4" (GRIND) NIL NIL))
        NIL)
       ("2" (DELETE 3)
        (("2" (LIFT-IF)
          (("2" (SPLIT -)
            (("1" (FLATTEN)
              (("1" (SIMPLIFY :LET-REDUCE? T)
                (("1"
                  (TYPEPRED "v(rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1],
               refindex(subref), rS`store(refindex(subref))`length)")
                  (("1" (REPLACE -5 :DIR RL)
                    (("1" (SPLIT)
                      (("1" (REWRITE ALLCOUNTSTORE_UPDATE)
                        (("1" (GRIND) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL))
                        NIL)
                       ("2" (PROPAX) NIL NIL)
                       ("3" (SKEEP)
                        (("3" (INST?)
                          (("3" (SIMPLIFY)
                            (("3" (FLATTEN)
                              (("3" (LIFT-IF)
                                (("3" (SIMPLIFY)
                                  (("3" (CASE-REPLACE "s = r")
                                    (("1" (SIMPLIFY) (("1" (GRIND) NIL NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL)
                   ("3" (TYPEPRED "rS`count(refindex(subref))")
                    (("3" (REWRITE -1)
                      (("3" (EXPAND REFCOUNT)
                        (("3" (SPLIT)
                          (("1" (USE REFCOUNTSTORE_REF)
                            (("1" (SPLIT -1)
                              (("1" (GRIND) NIL NIL)
                               ("2" (GRIND-WITH-EXT) NIL NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL)
                           ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                            (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (FLATTEN)
              (("2" (REPLACE -1 :HIDE? T) (("2" (ASSERT) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)
       ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|s| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|newrS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL "upto(rS`store(r)`length)" |rreduction| NIL)
    (|r| SKOLEM-CONST-DECL "(rS`domain)" |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|decref1| SUBTYPE
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}"))
  (|decref1_TCC13-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    ((""
      (CASE "allcountStore(newrS) <= allcountStore(rS) AND
       newrS`domain = rS`domain AND
        forall (s: (rS`domain)):
          newrS`store(s)`length = rS`store(s)`length AND
           newrS`count(s) <= rS`count(s) AND
            (newrS`count(s) = 0 OR
              newrS`store(s) = rS`store(s))")
      (("1" (TYPEPRED "v(newrS, r, i-1)")
        (("1" (FLATTEN)
          (("1" (SPLIT)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
             ("3" (SKEEP :PREDS? T)
              (("3" (INST?)
                (("1" (FLATTEN) (("1" (INST?) (("1" (GRIND) NIL NIL)) NIL))
                  NIL)
                 ("2" (GRIND) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (FLATTEN)
          (("2" (HIDE-ALL-BUT (1 -1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL)
         ("3" (FLATTEN) (("3" (INST?) (("3" (GRIND) NIL NIL)) NIL)) NIL)
         ("4" (GRIND) NIL NIL))
        NIL)
       ("2" (DELETE 3)
        (("2" (LIFT-IF)
          (("2" (SPLIT -)
            (("1" (FLATTEN)
              (("1" (SIMPLIFY :LET-REDUCE? T)
                (("1"
                  (TYPEPRED "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
                  (("1" (REPLACE -5 :DIR RL)
                    (("1" (SPLIT)
                      (("1" (REWRITE ALLCOUNTSTORE_UPDATE)
                        (("1" (GRIND) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL))
                        NIL)
                       ("2" (PROPAX) NIL NIL)
                       ("3" (SKEEP)
                        (("3" (INST?)
                          (("3" (SIMPLIFY)
                            (("3" (FLATTEN)
                              (("3" (LIFT-IF)
                                (("3" (SIMPLIFY)
                                  (("3" (CASE-REPLACE "s = r")
                                    (("1" (SIMPLIFY) (("1" (GRIND) NIL NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL)
                   ("3" (TYPEPRED "rS`count(refindex(subref))")
                    (("3" (REWRITE -1)
                      (("3" (EXPAND REFCOUNT)
                        (("3" (SPLIT)
                          (("1" (USE REFCOUNTSTORE_REF)
                            (("1" (SPLIT -1)
                              (("1" (GRIND) NIL NIL)
                               ("2" (GRIND-WITH-EXT) NIL NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL)
                           ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                            (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL)
       ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)
       ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|ordstruct| TYPE-DECL NIL |ordstruct_adt| NIL)
    (< DEF-DECL "bool" |ordinals| NIL)
    (|ordinal?| DEF-DECL "bool" |ordinals| NIL)
    (|ordinal| NONEMPTY-TYPE-EQ-DECL NIL |ordinals| NIL)
    (|lex2| CONST-DECL "ordinal" |lex2| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1| SUBTYPE
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}"))
  (|decref1_TCC13-1| "" 3710693976
   ("" (SKEEP* :PREDS? T)
    (("" (CASE "ref?(subref)")
      (("1" (ASSERT)
        (("1" (SIMPLIFY :LET-REDUCE? T)
          (("1"
            (TYPEPRED "v(rS
           WITH [(store)(r)(seq)(i - 1) := nil,
                 (count)(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)")
            (("1" (REWRITE ALLCOUNTSTORE_UPDATE)
              (("1" (ASSERT)
                (("1" (SKEEP)
                  (("1" (INST -3 S)
                    (("1" (FLATTEN)
                      (("1" (ASSERT)
                        (("1" (REPLACE -13 :DIR RL)
                          (("1" (ASSERT)
                            (("1" (LIFT-IF)
                              (("1" (ASSERT)
                                (("1" (SPLIT)
                                  (("1" (FLATTEN)
                                    (("1" (ASSERT)
                                      (("1" (TYPEPRED "v(newrS, r, i - 1)")
                                        (("1" (INST -3 S)
                                          (("1" (FLATTEN)
                                            (("1" (ASSERT)
                                              (("1" (FLATTEN)
                                                (("1" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL)
                                         ("2" (HIDE 3) (("2" (GRIND) NIL NIL))
                                          NIL)
                                         ("3"
                                          (CASE-REPLACE
                                           "newrS`store(r)`length = rS`store(r)`length")
                                          (("1" (GRIND) NIL NIL)
                                           ("2" (REVEAL *)
                                            (("2" (INST -1 R)
                                              (("2" (FLATTEN)
                                                (("2" (ASSERT) NIL NIL)) NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (REVEAL *)
                                      (("2" (INST -1 R)
                                        (("2" (ASSERT)
                                          (("2" (FLATTEN)
                                            (("2" (REPLACE -16 :DIR RL)
                                              (("2" (LIFT-IF)
                                                (("2" (ASSERT)
                                                  (("2" (SPLIT)
                                                    (("1" (FLATTEN)
                                                      (("1" (ASSERT) NIL NIL))
                                                      NIL)
                                                     ("2" (FLATTEN)
                                                      (("2" (ASSERT)
                                                        (("2"
                                                          (TYPEPRED
                                                           "v(newrS, r, i - 1)")
                                                          (("1" (INST -3 S)
                                                            (("1" (FLATTEN)
                                                              (("1" (ASSERT)
                                                                (("1" (SPLIT +)
                                                                  (("1"
                                                                    (ASSERT)
                                                                    (("1"
                                                                      (HIDE-ALL-BUT
                                                                       (-4 -9
                                                                        1))
                                                                      (("1"
                                                                        (GRIND)
                                                                        (("1"
                                                                          (GRIND)
                                                                          (("1"
                                                                            (NAME-REPLACE
                                                                             A
                                                                             "newrS`count(s)")
                                                                            (("1"
                                                                              (ASSERT)
                                                                              (("1"
                                                                                (NAME-REPLACE
                                                                                 B
                                                                                 "v(newrS, r, i - 1)`count(s)")
                                                                                (("1"
                                                                                  (ASSERT)
                                                                                  (("1"
                                                                                    (NAME-REPLACE
                                                                                     C
                                                                                     "rS`count(s)")
                                                                                    (("1"
                                                                                      (ASSERT)
                                                                                      (("1"
                                                                                        (GENERALIZE
                                                                                         A
                                                                                         A
                                                                                         NAT)
                                                                                        (("1"
                                                                                          (GENERALIZE
                                                                                           B
                                                                                           B
                                                                                           NAT)
                                                                                          (("1"
                                                                                            (GENERALIZE
                                                                                             C
                                                                                             C
                                                                                             NAT)
                                                                                            (("1"
                                                                                              (GRIND)
                                                                                              NIL
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL)
                                                                   ("2"
                                                                    (FLATTEN)
                                                                    (("2"
                                                                      (ASSERT)
                                                                      NIL NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (HIDE 5)
                                                            (("2" (GRIND) NIL
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (GRIND-WITH-EXT) NIL NIL))
              NIL)
             ("2" (LIFT-IF) (("2" (ASSERT) NIL NIL)) NIL)
             ("3" (HIDE 3)
              (("3" (TYPEPRED "rS`count(refindex(subref))")
                (("3" (REWRITE -1)
                  (("3" (EXPAND REFCOUNT)
                    (("3" (SPLIT)
                      (("1" (USE REFCOUNTSTORE_REF)
                        (("1" (SPLIT -1)
                          (("1" (ASSERT) NIL NIL)
                           ("2" (GRIND-WITH-EXT) NIL NIL))
                          NIL))
                        NIL)
                       ("2" (REWRITE REFCOUNTSTORE_UPDATE)
                        (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("4" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL)
       ("2" (ASSERT)
        (("2" (TYPEPRED "v(newrS, r, i - 1)")
          (("1" (ASSERT)
            (("1" (SKEEP)
              (("1" (INST?)
                (("1" (FLATTEN)
                  (("1" (ASSERT) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (REPLACE -7) (("2" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|decref1| SUBTYPE
    "rreduction.decref1(rreduction.newrS, rreduction.r, (number_fields.-)(rreduction.i, 1))"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}")))
 (|decref1_TCC14| 0
  (|decref1_TCC14-2| "" 3714544812 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   SHOSTAK
   (|decref1| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]"))
  (|decref1_TCC14-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNT)
      (("" (REWRITE REFCOUNTSTORE_UPDATE)
        (("1" (TYPEPRED "rS`count(subrefindex)")
          (("1" (EXPAND REFCOUNT)
            (("1" (ASSERT)
              (("1" (USE REFCOUNTSTORE_REF)
                (("1" (SPLIT)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (HIDE-ALL-BUT (1 -10 -11))
                    (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (HIDE-ALL-BUT (1 -10 -11)) (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   NIL
   (|decref1| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "below[rS`store(r)`length]")))
 (|decref1_TCC15| 0
  (|decref1_TCC15-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|decref1| SUBTYPE "rreduction.rS"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s))))))))}")))
 (|decref1_induction_TCC1| 0
  (|decref1_induction_TCC1-1| NIL 3702839528 ("" (SUBTYPE-TCC) NIL NIL)
   ((|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL))
   NIL
   (|decref1_induction| SUBTYPE "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.rS`domain))")))
 (|decref1_induction_TCC2| 0
  (|decref1_induction_TCC2-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "rS`store(r)`seq(i)") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1_induction| SUBTYPE
    "IExpression_adt.refindex(rreduction.rS`store(rreduction.r)`seq(rreduction.i))"
    "(rreduction.rS`domain)")))
 (|decref1_induction_TCC3| 0
  (|decref1_induction_TCC3-1| NIL 3702839528
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "rS`count(refindex(rS`store(r)`seq(i)))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (SPLIT)
            (("1" (USE REFCOUNTSTORE_REF) (("1" (GRIND-WITH-EXT) NIL NIL)) NIL)
             ("2" (REWRITE REFCOUNTSTORE_UPDATE)
              (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "rS`store(r)`seq(i)") (("2" (GRIND) NIL NIL)) NIL)
       ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1_induction| SUBTYPE
    "(number_fields.-)(rreduction.rS`count(IExpression_adt.refindex(rreduction.rS`store(rreduction.r)`seq(rreduction.i))), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store WITH [(rreduction.r)`seq(rreduction.i) := IExpression_adt.nil], rreduction.rS`stack, rreduction.rS`redex)(IExpression_adt.refindex(rreduction.rS`store(rreduction.r)`seq(rreduction.i)))}")))
 (|decref1_induction| 0
  (|decref1_induction-3| "" 3715525712
   ("" (SKEEP)
    (("" (MEASURE-INDUCT+ "allcountStore(rS)" ("rS"))
      (("" (SKEEP)
        (("" (GENERALIZE "i" "i" "upto(x!1`store(r)`length)" 1)
          (("" (INDUCT "i")
            (("1" (EXPAND DECREF1 1) (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKEEP)
              (("2" (EXPAND DECREF1 1)
                (("2" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (NAME-REPLACE "rS" "x!1")
                      (("1" (LIFT-IF)
                        (("1" (SPLIT)
                          (("1" (FLATTEN)
                            (("1"
                              (NAME-REPLACE "idx"
                               "refindex(rS`store(r)`seq(jt))")
                              (("1"
                                (NAME-REPLACE "rS2" "rS
                                            WITH [`store(r)`seq(jt) := nil,
                                                  `count(idx) := rS`count(idx) - 1]")
                                (("1"
                                  (CASE
                                      "allcountStore(rS2) < allcountStore(rS)")
                                  (("1"
                                    (CASE
                                        "P(decref1(rS2, idx, rS`store(idx)`length))")
                                    (("1" (INST? :WHERE +)
                                      (("1" (SPLIT)
                                        (("1" (PROPAX) NIL NIL)
                                         ("2" (ASSERT) NIL NIL)
                                         ("3"
                                          (TYPEPRED
                                           "decref1(rS2, idx, rS`store(idx)`length)")
                                          (("3" (ASSERT) NIL NIL)) NIL))
                                        NIL))
                                      NIL)
                                     ("2" (EXPAND IDX)
                                      (("2" (EXPAND RS)
                                        (("2" (TYPEPRED "x!1`store(r)`seq(jt)")
                                          (("2" (EXPAND DOMAINVALUE?)
                                            (("2" (PROP)
                                              (("2" (CASE "P(rS2)")
                                                (("1" (INST?)
                                                  (("1" (PROP) NIL NIL)) NIL)
                                                 ("2" (EXPAND RS2)
                                                  (("2" (EXPAND IDX)
                                                    (("2" (DELETE 2)
                                                      (("2" (DELETE 2)
                                                        (("2" (DELETE -8)
                                                          (("2" (INST?)
                                                            (("2" (SPLIT)
                                                              (("1" (PROPAX)
                                                                NIL NIL)
                                                               ("2" (EXPAND RS)
                                                                (("2" (PROPAX)
                                                                  NIL NIL))
                                                                NIL)
                                                               ("3" (EXPAND RS)
                                                                (("3" (ASSERT)
                                                                  NIL NIL))
                                                                NIL)
                                                               ("4" (EXPAND RS)
                                                                (("4" (ASSERT)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("3" (EXPAND IDX)
                                      (("3" (EXPAND RS2)
                                        (("3" (EXPAND IDX)
                                          (("3" (ASSERT)
                                            (("3" (LIFT-IF)
                                              (("3" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("4" (EXPAND IDX)
                                      (("4" (TYPEPRED "rS`store(r)`seq(jt)")
                                        (("4" (EXPAND DOMAINVALUE?)
                                          (("4" (PROP) (("4" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (EXPAND RS2)
                                    (("2" (EXPAND IDX)
                                      (("2" (USE ALLCOUNTSTORE_UPDATE)
                                        (("2" (SPLIT -1)
                                          (("1" (GRIND) NIL NIL)
                                           ("2" (HIDE-ALL-BUT (1 -1))
                                            (("2" (GRIND-WITH-EXT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (EXPAND IDX)
                                  (("2" (DELETE 2)
                                    (("2"
                                      (TYPEPRED
                                       "rS`count(refindex(rS`store(r)`seq(jt)))")
                                      (("1" (REWRITE -1)
                                        (("1" (EXPAND REFCOUNT)
                                          (("1" (SPLIT)
                                            (("1" (USE REFCOUNTSTORE_REF)
                                              (("1" (SPLIT -1)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (HIDE-ALL-BUT (1 -1))
                                                  (("2" (GRIND-WITH-EXT) NIL
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2"
                                              (REWRITE REFCOUNTSTORE_UPDATE)
                                              (("2" (HIDE-ALL-BUT (1 -1))
                                                (("2" (GRIND-WITH-EXT) NIL
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL)
                                       ("2" (TYPEPRED "rS`store(r)`seq(jt)")
                                        (("2" (EXPAND DOMAINVALUE?)
                                          (("2" (PROP)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL)
                                       ("3" (ASSERT) NIL NIL)
                                       ("4" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("3" (GRIND) NIL NIL) ("4" (ASSERT) NIL NIL))
                                NIL)
                               ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (ASSERT) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|decref1| DEF-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|idx| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|rS2| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rS| SKOLEM-CONST-DECL "rstate" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|upto_induction| FORMULA-DECL NIL |bounded_nat_inductions| NIL))
   SHOSTAK)
  (|decref1_induction-2| "" 3710691615
   ("" (SKEEP)
    (("" (MEASURE-INDUCT+ "allcountStore(rS)" ("rS"))
      (("" (SKEEP)
        (("" (GENERALIZE I I "upto(x!1`store(r)`length)" 1)
          (("" (INDUCT I)
            (("1" (EXPAND DECREF1 1) (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKEEP)
              (("2" (EXPAND DECREF1 1)
                (("2" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (NAME-REPLACE "rS" "x!1")
                      (("1" (LIFT-IF)
                        (("1" (SPLIT)
                          (("1" (FLATTEN)
                            (("1"
                              (NAME-REPLACE "idx"
                               "refindex(rS`store(r)`seq(jt))")
                              (("1"
                                (NAME-REPLACE "rS2" "rS
                                  WITH [`store(r)`seq(jt) := nil,
                                        `count(idx) := rS`count(idx) - 1]")
                                (("1"
                                  (CASE
                                      "allcountStore(rS2) < allcountStore(rS)")
                                  (("1"
                                    (CASE
                                        "P(decref1(rS2, idx, rS`store(idx)`length))")
                                    (("1" (INST? :WHERE +)
                                      (("1" (SPLIT)
                                        (("1" (PROPAX) NIL NIL)
                                         ("2" (ASSERT) NIL NIL)
                                         ("3"
                                          (TYPEPRED
                                           "decref1(rS2, idx, rS`store(idx)`length)")
                                          (("3" (ASSERT) NIL NIL)) NIL))
                                        NIL))
                                      NIL)
                                     ("2" (EXPAND IDX)
                                      (("2" (EXPAND RS)
                                        (("2" (TYPEPRED "x!1`store(r)`seq(jt)")
                                          (("2" (EXPAND DOMAINVALUE?)
                                            (("2" (PROP)
                                              (("2" (CASE "P(rS2)")
                                                (("1" (INST?)
                                                  (("1" (PROP) NIL NIL)) NIL)
                                                 ("2" (EXPAND RS2)
                                                  (("2" (EXPAND IDX)
                                                    (("2" (DELETE 2)
                                                      (("2" (DELETE 2)
                                                        (("2" (DELETE -8)
                                                          (("2" (INST?)
                                                            (("2" (SPLIT)
                                                              (("1" (PROPAX)
                                                                NIL NIL)
                                                               ("2" (EXPAND RS)
                                                                (("2" (PROPAX)
                                                                  NIL NIL))
                                                                NIL)
                                                               ("3" (EXPAND RS)
                                                                (("3" (ASSERT)
                                                                  NIL NIL))
                                                                NIL)
                                                               ("4" (EXPAND RS)
                                                                (("4" (ASSERT)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("3" (EXPAND IDX)
                                      (("3" (EXPAND RS2)
                                        (("3" (EXPAND IDX)
                                          (("3" (ASSERT)
                                            (("3" (LIFT-IF)
                                              (("3" (ASSERT) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("4" (EXPAND IDX)
                                      (("4" (TYPEPRED "rS`store(r)`seq(jt)")
                                        (("4" (EXPAND DOMAINVALUE?)
                                          (("4" (PROP) (("4" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (EXPAND RS2)
                                    (("2" (EXPAND IDX)
                                      (("2" (USE ALLCOUNTSTORE_UPDATE)
                                        (("2" (SPLIT -1)
                                          (("1" (GRIND) NIL NIL)
                                           ("2" (HIDE-ALL-BUT (1 -1))
                                            (("2" (GRIND-WITH-EXT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (EXPAND IDX)
                                  (("2" (DELETE 2)
                                    (("2"
                                      (TYPEPRED
                                       "rS`count(refindex(rS`store(r)`seq(jt)))")
                                      (("1" (REWRITE -1)
                                        (("1" (EXPAND REFCOUNT)
                                          (("1" (SPLIT)
                                            (("1" (USE REFCOUNTSTORE_REF)
                                              (("1" (SPLIT -1)
                                                (("1" (ASSERT) NIL NIL)
                                                 ("2" (HIDE-ALL-BUT (1 -1))
                                                  (("2" (GRIND-WITH-EXT) NIL
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2"
                                              (REWRITE REFCOUNTSTORE_UPDATE)
                                              (("2" (HIDE-ALL-BUT (1 -1))
                                                (("2" (GRIND-WITH-EXT) NIL
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL)
                                       ("2" (TYPEPRED "rS`store(r)`seq(jt)")
                                        (("2" (EXPAND DOMAINVALUE?)
                                          (("2" (PROP)
                                            (("1" (ASSERT) NIL NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL)
                                       ("3" (ASSERT) NIL NIL)
                                       ("4" (ASSERT) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("3" (GRIND) NIL NIL) ("4" (ASSERT) NIL NIL))
                                NIL)
                               ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (ASSERT) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|decref1| DEF-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    NIL NIL (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|upto_induction| FORMULA-DECL NIL |bounded_nat_inductions| NIL))
   SHOSTAK)
  (|decref1_induction-1| NIL 3702845439
   ("" (SKEEP)
    (("" (MEASURE-INDUCT+ "allcountStore(rS)" ("rS"))
      (("" (SKEEP)
        (("" (GENERALIZE I I "upto(x!1`store(r)`length)" 1)
          (("" (INDUCT I)
            (("1" (EXPAND DECREF1 1) (("1" (PROPAX) NIL NIL)) NIL)
             ("2" (SKEEP)
              (("2" (EXPAND DECREF1 1)
                (("2" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (NAME-REPLACE "rS" "x!1")
                      (("1" (LIFT-IF)
                        (("1" (SPLIT)
                          (("1" (FLATTEN)
                            (("1"
                              (NAME-REPLACE "idx"
                               "refindex(rS`store(r)`seq(jt))")
                              (("1"
                                (NAME-REPLACE "rS2" "rS
                          WITH [`store(r)`seq(jt) := nil,
                                `count(idx) := rS`count(idx) - 1]")
                                (("1"
                                  (CASE
                                      "allcountStore(rS2) < allcountStore(rS)")
                                  (("1"
                                    (CASE
                                        "P(decref1(rS2, idx, rS`store(idx)`length))")
                                    (("1" (INST? :WHERE +)
                                      (("1" (SPLIT)
                                        (("1" (PROPAX) NIL NIL)
                                         ("2" (PROPAX) NIL NIL)
                                         ("3"
                                          (TYPEPRED
                                           "decref1(rS2, idx, rS`store(idx)`length)")
                                          (("3" (GRIND) NIL NIL)) NIL))
                                        NIL)
                                       ("2" (EXPAND IDX)
                                        (("2" (EXPAND RS)
                                          (("2"
                                            (TYPEPRED "x!1`store(r)`seq(jt)")
                                            (("1" (EXPAND DOMAINVALUE?)
                                              (("1" (PROP) NIL NIL)) NIL)
                                             ("2" (PROPAX) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (CASE "P(rS2)")
                                      (("1" (INST?) (("1" (PROP) NIL NIL)) NIL)
                                       ("2" (EXPAND RS2)
                                        (("2" (EXPAND IDX)
                                          (("2" (DELETE 2)
                                            (("2" (DELETE 2)
                                              (("2" (DELETE -6)
                                                (("2" (INST?)
                                                  (("2" (SPLIT)
                                                    (("1" (PROPAX) NIL NIL)
                                                     ("2" (PROPAX) NIL NIL)
                                                     ("3" (PROPAX) NIL NIL)
                                                     ("4" (PROPAX) NIL NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("3" (EXPAND IDX)
                                      (("3" (TYPEPRED "rS`store(r)`seq(jt)")
                                        (("3" (EXPAND DOMAINVALUE?)
                                          (("3" (PROP) NIL NIL)) NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (EXPAND RS2)
                                    (("2" (EXPAND IDX)
                                      (("2" (USE ALLCOUNTSTORE_UPDATE)
                                        (("2" (SPLIT -1)
                                          (("1" (GRIND) NIL NIL)
                                           ("2" (HIDE-ALL-BUT (1 -1))
                                            (("2" (GRIND-WITH-EXT) NIL NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (EXPAND IDX)
                                  (("2" (DELETE 2)
                                    (("2"
                                      (TYPEPRED
                                       "rS`count(refindex(rS`store(r)`seq(jt)))")
                                      (("1" (REWRITE -1)
                                        (("1" (EXPAND REFCOUNT)
                                          (("1" (SPLIT)
                                            (("1" (USE REFCOUNTSTORE_REF)
                                              (("1" (SPLIT -1)
                                                (("1" (GRIND) NIL NIL)
                                                 ("2" (HIDE-ALL-BUT (1 -1))
                                                  (("2" (GRIND-WITH-EXT) NIL
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2"
                                              (REWRITE REFCOUNTSTORE_UPDATE)
                                              (("2" (HIDE-ALL-BUT (1 -1))
                                                (("2" (GRIND-WITH-EXT) NIL
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL)
                                       ("2" (TYPEPRED "rS`store(r)`seq(jt)")
                                        (("2" (EXPAND DOMAINVALUE?)
                                          (("2" (PROP) NIL NIL)) NIL))
                                        NIL)
                                       ("3" (PROPAX) NIL NIL)
                                       ("4" (PROPAX) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("3" (GRIND) NIL NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (ASSERT) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|decref1| DEF-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|refcountStore_ref| FORMULA-DECL NIL |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|allcountStore_update| FORMULA-DECL NIL |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|upto_induction| FORMULA-DECL NIL |bounded_nat_inductions| NIL))
   SHOSTAK))
 (|decref_TCC1| 0
  (|decref_TCC1-2| "" 3715525928
   ("" (LEMMA DECREF1_INDUCTION)
    (("" (INST -1 "noDanglingRefs?")
      (("" (SPLIT -1)
        (("1" (SKEEP* :PREDS? T)
          (("1" (TYPEPRED "decref1(rS, r, i)")
            (("1" (ASSERT)
              (("1" (SPLIT)
                (("1" (PROPAX) NIL NIL)
                 ("2" (INST? -7) (("2" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (DELETE 2)
          (("2" (SKEEP* :PREDS? T)
            (("2" (EXPAND NODANGLINGREFS?) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|decref1| DEF-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|decref1_induction| FORMULA-DECL NIL |rreduction| NIL))
   SHOSTAK
   (|decref| SUBTYPE
    "rreduction.decref1(rreduction.rS, rreduction.r, rreduction.i)"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, booleans.AND((FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s)))))), rreduction.noDanglingRefs?(rreduction.rS1))))}"))
  (|decref_TCC1-1| NIL 3692915538
   ("" (LEMMA DECREF1_INDUCTION)
    (("" (INST -1 NODANGLINGREFS?)
      (("" (SPLIT -1)
        (("1" (SKEEP* :PREDS? T)
          (("1" (TYPEPRED "decref1(rS, r, i)")
            (("1" (ASSERT)
              (("1" (SPLIT)
                (("1" (PROPAX) NIL NIL)
                 ("2" (INST? -7) (("2" (ASSERT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (DELETE 2)
          (("2" (SKEEP* :PREDS? T)
            (("2" (EXPAND NODANGLINGREFS?) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|decref1| DEF-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|decref1_induction| FORMULA-DECL NIL |rreduction| NIL))
   NIL
   (|decref| SUBTYPE
    "rreduction.decref1(rreduction.rS, rreduction.r, rreduction.i)"
    "{rS1 | booleans.AND(reals.<=(rreduction.allcountStore(rreduction.rS1), rreduction.allcountStore(rreduction.rS)), booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, booleans.AND((FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s)))))), rreduction.noDanglingRefs?(rreduction.rS1))))}")))
 (|decref1_chk_TCC1| 0
  (|decref1_chk_TCC1-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL))
   NIL (|decref1_chk| SUBTYPE "rreduction.s" "(rreduction.rS1`domain)")))
 (|decref1_chk_TCC2| 0
  (|decref1_chk_TCC2-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|decref1_chk| SUBTYPE "IExpression_adt.refindex(rreduction.x)"
    "(rreduction.rS`domain)")))
 (|decref1_chk_TCC3| 0
  (|decref1_chk_TCC3-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|decref1_chk| SUBTYPE
    "rreduction.rS`store(IExpression_adt.refindex(rreduction.x))`length"
    "naturalnumbers.upto(rreduction.rS`store(IExpression_adt.refindex(rreduction.x))`length)")))
 (|decref1_chk_TCC4| 0
  (|decref1_chk_TCC4-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|decref1_chk| SUBTYPE "rreduction.rS"
    "{rS1 | booleans.AND(rreduction.rS1`domain = rreduction.rS`domain, (FORALL (s: (rreduction.rS`domain)): booleans.AND(rreduction.rS1`store(s)`length = rreduction.rS`store(s)`length, booleans.AND(reals.<=(rreduction.rS1`count(s), rreduction.rS`count(s)), (booleans.OR(rreduction.rS1`count(s) = 0, rreduction.rS1`store(s) = rreduction.rS`store(s)))))))}")))
 (|decref1_chk_ndr| 0
  (|decref1_chk_ndr-1| NIL 3706037470
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND DECREF1_CHK)
      (("" (SPLIT)
        (("1" (FLATTEN)
          (("1"
            (CASE-REPLACE "decref1(rS, refindex(x),
                              rS`store(refindex(x))`length) = decref(rS, refindex(x),
                              rS`store(refindex(x))`length)")
            (("1" (ASSERT) NIL NIL)
             ("2" (EXPAND DECREF) (("2" (PROPAX) NIL NIL)) NIL))
            NIL))
          NIL)
         ("2" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|decref1_chk| CONST-DECL "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (|decref| CONST-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}"
     |rreduction| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|decref1| DEF-DECL "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|allcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|decref1_chk_ndr| SUBTYPE
    "rreduction.decref1_chk(rreduction.rS, rreduction.x)"
    "(rreduction.noDanglingRefs?)")))
 (|stack_update_correct| 0
  (|stack_update_correct-2| "" 3715526064
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "rS`stack")
      (("" (EXPAND EVERY)
        (("" (SKEEP*) (("" (INST -1 "i_1") (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL))
   SHOSTAK)
  (|stack_update_correct-1| NIL 3700487299
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "rS`stack")
      (("" (EXPAND EVERY)
        (("" (SKEEP*) (("" (INST -1 I_1) (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL))
   SHOSTAK))
 (|letApply_TCC1| 0
  (|letApply_TCC1-1| NIL 3699206216 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL (|letApply| SUBTYPE "(number_fields.-)(rreduction.arity, 1)" "nat"))
  (|pure_letApply_TCC1-1| NIL 3699206216 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL)
   ((|pure?| DEF-DECL "bool" IL NIL)) NIL
   (|letApply| SUBTYPE "(number_fields.-)(rreduction.arity, 1)" "nat")))
 (|letApply_TCC2| 0
  (|letApply_TCC2-1| NIL 3699206216 ("" (GRIND) NIL NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|letApply| SUBTYPE "rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)"))
  (|pure_letApply_TCC2-1| NIL 3699206216 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL)
   ((|pure?| DEF-DECL "bool" IL NIL)) NIL
   (|letApply| SUBTYPE "rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)")))
 (|letApply_TCC3| 0
  (|letApply_TCC3-1| NIL 3699206216 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|letApply| SUBTYPE "rreduction.x" "(IExpression_adt.variable?)")))
 (|letApply_TCC4| 0
  (|letApply_TCC4-1| NIL 3699206216 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|letApply| SUBTYPE
    "rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)]"
    "(IExpression_adt.variable?)")))
 (|letApply_TCC5| 0
  (|letApply_TCC5-2| "" 3715570547
   ("" (GRIND)
    (("" (REWRITE "map_length")
      (("" (GRIND) (("" (EXPAND "length" -) (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|map_length| FORMULA-DECL NIL |more_map_props| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK
   (|letApply| SUBTYPE
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)])(list_adt[(IExpression_adt.variable?)].cdr(rreduction.args))"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = (number_fields.-)(rreduction.arity, 1)}"))
  (|letApply_TCC5-1| NIL 3699206216
   ("" (SKEEP*)
    (("" (REWRITE MAP_LENGTH)
      (("" (TYPEPRED ARGS)
        (("" (GRIND) (("" (EXPAND LENGTH -2) (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|map_length| FORMULA-DECL NIL |more_map_props| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    NIL (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   NIL
   (|letApply| SUBTYPE
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)])(list_adt[(IExpression_adt.variable?)].cdr(rreduction.args))"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = (number_fields.-)(rreduction.arity, 1)}")))
 (|letApply_TCC6| 0
  (|letApply_TCC6-1| NIL 3699206216 ("" (TERMINATION-TCC) NIL NIL) NIL NIL
   (|letApply| TERMINATION
    "rreduction.letApply((number_fields.-)(rreduction.arity, 1), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: rreduction.x WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.x), 1)])(list_adt[(IExpression_adt.variable?)].cdr(rreduction.args)), rreduction.A)"
    "NIL")))
 (|letApply_TCC7| 0
  (|letApply_TCC7-1| NIL 3699206216
   ("" (SUBTYPE-TCC) (("" (GRIND) NIL NIL)) NIL)
   ((|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   NIL
   (|letApply| SUBTYPE "rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)")))
 (|pure_letApply_TCC1| 0
  (|pure_letApply_TCC1-1| NIL 3699206216 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL)
   ((|pure?| DEF-DECL "bool" IL NIL)) NIL
   (|pure_letApply_| SUBTYPE
    "IExpression_adt.letexpr(rreduction.arg1, IExpression_adt.release(IExpression_adt.variable(0, booleans.TRUE), rreduction.B))"
    "(IL.pure?)")))
 (|pure_letApply_TCC2| 0
  (|pure_letApply_TCC2-1| NIL 3699206216 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL)
   ((|pure?| DEF-DECL "bool" IL NIL)) NIL
   (|pure_letApply_| SUBTYPE
    "IExpression_adt.letexpr(rreduction.arg1, rreduction.B)" "(IL.pure?)")))
 (|bump_varlist_TCC1| 0
  (|bump_varlist_TCC1-1| NIL 3699274146 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|bump_varlist| SUBTYPE "rreduction.y" "(IExpression_adt.variable?)")))
 (|bump_varlist_TCC2| 0
  (|bump_varlist_TCC2-1| NIL 3699274146 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|bump_varlist| SUBTYPE
    "rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.y), 1)]"
    "(IExpression_adt.variable?)")))
 (|bump_varlist| 0
  (|bump_varlist-1| NIL 3699274147
   ("" (SKEEP*)
    (("" (EXPAND IN_VARLIST)
      (("" (APPLY-EXTENSIONALITY 1)
        (("1" (DELETE 2)
          (("1" (REWRITE SOME_MAP)
            (("1" (EXPAND BUMP)
              (("1" (EXPAND BUMPN)
                (("1" (EXPAND O)
                  (("1" (REWRITE SOME_NTH)
                    (("1" (REWRITE SOME_NTH)
                      (("1" (IFF)
                        (("1" (GROUND)
                          (("1" (GRIND) NIL NIL)
                           ("2" (SKEEP*) (("2" (GRIND) NIL NIL)) NIL)
                           ("3" (SKEEP*) (("3" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (DELETE 2)
          (("2"
            (CASE-REPLACE "{i |
              some[(variable?)](lambda (v: (variable?)): index(v) = i)(L)} = in_varlist(L)")
            (("1" (GRIND) NIL NIL)
             ("2" (EXPAND IN_VARLIST) (("2" (PROPAX) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (O CONST-DECL "T3" |function_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|some_nth| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|some_map| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|some| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (L SKOLEM-CONST-DECL "list[(variable?)]" |rreduction| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|map| ADT-DEF-DECL "list[T1]" |list_adt_map| NIL))
   SHOSTAK))
 (|vars_letApply| 0
  (|vars_letApply-2| "" 3715587919
   ("" (INDUCT "i")
    (("1" (SKEEP* :PREDS? T)
      (("1" (EXPAND LETAPPLY)
        (("1" (CASE "args = null")
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL)
     ("2" (SKEEP*)
      (("2" (EXPAND LETAPPLY 1)
        (("2" (EXPAND VARS 1 2)
          (("2" (EXPAND VARS 1 3)
            (("2" (EXPAND VARS 1 4)
              (("2" (EXPAND DROP)
                (("2" (EXPAND ADD)
                  (("2" (EXPAND MEMBER)
                    (("2" (EXPAND UNION)
                      (("2" (EXPAND MEMBER)
                        (("2" (EXPAND IN_VARLIST 1)
                          (("2" (NAME "hd" "car(args)")
                            (("2" (NAME "tl" "cdr(args)")
                              (("2" (CASE-REPLACE "args = cons(hd, tl)")
                                (("1" (SIMPLIFY)
                                  (("1" (EXPAND SOME)
                                    (("1" (TYPEPRED "hd")
                                      (("1" (EXPAND VARS 1 1)
                                        (("1" (EXPAND SINGLETON 1)
                                          (("1" (REWRITE -5)
                                            (("1" (REWRITE BUMP_VARLIST)
                                              (("1" (EXPAND BUMP)
                                                (("1" (EXPAND BUMPN)
                                                  (("1" (EXPAND IN_VARLIST 1)
                                                    (("1" (GRIND) NIL NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (GRIND-WITH-EXT) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[T]" |countability| "sets_aux/")
    (|list_cons_extensionality| FORMULA-DECL NIL |list_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bump_varlist| FORMULA-DECL NIL |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|map| ADT-DEF-DECL "list[T1]" |list_adt_map| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|some| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   SHOSTAK)
  (|vars_letApply-1| NIL 3699282159
   ("" (INDUCT I)
    (("1" (SKEEP* :PREDS? T)
      (("1" (EXPAND LETAPPLY)
        (("1" (CASE "args = null")
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL)
     ("2" (SKEEP*)
      (("2" (EXPAND LETAPPLY 1)
        (("2" (EXPAND VARS 1 2)
          (("2" (EXPAND VARS 1 3)
            (("2" (EXPAND VARS 1 4)
              (("2" (EXPAND DROP)
                (("2" (EXPAND ADD)
                  (("2" (EXPAND MEMBER)
                    (("2" (EXPAND UNION)
                      (("2" (EXPAND MEMBER)
                        (("2" (EXPAND IN_VARLIST 1)
                          (("2" (NAME "hd" "car(args)")
                            (("2" (NAME "tl" "cdr(args)")
                              (("2" (CASE-REPLACE "args = cons(hd, tl)")
                                (("1" (SIMPLIFY)
                                  (("1" (EXPAND SOME)
                                    (("1" (TYPEPRED HD)
                                      (("1" (EXPAND VARS 1 1)
                                        (("1" (EXPAND SINGLETON 1)
                                          (("1" (REWRITE -5)
                                            (("1" (REWRITE BUMP_VARLIST)
                                              (("1" (EXPAND BUMP)
                                                (("1" (EXPAND BUMPN)
                                                  (("1" (EXPAND IN_VARLIST 1)
                                                    (("1" (GRIND) NIL NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (GRIND-WITH-EXT) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[T]" |countability| "sets_aux/")
    (|list_cons_extensionality| FORMULA-DECL NIL |list_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bump_varlist| FORMULA-DECL NIL |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL) NIL
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    NIL (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL) NIL
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    NIL (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL))
   SHOSTAK))
 (|popdepth_letApply| 0
  (|popdepth_letApply-1| NIL 3699282706
   ("" (INDUCT I)
    (("1" (SKEEP :PREDS? T) (("1" (GRIND) NIL NIL)) NIL)
     ("2" (SKEEP* :PREDS? T) (("2" (GRIND) NIL NIL)) NIL)
     ("3" (GRIND) NIL NIL))
    NIL)
   ((|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   SHOSTAK))
 (|mark_letApply_cons_TCC1| 0
  (|mark_letApply_cons_TCC1-1| NIL 3699212334 ("" (GRIND) NIL NIL)
   ((|length| DEF-DECL "nat" |list_props| NIL)) NIL
   (|mark_letApply_cons| SUBTYPE
    "list_adt[(IExpression_adt.variable?)].cons(rreduction.x, rreduction.L)"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = (number_fields.+)(1, list_props[(IExpression_adt.variable?)].length(rreduction.L))}")))
 (|mark_letApply_cons_TCC2| 0
  (|mark_letApply_cons_TCC2-1| NIL 3699212334
   ("" (SKEEP*) (("" (REWRITE MAP_LENGTH) NIL NIL)) NIL)
   ((|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|map_length| FORMULA-DECL NIL |more_map_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL))
   NIL
   (|mark_letApply_cons| SUBTYPE
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(rreduction.y), 1)])(rreduction.L)"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = list_props[(IExpression_adt.variable?)].length(rreduction.L)}")))
 (|mark_letApply_cons| 0
  (|mark_letApply_cons-1| NIL 3699212334
   ("" (SKEEP*)
    (("" (EXPAND LETAPPLY 1 1)
      (("" (REWRITE VARS_MARK)
        (("1" (LIFT-IF)
          (("1" (GROUND)
            (("1" (EXPAND MARK 2 1)
              (("1" (DECOMPOSE-EQUALITY)
                (("1" (EXPAND MARK)
                  (("1" (EXPAND MARKV)
                    (("1" (EXPAND UNION)
                      (("1" (EXPAND DROP)
                        (("1" (EXPAND MEMBER)
                          (("1" (EXPAND VARS 1 1)
                            (("1" (EXPAND ADD)
                              (("1" (EXPAND MEMBER)
                                (("1" (REWRITE VARS_LETAPPLY)
                                  (("1" (EXPAND IN_VARLIST)
                                    (("1" (REWRITE SOME_MAP)
                                      (("1" (EXPAND O)
                                        (("1" (LIFT-IF)
                                          (("1" (LIFT-IF)
                                            (("1" (LIFT-IF)
                                              (("1" (GROUND) NIL NIL)) NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND VARS 1 1)
                  (("2" (EXPAND ADD)
                    (("2" (EXPAND MARK 1 1)
                      (("2" (DECOMPOSE-EQUALITY)
                        (("2" (EXPAND MARKV)
                          (("2" (LIFT-IF)
                            (("2" (GROUND)
                              (("2" (EXPAND UNION)
                                (("2" (EXPAND BUMP)
                                  (("2" (EXPAND BUMPN)
                                    (("2" (EXPAND MEMBER)
                                      (("2" (PROPAX) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND MARK 1 1)
              (("2" (DECOMPOSE-EQUALITY)
                (("2" (EXPAND MARK)
                  (("2" (EXPAND MARKV)
                    (("2" (EXPAND UNION)
                      (("2" (EXPAND DROP)
                        (("2" (EXPAND MEMBER)
                          (("2" (REWRITE VARS_LETAPPLY 1)
                            (("2" (EXPAND IN_VARLIST 1)
                              (("2" (REWRITE SOME_MAP 1)
                                (("2" (EXPAND O) (("2" (GRIND) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (REWRITE MAP_LENGTH) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|map_length| FORMULA-DECL NIL |more_map_props| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|vars_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|some_map| FORMULA-DECL NIL |finseq_theorems| NIL)
    (O CONST-DECL "T3" |function_props| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|IExpression_letexpr_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|letexpr| ADT-CONSTRUCTOR-DECL
     "[[IExpression, IExpression] -> (letexpr?)]" |IExpression_adt| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|map| ADT-DEF-DECL "list[T1]" |list_adt_map| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL))
   SHOSTAK))
 (|mark_letApply| 0
  (|mark_letApply-6| "" 3714852783
   ("" (MEASURE-INDUCT "length(L)" "L")
    (("" (SKOLEM 1 "L")
      (("" (FLATTEN)
        (("" (SKEEP*)
          (("" (CASE-REPLACE "L = null")
            (("1" (EXPAND LENGTH 1)
              (("1" (EXPAND LETAPPLY 1)
                (("1" (USE MARK_REPEAT)
                  (("1" (SPLIT -1)
                    (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)
                     ("3" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (NAME "hd" "car(L)")
              (("1" (NAME "tl" "cdr(L)")
                (("1" (CASE-REPLACE "L = cons(hd, tl)")
                  (("1" (EXPAND LENGTH 2)
                    (("1" (REWRITE MARK_LETAPPLY_CONS)
                      (("1" (REWRITE VARS_MARK)
                        (("1" (EXPAND LETAPPLY 2 4)
                          (("1" (EXPAND MARKVARS 2)
                            (("1" (SIMPLIFY)
                              (("1" (REWRITE VARS_LETAPPLY)
                                (("1" (REWRITE VARS_LETAPPLY)
                                  (("1" (REWRITE MARKVARS_BUMP)
                                    (("1" (REWRITE MARKVARS_VARLIST)
                                      (("1" (GROUND)
                                        (("1"
                                          (NAME "u"
                                                "NOT (in_varlist(map(lambda x: x WITH [`index := 1 + index(x)])
                                                (tl))
                                            (0)
                                   OR vars(mark(emptyset)(A))(length(tl)))")
                                          (("1" (REPLACE -1)
                                            (("1" (CASE-REPLACE "u = TRUE")
                                              (("1" (DECOMPOSE-EQUALITY 2)
                                                (("1" (LIFT-IF)
                                                  (("1" (LIFT-IF)
                                                    (("1" (LIFT-IF)
                                                      (("1" (SPLIT 1)
                                                        (("1" (FLATTEN 1)
                                                          (("1" (SPLIT 1)
                                                            (("1"
                                                              (GRIND-WITH-EXT)
                                                              NIL NIL)
                                                             ("2" (FLATTEN 1)
                                                              (("2"
                                                                (REWRITE
                                                                 VARS_MARK -1)
                                                                (("2" (GRIND)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL)
                                                         ("2" (FLATTEN)
                                                          (("2" (SPLIT 4)
                                                            (("1" (FLATTEN)
                                                              (("1" (GRIND) NIL
                                                                NIL))
                                                              NIL)
                                                             ("2"
                                                              (GRIND-WITH-EXT)
                                                              NIL NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (DECOMPOSE-EQUALITY)
                                                  (("2"
                                                    (INST -3
                                                     " map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2" (SPLIT -3)
                                                      (("1"
                                                        (REWRITE MAP_LENGTH)
                                                        (("1" (REWRITE -1)
                                                          (("1"
                                                            (REWRITE
                                                             BUMP_VARLIST)
                                                            (("1"
                                                              (HIDE-ALL-BUT
                                                               (1 -4))
                                                              (("1" (SKEEP*)
                                                                (("1"
                                                                  (EXPAND BUMP)
                                                                  (("1"
                                                                    (EXPAND
                                                                     BUMPN)
                                                                    (("1"
                                                                      (FLATTEN)
                                                                      (("1"
                                                                        (INST
                                                                         -4 "i"
                                                                         "j-1")
                                                                        (("1"
                                                                          (EXPAND
                                                                           IN_VARLIST)
                                                                          (("1"
                                                                            (EXPAND
                                                                             SOME
                                                                             -4)
                                                                            (("1"
                                                                              (GRIND)
                                                                              NIL
                                                                              NIL))
                                                                            NIL))
                                                                          NIL)
                                                                         ("2"
                                                                          (GRIND)
                                                                          NIL
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2"
                                                        (REWRITE MAP_LENGTH)
                                                        (("2" (GRIND) NIL NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL)
                                               ("2" (CASE-REPLACE "u = FALSE")
                                                (("1" (DECOMPOSE-EQUALITY 2)
                                                  (("1" (LIFT-IF)
                                                    (("1" (LIFT-IF)
                                                      (("1" (LIFT-IF)
                                                        (("1" (SPLIT 1)
                                                          (("1" (FLATTEN 1)
                                                            (("1" (SPLIT 1)
                                                              (("1"
                                                                (GRIND-WITH-EXT)
                                                                NIL NIL)
                                                               ("2" (FLATTEN 1)
                                                                (("2"
                                                                  (REWRITE
                                                                   VARS_MARK)
                                                                  (("2" (GRIND)
                                                                    NIL NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (FLATTEN)
                                                            (("2" (SPLIT 4)
                                                              (("1" (FLATTEN)
                                                                (("1" (GRIND)
                                                                  NIL NIL))
                                                                NIL)
                                                               ("2"
                                                                (GRIND-WITH-EXT)
                                                                NIL NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2"
                                                    (INST -2
                                                     "map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2" (SPLIT -2)
                                                      (("1"
                                                        (REWRITE MAP_LENGTH)
                                                        (("1" (REWRITE -1)
                                                          (("1"
                                                            (HIDE-ALL-BUT
                                                             (1 -3))
                                                            (("1" (SKEEP*)
                                                              (("1"
                                                                (REWRITE
                                                                 BUMP_VARLIST)
                                                                (("1"
                                                                  (EXPAND BUMP)
                                                                  (("1"
                                                                    (EXPAND
                                                                     BUMPN)
                                                                    (("1"
                                                                      (INST -3
                                                                       "i"
                                                                       "j - 1")
                                                                      (("1"
                                                                        (EXPAND
                                                                         IN_VARLIST)
                                                                        (("1"
                                                                          (EXPAND
                                                                           SOME
                                                                           -3)
                                                                          (("1"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL)
                                                                       ("2"
                                                                        (GRIND)
                                                                        NIL
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2"
                                                        (REWRITE MAP_LENGTH)
                                                        (("2" (GRIND) NIL NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (GRIND) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (REWRITE MAP_LENGTH)
                                    (("2" (GRIND) NIL NIL)) NIL))
                                  NIL)
                                 ("2" (REWRITE MAP_LENGTH) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (REWRITE MAP_LENGTH) NIL NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND-WITH-EXT) NIL NIL))
                  NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|mark_letApply_cons| FORMULA-DECL NIL |rreduction| NIL)
    (|markvars_varlist| FORMULA-DECL NIL |preprocess| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|j| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|bump_varlist| FORMULA-DECL NIL |rreduction| NIL)
    (|map_length| FORMULA-DECL NIL |more_map_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|IExpression_variable_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|IExpression_letexpr_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|letexpr| ADT-CONSTRUCTOR-DECL
     "[[IExpression, IExpression] -> (letexpr?)]" |IExpression_adt| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|unmarkvar| CONST-DECL "(variable?)" |preprocess| NIL)
    (|markvar| CONST-DECL "(variable?)" |preprocess| NIL)
    (|j| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|markvars_bump| FORMULA-DECL NIL |preprocess| NIL)
    (|vars_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|map| ADT-DEF-DECL "list[T1]" |list_adt_map| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|list_cons_extensionality| FORMULA-DECL NIL |list_adt| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|mark_repeat| FORMULA-DECL NIL |preprocess| NIL)
    (|some| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|markvars| DEF-DECL "{J | length(J) = length(L)}" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL))
   SHOSTAK)
  (|mark_letApply-5| "" 3699274034
   ("" (MEASURE-INDUCT "length(L)" "L")
    (("" (SKOLEM 1 "L")
      (("" (FLATTEN)
        (("" (SKEEP*)
          (("" (CASE-REPLACE "L = null")
            (("1" (EXPAND LENGTH 1)
              (("1" (EXPAND LETAPPLY 1)
                (("1" (USE MARK_REPEAT)
                  (("1" (SPLIT -1)
                    (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)
                     ("3" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (NAME "hd" "car(L)")
              (("1" (NAME "tl" "cdr(L)")
                (("1" (CASE-REPLACE "L = cons(hd, tl)")
                  (("1" (EXPAND LENGTH 2)
                    (("1" (REWRITE MARK_LETAPPLY_CONS)
                      (("1" (REWRITE VARS_MARK)
                        (("1" (EXPAND LETAPPLY 2 4)
                          (("1" (EXPAND MARKVARS 2)
                            (("1" (SIMPLIFY)
                              (("1" (REWRITE VARS_LETAPPLY)
                                (("1" (REWRITE VARS_LETAPPLY)
                                  (("1" (REWRITE MARKVARS_BUMP)
                                    (("1" (REWRITE MARKVARS_VARLIST)
                                      (("1" (GROUND)
                                        (("1"
                                          (NAME "u"
                                                "NOT (in_varlist(map(lambda x: x WITH [`index := 1 + index(x)])
                             (tl))
                         (0)
                OR vars(mark(emptyset)(A))(length(tl)))")
                                          (("1" (REPLACE -1)
                                            (("1" (CASE-REPLACE "u = TRUE")
                                              (("1" (DECOMPOSE-EQUALITY 3)
                                                (("1" (LIFT-IF)
                                                  (("1" (LIFT-IF)
                                                    (("1" (LIFT-IF)
                                                      (("1" (SPLIT 1)
                                                        (("1" (FLATTEN 1)
                                                          (("1" (SPLIT 1)
                                                            (("1"
                                                              (GRIND-WITH-EXT)
                                                              NIL NIL)
                                                             ("2" (FLATTEN 1)
                                                              (("2"
                                                                (REWRITE
                                                                 VARS_MARK -1)
                                                                (("2" (GRIND)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL)
                                                         ("2" (FLATTEN)
                                                          (("2" (SPLIT 4)
                                                            (("1" (FLATTEN)
                                                              (("1" (GRIND) NIL
                                                                NIL))
                                                              NIL)
                                                             ("2"
                                                              (GRIND-WITH-EXT)
                                                              NIL NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (DECOMPOSE-EQUALITY)
                                                  (("2"
                                                    (INST -3
                                                     " map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2" (SPLIT -3)
                                                      (("1"
                                                        (REWRITE MAP_LENGTH)
                                                        (("1" (REWRITE -1)
                                                          (("1"
                                                            (REWRITE
                                                             BUMP_VARLIST)
                                                            (("1"
                                                              (HIDE-ALL-BUT
                                                               (1 -4))
                                                              (("1" (SKEEP*)
                                                                (("1"
                                                                  (EXPAND BUMP)
                                                                  (("1"
                                                                    (EXPAND
                                                                     BUMPN)
                                                                    (("1"
                                                                      (FLATTEN)
                                                                      (("1"
                                                                        (INST
                                                                         -4 "i"
                                                                         "j-1")
                                                                        (("1"
                                                                          (EXPAND
                                                                           IN_VARLIST)
                                                                          (("1"
                                                                            (EXPAND
                                                                             SOME
                                                                             -4)
                                                                            (("1"
                                                                              (GRIND)
                                                                              NIL
                                                                              NIL))
                                                                            NIL))
                                                                          NIL)
                                                                         ("2"
                                                                          (GRIND)
                                                                          NIL
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2"
                                                        (REWRITE MAP_LENGTH)
                                                        (("2" (GRIND) NIL NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL)
                                               ("2" (CASE-REPLACE "u = FALSE")
                                                (("1" (DECOMPOSE-EQUALITY 2)
                                                  (("1" (LIFT-IF)
                                                    (("1" (LIFT-IF)
                                                      (("1" (LIFT-IF)
                                                        (("1" (SPLIT 1)
                                                          (("1" (FLATTEN 1)
                                                            (("1" (SPLIT 1)
                                                              (("1"
                                                                (GRIND-WITH-EXT)
                                                                NIL NIL)
                                                               ("2" (FLATTEN 1)
                                                                (("2"
                                                                  (REWRITE
                                                                   VARS_MARK)
                                                                  (("2" (GRIND)
                                                                    NIL NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (FLATTEN)
                                                            (("2" (SPLIT 4)
                                                              (("1" (FLATTEN)
                                                                (("1" (GRIND)
                                                                  NIL NIL))
                                                                NIL)
                                                               ("2"
                                                                (GRIND-WITH-EXT)
                                                                NIL NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2"
                                                    (INST -3
                                                     "map(lambda y: y WITH [`index := 1 + index(y)])(tl)")
                                                    (("2" (SPLIT -3)
                                                      (("1"
                                                        (REWRITE MAP_LENGTH)
                                                        (("1" (REWRITE -1)
                                                          (("1"
                                                            (HIDE-ALL-BUT
                                                             (1 -4))
                                                            (("1" (SKEEP*)
                                                              (("1"
                                                                (REWRITE
                                                                 BUMP_VARLIST)
                                                                (("1"
                                                                  (EXPAND BUMP)
                                                                  (("1"
                                                                    (EXPAND
                                                                     BUMPN)
                                                                    (("1"
                                                                      (INST -3
                                                                       "i"
                                                                       "j - 1")
                                                                      (("1"
                                                                        (EXPAND
                                                                         IN_VARLIST)
                                                                        (("1"
                                                                          (EXPAND
                                                                           SOME
                                                                           -3)
                                                                          (("1"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL)
                                                                       ("2"
                                                                        (GRIND)
                                                                        NIL
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2"
                                                        (REWRITE MAP_LENGTH)
                                                        (("2" (GRIND) NIL NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (GRIND) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (REWRITE MAP_LENGTH)
                                    (("2" (GRIND) NIL NIL)) NIL))
                                  NIL)
                                 ("2" (REWRITE MAP_LENGTH) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (REWRITE MAP_LENGTH) NIL NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND-WITH-EXT) NIL NIL))
                  NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL)
    (|mark_letApply_cons| FORMULA-DECL NIL |rreduction| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|markvars_varlist| FORMULA-DECL NIL |preprocess| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|bump_varlist| FORMULA-DECL NIL |rreduction| NIL)
    (|map_length| FORMULA-DECL NIL |more_map_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|IExpression_variable_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|IExpression_letexpr_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|markvar| CONST-DECL "(variable?)" |preprocess| NIL)
    (|unmarkvar| CONST-DECL "(variable?)" |preprocess| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|letexpr| ADT-CONSTRUCTOR-DECL
     "[[IExpression, IExpression] -> (letexpr?)]" |IExpression_adt| NIL)
    (|markvars_bump| FORMULA-DECL NIL |preprocess| NIL)
    (|vars_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|list_cons_extensionality| FORMULA-DECL NIL |list_adt| NIL)
    (|cdr| ADT-ACCESSOR-DECL "[(cons?) -> list]" |list_adt| NIL)
    (|mark_repeat| FORMULA-DECL NIL |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|null?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|null| ADT-CONSTRUCTOR-DECL "(null?)" |list_adt| NIL)
    (|markvars| DEF-DECL "{J | length(J) = length(L)}" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL)
    (|well_founded?| CONST-DECL "bool" |orders| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK)
  (|mark_letApply-4| "" 3699215143
   ("" (MEASURE-INDUCT "length(L)" "L")
    (("" (SKOLEM 1 "L")
      (("" (FLATTEN)
        (("" (SKEEP*)
          (("" (CASE-REPLACE "L = null")
            (("1" (EXPAND LENGTH 1)
              (("1" (EXPAND LETAPPLY 1)
                (("1" (USE MARK_REPEAT) (("1" (POSTPONE) NIL NIL)) NIL)) NIL))
              NIL)
             ("2" (POSTPONE) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK)
  (|mark_letApply-3| "" 3699209434
   ("" (MEASURE-INDUCT "length(L)" "L")
    (("" (SKOLEM 1 ("L"))
      (("" (FLATTEN)
        (("" (SKEEP*)
          (("" (EXPAND LETAPPLY 1)
            (("" (LIFT-IF)
              (("" (SPLIT)
                (("1" (USE MARK_REPEAT) (("1" (POSTPONE) NIL NIL)) NIL)
                 ("2" (POSTPONE) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK)
  (|mark_letApply-2| "" 3698756834
   ("" (MEASURE-INDUCT+ "length(L)" ("L"))
    (("" (NAME-REPLACE "L" "x!1")
      (("" (SKEEP*)
        (("" (EXPAND LETAPPLY 1)
          (("" (LIFT-IF)
            (("" (SPLIT)
              (("1" (USE MARK_REPEAT)
                (("1" (FLATTEN)
                  (("1" (SPLIT -1)
                    (("1" (PROPAX) NIL NIL)
                     ("2" (SKEEP*)
                      (("2" (INST -4 I) (("2" (GRIND) NIL NIL)) NIL)) NIL)
                     ("3" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (NAME "hd" "car(L)")
                (("1" (NAME "tl" "cdr(L)")
                  (("1" (CASE-REPLACE "L = cons(hd, tl)")
                    (("1" (FLATTEN)
                      (("1" (LIFT-IF)
                        (("1" (LIFT-IF)
                          (("1" (REWRITE VARS_LETAPPLY)
                            (("1" (REWRITE VARS_LETAPPLY)
                              (("1" (EXPAND MARKVARS 2)
                                (("1" (SIMPLIFY)
                                  (("1" (REWRITE MARKVARS_BUMP)
                                    (("1" (REWRITE MARKVARS_VARLIST)
                                      (("1" (REWRITE VARS_MARK)
                                        (("1" (EXPAND LENGTH 2 1)
                                          (("1" (SPLIT)
                                            (("1" (FLATTEN)
                                              (("1" (EXPAND MARK 3 1)
                                                (("1" (DECOMPOSE-EQUALITY 3)
                                                  (("1" (EXPAND MARK 1 1)
                                                    (("1" (EXPAND MARKV 1 1)
                                                      (("1" (LIFT-IF)
                                                        (("1" (LIFT-IF)
                                                          (("1" (LIFT-IF)
                                                            (("1" (SPLIT 1)
                                                              (("1" (FLATTEN)
                                                                (("1" (SPLIT 1)
                                                                  (("1"
                                                                    (GRIND-WITH-EXT)
                                                                    NIL NIL)
                                                                   ("2"
                                                                    (FLATTEN)
                                                                    (("2"
                                                                      (EXPAND
                                                                       UNION
                                                                       -1)
                                                                      (("2"
                                                                        (EXPAND
                                                                         DROP
                                                                         -1)
                                                                        (("2"
                                                                          (EXPAND
                                                                           VARS
                                                                           -1)
                                                                          (("2"
                                                                            (EXPAND
                                                                             ADD
                                                                             -1)
                                                                            (("2"
                                                                              (EXPAND
                                                                               MEMBER)
                                                                              (("2"
                                                                                (EXPAND
                                                                                 LENGTH
                                                                                 -1)
                                                                                (("2"
                                                                                  (REWRITE
                                                                                   VARS_LETAPPLY)
                                                                                  (("1"
                                                                                    (EXPAND
                                                                                     IN_VARLIST)
                                                                                    (("1"
                                                                                      (REWRITE
                                                                                       SOME_MAP)
                                                                                      (("1"
                                                                                        (EXPAND
                                                                                         O)
                                                                                        (("1"
                                                                                          (REWRITE
                                                                                           VARS_MARK)
                                                                                          (("1"
                                                                                            (GRIND)
                                                                                            (("1"
                                                                                              (INST?
                                                                                               -4)
                                                                                              (("1"
                                                                                                (GRIND)
                                                                                                NIL
                                                                                                NIL))
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL)
                                                                                   ("2"
                                                                                    (REWRITE
                                                                                     MAP_LENGTH)
                                                                                    NIL
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL)
                                                               ("2" (FLATTEN)
                                                                (("2" (SPLIT 2)
                                                                  (("1"
                                                                    (FLATTEN)
                                                                    (("1"
                                                                      (EXPAND
                                                                       UNION 2)
                                                                      (("1"
                                                                        (EXPAND
                                                                         DROP
                                                                         2)
                                                                        (("1"
                                                                          (EXPAND
                                                                           VARS
                                                                           2)
                                                                          (("1"
                                                                            (EXPAND
                                                                             LENGTH
                                                                             2)
                                                                            (("1"
                                                                              (EXPAND
                                                                               ADD
                                                                               2)
                                                                              (("1"
                                                                                (EXPAND
                                                                                 MEMBER
                                                                                 2)
                                                                                (("1"
                                                                                  (REWRITE
                                                                                   VARS_LETAPPLY)
                                                                                  (("1"
                                                                                    (EXPAND
                                                                                     IN_VARLIST)
                                                                                    (("1"
                                                                                      (REWRITE
                                                                                       SOME_MAP)
                                                                                      (("1"
                                                                                        (EXPAND
                                                                                         O)
                                                                                        (("1"
                                                                                          (REWRITE
                                                                                           VARS_MARK)
                                                                                          (("1"
                                                                                            (GRIND)
                                                                                            NIL
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL)
                                                                   ("2"
                                                                    (GRIND-WITH-EXT)
                                                                    NIL NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (EXPAND VARS 1 1)
                                                    (("2" (EXPAND ADD 1 1)
                                                      (("2" (EXPAND MARK 1 1)
                                                        (("2"
                                                          (DECOMPOSE-EQUALITY
                                                           1)
                                                          (("1" (EXPAND MARKV)
                                                            (("1" (LIFT-IF)
                                                              (("1" (SPLIT)
                                                                (("1"
                                                                  (EXPAND
                                                                   LENGTH 1)
                                                                  (("1"
                                                                    (EXPAND
                                                                     UNION 1)
                                                                    (("1"
                                                                      (EXPAND
                                                                       MEMBER
                                                                       1)
                                                                      (("1"
                                                                        (EXPAND
                                                                         BUMP
                                                                         1)
                                                                        (("1"
                                                                          (EXPAND
                                                                           BUMPN
                                                                           1)
                                                                          (("1"
                                                                            (REWRITE
                                                                             VARS_LETAPPLY)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL)
                                                                 ("2" (PROPAX)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2"
                                                            (EXPAND LENGTH 1)
                                                            (("2"
                                                              (INST -2
                                                               "map(lambda x: x WITH [(index) := 1 + index(x)])(tl)")
                                                              (("2" (INST? -2)
                                                                (("2"
                                                                  (INST? -2)
                                                                  (("2"
                                                                    (SPLIT -2)
                                                                    (("1"
                                                                      (REWRITE
                                                                       MAP_LENGTH)
                                                                      NIL NIL)
                                                                     ("2"
                                                                      (REWRITE
                                                                       MAP_LENGTH)
                                                                      (("2"
                                                                        (EXPAND
                                                                         LENGTH
                                                                         -2)
                                                                        (("2"
                                                                          (SKEEP*)
                                                                          (("2"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL)
                                                                     ("3"
                                                                      (REWRITE
                                                                       MAP_LENGTH)
                                                                      (("3"
                                                                        (GRIND)
                                                                        NIL
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2" (FLATTEN)
                                              (("2" (EXPAND LENGTH 1)
                                                (("2" (SPLIT 1)
                                                  (("1" (FLATTEN)
                                                    (("1" (EXPAND MARK 3 1)
                                                      (("1"
                                                        (DECOMPOSE-EQUALITY)
                                                        NIL NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (FLATTEN)
                                                    (("2" (EXPAND MARK 1 1)
                                                      (("2"
                                                        (DECOMPOSE-EQUALITY)
                                                        (("1" (EXPAND MARK 1 1)
                                                          (("1" (EXPAND MARKV)
                                                            (("1" (LIFT-IF)
                                                              (("1" (LIFT-IF)
                                                                (("1" (LIFT-IF)
                                                                  (("1" (SPLIT)
                                                                    (("1"
                                                                      (FLATTEN)
                                                                      (("1"
                                                                        (SPLIT
                                                                         1)
                                                                        (("1"
                                                                          (GRIND-WITH-EXT)
                                                                          NIL
                                                                          NIL)
                                                                         ("2"
                                                                          (FLATTEN)
                                                                          (("2"
                                                                            (EXPAND
                                                                             UNION
                                                                             -1)
                                                                            (("2"
                                                                              (EXPAND
                                                                               DROP
                                                                               -1)
                                                                              (("2"
                                                                                (EXPAND
                                                                                 MEMBER
                                                                                 -1)
                                                                                (("2"
                                                                                  (REWRITE
                                                                                   VARS_LETAPPLY)
                                                                                  (("1"
                                                                                    (EXPAND
                                                                                     IN_VARLIST)
                                                                                    (("1"
                                                                                      (REWRITE
                                                                                       SOME_MAP)
                                                                                      (("1"
                                                                                        (EXPAND
                                                                                         O)
                                                                                        (("1"
                                                                                          (REWRITE
                                                                                           VARS_MARK)
                                                                                          (("1"
                                                                                            (SPLIT
                                                                                             -1)
                                                                                            (("1"
                                                                                              (PROPAX)
                                                                                              NIL
                                                                                              NIL)
                                                                                             ("2"
                                                                                              (INST?
                                                                                               -6)
                                                                                              (("2"
                                                                                                (GRIND)
                                                                                                NIL
                                                                                                NIL))
                                                                                              NIL)
                                                                                             ("3"
                                                                                              (PROPAX)
                                                                                              NIL
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL)
                                                                                   ("2"
                                                                                    (REWRITE
                                                                                     MAP_LENGTH)
                                                                                    NIL
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL)
                                                                     ("2"
                                                                      (FLATTEN)
                                                                      (("2"
                                                                        (EXPAND
                                                                         UNION
                                                                         1)
                                                                        (("2"
                                                                          (EXPAND
                                                                           DROP
                                                                           1)
                                                                          (("2"
                                                                            (EXPAND
                                                                             MEMBER)
                                                                            (("2"
                                                                              (REWRITE
                                                                               VARS_LETAPPLY)
                                                                              (("2"
                                                                                (EXPAND
                                                                                 IN_VARLIST)
                                                                                (("2"
                                                                                  (REWRITE
                                                                                   SOME_MAP
                                                                                   1)
                                                                                  (("2"
                                                                                    (EXPAND
                                                                                     O)
                                                                                    (("2"
                                                                                      (SPLIT
                                                                                       2)
                                                                                      (("1"
                                                                                        (FLATTEN)
                                                                                        (("1"
                                                                                          (GRIND)
                                                                                          NIL
                                                                                          NIL))
                                                                                        NIL)
                                                                                       ("2"
                                                                                        (GRIND-WITH-EXT)
                                                                                        NIL
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL)
                                                         ("2"
                                                          (REWRITE
                                                           VARS_LETAPPLY)
                                                          (("1" (LIFT-IF)
                                                            (("1" (SPLIT)
                                                              (("1" (FLATTEN)
                                                                (("1"
                                                                  (INST? -5)
                                                                  (("1"
                                                                    (INST? -5)
                                                                    (("1"
                                                                      (SPLIT
                                                                       -5)
                                                                      (("1"
                                                                        (REWRITE
                                                                         MAP_LENGTH)
                                                                        NIL
                                                                        NIL)
                                                                       ("2"
                                                                        (REWRITE
                                                                         MAP_LENGTH)
                                                                        (("2"
                                                                          (SPLIT
                                                                           -3)
                                                                          (("1"
                                                                            (EXPAND
                                                                             IN_VARLIST)
                                                                            (("1"
                                                                              (REWRITE
                                                                               SOME_MAP)
                                                                              (("1"
                                                                                (EXPAND
                                                                                 O)
                                                                                (("1"
                                                                                  (REWRITE
                                                                                   SOME_NTH)
                                                                                  (("1"
                                                                                    (GRIND)
                                                                                    NIL
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL)
                                                                           ("2"
                                                                            (POSTPONE)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL)
                                                                       ("3"
                                                                        (POSTPONE)
                                                                        NIL
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL)
                                                               ("2" (POSTPONE)
                                                                NIL NIL))
                                                              NIL))
                                                            NIL)
                                                           ("2" (POSTPONE) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL)
                               ("2" (POSTPONE) NIL NIL)
                               ("3" (POSTPONE) NIL NIL))
                              NIL)
                             ("2" (POSTPONE) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (POSTPONE) NIL NIL))
                    NIL))
                  NIL)
                 ("2" (POSTPONE) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK)
  (|mark_letApply-1| NIL 3693496107
   ("" (INDUCT "L")
    (("1" (GRIND)
      (("1" (LEMMA "mark_idem") (("1" (INST?) (("1" (POSTPONE) NIL NIL)) NIL))
        NIL)
       ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL))
      NIL)
     ("2" (POSTPONE) NIL NIL))
    NIL)
   NIL SHOSTAK))
 (|mark_letApply_weak| 0
  (|mark_letApply_weak-1| NIL 3699274870
   ("" (SKEEP*)
    (("" (USE MARK_LETAPPLY)
      (("" (SPLIT -1)
        (("1" (PROPAX) NIL NIL) ("2" (SKEEP*) (("2" (GRIND) NIL NIL)) NIL)
         ("3" (SKEEP*) (("3" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|mark_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/"))
   SHOSTAK))
 (|release_marked_correct_redex| 0
  (|release_marked_correct_redex-1| NIL 3701113253
   ("" (SKEEP)
    (("" (TYPEPRED "rS`redex")
      (("" (SPLIT 3)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)
         ("6" (EXPAND MARK 1)
          (("6" (DECOMPOSE-EQUALITY 1) (("6" (GRIND-WITH-EXT) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|IExpression_variable_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|release_marked_correct_count| 0
  (|release_marked_correct_count-1| NIL 3701114067
   ("" (SKEEP)
    (("" (TYPEPRED "rS`count(x1)")
      (("" (REWRITE -1) (("" (EXPAND REFCOUNT) (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|release_marked_TCC1| 0
  (|release_marked_TCC1-2| "" 3715588372
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (EXPAND REFS)
        (("1" (TYPEPRED "rS`redex") (("1" (PROPAX) NIL NIL)) NIL)) NIL)
       ("2" (EXPAND VARS)
        (("2" (EXPAND POPDEPTH)
          (("2" (TYPEPRED "rS`redex")
            (("2" (SKEEP) (("2" (INST -2 "i") (("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (EXPAND POPDEPTH 1 1)
        (("3" (TYPEPRED "rS`redex") (("3" (PROPAX) NIL NIL)) NIL)) NIL)
       ("4" (EXPAND POPDEPTH 1 1)
        (("4" (TYPEPRED "rS`redex") (("4" (PROPAX) NIL NIL)) NIL)) NIL)
       ("5" (EXPAND CONTEXTPURE?) (("5" (PROPAX) NIL NIL)) NIL)
       ("6" (EXPAND MARK)
        (("6" (TYPEPRED "rS`redex")
          (("6" (REPLACE -6)
            (("6" (DECOMPOSE-EQUALITY 1)
              (("6" (EXPAND MARKV)
                (("6" (LIFT-IF)
                  (("6" (GROUND)
                    (("1" (EXPAND UNION)
                      (("1" (TYPEPRED "x") (("1" (GRIND) NIL NIL)) NIL)) NIL)
                     ("2" (GRIND-WITH-EXT) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (|IExpression_variable_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|release_marked| SUBTYPE
    "IExpression_adt.release(rreduction.x, rreduction.rS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}"))
  (|release_marked_TCC1-1| NIL 3699016249
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (EXPAND REFS)
        (("1" (TYPEPRED "rS`redex") (("1" (PROPAX) NIL NIL)) NIL)) NIL)
       ("2" (EXPAND VARS)
        (("2" (EXPAND POPDEPTH)
          (("2" (TYPEPRED "rS`redex")
            (("2" (SKEEP) (("2" (INST -2 I) (("2" (GRIND) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("3" (EXPAND POPDEPTH 1 1)
        (("3" (TYPEPRED "rS`redex") (("3" (PROPAX) NIL NIL)) NIL)) NIL)
       ("4" (EXPAND POPDEPTH 1 1)
        (("4" (TYPEPRED "rS`redex") (("4" (PROPAX) NIL NIL)) NIL)) NIL)
       ("5" (EXPAND CONTEXTPURE?) (("5" (PROPAX) NIL NIL)) NIL)
       ("6" (EXPAND MARK)
        (("6" (TYPEPRED "rS`redex")
          (("6" (REPLACE -6)
            (("6" (DECOMPOSE-EQUALITY 1)
              (("6" (EXPAND MARKV)
                (("6" (LIFT-IF)
                  (("6" (GROUND)
                    (("1" (EXPAND UNION)
                      (("1" (TYPEPRED X) (("1" (GRIND) NIL NIL)) NIL)) NIL)
                     ("2" (GRIND-WITH-EXT) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (|IExpression_variable_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|release_marked| SUBTYPE
    "IExpression_adt.release(rreduction.x, rreduction.rS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}")))
 (|release_marked_TCC2| 0
  (|release_marked_TCC2-1| NIL 3699016249
   ("" (SKEEP*)
    (("" (TYPEPRED "rS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR)
            (("" (EXPAND REFS 1 2) (("" (PROPAX) NIL NIL)) NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|release_marked| SUBTYPE "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, IExpression_adt.release(rreduction.x, rreduction.rS`redex))(i)}]")))
 (|pure_count_keep| 0
  (|pure_count_keep-1| NIL 3700328221
   ("" (SKEEP*)
    (("" (TYPEPRED "rS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR)
            (("" (USE PURE_REFS)
              (("" (ASSERT)
                (("" (LIFT-IF)
                  (("" (GROUND)
                    (("" (USE PURE_REFS) (("" (ASSERT) NIL NIL)) NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|applyReduce_correct_redex_TCC1| 0
  (|applyReduce_correct_redex_TCC1-1| NIL 3700325321 ("" (SUBTYPE-TCC) NIL NIL)
   ((|applyRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|applyReduce_correct_redex| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.application?)")))
 (|applyReduce_correct_redex_TCC2| 0
  (|applyReduce_correct_redex_TCC2-1| NIL 3700325321 ("" (SUBTYPE-TCC) NIL NIL)
   ((|applyRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|applyReduce_correct_redex| SUBTYPE
    "IExpression_adt.args(rreduction.grS`redex)"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = rreduction.arity}")))
 (|applyReduce_correct_redex| 0
  (|applyReduce_correct_redex-1| NIL 3700326018
   (""
    (WITH-LABELS (SKEEP* :PREDS? T)
     ((ERR ARITY_POS A_PURE VARS_A APR ARITY_LEN OBJ)))
    (("" (SIMPLIFY :LET-REDUCE? T)
      (("" (SPLIT OBJ)
        (("1" (SKEEP)
          (("1" (USE PURE_REFS)
            (("1" (USE PURE_LETAPPLY)
              (("1" (GRIND) NIL NIL)
               ("2" (USE PURE_MARK) (("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL)
         ("2" (WITH-LABELS (SKEEP) ((IVARS OBJ)))
          (("2" (REWRITE POPDEPTH_LETAPPLY)
            (("2" (LIFT-IF)
              (("2" (REWRITE VARS_LETAPPLY)
                (("2" (REWRITE VARS_MARK)
                  (("2" (SPLIT IVARS)
                    (("1" (TYPEPRED "grS`redex")
                      (("1" (REWRITE PUREPOPDEPTH)
                        (("1" (REWRITE PUREPOPDEPTH)
                          (("1" (REWRITE PUREPOPDEPTH)
                            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
                             ("3" (GRIND) NIL NIL))
                            NIL)
                           ("2" (USE PURE_MARK) (("2" (GRIND) NIL NIL)) NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("3" (SKEEP*)
          (("3" (REWRITE PUREPOPDEPTH)
            (("1" (TYPEPRED "grS`redex") (("1" (GRIND) NIL NIL)) NIL)
             ("2" (USE PURE_LETAPPLY) (("2" (REWRITE PURE_MARK) NIL NIL)) NIL))
            NIL))
          NIL)
         ("4" (REWRITE PUREPOPDEPTH)
          (("1" (TYPEPRED "grS`redex") (("1" (GRIND) NIL NIL)) NIL)
           ("2" (USE PURE_LETAPPLY) (("2" (REWRITE PURE_MARK) NIL NIL)) NIL))
          NIL)
         ("5" (USE PURE_CONTEXTPURE)
          (("5" (USE PURE_LETAPPLY)
            (("1" (GRIND) NIL NIL) ("2" (REWRITE PURE_MARK) NIL NIL)) NIL))
          NIL)
         ("6" (USE MARK_LETAPPLY_WEAK)
          (("6" (REPLACE ARITY_LEN)
            (("6" (REWRITE MARK_LETAPPLY_WEAK)
              (("6"
                (WITH-LABELS
                 (CASE-REPLACE
                  "markvars(cvars(grS`context))(args(grS`redex)) = args(grS`redex)")
                 ((MVA)))
                (("6" (TYPEPRED "grS`redex")
                  (("6" (APPLY-ETA "grS`redex" "(application?)")
                    (("6" (REPLACE -1 :DIR RL)
                      (("6" (EXPAND MARK -)
                        (("6" (DELETE OBJ)
                          (("6" (SIMPLIFY)
                            (("6" (DECOMPOSE-EQUALITY -7) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|mark_letApply_weak| FORMULA-DECL NIL |rreduction| NIL)
    (|fun| ADT-ACCESSOR-DECL "[(application?) -> nat]" |IExpression_adt| NIL)
    (|application| ADT-CONSTRUCTOR-DECL
     "[[nat, list[(variable?)]] -> (application?)]" |IExpression_adt| NIL)
    (|IExpression_application_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|markvars| DEF-DECL "{J | length(J) = length(L)}" |preprocess| NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|some| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL)
    (|car| ADT-ACCESSOR-DECL "[(cons?) -> T]" |list_adt| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|vars_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|popdepth_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|arity| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (A SKOLEM-CONST-DECL
     "{A | pure?(A) AND FORALL i: vars(A)(i) IMPLIES i < arity}" |rreduction|
     NIL)
    (|pure_letApply| RECURSIVE-JUDGEMENT-AXIOM NIL |rreduction| NIL)
    (|pure_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL) (|pure?| DEF-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|args| ADT-ACCESSOR-DECL "[(application?) -> list[(variable?)]]"
     |IExpression_adt| NIL)
    (|application?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|applyReduce_correct_count| 0
  (|applyReduce_correct_count-1| NIL 3700328153
   ("" (SKEEP*)
    (("" (USE PURE_COUNT_KEEP)
      (("" (SPLIT)
        (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)
         ("3" (USE PURE_LETAPPLY) (("3" (REWRITE PURE_MARK) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure_count_keep| FORMULA-DECL NIL |rreduction| NIL)
    (A SKOLEM-CONST-DECL "IExpression" |rreduction| NIL)
    (|pure_letApply| RECURSIVE-JUDGEMENT-AXIOM NIL |rreduction| NIL)
    (|pure_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|applyReduce_TCC1| 0
  (|applyReduce_TCC1-1| NIL 3676345135 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|applyReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.application?)")))
 (|applyReduce_TCC2| 0
  (|applyReduce_TCC2-1| NIL 3676345135
   ("" (SKEEP*) (("" (ASSERT) NIL NIL)) NIL)
   ((|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|applyReduce| SUBTYPE "rreduction.args"
    "{args: list_adt[(IExpression_adt.variable?)].list | list_props[(IExpression_adt.variable?)].length(args) = rreduction.arity}")))
 (|applyReduce_TCC3| 0
  (|applyReduce_TCC3-2| "" 3715588466
   ("" (SKEEP*)
    (("" (USE APPLYREDUCE_CORRECT_REDEX)
      (("" (SPLIT -1)
        (("1" (GRIND) NIL NIL)
         ("2" (TYPEPRED "grS") (("2" (PROPAX) NIL NIL)) NIL)
         ("3" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|applyReduce_correct_redex| FORMULA-DECL NIL |rreduction| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|applyReduce| SUBTYPE
    "rreduction.letApply(rreduction.arity, rreduction.args, preprocess.mark(sets[naturalnumbers.nat].emptyset)(rreduction.body))"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|applyReduce_TCC3-1| NIL 3676345135
   ("" (SKEEP*)
    (("" (USE APPLYREDUCE_CORRECT_REDEX)
      (("" (SPLIT -1)
        (("1" (GRIND) NIL NIL)
         ("2" (TYPEPRED GRS) (("2" (PROPAX) NIL NIL)) NIL)
         ("3" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|applyReduce_correct_redex| FORMULA-DECL NIL |rreduction| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|applyReduce| SUBTYPE
    "rreduction.letApply(rreduction.arity, rreduction.args, preprocess.mark(sets[naturalnumbers.nat].emptyset)(rreduction.body))"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|applyReduce_TCC4| 0
  (|applyReduce_TCC4-2| "" 3715588726
   ("" (SKEEP*)
    (("" (USE APPLYREDUCE_CORRECT_COUNT)
      (("" (SPLIT -1)
        (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)
         ("3" (TYPEPRED "grS") (("3" (PROPAX) NIL NIL)) NIL)
         ("4" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|applyReduce_correct_count| FORMULA-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|applyReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.letApply(rreduction.arity, rreduction.args, preprocess.mark(sets[naturalnumbers.nat].emptyset)(rreduction.body)))(i)}]"))
  (|applyReduce_TCC4-1| NIL 3676345135
   ("" (SKEEP*)
    (("" (USE APPLYREDUCE_CORRECT_COUNT)
      (("" (SPLIT -1)
        (("1" (PROPAX) NIL NIL) ("2" (GRIND) NIL NIL)
         ("3" (TYPEPRED GRS) (("3" (PROPAX) NIL NIL)) NIL)
         ("4" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL) NIL
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|applyReduce_correct_count| FORMULA-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|applyReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.letApply(rreduction.arity, rreduction.args, preprocess.mark(sets[naturalnumbers.nat].emptyset)(rreduction.body)))(i)}]")))
 (|ifReduce_correct_redex_then_TCC1| 0
  (|ifReduce_correct_redex_then_TCC1-1| NIL 3700339138
   ("" (SUBTYPE-TCC) NIL NIL)
   ((|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|ifReduce_correct_redex_then| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.ift?)")))
 (|ifReduce_correct_redex_then| 0
  (|ifReduce_correct_redex_then-1| NIL 3701115301
   ("" (SKEEP)
    (("" (SIMPLIFY :LET-REDUCE? T)
      (("" (TYPEPRED "grS`redex")
        (("" (SPLIT)
          (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)
           ("2" (SKEEP)
            (("2" (REWRITE PUREPOPDEPTH)
              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("3" (SKEEP)
            (("3" (REWRITE PUREPOPDEPTH)
              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("4" (REWRITE PUREPOPDEPTH)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
           ("5" (USE PURE_CONTEXTPURE) (("5" (GRIND) NIL NIL)) NIL)
           ("6" (APPLY-ETA "grS`redex" "(ift?)")
            (("6" (REPLACE -1 :DIR RL)
              (("6" (SIMPLIFY)
                (("6" (EXPAND MARK -)
                  (("6" (DECOMPOSE-EQUALITY -7)
                    (("6" (USE EQ_MARK_RELEASE_SET)
                      (("6" (SPLIT -1)
                        (("1" (EXPAND RELEASE_SET) (("1" (ASSERT) NIL NIL))
                          NIL)
                         ("2" (PROPAX) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|eq_mark_release_set| FORMULA-DECL NIL |preprocess| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|IExpression_ift_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|ifReduce_correct_redex_else| 0
  (|ifReduce_correct_redex_else-1| NIL 3701115555
   ("" (SKEEP)
    (("" (SIMPLIFY :LET-REDUCE? T)
      (("" (TYPEPRED "grS`redex")
        (("" (SPLIT)
          (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)
           ("2" (SKEEP)
            (("2" (REWRITE PUREPOPDEPTH)
              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("3" (SKEEP)
            (("3" (REWRITE PUREPOPDEPTH)
              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("4" (REWRITE PUREPOPDEPTH)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
           ("5" (USE PURE_CONTEXTPURE) (("5" (GRIND) NIL NIL)) NIL)
           ("6" (APPLY-ETA "grS`redex" "(ift?)")
            (("6" (REPLACE -1 :DIR RL)
              (("6" (SIMPLIFY)
                (("6" (EXPAND MARK -)
                  (("6" (DECOMPOSE-EQUALITY -7)
                    (("6" (DELETE -2)
                      (("6" (USE EQ_MARK_RELEASE_SET)
                        (("6" (SPLIT -1)
                          (("1" (EXPAND RELEASE_SET) (("1" (ASSERT) NIL NIL))
                            NIL)
                           ("2" (PROPAX) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|eq_mark_release_set| FORMULA-DECL NIL |preprocess| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|IExpression_ift_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|ifReduce_correct_count_then| 0
  (|ifReduce_correct_count_then-1| NIL 3700339138
   ("" (SKEEP*) (("" (USE PURE_COUNT_KEEP) (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure_count_keep| FORMULA-DECL NIL |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|ifReduce_correct_count_else| 0
  (|ifReduce_correct_count_else-1| NIL 3700339177
   ("" (SKEEP*) (("" (USE PURE_COUNT_KEEP) (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure_count_keep| FORMULA-DECL NIL |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|ifReduce_correct_indexing| 0
  (|ifReduce_correct_indexing-1| NIL 3700339192
   ("" (SKEEP*)
    (("" (CASE "vars(grS`redex)(index(condition(grS`redex)))")
      (("1" (TYPEPRED "grS`redex")
        (("1" (REWRITE PUREPOPDEPTH)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
        NIL)
       ("2" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|ifReduce_correct_release_marked| 0
  (|ifReduce_correct_release_marked-1| NIL 3700339362
   ("" (WITH-LABELS (SKEEP*) ((IFTR MRK OBJ)))
    ((""
      (WITH-LABELS (TYPEPRED "grS`redex") ((HDOM HVAR HCVAR HLEN HPURE HMARK)))
      (("" (APPLY-ETA "grS`redex" "(ift?)")
        (("" (REPLACE -1 :DIR RL)
          (("" (SIMPLIFY)
            (("" (EXPAND MARK)
              ((""
                (WITH-LABELS (DECOMPOSE-EQUALITY HMARK)
                 ((HMARK1 HMARK2 HMARK3)))
                (("" (REPLACE HMARK1 MRK :DIR RL)
                  (("" (EXPAND MARKV)
                    (("" (HIDE-ALL-BUT (MRK OBJ))
                      (("" (EXPAND UNION)
                        (("" (EXPAND MEMBER) (("" (GROUND) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|IExpression_ift_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|ifReduce_TCC1| 0
  (|ifReduce_TCC1-1| NIL 3683858380 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL (|ifReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.ift?)")))
 (|ifReduce_TCC2| 0
  (|ifReduce_TCC2-1| NIL 3683858380
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND MEMBER)
      (("" (ASSERT)
        (("" (EXPAND PUREIFTREDEX?)
          (("" (EXPAND IFTREDEX?)
            (("" (FLATTEN)
              (("" (ASSERT)
                (("" (SPLIT)
                  (("1" (REWRITE PUREPOPDEPTH)
                    (("1" (REWRITE PUREPOPDEPTH)
                      (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (EXPAND MARK)
                      (("2" (DECOMPOSE-EQUALITY -8)
                        (("2" (EXPAND MARKV)
                          (("2" (LIFT-IF)
                            (("2" (SPLIT -1)
                              (("1" (FLATTEN)
                                (("1" (DECOMPOSE-EQUALITY -2)
                                  (("1" (GRIND) NIL NIL)) NIL))
                                NIL)
                               ("2" (FLATTEN) (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|member| CONST-DECL "bool" |sets| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|popDepth| DEF-DECL "nat" IL NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce| SUBTYPE "rreduction.condition"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN IL.popDepth(rreduction.elseexpr) ELSE IL.popDepth(rreduction.thenexpr) ENDIF), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN rreduction.grS`stack`length ELSE rreduction.grS`stack`length ENDIF), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}"))
  (|ifReduce_TCC2-2| "" 3699283733
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (TYPEPRED "grS`redex")
        (("1" (INST -2 "index(condition)")
          (("1" (GROUND)
            (("1" (TYPEPRED "grS")
              (("1" (EXPAND PUREIFTREDEX?)
                (("1" (EXPAND IFTREDEX?)
                  (("1" (REWRITE PUREPOPDEPTH 2)
                    (("1" (REWRITE PUREPOPDEPTH 2) (("1" (GRIND) NIL NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (TYPEPRED "grS`redex")
              (("2"
                (CASE-REPLACE "grS`redex = ift(condition, thenexpr, elseexpr)")
                (("1" (GRIND) NIL NIL) ("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "grS`redex")
        (("2" (CASE "grS`redex = ift(condition, thenexpr, elseexpr)")
          (("1" (REWRITE -1)
            (("1" (EXPAND MARK -6)
              (("1" (EXPAND MARKV -6)
                (("1" (EXPAND UNION -6)
                  (("1" (EXPAND MEMBER)
                    (("1" (DECOMPOSE-EQUALITY -6)
                      (("1" (REPLACE -1 -10 :DIR RL) (("1" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (GRIND-WITH-EXT) NIL NIL))
          NIL))
        NIL)
       ("3" (EXPAND MEMBER)
        (("3" (TYPEPRED "grS`redex")
          (("3" (CASE-REPLACE "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (EXPAND MARK -7)
              (("1" (DECOMPOSE-EQUALITY -7)
                (("1" (EXPAND MARKV -1)
                  (("1" (REPLACE -1 -11 :DIR RL) (("1" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (GRIND-WITH-EXT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|IExpression_ift_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|ifReduce| SUBTYPE "rreduction.condition"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN IL.popDepth(rreduction.elseexpr) ELSE IL.popDepth(rreduction.thenexpr) ENDIF), IF IL.get(rreduction.stack)(rreduction.condition) = IExpression_adt.constant(0) THEN rreduction.grS`stack`length ELSE rreduction.grS`stack`length ENDIF), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}")))
 (|ifReduce_TCC3| 0
  (|ifReduce_TCC3-1| NIL 3683858380
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (TYPEPRED "grS")
        (("" (INST -3 "index(condition)")
          (("" (EXPAND VARS) (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce| SUBTYPE "rreduction.condition"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|ifReduce_TCC4| 0
  (|ifReduce_TCC4-1| NIL 3683858380
   ("" (SKEEP*)
    (("" (TYPEPRED "grS")
      (("" (TYPEPRED "grS`redex")
        (("" (GROUND)
          (("1" (HIDE-ALL-BUT (1 -1 -7 -10 -14)) (("1" (GRIND) NIL NIL)) NIL)
           ("2" (HIDE-ALL-BUT (1 -2 -7 -10 -14))
            (("2" (SKEEP*)
              (("2" (REWRITE PUREPOPDEPTH)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL)
           ("3" (REWRITE PUREPOPDEPTH)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
           ("4" (REWRITE PUREPOPDEPTH)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
           ("5" (REWRITE PURE_CONTEXTPURE) (("5" (GRIND) NIL NIL)) NIL)
           ("6" (CASE-REPLACE "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (EXPAND MARK -7)
              (("1" (DECOMPOSE-EQUALITY -7)
                (("1"
                  (CASE-REPLACE
                   "difference(vars(thenexpr), union(vars(elseexpr), cvars(grS`context))) = emptyset")
                  (("1" (GRIND) NIL NIL)
                   ("2" (HIDE-ALL-BUT (1 -3))
                    (("2" (USE EQ_MARK_RELEASE_SET)
                      (("2" (SPLIT -1)
                        (("1" (GRIND-WITH-EXT) NIL NIL) ("2" (PROPAX) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (GRIND-WITH-EXT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|IExpression_ift_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|eq_mark_release_set| FORMULA-DECL NIL |preprocess| NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce| SUBTYPE "rreduction.elseexpr"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|ifReduce_TCC5| 0
  (|ifReduce_TCC5-1| NIL 3683858380
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (TYPEPRED "grS`redex")
        (("" (TYPEPRED "grS")
          (("" (EXPAND "pureIftRedex?")
            (("" (EXPAND "iftRedex?")
              (("" (TYPEPRED "grS`count(x1)")
                (("" (REWRITE -1)
                  (("" (EXPAND REFCOUNT)
                    (("" (EXPAND REFCOUNTEXPR)
                      (("" (EXPAND REFS 2 1)
                        (("" (FLATTEN)
                          (("" (USE PURE_REFS)
                            (("" (GROUND)
                              (("" (LIFT-IF)
                                (("" (GROUND)
                                  (("" (USE PURE_REFS) (("" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.elseexpr)(i)}]")))
 (|ifReduce_TCC6| 0
  (|ifReduce_TCC6-1| NIL 3683858380
   ("" (SKEEP*)
    (("" (TYPEPRED "grS")
      (("" (TYPEPRED "grS`redex")
        (("" (GROUND)
          (("1" (HIDE-ALL-BUT (1 -1 -7 -10 -12)) (("1" (GRIND) NIL NIL)) NIL)
           ("2" (SKEEP)
            (("2" (REWRITE PUREPOPDEPTH)
              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("3" (SKEEP*)
            (("3" (REWRITE PUREPOPDEPTH)
              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
            NIL)
           ("4" (REWRITE PUREPOPDEPTH)
            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
           ("5" (REWRITE PURE_CONTEXTPURE) (("5" (GRIND) NIL NIL)) NIL)
           ("6" (CASE-REPLACE "grS`redex = ift(condition, thenexpr, elseexpr)")
            (("1" (EXPAND MARK -7)
              (("1" (DECOMPOSE-EQUALITY -7)
                (("1"
                  (CASE-REPLACE
                   "difference(vars(elseexpr), union(vars(thenexpr), cvars(grS`context))) = emptyset")
                  (("1" (GRIND) NIL NIL)
                   ("2" (LEMMA EQ_MARK_RELEASE_SET)
                    (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (GRIND-WITH-EXT) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|IExpression_ift_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|eq_mark_release_set| FORMULA-DECL NIL |preprocess| NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce| SUBTYPE "rreduction.thenexpr"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|ifReduce_TCC7| 0
  (|ifReduce_TCC7-1| NIL 3698757037
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (TYPEPRED "grS`redex")
        (("" (TYPEPRED "grS")
          (("" (EXPAND "pureIftRedex?")
            (("" (EXPAND "iftRedex?")
              (("" (TYPEPRED "grS`count(x1)")
                (("" (REWRITE -1)
                  (("" (EXPAND REFCOUNT)
                    (("" (EXPAND REFCOUNTEXPR)
                      (("" (EXPAND REFS 3 1)
                        (("" (FLATTEN)
                          (("" (USE PURE_REFS)
                            (("" (GROUND)
                              (("" (LIFT-IF)
                                (("" (GROUND)
                                  (("" (USE PURE_REFS) (("" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.thenexpr)(i)}]")))
 (|setRedex_TCC1| 0
  (|setRedex_TCC1-1| NIL 3698784150
   ("" (SKEEP*)
    (("" (TYPEPRED "rS")
      (("" (GRIND)
        (("1" (TYPEPRED "rS`redex") (("1" (GRIND) NIL NIL)) NIL)
         ("2" (TYPEPRED "rS`redex")
          (("2" (INST -3 "i!1") (("2" (GRIND) NIL NIL)) NIL)) NIL)
         ("3" (TYPEPRED "vv") (("3" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|pure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|setRedex| SUBTYPE "rreduction.vv"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}")))
 (|setRedex_TCC2| 0
  (|setRedex_TCC2-3| "" 3715595484
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (TYPEPRED "rS`count(refindex(vv))")
        (("" (REWRITE -1)
          (("" (EXPAND REFCOUNT)
            (("" (EXPAND REFCOUNTEXPR)
              (("" (TYPEPRED "rS`redex")
                (("" (TYPEPRED "rS")
                  (("" (REWRITE PURE_REFS) (("" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|setRedex| SUBTYPE
    "(number_fields.+)(rreduction.rS`count(IExpression_adt.refindex(rreduction.vv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(IExpression_adt.refindex(rreduction.vv))}"))
  (|setRedex_TCC2-2| "" 3714696103
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (TYPEPRED "rS`count(refindex(vv))")
        (("" (REWRITE -1)
          (("" (EXPAND REFCOUNT)
            (("" (EXPAND REFCOUNTEXPR)
              (("" (TYPEPRED "rS`redex")
                (("" (TYPEPRED RS)
                  (("" (REWRITE PURE_REFS) (("" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|setRedex| SUBTYPE
    "(number_fields.+)(rreduction.rS`count(IExpression_adt.refindex(rreduction.vv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(IExpression_adt.refindex(rreduction.vv))}"))
  (|setRedex_TCC2-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|setRedex| SUBTYPE
    "(number_fields.+)(rreduction.rS`count(IExpression_adt.refindex(rreduction.vv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(IExpression_adt.refindex(rreduction.vv))}")))
 (|setRedex_TCC3| 0
  (|setRedex_TCC3-2| "" 3715595548
   ("" (SKEEP* :PREDS? T)
    (("" (GROUND)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
       ("3" (TYPEPRED "rS`redex")
        (("3" (SKEEP) (("3" (INST -3 "i") (("3" (GRIND) NIL NIL)) NIL)) NIL))
        NIL)
       ("4" (TYPEPRED "rS`redex") (("4" (GRIND) NIL NIL)) NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|pure?| DEF-DECL "bool" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|setRedex| SUBTYPE "rreduction.vv"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}"))
  (|setRedex_TCC3-1| NIL 3698784150
   ("" (SKEEP* :PREDS? T)
    (("" (GROUND)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
       ("3" (TYPEPRED "rS`redex")
        (("3" (SKEEP) (("3" (INST -3 I) (("3" (GRIND) NIL NIL)) NIL)) NIL))
        NIL)
       ("4" (TYPEPRED "rS`redex") (("4" (GRIND) NIL NIL)) NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|emptyset| CONST-DECL "set" |sets| NIL) NIL
    (|pure?| DEF-DECL "bool" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|setRedex| SUBTYPE "rreduction.vv"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.rS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.rS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.rS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.rS`context)), rreduction.rS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.rS`context))(rreduction.A) = rreduction.A)}")))
 (|setRedex_TCC4| 0
  (|setRedex_TCC4-3| "" 3715595604
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNT)
      (("" (TYPEPRED "rS`count(x1)")
        (("" (REWRITE -1)
          (("" (EXPAND "refcount")
            (("" (EXPAND REFCOUNTEXPR)
              (("" (TYPEPRED "rS`redex")
                (("" (TYPEPRED "rS")
                  (("" (REWRITE PURE_REFS) (("" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL) (|pure?| DEF-DECL "bool" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|setRedex| SUBTYPE "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(i)}]"))
  (|setRedex_TCC4-2| "" 3715055696
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND REFCOUNT)
      (("" (TYPEPRED "rS`count(x1)")
        (("" (REWRITE -1)
          (("" (EXPAND "refcount")
            (("" (EXPAND REFCOUNTEXPR)
              (("" (TYPEPRED "rS`redex")
                (("" (TYPEPRED RS)
                  (("" (REWRITE PURE_REFS) (("" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL) (|pure?| DEF-DECL "bool" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|setRedex| SUBTYPE "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(i)}]"))
  (|setRedex_TCC4-1| NIL 3698784150
   ("" (SKEEP* :PREDS? T)
    (("" (GROUND)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
       ("3" (TYPEPRED "rS`redex")
        (("3" (SKEEP) (("3" (INST -3 I) (("3" (GRIND) NIL NIL)) NIL)) NIL))
        NIL)
       ("4" (TYPEPRED "rS`redex") (("4" (GRIND) NIL NIL)) NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|setRedex| SUBTYPE "rreduction.rS`count"
    "[i: (rreduction.rS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.rS`domain, rreduction.rS`store, rreduction.rS`stack, rreduction.vv)(i)}]")))
 (|lookupRedex_arrayvalue_index_TCC1| 0
  (|lookupRedex_arrayvalue_index_TCC1-1| NIL 3701021413
   ("" (SUBTYPE-TCC) NIL NIL)
   ((|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|lookupRedex_arrayvalue_index| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.lookup?)")))
 (|lookupRedex_arrayvalue_index| 0
  (|lookupRedex_arrayvalue_index-1| NIL 3701115715
   ("" (SKEEP) (("" (TYPEPRED "grS`redex") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|arrayvalue| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|lookup?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|lookupRedex_position_index| 0
  (|lookupRedex_position_index-1| NIL 3701115726
   ("" (SKEEP) (("" (TYPEPRED "grS`redex") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|arrayvalue| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|lookup?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|position| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|lookupReduce_TCC1| 0
  (|lookupReduce_TCC1-1| NIL 3693417317 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL (|lookupReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.lookup?)")))
 (|lookupReduce_TCC2| 0
  (|lookupReduce_TCC2-2| "" 3715597907
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (INST -2 "index(avar)")
        (("" (TYPEPRED "grS") (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|lookupReduce| SUBTYPE "rreduction.avar"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (|lookupReduce_TCC2-1| NIL 3693417317
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (INST -2 "index(avar)")
        (("" (TYPEPRED GRS) (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|lookupReduce| SUBTYPE "rreduction.avar"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|lookupReduce_TCC3| 0
  (|lookupReduce_TCC3-2| "" 3715598302
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (TYPEPRED "grS")
        (("" (INST -3 "index(pos)") (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|lookupReduce| SUBTYPE "rreduction.pos"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (|lookupReduce_TCC3-1| NIL 3693417317
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (TYPEPRED GRS)
        (("" (INST -3 "index(pos)") (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|lookupReduce| SUBTYPE "rreduction.pos"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|lookupReduce_TCC4| 0
  (|lookupReduce_TCC4-1| NIL 3693417317 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|lookupReduce| SUBTYPE "IExpression_adt.refindex(rreduction.aval)"
    "(rreduction.grS`domain)")))
 (|lookupReduce_TCC5| 0
  (|lookupReduce_TCC5-1| NIL 3693417317 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|lookupReduce| SUBTYPE "IExpression_adt.value(rreduction.pval)"
    "below[store(refindex(aval))`length]")))
 (|lookupReduce_TCC6| 0
  (|lookupReduce_TCC6-2| "" 3715598717
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (EXPAND SETREDEX)
        (("1" (SIMPLIFY)
          (("1" (TYPEPRED "grS`redex")
            (("1" (TYPEPRED "grS")
              (("1" (INST -3 "index(avar)")
                (("1" (TYPEPRED "rval") (("1" (GRIND) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (EXPAND SETREDEX)
        (("2" (SIMPLIFY)
          (("2" (EXPAND MEMBER)
            (("2" (TYPEPRED "rval") (("2" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("3" (EXPAND SETREDEX)
        (("3" (EXPAND MEMBER)
          (("3" (TYPEPRED "grS`redex")
            (("3" (CASE-REPLACE "grS`redex = lookup(avar, pos)")
              (("1" (EXPAND MARK -7)
                (("1" (DECOMPOSE-EQUALITY -7)
                  (("1" (REPLACE -1 -10 :DIR RL) (("1" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL)
               ("2" (GRIND-WITH-EXT) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|lookup?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|arrayvalue| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|position| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|grS| SKOLEM-CONST-DECL "{grS | lookupRedex?(grS`redex)}" |rreduction|
     NIL)
    (|constant?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|value| ADT-ACCESSOR-DECL "[(constant?) -> int]" |IExpression_adt| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|setRedex| CONST-DECL "rstate" |rreduction| NIL)
    (|lookup| ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]"
     |IExpression_adt| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|IExpression_lookup_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|lookupReduce| SUBTYPE "rreduction.avar"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IL.popDepth(rreduction.setRedex(rreduction.grS, rreduction.rval)`redex)), rreduction.setRedex(rreduction.grS, rreduction.rval)`stack`length), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}"))
  (|lookupReduce_TCC6-1| NIL 3693417317
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (EXPAND SETREDEX)
        (("1" (SIMPLIFY)
          (("1" (TYPEPRED "grS`redex")
            (("1" (TYPEPRED GRS)
              (("1" (INST -3 "index(avar)")
                (("1" (TYPEPRED "rval") (("1" (GRIND) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (EXPAND SETREDEX)
        (("2" (SIMPLIFY)
          (("2" (EXPAND MEMBER)
            (("2" (TYPEPRED "rval") (("2" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("3" (EXPAND SETREDEX)
        (("3" (EXPAND MEMBER)
          (("3" (TYPEPRED "grS`redex")
            (("3" (CASE-REPLACE "grS`redex = lookup(avar, pos)")
              (("1" (EXPAND MARK -7)
                (("1" (DECOMPOSE-EQUALITY -7)
                  (("1" (REPLACE -1 -10 :DIR RL) (("1" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL)
               ("2" (GRIND-WITH-EXT) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|lookup?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|arrayvalue| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|position| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    NIL
    (|constant?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|value| ADT-ACCESSOR-DECL "[(constant?) -> int]" |IExpression_adt| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|setRedex| CONST-DECL "rstate" |rreduction| NIL)
    (|lookup| ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]"
     |IExpression_adt| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|IExpression_lookup_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|lookupReduce| SUBTYPE "rreduction.avar"
    "{x | booleans.AND(reals.<((number_fields.+)(IExpression_adt.index(rreduction.x), IL.popDepth(rreduction.setRedex(rreduction.grS, rreduction.rval)`redex)), rreduction.setRedex(rreduction.grS, rreduction.rval)`stack`length), (booleans.IMPLIES(IExpression_adt.marked(rreduction.x), booleans.AND(, ))))}")))
 (|lookupReduce_TCC7| 0
  (|lookupReduce_TCC7-1| NIL 3693417317
   ("" (SKEEP*) (("" (TYPEPRED "grS") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL) (|pure?| DEF-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|lookupReduce| SUBTYPE "rreduction.grS"
    "{rS | IL.pure?(rreduction.rS`redex)}")))
 (|newintReduce_TCC1| 0
  (|newintReduce_TCC1-1| NIL 3699020624 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|newintReduce| SUBTYPE "rreduction.expr"
    "{x: IExpression_adt.IExpression | booleans.OR(IExpression_adt.newint?(x), IExpression_adt.newref?(x))}")))
 (|newintReduce_TCC2| 0
  (|newintReduce_TCC2-1| NIL 3699020624 ("" (SUBTYPE-TCC) NIL NIL)
   ((|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|newint?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|newref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|size| SHARED-ADT-ACCESSOR-DECL
     "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]" |IExpression_adt|
     NIL)
    (|size!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|grS!1| SKOLEM-CONST-DECL "{grS | newintRedex?(grS`redex)}" |rreduction|
     NIL)
    (|x!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (N!2 SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|pick_new| CONST-DECL "{j | NOT NS(j)}" |finite_set_theorems| NIL)
    (|least_out_rec| DEF-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|newintReduce| SUBTYPE "rreduction.grS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.newdomain))(S)}")))
 (|newintReduce_TCC3| 0
  (|newintReduce_TCC3-1| NIL 3699020624
   ("" (SKEEP*)
    (("" (GRIND)
      (("1" (TYPEPRED "grS`redex") (("1" (GRIND) NIL NIL)) NIL)
       ("2" (TYPEPRED "grS`redex")
        (("2" (INST -3 "i!1") (("2" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|newintReduce| SUBTYPE "IExpression_adt.ref(rreduction.newrefredex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|newintReduce_TCC4| 0
  (|newintReduce_TCC4-1| NIL 3699020624 ("" (SUBTYPE-TCC) NIL NIL)
   ((|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|newintReduce| SUBTYPE "rreduction.newrefredex" "(rreduction.newdomain)")))
 (|newintReduce_TCC5| 0
  (|newintReduce_TCC5-1| NIL 3699020624 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL))
   NIL
   (|newintReduce| SUBTYPE "IExpression_adt.constant(0)"
    "(IL.domainValue?(rreduction.newdomain))")))
 (|newintReduce_TCC6| 0
  (|newintReduce_TCC6-2| "" 3715600890
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (EXPAND REFCOUNTEXPR)
        (("" (EXPAND REFS)
          (("" (REWRITE REFCOUNT_STACK_OUTSIDE_DOMAIN)
            (("1" (LEMMA REFCOUNT_NEW)
              (("1" (INST -1 "domain" "newdomain" "newrefredex" "store" _)
                (("1" (INST?)
                  (("1" (GROUND)
                    (("1" (REWRITE -1)
                      (("1" (EXPAND REFCOUNTARRAY)
                        (("1" (REWRITE COUNT_NONE_ZERO) (("1" (GRIND) NIL NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL)
                 ("2" (DELETE 2)
                  (("2" (GROUND)
                    (("1" (GRIND) NIL NIL)
                     ("2" (SKEEP*)
                      (("2" (TYPEPRED "store(x1)`seq(x2)")
                        (("2" (GRIND) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|refcount_new| FORMULA-DECL NIL |rreduction| NIL)
    (|size| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|constant?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|constant| ADT-CONSTRUCTOR-DECL "[int -> (constant?)]" |IExpression_adt|
     NIL)
    (|newdomain| SKOLEM-CONST-DECL "non_empty_finite_set[nat]" |rreduction|
     NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|store| SKOLEM-CONST-DECL "Store(grS`domain)" |rreduction| NIL)
    (|domain| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL "{grS | newintRedex?(grS`redex)}" |rreduction|
     NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|refcount_stack_outside_domain| FORMULA-DECL NIL |rreduction| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|newintReduce| SUBTYPE "1"
    "{j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.store WITH [(rreduction.newrefredex) |-> (# length := rreduction.size, seq := (LAMBDA (i: naturalnumbers.below(rreduction.size)): IExpression_adt.constant(0)) #)], rreduction.grS`stack, IExpression_adt.ref(rreduction.newrefredex))(rreduction.newrefredex)}"))
  (|newintReduce_TCC6-1| NIL 3699020624
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (EXPAND REFCOUNTEXPR)
        (("" (EXPAND REFS)
          (("" (REWRITE REFCOUNT_STACK_OUTSIDE_DOMAIN)
            (("1" (LEMMA REFCOUNT_NEW)
              (("1" (INST -1 DOMAIN NEWDOMAIN NEWREFREDEX STORE _)
                (("1" (INST?)
                  (("1" (GROUND)
                    (("1" (REWRITE -1)
                      (("1" (EXPAND REFCOUNTARRAY)
                        (("1" (REWRITE COUNT_NONE_ZERO) (("1" (GRIND) NIL NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL)
                 ("2" (DELETE 2)
                  (("2" (GROUND)
                    (("1" (GRIND) NIL NIL)
                     ("2" (SKEEP*)
                      (("2" (TYPEPRED "store(x1)`seq(x2)")
                        (("2" (GRIND) NIL NIL)) NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|refcount_new| FORMULA-DECL NIL |rreduction| NIL) NIL
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|constant?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|constant| ADT-CONSTRUCTOR-DECL "[int -> (constant?)]" |IExpression_adt|
     NIL)
    NIL (|member| CONST-DECL "bool" |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    NIL NIL NIL (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|refcount_stack_outside_domain| FORMULA-DECL NIL |rreduction| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|newintReduce| SUBTYPE "1"
    "{j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.store WITH [(rreduction.newrefredex) |-> (# length := rreduction.size, seq := (LAMBDA (i: naturalnumbers.below(rreduction.size)): IExpression_adt.constant(0)) #)], rreduction.grS`stack, IExpression_adt.ref(rreduction.newrefredex))(rreduction.newrefredex)}")))
 (|newrefReduce_TCC1| 0
  (|newrefReduce_TCC1-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|newrefReduce| SUBTYPE "rreduction.expr"
    "{x: IExpression_adt.IExpression | booleans.OR(IExpression_adt.newint?(x), IExpression_adt.newref?(x))}")))
 (|newrefReduce_TCC2| 0
  (|newrefReduce_TCC2-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|newint?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|newref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|size| SHARED-ADT-ACCESSOR-DECL
     "[{x: IExpression | newint?(x) OR newref?(x)} -> nat]" |IExpression_adt|
     NIL)
    (|size!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|grS!1| SKOLEM-CONST-DECL "{grS | newrefRedex?(grS`redex)}" |rreduction|
     NIL)
    (|x!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (N!2 SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|pick_new| CONST-DECL "{j | NOT NS(j)}" |finite_set_theorems| NIL)
    (|least_out_rec| DEF-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|newrefReduce| SUBTYPE "rreduction.grS`stack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.newdomain))(S)}")))
 (|newrefReduce_TCC3| 0
  (|newrefReduce_TCC3-1| NIL 3699031813
   ("" (SKEEP*)
    (("" (GROUND)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
       ("3" (GRIND)
        (("3" (TYPEPRED "grS`redex")
          (("3" (INST -3 "i!1") (("3" (GRIND) NIL NIL)) NIL)) NIL))
        NIL)
       ("4" (GRIND) (("4" (TYPEPRED "grS`redex") (("4" (GRIND) NIL NIL)) NIL))
        NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (|emptyset| CONST-DECL "set" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|newrefReduce| SUBTYPE "IExpression_adt.ref(rreduction.newrefredex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|newrefReduce_TCC4| 0
  (|newrefReduce_TCC4-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|newrefReduce| SUBTYPE "rreduction.newrefredex" "(rreduction.newdomain)")))
 (|newrefReduce_TCC5| 0
  (|newrefReduce_TCC5-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL))
   NIL
   (|newrefReduce| SUBTYPE "IExpression_adt.nil"
    "(IL.domainValue?(rreduction.newdomain))")))
 (|newrefReduce_TCC6| 0
  (|newrefReduce_TCC6-1| NIL 3699031813
   ("" (SKEEP*)
    (("" (EXPAND REFCOUNT)
      (("" (EXPAND REFCOUNTEXPR)
        (("" (EXPAND REFS)
          (("" (REWRITE REFCOUNT_STACK_OUTSIDE_DOMAIN)
            (("1" (USE REFCOUNT_NEW)
              (("1" (GROUND)
                (("1" (REWRITE -1)
                  (("1" (EXPAND REFCOUNTARRAY)
                    (("1" (REWRITE COUNT_NONE_ZERO)
                      (("1" (SKEEP*) (("1" (GRIND) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL)
                 ("2" (GRIND) NIL NIL))
                NIL)
               ("2" (DELETE 2)
                (("2" (GROUND)
                  (("1" (SKEEP*) (("1" (GRIND) NIL NIL)) NIL)
                   ("2" (SKEEP*)
                    (("2" (TYPEPRED "store(x1)`seq(x2)")
                      (("2" (GRIND) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (GRIND) NIL NIL))
              NIL)
             ("2" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|grS| SKOLEM-CONST-DECL "{grS | newrefRedex?(grS`redex)}" |rreduction|
     NIL)
    (|domain| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (|store| SKOLEM-CONST-DECL "Store(grS`domain)" |rreduction| NIL)
    (|size| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|newdomain| SKOLEM-CONST-DECL "non_empty_finite_set[nat]" |rreduction|
     NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|refcount_new| FORMULA-DECL NIL |rreduction| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|refcount_stack_outside_domain| FORMULA-DECL NIL |rreduction| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|newrefReduce| SUBTYPE "1"
    "{j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.store WITH [(rreduction.newrefredex) |-> (# length := rreduction.size, seq := (LAMBDA (i: naturalnumbers.below(rreduction.size)): IExpression_adt.nil) #)], rreduction.grS`stack, IExpression_adt.ref(rreduction.newrefredex))(rreduction.newrefredex)}")))
 (|popReduce_TCC1| 0
  (|popReduce_TCC1-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL (|popReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.pop?)")))
 (|popReduce_TCC2| 0
  (|popReduce_TCC2-2| "" 3715600945
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (TYPEPRED "grS") (("" (GRIND) NIL NIL)) NIL)) NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK (|popReduce| SUBTYPE "rreduction.stack" "neStack"))
  (|popReduce_TCC2-1| NIL 3699031813
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (TYPEPRED GRS) (("" (GRIND) NIL NIL)) NIL)) NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL (|popReduce| SUBTYPE "rreduction.stack" "neStack")))
 (|popReduce_TCC3| 0
  (|popReduce_TCC3-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|pop| CONST-DECL "Stack" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|popReduce| SUBTYPE "IL.pop(rreduction.stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S)}")))
 (|popReduce_TCC4| 0
  (|popReduce_TCC4-2| "" 3715601023
   ("" (SKEEP* :PREDS? T)
    (("" (GROUND)
      (("1" (SKEEP) (("1" (INST -2 "i") (("1" (GRIND) NIL NIL)) NIL)) NIL)
       ("2" (GRIND) NIL NIL)
       ("3" (SKEEP) (("3" (INST -4 "i") (("3" (GRIND) NIL NIL)) NIL)) NIL)
       ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|pop| CONST-DECL "Stack" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|pop?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|pbody| ADT-ACCESSOR-DECL "[(pop?) -> IExpression]" |IExpression_adt| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|popReduce| SUBTYPE "rreduction.body"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.pop(rreduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), IL.pop(rreduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), IL.pop(rreduction.stack)`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|popReduce_TCC4-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (GROUND)
      (("1" (SKEEP) (("1" (INST -2 I) (("1" (GRIND) NIL NIL)) NIL)) NIL)
       ("2" (GRIND) NIL NIL)
       ("3" (SKEEP) (("3" (INST -4 I) (("3" (GRIND) NIL NIL)) NIL)) NIL)
       ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL NIL NIL
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|pop| CONST-DECL "Stack" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|pop?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|pbody| ADT-ACCESSOR-DECL "[(pop?) -> IExpression]" |IExpression_adt| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|popReduce| SUBTYPE "rreduction.body"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.pop(rreduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), IL.pop(rreduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), IL.pop(rreduction.stack)`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|popReduce_TCC5| 0
  (|popReduce_TCC5-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR)
            (("" (EXPAND REFCOUNTSTACK)
              (("" (CASE-REPLACE "grS`redex = pop(body)")
                (("1" (EXPAND REFS 2 1)
                  (("1"
                    (CASE-REPLACE
                     "grS`stack = add(stack(stack`length - 1), pop(stack))")
                    (("1" (REWRITE COUNT_ADD)
                      (("1" (LIFT-IF)
                        (("1" (GROUND)
                          (("1" (EXPAND NODANGLINGREFS?)
                            (("1" (INST -13 0)
                              (("1" (SPLIT -13)
                                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
                                 ("3" (GRIND) NIL NIL))
                                NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (GRIND) NIL NIL))
                      NIL)
                     ("2" (EXPAND ADD 1)
                      (("2" (EXPAND POP 1)
                        (("2" (REPLACE -12)
                          (("2" (HIDE-ALL-BUT (-6 -14 1))
                            (("2" (GRIND-WITH-EXT) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("3" (GRIND) NIL NIL))
                    NIL))
                  NIL)
                 ("2" (GRIND-WITH-EXT) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|IExpression_pop_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|pbody| ADT-ACCESSOR-DECL "[(pop?) -> IExpression]" |IExpression_adt| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_add| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | popRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|pop| CONST-DECL "Stack" IL NIL) (|neStack| TYPE-EQ-DECL NIL IL NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|seq| TYPE-EQ-DECL NIL |more_finseq| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|pop?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|pop| ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" |IExpression_adt|
     NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|popReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, IL.pop(rreduction.stack), rreduction.body)(i)}]")))
 (|release_reduce_redex_correct_TCC1| 0
  (|release_reduce_redex_correct_TCC1-1| NIL 3700485765
   ("" (SUBTYPE-TCC) NIL NIL)
   ((|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|release_reduce_redex_correct| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.release?)")))
 (|release_reduce_redex_correct| 0
  (|release_reduce_redex_correct-1| NIL 3700485765
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (SPLIT)
        (("1" (SKEEP) (("1" (GRIND) NIL NIL)) NIL)
         ("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL)
         ("3" (SKEEP) (("3" (GRIND) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)
         ("5" (GRIND) NIL NIL)
         ("6" (APPLY-ETA "grS`redex" "(release?)")
          (("6" (REPLACE -1 :DIR RL)
            (("6" (SIMPLIFY)
              (("6" (EXPAND MARK -) (("6" (DECOMPOSE-EQUALITY -7) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|IExpression_release_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rexpr| ADT-ACCESSOR-DECL "[(release?) -> IExpression]" |IExpression_adt|
     NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|releaseReduce_TCC1| 0
  (|releaseReduce_TCC1-1| NIL 3699031813 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|releaseReduce| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.release?)")))
 (|releaseReduce_TCC2| 0
  (|releaseReduce_TCC2-2| "" 3714763278
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (REPLACE -11 :HIDE? T)
        (("" (ASSERT)
          (("" (INST -2 "index(rvar(grS`redex))") (("" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|releaseReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[stack`length]"))
  (|releaseReduce_TCC2-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (SPLIT)
        (("1" (EXPAND PURERELEASEREDEX?)
          (("1" (EXPAND RELEASEREDEX?)
            (("1" (FLATTEN)
              (("1" (ASSERT)
                (("1" (EXPAND REFS -1) (("1" (PROPAX) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL)
         ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)
         ("5" (GRIND) NIL NIL)
         ("6" (EXPAND PURERELEASEREDEX?)
          (("6" (EXPAND RELEASEREDEX?)
            (("6" (FLATTEN)
              (("6" (ASSERT)
                (("6" (EXPAND MARK -6) (("6" (DECOMPOSE-EQUALITY -6) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[stack`length]")))
 (|releaseReduce_TCC3| 0
  (|releaseReduce_TCC3-1| "" 3710694054
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND EVERY)
      (("" (INST?)
        (("" (TYPEPRED "grS`redex")
          (("" (INST -2 "index(rvar(grS`redex))") (("" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     |rreduction| NIL)
    (|stack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S)}" |rreduction| NIL)
    (|x| SKOLEM-CONST-DECL "nonneg_int" |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|releaseReduce| SUBTYPE
    "rreduction.stack`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1))"
    "(IL.domainValue?(rreduction.grS`domain))"))
  (|releaseReduce_TCC3-1| NIL 3699031813
   ("" (SKEEP*)
    (("" (TYPEPRED STACK)
      (("" (GRIND)
        (("" (TYPEPRED "grS`redex")
          (("" (INST -2 "index(rvar(grS`redex))")
            (("" (TYPEPRED GRS) (("" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL) (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE
    "rreduction.stack`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (|releaseReduce_TCC4| 0
  (|releaseReduce_TCC4-1| "" 3710694082
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (INST -2 "index(rvar(grS`redex))") (("" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|releaseReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[grS`stack`length]"))
  (|releaseReduce_TCC4-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(refindex(vx))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (SPLIT)
            (("1" (EXPAND REFCOUNTSTACK)
              (("1" (USE "count_elem[(value?)]")
                (("1" (SPLIT)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (INST 1 "grS`stack`length-x-1")
                    (("1" (ASSERT) NIL NIL)
                     ("2" (TYPEPRED "grS`redex")
                      (("2" (INST -2 "index(rvar(grS`redex))")
                        (("2" (SPLIT -2)
                          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("3" (PROPAX) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND REFCOUNTSTACK)
              (("2" (REWRITE COUNT_UPDATE)
                (("1" (EXPAND REFCOUNTEXPR)
                  (("1" (EXPAND PURERELEASEREDEX?)
                    (("1" (EXPAND RELEASEREDEX?)
                      (("1" (FLATTEN)
                        (("1" (ASSERT)
                          (("1" (EXPAND REFS 1 1) (("1" (PROPAX) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (TYPEPRED "grS`redex")
                  (("2" (INST -2 "index(rvar(grS`redex))")
                    (("2" (GRIND) NIL NIL)) NIL))
                  NIL)
                 ("3" (GRIND) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (EXPAND EVERY)
        (("2" (INST?)
          (("1" (GRIND) NIL NIL)
           ("2" (TYPEPRED "grS`redex")
            (("2" (INST -2 "index(rvar(grS`redex))") (("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   ((|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)"
    "below[grS`stack`length]")))
 (|releaseReduce_TCC5| 0
  (|releaseReduce_TCC5-1| NIL 3699031813
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`redex")
      (("" (TYPEPRED "grS") (("" (GROUND) (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL (|releaseReduce| SUBTYPE "IExpression_adt.nil" "(IL.value?)")))
 (|releaseReduce_TCC6| 0
  (|releaseReduce_TCC6-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (GROUND)
        (("1" (SKEEP*) (("1" (GRIND) NIL NIL)) NIL)
         ("2" (SKEEP*) (("2" (GRIND) NIL NIL)) NIL)
         ("3" (SKEEP*) (("3" (GRIND) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)
         ("5" (GRIND) NIL NIL)
         ("6"
          (CASE-REPLACE
           "grS`redex = release(rvar(grS`redex), rexpr(grS`redex))")
          (("1" (EXPAND MARK -7)
            (("1" (SIMPLIFY) (("1" (DECOMPOSE-EQUALITY -7) NIL NIL)) NIL)) NIL)
           ("2" (GRIND-WITH-EXT) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|rexpr| ADT-ACCESSOR-DECL "[(release?) -> IExpression]" |IExpression_adt|
     NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|IExpression_release_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE "IExpression_adt.rexpr(rreduction.grS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|releaseReduce_TCC7| 0
  (|releaseReduce_TCC7-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE "IExpression_adt.refindex(rreduction.vx)"
    "(rreduction.grS`domain)")))
 (|releaseReduce_TCC8| 0
  (|releaseReduce_TCC8-1| NIL 3699031813
   ("" (SKEEP*)
    (("" (TYPEPRED "grS`count(refindex(vx))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (REPLACE-ETA "grS`redex" "(release?)")
            (("1" (REPLACE-ETA "grS`redex" "(release?)" T)
              (("1" (REPLACE -1 :DIR RL)
                (("1" (SIMPLIFY)
                  (("1" (EXPAND REFCOUNTSTACK)
                    (("1" (REWRITE COUNT_UPDATE)
                      (("1" (SPLIT)
                        (("1" (LEMMA "finseq_theorems[(value?)].count_elem")
                          (("1" (INST?)
                            (("1" (INST?)
                              (("1" (SPLIT -1)
                                (("1" (GRIND) NIL NIL)
                                 ("2" (INST 1 "grS`stack`length - x - 1")
                                  (("1" (GRIND) NIL NIL)
                                   ("2" (TYPEPRED "grS`redex")
                                    (("2" (INST -2 "index(rvar(grS`redex))")
                                      (("2" (GRIND) NIL NIL)) NIL))
                                    NIL))
                                  NIL)
                                 ("3" (PROPAX) NIL NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL)
                       ("2" (TYPEPRED "grS`redex")
                        (("2" (INST -2 "index(rvar(grS`redex))")
                          (("2" (GRIND) NIL NIL)) NIL))
                        NIL)
                       ("3" (GRIND) NIL NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "grS`stack")
        (("2" (GRIND)
          (("1" (TYPEPRED "grS`redex")
            (("1" (DELETE 2 3)
              (("1" (APPLY-ETA "grS`redex" "(release?)")
                (("1" (REPLACE -1 :DIR RL)
                  (("1" (INST -3 "index(rvar(grS`redex))")
                    (("1" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (DELETE 2 3 4)
            (("2" (TYPEPRED "grS`redex")
              (("2" (APPLY-ETA "grS`redex" "(release?)")
                (("2" (REPLACE -1 :DIR RL)
                  (("2" (INST -3 "index(rvar(grS`redex))")
                    (("2" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("3" (TYPEPRED "grS`redex")
            (("3" (APPLY-ETA "grS`redex" "(release?)")
              (("3" (REPLACE -1 :DIR RL)
                (("3" (INST -3 "index(rvar(grS`redex))")
                  (("3" (GRIND) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     |rreduction| NIL)
    (|x| SKOLEM-CONST-DECL "nonneg_int" |rreduction| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|IExpression_release_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE
    "(number_fields.-)(rreduction.grS`count(IExpression_adt.refindex(rreduction.vx)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), rreduction.x)) := IExpression_adt.nil], IExpression_adt.rexpr(rreduction.grS`redex))(IExpression_adt.refindex(rreduction.vx))}")))
 (|releaseReduce_TCC9| 0
  (|releaseReduce_TCC9-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (LIFT-IF)
          (("" (GROUND)
            (("" (INST -7 I)
              (("" (GROUND)
                (("1" (APPLY-ETA "grS`redex" "(release?)")
                  (("1" (REPLACE -1 :DIR RL) (("1" (GRIND) NIL NIL)) NIL)) NIL)
                 ("2" (GRIND) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|IExpression_release_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE
    "rreduction.grS WITH [`stack`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, rreduction.x), 1)) := IExpression_adt.nil, `count(IExpression_adt.refindex(rreduction.vx)) := (number_fields.-)(rreduction.grS`count(IExpression_adt.refindex(rreduction.vx)), 1), `redex := IExpression_adt.rexpr(rreduction.grS`redex)]"
    "(rreduction.noDanglingRefs?)")))
 (|releaseReduce_TCC10| 0
  (|releaseReduce_TCC10-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (INST -2 "index(rvar(grS`redex))")
        (("" (ASSERT)
          (("" (SPLIT -2) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE
    "rreduction.grS`store(IExpression_adt.refindex(rreduction.vx))`length"
    "naturalnumbers.upto(rreduction.grS`store(IExpression_adt.refindex(rreduction.vx))`length)")))
 (|releaseReduce_TCC11| 0
  (|releaseReduce_TCC11-1| NIL 3699031813
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (GROUND)
        (("1" (SKEEP*) (("1" (GRIND) NIL NIL)) NIL)
         ("2" (SKEEP*) (("2" (GRIND) NIL NIL)) NIL)
         ("3" (SKEEP*) (("3" (GRIND) NIL NIL)) NIL) ("4" (GRIND) NIL NIL)
         ("5" (GRIND) NIL NIL)
         ("6" (APPLY-ETA "grS`redex" "(release?)")
          (("6" (REPLACE -1 :DIR RL)
            (("6" (EXPAND MARK -7) (("6" (DECOMPOSE-EQUALITY -7) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|IExpression_release_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rexpr| ADT-ACCESSOR-DECL "[(release?) -> IExpression]" |IExpression_adt|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE "IExpression_adt.rexpr(rreduction.grS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|releaseReduce_TCC11-1| "" 3710694880
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (EXPAND PURERELEASEREDEX?)
        (("" (EXPAND RELEASEREDEX?)
          (("" (FLATTEN)
            (("" (ASSERT)
              (("" (SPLIT +)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
                 ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)
                 ("5" (EXPAND MARK -6) (("5" (DECOMPOSE-EQUALITY -6) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|releaseReduce| SUBTYPE "IExpression_adt.rexpr(rreduction.grS`redex)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|releaseReduce_TCC12| 0
  (|releaseReduce_TCC12-1| NIL 3699276705
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1) (("" (EXPAND REFCOUNT) (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}"
     |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rvar| ADT-ACCESSOR-DECL "[(release?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, IExpression_adt.rexpr(rreduction.grS`redex))(i)}]"))
  (|releaseReduce_TCC12-1| "" 3710694913
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1) (("" (EXPAND REFCOUNT) (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|releaseReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, IExpression_adt.rexpr(rreduction.grS`redex))(i)}]")))
 (|variableReduce_TCC1| 0
  (|variableReduce_TCC1-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)
   ((|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.expr"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|variableReduce_TCC2| 0
  (|variableReduce_TCC2-1| "" 3710694963
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND GET)
      (("" (EXPAND EVERY)
        (("" (INST? -8)
          (("" (INST -2 "index(expr)") (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|expr| SKOLEM-CONST-DECL "{A |
        (FORALL i: refs(A)(i) IMPLIES grS`domain(i))
    AND (FORALL i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length)
    AND (FORALL i:
           vars(grS`context)(i) IMPLIES
            i + popDepth(A) + popDepth(grS`context) < grS`stack`length)
    AND (popDepth(A) + popDepth(grS`context) <= grS`stack`length)
    AND contextPure?(A) AND (mark(cvars(grS`context))(A) = A)}"
     |rreduction| NIL)
    (|stack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S)}" |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL "{grS | variable?(grS`redex)}" |rreduction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[T]" |countability| "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|variableReduce| SUBTYPE "IL.get(rreduction.stack)(rreduction.expr)"
    "(IL.domainValue?(rreduction.grS`domain))"))
  (|variableReduce_TCC2-1| NIL 3705857843
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "stack")
      (("" (EXPAND EVERY)
        (("" (INST -1 "stack`length-1-index(expr)")
          (("1" (GRIND) NIL NIL)
           ("2" (INST -2 "index(expr)") (("2" (GRIND) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL) (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "IL.get(rreduction.stack)(rreduction.expr)"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (|variableReduce_TCC3| 0
  (|variableReduce_TCC3-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.variable?)")))
 (|variableReduce_TCC4| 0
  (|variableReduce_TCC4-2| "" 3714545539
   ("" (SKEEP* :PREDS? T)
    (("" (INST -4 "index(expr)") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|variableReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.variable?)"))
  (|variableReduce_TCC4-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT +)
          (("" (EXPAND REFCOUNTSTACK)
            (("" (REWRITE COUNT_UPDATE)
              (("1" (GRIND) NIL NIL)
               ("2" (INST -5 "index(expr)") (("2" (GRIND) NIL NIL)) NIL)
               ("3" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.variable?)"))
  (|variableReduce_TCC4-1| NIL 3705857843
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (SPLIT +)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.variable?)")))
 (|variableReduce_TCC5| 0
  (|variableReduce_TCC5-1| "" 3710694981
   ("" (SKEEP* :PREDS? T)
    (("" (INST -4 "index(expr)") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[T]" |countability| "sets_aux/")
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|variableReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(rreduction.expr))"
    "below[grS`stack`length]"))
  (|variableReduce_TCC5-1| NIL 3705857843
   ("" (SKEEP* :PREDS? T)
    (("" (INST -4 "index(expr)") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(rreduction.expr))"
    "below[grS`stack`length]")))
 (|variableReduce_TCC6| 0
  (|variableReduce_TCC6-1| NIL 3705848866 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|get| CONST-DECL "(value?)" IL NIL))
   NIL (|variableReduce| SUBTYPE "IExpression_adt.nil" "(IL.value?)")))
 (|variableReduce_TCC7| 0
  (|variableReduce_TCC7-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
       ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|popDepth| DEF-DECL "nat" IL NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|variableReduce_TCC8| 0
  (|variableReduce_TCC8-1| NIL 3705857843
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTSTACK)
            (("" (REWRITE COUNT_UPDATE)
              (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)
               ("2" (INST -5 "index(expr)") (("2" (GRIND) NIL NIL)) NIL)
               ("3" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nonempty_singleton_finite| APPLICATION-JUDGEMENT
     "non_empty_finite_set[T]" |countability| "sets_aux/")
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(rreduction.expr))) := IExpression_adt.nil], rreduction.value)(i)}]")))
 (|variableReduce_TCC9| 0
  (|variableReduce_TCC9-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
       ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|popDepth| DEF-DECL "nat" IL NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|variableReduce_TCC10| 0
  (|variableReduce_TCC10-1| NIL 3705848866 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|variableReduce| SUBTYPE "IExpression_adt.refindex(rreduction.value)"
    "(rreduction.grS`domain)")))
 (|variableReduce_TCC11| 0
  (|variableReduce_TCC11-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(refindex(value))")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR) (("" (GRIND) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE
    "(number_fields.+)(rreduction.grS`count(IExpression_adt.refindex(rreduction.value)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(IExpression_adt.refindex(rreduction.value))}"))
  (|variableReduce_TCC11-1| "" 3710695100
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(refindex(value))")
      (("" (REWRITE -1) (("" (EXPAND REFCOUNT) (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|variableReduce| SUBTYPE
    "(number_fields.+)(rreduction.grS`count(IExpression_adt.refindex(rreduction.value)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(IExpression_adt.refindex(rreduction.value))}")))
 (|variableReduce_TCC12| 0
  (|variableReduce_TCC12-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
       ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|popDepth| DEF-DECL "nat" IL NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|grS| SKOLEM-CONST-DECL "{grS | variable?(grS`redex)}" |rreduction| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|variableReduce_TCC12-1| "" 3710695144
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (SPLIT +)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|variableReduce| SUBTYPE "rreduction.value"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.grS`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.grS`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|variableReduce_TCC13| 0
  (|variableReduce_TCC13-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1) (("" (EXPAND REFCOUNT) (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(i)}]"))
  (|variableReduce_TCC13-1| "" 3710695164
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1) (("" (EXPAND REFCOUNT) (("" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|variableReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.grS`stack, rreduction.value)(i)}]")))
 (|letReduce_TCC1| 0
  (|letReduce_TCC1-1| NIL 3699107903 ("" (GRIND) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL (|letReduce| SUBTYPE "rreduction.expr" "(IExpression_adt.letexpr?)")))
 (|letReduce_TCC2| 0
  (|letReduce_TCC2-1| NIL 3699107903 ("" (GRIND) NIL NIL)
   ((|value?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|letReduce| SUBTYPE "IExpression_adt.letrhs(rreduction.expr)"
    "(IL.value?)")))
 (|letReduce_TCC3| 0
  (|letReduce_TCC3-2| "" 3715601263
   ("" (SKEEP*)
    (("" (TYPEPRED "stack")
      (("" (EXPAND EVERY)
        (("" (EXPAND PUSH)
          (("" (EXPAND ADD)
            (("" (SKEEP :PREDS? T)
              (("" (LIFT-IF)
                (("" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (TYPEPRED "expr")
                      (("1" (EXPAND DOMAINVALUE?)
                        (("1" (FLATTEN)
                          (("1" (INST? -1)
                            (("1" (SPLIT)
                              (("1" (PROPAX) NIL NIL)
                               ("2" (APPLY-ETA "expr" "(letexpr?)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|push| CONST-DECL "Stack" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_letexpr_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|letrhs| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|letReduce| SUBTYPE
    "IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S)}"))
  (|letReduce_TCC3-1| NIL 3699107903
   ("" (SKEEP*)
    (("" (TYPEPRED "stack")
      (("" (EXPAND EVERY)
        (("" (EXPAND PUSH)
          (("" (EXPAND ADD)
            (("" (SKEEP :PREDS? T)
              (("" (LIFT-IF)
                (("" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (TYPEPRED "expr")
                      (("1" (EXPAND DOMAINVALUE?)
                        (("1" (FLATTEN)
                          (("1" (INST? -1)
                            (("1" (SPLIT)
                              (("1" (PROPAX) NIL NIL)
                               ("2" (APPLY-ETA EXPR "(letexpr?)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|push| CONST-DECL "Stack" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_letexpr_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|letrhs| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|letReduce| SUBTYPE
    "IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S)}")))
 (|letReduce_TCC4| 0
  (|letReduce_TCC4-2| "" 3715601514
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT)
      (("1" (SKEEP)
        (("1" (EXPAND REFS -1)
          (("1" (USE PURE_REFS) (("1" (GRIND) NIL NIL)) NIL)) NIL))
        NIL)
       ("2" (SKEEP* :PREDS? T)
        (("2" (EXPAND POPDEPTH +)
          (("2" (EXPAND PUSH +)
            (("2" (EXPAND ADD +)
              (("2" (INST -4 "i")
                (("2" (SPLIT)
                  (("1" (REWRITE PUREPOPDEPTH +)
                    (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (SKEEP)
        (("3" (INST -4 "i")
          (("3" (SPLIT)
            (("1" (EXPAND POPDEPTH + 1)
              (("1" (REWRITE PUREPOPDEPTH +)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL)
             ("2" (PROPAX) NIL NIL))
            NIL))
          NIL))
        NIL)
       ("4" (EXPAND POPDEPTH + 1)
        (("4" (REWRITE PUREPOPDEPTH +)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
        NIL)
       ("5" (EXPAND CONTEXTPURE?)
        (("5" (USE PURE_CONTEXTPURE) (("5" (GRIND) NIL NIL)) NIL)) NIL)
       ("6" (EXPAND MARK +)
        (("6" (DECOMPOSE-EQUALITY)
          (("6" (APPLY-ETA "expr" "(letexpr?)")
            (("6" (REPLACE -1 :DIR RL)
              (("6" (ASSERT)
                (("6" (EXPAND MARK -)
                  (("6" (DECOMPOSE-EQUALITY -7)
                    (("6" (CASE "vars(body(expr))(0)")
                      (("1" (ASSERT) NIL NIL)
                       ("2" (ASSERT)
                        (("2"
                          (CASE "top_releases(release(variable(0, TRUE),
                       mark(bump(cvars(grS`context)))(body(expr))))
                = top_releases(body(expr))")
                          (("1" (EXPAND TOP_RELEASES -1 1)
                            (("1" (REWRITE TOP_RELEASES_MARK)
                              (("1" (ASSERT) NIL NIL)) NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refs| DEF-DECL "bool" IL NIL) (|letRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|body| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|push| CONST-DECL "Stack" IL NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|pop| ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" |IExpression_adt|
     NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_pop_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|pop?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|top_releases| DEF-DECL "nat" |preprocess| NIL)
    (|top_releases_mark| FORMULA-DECL NIL |preprocess| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|letexpr| ADT-CONSTRUCTOR-DECL
     "[[IExpression, IExpression] -> (letexpr?)]" |IExpression_adt| NIL)
    (|letrhs| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|IExpression_letexpr_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|letReduce| SUBTYPE
    "IExpression_adt.pop(IExpression_adt.body(rreduction.expr))"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|letReduce_TCC4-1| NIL 3699107903
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT)
      (("1" (SKEEP)
        (("1" (EXPAND REFS -1)
          (("1" (USE PURE_REFS) (("1" (GRIND) NIL NIL)) NIL)) NIL))
        NIL)
       ("2" (SKEEP* :PREDS? T)
        (("2" (EXPAND POPDEPTH +)
          (("2" (EXPAND PUSH +)
            (("2" (EXPAND ADD +)
              (("2" (INST -4 I)
                (("2" (SPLIT)
                  (("1" (REWRITE PUREPOPDEPTH +)
                    (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("3" (SKEEP)
        (("3" (INST -4 I)
          (("3" (SPLIT)
            (("1" (EXPAND POPDEPTH + 1)
              (("1" (REWRITE PUREPOPDEPTH +)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL)
             ("2" (PROPAX) NIL NIL))
            NIL))
          NIL))
        NIL)
       ("4" (EXPAND POPDEPTH + 1)
        (("4" (REWRITE PUREPOPDEPTH +)
          (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
        NIL)
       ("5" (EXPAND CONTEXTPURE?)
        (("5" (USE PURE_CONTEXTPURE) (("5" (GRIND) NIL NIL)) NIL)) NIL)
       ("6" (EXPAND MARK +)
        (("6" (DECOMPOSE-EQUALITY)
          (("6" (APPLY-ETA "expr" "(letexpr?)")
            (("6" (REPLACE -1 :DIR RL)
              (("6" (ASSERT)
                (("6" (EXPAND MARK -)
                  (("6" (DECOMPOSE-EQUALITY -7)
                    (("6" (CASE "vars(body(expr))(0)")
                      (("1" (ASSERT) NIL NIL)
                       ("2" (ASSERT)
                        (("2"
                          (CASE "top_releases(release(variable(0, TRUE),
              mark(bump(cvars(grS`context)))(body(expr))))
       = top_releases(body(expr))")
                          (("1" (EXPAND TOP_RELEASES -1 1)
                            (("1" (REWRITE TOP_RELEASES_MARK)
                              (("1" (ASSERT) NIL NIL)) NIL))
                            NIL)
                           ("2" (ASSERT) NIL NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refs| DEF-DECL "bool" IL NIL) (|letRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|body| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|push| CONST-DECL "Stack" IL NIL)
    (|pure_contextPure| FORMULA-DECL NIL IL NIL)
    (|pop| ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" |IExpression_adt|
     NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_pop_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|pop?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|top_releases| DEF-DECL "nat" |preprocess| NIL)
    (|top_releases_mark| FORMULA-DECL NIL |preprocess| NIL)
    (TRUE CONST-DECL "bool" |booleans| NIL)
    (|variable| ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]"
     |IExpression_adt| NIL)
    (|release| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression] -> (release?)]" |IExpression_adt| NIL)
    (|release?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|letexpr| ADT-CONSTRUCTOR-DECL
     "[[IExpression, IExpression] -> (letexpr?)]" |IExpression_adt| NIL)
    (|letrhs| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|IExpression_letexpr_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|letReduce| SUBTYPE
    "IExpression_adt.pop(IExpression_adt.body(rreduction.expr))"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack)`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|letReduce_TCC5| 0
  (|letReduce_TCC5-1| NIL 3699107903
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTSTACK)
            (("" (EXPAND REFCOUNTEXPR)
              (("" (CASE-REPLACE "refs(pop(body(expr)))(x1) = FALSE")
                (("1" (EXPAND PUSH)
                  (("1" (REWRITE COUNT_ADD) (("1" (GRIND) NIL NIL)) NIL)) NIL)
                 ("2" (EXPAND REFS)
                  (("2" (USE PURE_REFS) (("2" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|pure_refs| FORMULA-DECL NIL IL NIL) (|push| CONST-DECL "Stack" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|count_add| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|letrhs| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (FALSE CONST-DECL "bool" |booleans| NIL)
    (|body| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|pop| ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" |IExpression_adt|
     NIL)
    (|pop?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|letReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, IL.push(IExpression_adt.letrhs(rreduction.expr), rreduction.stack), IExpression_adt.pop(IExpression_adt.body(rreduction.expr)))(i)}]")))
 (|count_copy_TCC1| 0
  (|count_copy_TCC1-1| NIL 3699369652 ("" (SUBTYPE-TCC) NIL NIL)
   ((|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|count_copy| SUBTYPE "IExpression_adt.refindex(rreduction.r)"
    "(rreduction.dom)")))
 (|count_copy_TCC2| 0
  (|count_copy_TCC2-1| NIL 3699369652 ("" (SKEEP*) (("" (GRIND) NIL NIL)) NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL
   (|count_copy| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "naturalnumbers.upto(rreduction.V`length)")))
 (|count_copy_TCC3| 0
  (|count_copy_TCC3-1| NIL 3699369652 ("" (TERMINATION-TCC) NIL NIL)
   ((|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL))
   NIL
   (|count_copy| TERMINATION
    "rreduction.count_copy(rreduction.dom, rreduction.ncnt, rreduction.V, (number_fields.-)(rreduction.i, 1))"
    "NIL")))
 (|count_copy_TCC4| 0
  (|count_copy_TCC4-1| NIL 3699369652 ("" (SUBTYPE-TCC) NIL NIL)
   ((|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|count_copy| SUBTYPE "(number_fields.-)(rreduction.i, 1)"
    "below[length(V)]")))
 (|count_copy_def_TCC1| 0
  (|count_copy_def_TCC1-1| NIL 3699369652 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|count_copy_def| SUBTYPE "rreduction.V`length"
    "naturalnumbers.upto(rreduction.V`length)")))
 (|count_copy_def| 0
  (|count_copy_def-2| "" 3715608992
   ("" (SKEEP*)
    ((""
      (CASE
          "forall (j: nat): j <= V`length IMPLIES forall (cnt: [(dom) -> nat]): count_copy(dom, cnt, V, j)(i) = cnt(i) + count((lambda u: ref?(u) and refindex(u) = i), (# `length := j, `seq := (LAMBDA (k: below(j)): V`seq(k)) #))")
      (("1" (INST -1 "V`length")
        (("1" (SIMPLIFY)
          (("1" (INST -1 "cnt")
            (("1" (REWRITE -1)
              (("1" (EXPAND REFCOUNTARRAY)
                (("1"
                  (CASE-REPLACE "(# `length := V`length,
                   `seq := lambda (k: below(V`length)): V`seq(k) #) = V")
                  (("1" (GRIND-WITH-EXT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (INDUCT "j")
        (("1" (GRIND) NIL NIL)
         ("2" (SKEEP)
          (("2" (SKOLEM 1 "cnt2")
            (("2" (DELETE 2)
              (("2" (SIMPLIFY)
                (("2" (SPLIT -1)
                  (("1" (EXPAND COUNT_COPY 1)
                    (("1" (REWRITE -1)
                      (("1"
                        (NAME "Z" "(# `length := j_1,
                               `seq := lambda (k: below(j_1)): V`seq(k) #)")
                        (("1" (REPLACE -1)
                          (("1"
                            (CASE-REPLACE "(# `length := 1 + j_1,
                             `seq := lambda (k: below(1 + j_1)): V`seq(k) #) = add(V`seq(j_1), Z)")
                            (("1" (REWRITE COUNT_ADD)
                              (("1" (LIFT-IF)
                                (("1" (LIFT-IF)
                                  (("1" (LIFT-IF)
                                    (("1" (LIFT-IF)
                                      (("1" (SIMPLIFY) (("1" (GRIND) NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (DELETE 2)
                              (("2" (EXPAND ADD)
                                (("2" (DELETE -2)
                                  (("2" (REPLACE -1 :DIR RL)
                                    (("2" (SIMPLIFY)
                                      (("2" (APPLY-EXTENSIONALITY 1)
                                        (("2" (DELETE 2)
                                          (("2" (LIFT-IF 1)
                                            (("2" (GRIND) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)
                             ("5" (GRIND) NIL NIL))
                            NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL)
                       ("2" (GRIND)
                        (("2" (GRIND)
                          (("2" (GRIND)
                            (("2" (GRIND)
                              (("2" (TYPEPRED "V`seq(j_1)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("3" (GRIND) NIL NIL))
        NIL)
       ("3" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|j_1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|count_add| FORMULA-DECL NIL |finseq_theorems| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|seq| TYPE-EQ-DECL NIL |more_finseq| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL)
    (V SKOLEM-CONST-DECL "finseq[(domainValue?(dom))]" |rreduction| NIL)
    (|dom| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK)
  (|count_copy_def-1| NIL 3699371811
   ("" (SKEEP*)
    ((""
      (CASE
          "forall (j: nat): j <= V`length IMPLIES forall (cnt: [(dom) -> nat]): count_copy(dom, cnt, V, j)(i) = cnt(i) + count((lambda u: ref?(u) and refindex(u) = i), (# `length := j, `seq := (LAMBDA (k: below(j)): V`seq(k)) #))")
      (("1" (INST -1 "V`length")
        (("1" (SIMPLIFY)
          (("1" (INST -1 "cnt")
            (("1" (REWRITE -1)
              (("1" (EXPAND REFCOUNTARRAY)
                (("1"
                  (CASE-REPLACE "(# `length := V`length,
               `seq := lambda (k: below(V`length)): V`seq(k) #) = V")
                  (("1" (GRIND-WITH-EXT) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (INDUCT J)
        (("1" (GRIND) NIL NIL)
         ("2" (SKEEP)
          (("2" (SKOLEM 1 "cnt2")
            (("2" (DELETE 2)
              (("2" (SIMPLIFY)
                (("2" (SPLIT -1)
                  (("1" (EXPAND COUNT_COPY 1)
                    (("1" (REWRITE -1)
                      (("1"
                        (NAME "Z" "(# `length := j_1,
                `seq := lambda (k: below(j_1)): V`seq(k) #)")
                        (("1" (REPLACE -1)
                          (("1"
                            (CASE-REPLACE "(# `length := 1 + j_1,
                 `seq := lambda (k: below(1 + j_1)): V`seq(k) #) = add(V`seq(j_1), Z)")
                            (("1" (REWRITE COUNT_ADD)
                              (("1" (LIFT-IF)
                                (("1" (LIFT-IF)
                                  (("1" (LIFT-IF)
                                    (("1" (LIFT-IF)
                                      (("1" (SIMPLIFY) (("1" (GRIND) NIL NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (DELETE 2)
                              (("2" (EXPAND ADD)
                                (("2" (DELETE -2)
                                  (("2" (REPLACE -1 :DIR RL)
                                    (("2" (SIMPLIFY)
                                      (("2" (APPLY-EXTENSIONALITY 1)
                                        (("2" (DELETE 2)
                                          (("2" (LIFT-IF 1)
                                            (("2" (GRIND) NIL NIL)) NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)
                             ("5" (GRIND) NIL NIL))
                            NIL))
                          NIL)
                         ("2" (GRIND) NIL NIL))
                        NIL)
                       ("2" (GRIND)
                        (("2" (GRIND)
                          (("2" (GRIND)
                            (("2" (GRIND)
                              (("2" (TYPEPRED "V`seq(j_1)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL))
                      NIL))
                    NIL)
                   ("2" (GRIND) NIL NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("3" (GRIND) NIL NIL))
        NIL)
       ("3" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (<= CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|upto| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    NIL
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|count_add| FORMULA-DECL NIL |finseq_theorems| NIL)
    (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|seq| TYPE-EQ-DECL NIL |more_finseq| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) NIL NIL
    (|pred| TYPE-EQ-DECL NIL |defined_types| NIL))
   SHOSTAK))
 (|updateRedex_target_index_TCC1| 0
  (|updateRedex_target_index_TCC1-1| NIL 3701021413 ("" (SUBTYPE-TCC) NIL NIL)
   ((|updateRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateRedex_target_index| SUBTYPE "rreduction.grS`redex"
    "(IExpression_adt.update?)")))
 (|updateRedex_target_index| 0
  (|updateRedex_target_index-1| NIL 3701115744
   ("" (SKEEP) (("" (TYPEPRED "grS`redex") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|updateRedex_lhs_index| 0
  (|updateRedex_lhs_index-1| NIL 3701115767
   ("" (SKEEP) (("" (TYPEPRED "grS`redex") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|updateRedex_rhs_index| 0
  (|updateRedex_rhs_index-1| NIL 3701115794
   ("" (SKEEP) (("" (TYPEPRED "grS`redex") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|maybe_clear_stack_at_TCC1| 0
  (|maybe_clear_stack_at_TCC1-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) NIL
   (|maybe_clear_stack_at| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.newStack`length, 1), rreduction.i)"
    "below[newStack`length]")))
 (|maybe_clear_stack_at_TCC2| 0
  (|maybe_clear_stack_at_TCC2-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) NIL
   (|maybe_clear_stack_at| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.S`length, 1), rreduction.i)"
    "below[S`length]")))
 (|maybe_clear_stack_at_TCC3| 0
  (|maybe_clear_stack_at_TCC3-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)"
    "below[S`length]")))
 (|maybe_clear_stack_at_TCC4| 0
  (|maybe_clear_stack_at_TCC4-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|get| CONST-DECL "(value?)" IL NIL))
   NIL (|maybe_clear_stack_at| SUBTYPE "IExpression_adt.nil" "(IL.value?)")))
 (|maybe_clear_stack_at_TCC5| 0
  (|maybe_clear_stack_at_TCC5-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE
    "rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)) := IExpression_adt.nil]"
    "{newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)}")))
 (|maybe_clear_stack_at_TCC6| 0
  (|maybe_clear_stack_at_TCC6-3| "" 3715072944
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTSTACK)
            (("" (REWRITE COUNT_UPDATE)
              (("1" (EXPAND GET)
                (("1" (REPLACE -9)
                  (("1" (REPLACE -9 :DIR RL) (("1" (POSTPONE) NIL NIL)) NIL))
                  NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|maybe_clear_stack_at| SUBTYPE "rreduction.cnt"
    "[i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(i)}]"))
  (|maybe_clear_stack_at_TCC6-2| "" 3714766340
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(v))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (EXPAND REFCOUNTSTACK)
            (("1" (USE "count_elem[(value?)]")
              (("1" (SPLIT -1)
                (("1" (ASSERT)
                  (("1" (EXPAND "count") (("1" (POSTPONE) NIL NIL)) NIL)) NIL)
                 ("2" (EXPAND GET) (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL))
                  NIL)
                 ("3" (PROPAX) NIL NIL))
                NIL)
               ("2" (ASSERT) (("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|maybe_clear_stack_at| SUBTYPE "rreduction.cnt"
    "[i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(i)}]"))
  (|maybe_clear_stack_at_TCC6-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(v))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (SPLIT)
            (("1" (EXPAND REFCOUNTSTACK)
              (("1" (USE "count_elem[(value?)]")
                (("1" (SPLIT -1)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (EXPAND GET)
                    (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)
                   ("3" (PROPAX) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND REFCOUNTSTACK)
              (("2" (REWRITE COUNT_UPDATE)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (GRIND) NIL NIL) ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   ((|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE "rreduction.cnt"
    "[i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(i)}]")))
 (|maybe_clear_stack_at_TCC7| 0
  (|maybe_clear_stack_at_TCC7-2| "" 3714766523
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND "every")
      (("" (EXPAND GET) (("" (REPLACE -8) (("" (GRIND) NIL NIL)) NIL)) NIL))
      NIL))
    NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   SHOSTAK
   (|maybe_clear_stack_at| SUBTYPE "IExpression_adt.refindex(rreduction.v)"
    "(rreduction.dom)"))
  (|maybe_clear_stack_at_TCC7-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(v))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (SPLIT)
            (("1" (EXPAND REFCOUNTSTACK)
              (("1" (USE "count_elem[(value?)]")
                (("1" (SPLIT)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (EXPAND GET)
                    (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)
                   ("3" (PROPAX) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND REFCOUNTSTACK)
              (("2" (REWRITE COUNT_UPDATE)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (GRIND) NIL NIL) ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE "IExpression_adt.refindex(rreduction.v)"
    "(rreduction.dom)")))
 (|maybe_clear_stack_at_TCC8| 0
  (|maybe_clear_stack_at_TCC8-1| "" 3710695262
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(v))")
      (("1" (REWRITE -1)
        (("1" (EXPAND REFCOUNT)
          (("1" (SPLIT)
            (("1" (EXPAND "refcountStack")
              (("1" (USE "count_elem[(value?)]")
                (("1" (SPLIT)
                  (("1" (ASSERT) NIL NIL)
                   ("2" (EXPAND GET)
                    (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)
                   ("3" (PROPAX) NIL NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (EXPAND "refcountStack")
              (("2" (REWRITE COUNT_UPDATE)
                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (GRIND) NIL NIL) ("3" (PROPAX) NIL NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK
   (|maybe_clear_stack_at| SUBTYPE
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(IExpression_adt.refindex(rreduction.v))}"))
  (|maybe_clear_stack_at_TCC8-1| NIL 3706034968 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), IExpression_adt.index(rreduction.x))) := IExpression_adt.nil], rreduction.A)(IExpression_adt.refindex(rreduction.v))}")))
 (|maybe_clear_stack_at_TCC9| 0
  (|maybe_clear_stack_at_TCC9-1| NIL 3706032808 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE
    "(rreduction.S WITH [`seq((number_fields.-)((number_fields.-)(rreduction.S`length, IExpression_adt.index(rreduction.x)), 1)) := IExpression_adt.nil], rreduction.cnt WITH [(IExpression_adt.refindex(rreduction.v)) := (number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.v)), 1)])"
    "{((newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)), (newcnt: [i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.newStack, rreduction.A)(i)}])) | FORALL (i: naturalnumbers.below(rreduction.S`length)): booleans.IMPLIES(IExpression_adt.ref?(newStack`seq((number_fields.-)((number_fields.-)(newStack`length, 1), i))), booleans.AND(IExpression_adt.ref?(rreduction.S`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), i))), ))}")))
 (|maybe_clear_stack_at_TCC10| 0
  (|maybe_clear_stack_at_TCC10-1| NIL 3706034968 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|get| CONST-DECL "(value?)" IL NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE "rreduction.S"
    "{newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)}")))
 (|maybe_clear_stack_at_TCC11| 0
  (|maybe_clear_stack_at_TCC11-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|maybe_clear_stack_at| SUBTYPE "(rreduction.S, rreduction.cnt)"
    "{((newStack: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.dom))(newStack), newStack`length = rreduction.S`length)), (newcnt: [i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str, rreduction.newStack, rreduction.A)(i)}])) | FORALL (i: naturalnumbers.below(rreduction.S`length)): booleans.IMPLIES(IExpression_adt.ref?(newStack`seq((number_fields.-)((number_fields.-)(newStack`length, 1), i))), booleans.AND(IExpression_adt.ref?(rreduction.S`seq((number_fields.-)((number_fields.-)(rreduction.S`length, 1), i))), ))}")))
 (|update_store_TCC1| 0
  (|update_store_TCC1-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|update_store| SUBTYPE "IExpression_adt.refindex(rreduction.ov)"
    "(rreduction.dom)")))
 (|update_store_TCC2| 0
  (|update_store_TCC2-2| "" 3715618863
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(ov))")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (CASE "refcountStore(dom, str)(refindex(ov)) > 0")
            (("1" (ASSERT) NIL NIL)
             ("2" (HIDE 2)
              (("2" (EXPAND REFCOUNTSTORE)
                (("2" (EXPAND ALLCOUNT)
                  (("2" (LEMMA SIGMA_ADD)
                    (("2" (INST -1 "dom" _ "r")
                      (("2" (INST?)
                        (("1" (SPLIT)
                          (("1" (REWRITE -1)
                            (("1" (EXPAND REFCOUNTARRAY 1 1)
                              (("1" (USE "count_elem[(value?)]")
                                (("1" (SPLIT)
                                  (("1" (ASSERT) NIL NIL)
                                   ("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)
                                   ("3" (PROPAX) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (EXPAND MEMBER) (("2" (PROPAX) NIL NIL)) NIL))
                          NIL)
                         ("2" (ASSERT) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|member| CONST-DECL "bool" |sets| NIL)
    (|ov| SKOLEM-CONST-DECL "(domainValue?(dom))" |rreduction| NIL)
    (|dom| SKOLEM-CONST-DECL "finite_set[nat]" |rreduction| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK
   (|update_store| SUBTYPE
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.ov)), 1)"
    "nat"))
  (|update_store_TCC2-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(ov))")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (CASE "refcountStore(dom, str)(refindex(ov)) > 0")
            (("1" (ASSERT) NIL NIL)
             ("2" (HIDE 2)
              (("2" (EXPAND REFCOUNTSTORE)
                (("2" (EXPAND ALLCOUNT)
                  (("2" (LEMMA SIGMA_ADD)
                    (("2" (INST -1 "dom" _ R)
                      (("2" (INST?)
                        (("1" (SPLIT)
                          (("1" (REWRITE -1)
                            (("1" (EXPAND REFCOUNTARRAY 1 1)
                              (("1" (USE "count_elem[(value?)]")
                                (("1" (SPLIT)
                                  (("1" (ASSERT) NIL NIL)
                                   ("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)
                                   ("3" (PROPAX) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (EXPAND MEMBER) (("2" (PROPAX) NIL NIL)) NIL))
                          NIL)
                         ("2" (ASSERT) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|count_elem| FORMULA-DECL NIL |finseq_theorems| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|member| CONST-DECL "bool" |sets| NIL) NIL NIL
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (> CONST-DECL "bool" |reals| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL))
   NIL
   (|update_store| SUBTYPE
    "(number_fields.-)(rreduction.cnt(IExpression_adt.refindex(rreduction.ov)), 1)"
    "nat")))
 (|update_store_TCC3| 0
  (|update_store_TCC3-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|injective?| CONST-DECL "bool" |functions| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|update_store| SUBTYPE "IExpression_adt.refindex(rreduction.nv)"
    "(rreduction.dom)")))
 (|update_store_TCC4| 0
  (|update_store_TCC4-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "cnt(refindex(nv))")
      (("" (REPLACE -11)
        (("" (LIFT-IF)
          (("" (LIFT-IF)
            (("" (ASSERT)
              (("" (REWRITE -1)
                (("" (SPLIT +)
                  (("1" (FLATTEN)
                    (("1" (SPLIT +)
                      (("1" (FLATTEN)
                        (("1" (REPLACE -1 :DIR RL)
                          (("1" (TYPEPRED "cnt(refindex(nv))")
                            (("1" (REWRITE -1)
                              (("1"
                                (CASE-REPLACE
                                 "str WITH [(r)`seq(i) := nv] = str")
                                (("1" (DECOMPOSE-EQUALITY)
                                  (("1" (LIFT-IF)
                                    (("1" (SPLIT)
                                      (("1" (FLATTEN)
                                        (("1" (DECOMPOSE-EQUALITY)
                                          (("1" (DECOMPOSE-EQUALITY)
                                            (("1" (LIFT-IF)
                                              (("1" (SPLIT)
                                                (("1" (FLATTEN)
                                                  (("1" (ASSERT)
                                                    (("1" (REPLACE*)
                                                      (("1"
                                                        (HIDE-ALL-BUT
                                                         (1 -4 -3 -13))
                                                        (("1" (GRIND-WITH-EXT)
                                                          (("1" (GRIND)
                                                            (("1"
                                                              (GRIND-WITH-EXT)
                                                              (("1"
                                                                (APPLY-ETA "nv"
                                                                 "(ref?)")
                                                                (("1"
                                                                  (REPLACE -1
                                                                           :DIR
                                                                           RL)
                                                                  (("1"
                                                                    (ASSERT)
                                                                    (("1"
                                                                      (HIDE -1)
                                                                      (("1"
                                                                        (GRIND-WITH-EXT)
                                                                        NIL
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (PROPAX) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL)
                                       ("2" (PROPAX) NIL NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (FLATTEN)
                        (("2" (EXPAND REFCOUNT)
                          (("2" (REWRITE REFCOUNTSTORE_SET)
                            (("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (EXPAND REFCOUNT)
                      (("2" (REWRITE REFCOUNTSTORE_SET) (("2" (GRIND) NIL NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|IExpression_ref_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|ref| ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" |IExpression_adt| NIL)
    (|IExpression_ref_eta| FORMULA-DECL NIL |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|refcountStore_set| FORMULA-DECL NIL |rreduction| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|int_times_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL))
   NIL
   (|update_store| SUBTYPE
    "(number_fields.+)(rreduction.cnt1(IExpression_adt.refindex(rreduction.nv)), 1)"
    "{j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str WITH [(rreduction.r)`seq(rreduction.i) := rreduction.nv], rreduction.S, rreduction.A)(IExpression_adt.refindex(rreduction.nv))}")))
 (|update_store_TCC5| 0
  (|update_store_TCC5-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (REPLACE -10)
      (("" (LIFT-IF)
        (("" (SPLIT)
          (("1" (FLATTEN)
            (("1" (ASSERT)
              (("1" (LIFT-IF)
                (("1" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (TYPEPRED "cnt(refindex(ov))")
                      (("1" (REWRITE -1)
                        (("1" (EXPAND REFCOUNT)
                          (("1" (REPLACE -1)
                            (("1" (ASSERT)
                              (("1" (REWRITE REFCOUNTSTORE_SET)
                                (("1" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (TYPEPRED "cnt(x1)")
                      (("2" (REWRITE -1)
                        (("2" (EXPAND REFCOUNT)
                          (("2" (REWRITE REFCOUNTSTORE_SET)
                            (("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (SPLIT)
            (("1" (FLATTEN) NIL NIL)
             ("2" (FLATTEN)
              (("2" (TYPEPRED "cnt(x1)")
                (("2" (REWRITE -1)
                  (("2" (EXPAND REFCOUNT)
                    (("2" (REWRITE REFCOUNTSTORE_SET) (("2" (GRIND) NIL NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore_set| FORMULA-DECL NIL |rreduction| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|update_store| SUBTYPE "rreduction.cnt1"
    "[i: (rreduction.dom) -> {j | rreduction.j = rreduction.refcount(rreduction.dom, rreduction.str WITH [(rreduction.r)`seq(rreduction.i) := rreduction.nv], rreduction.S, rreduction.A)(i)}]")))
 (|updateReduce_TCC1| 0
  (|updateReduce_TCC1-1| NIL 3714529219
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (SPLIT)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.grS`redex"
    "{A: (IExpression_adt.update?) | booleans.AND(reals.<(IExpression_adt.index(IExpression_adt.target(A)), rreduction.stack`length), booleans.AND(reals.<(IExpression_adt.index(IExpression_adt.lhs(A)), rreduction.stack`length), reals.<(IExpression_adt.index(IExpression_adt.rhs(A)), rreduction.stack`length)))}")))
 (|updateReduce_TCC2| 0
  (|updateReduce_TCC2-1| NIL 3699107903
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`redex")
      (("" (SPLIT)
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
         ("4" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.target(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|updateReduce_TCC3| 0
  (|updateReduce_TCC3-1| NIL 3699107903 ("" (SUBTYPE-TCC) NIL NIL)
   ((|domainValue?| CONST-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE
    "IL.get(rreduction.stack)(IExpression_adt.target(rreduction.expr))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (|updateReduce_TCC4| 0
  (|updateReduce_TCC4-1| "" 3706018643 ("" (SKEEP* :PREDS? T) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "IExpression_adt.lhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (|updateReduce_TCC4-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.lhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|updateReduce_TCC5| 0
  (|updateReduce_TCC5-1| NIL 3714529219
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND EVERY -9)
      (("" (INST -9 "stack`length - 1 - index(lhs(expr))")
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction|
     NIL)
    (|stack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S)}" |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|expr| SKOLEM-CONST-DECL "{A: (update?) |
   index(target(A)) < stack`length AND
    index(lhs(A)) < stack`length AND index(rhs(A)) < stack`length}"
     |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE
    "IL.get(rreduction.stack)(IExpression_adt.lhs(rreduction.expr))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (|updateReduce_TCC6| 0
  (|updateReduce_TCC6-1| NIL 3699107903
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND EVERY -9)
      (("" (INST -9 "stack`length - 1 - index(lhs(expr))")
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.rhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (|updateReduce_TCC6-1| "" 3706018675 ("" (SKEEP* :PREDS? T) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "IExpression_adt.rhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}"))
  (|updateReduce_TCC6-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED STACK) (("" (EXPAND* EVERY GET) (("" (INST?) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.rhs(rreduction.expr)"
    "{x | reals.<(IExpression_adt.index(IL.x), rreduction.stack`length)}")))
 (|updateReduce_TCC7| 0
  (|updateReduce_TCC7-1| NIL 3714529219
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND EVERY -11)
      (("" (INST -11 "stack`length - 1 - index(rhs(expr))")
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction|
     NIL)
    (|stack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S)}" |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|expr| SKOLEM-CONST-DECL "{A: (update?) |
   index(target(A)) < stack`length AND
    index(lhs(A)) < stack`length AND index(rhs(A)) < stack`length}"
     |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE
    "IL.get(rreduction.stack)(IExpression_adt.rhs(rreduction.expr))"
    "(IL.domainValue?(rreduction.grS`domain))")))
 (|updateReduce_TCC8| 0
  (|updateReduce_TCC8-1| NIL 3699107903
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND EVERY -11)
      (("" (INST -11 "stack`length - 1 - index(rhs(expr))")
        (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.refindex(rreduction.aval)"
    "(rreduction.grS`domain)"))
  (|updateReduce_TCC8-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED STACK) (("" (EXPAND* EVERY GET) (("" (INST?) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.refindex(rreduction.aval)"
    "(rreduction.grS`domain)")))
 (|updateReduce_TCC9| 0
  (|updateReduce_TCC9-2| "" 3714786059
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR)
            (("" (REPLACE -16) (("" (REPLACE -15) (("" (PROPAX) NIL NIL)) NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.stack, rreduction.expr)(i)}]"))
  (|updateReduce_TCC9-1| "" 3706030420
   ("" (SKEEP* :PREDS? T) (("" (EXPAND EVERY) (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.grS`count"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.stack, rreduction.expr)(i)}]")))
 (|updateReduce_TCC10| 0
  (|updateReduce_TCC10-2| "" 3714546743 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "IExpression_adt.target(rreduction.expr)"
    "{x: (IExpression_adt.variable?) | reals.<(IExpression_adt.index(x), rreduction.nstack`length)}"))
  (|updateReduce_TCC10-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`count(x1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.target(rreduction.expr)"
    "{x: (IExpression_adt.variable?) | reals.<(IExpression_adt.index(x), rreduction.nstack`length)}"))
  (|updateReduce_TCC10-1| NIL 3699107903 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.target(rreduction.expr)"
    "{x: (IExpression_adt.variable?) | reals.<(IExpression_adt.index(x), rreduction.nstack`length)}")))
 (|updateReduce_TCC11| 0
  (|updateReduce_TCC11-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL (|updateReduce| SUBTYPE "rreduction.oldref" "(rreduction.grS`domain)")))
 (|updateReduce_TCC12| 0
  (|updateReduce_TCC12-1| NIL 3699107903
   ("" (SKEEP* :PREDS? T)
    (("" (CASE "domainValue?(grS`domain)(grS`store(oldref)`seq(x1))")
      (("1" (EXPAND "domainValue?")
        (("1" (ASSERT)
          (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "grS`store(oldref)`seq(x1)") (("2" (PROPAX) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.grS`store(rreduction.oldref)"
    "finseq[(domainValue?(newdomain))]")))
 (|updateReduce_TCC13| 0
  (|updateReduce_TCC13-2| "" 3714547029 ("" (SUBTYPE-TCC) NIL NIL)
   ((|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.newref" "(rreduction.newdomain)"))
  (|updateReduce_TCC13-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (CASE "domainValue?(grS`domain)(grS`store(oldref)`seq(x1))")
      (("1" (EXPAND DOMAINVALUE?)
        (("1" (ASSERT)
          (("1" (FLATTEN) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "grS`store(oldref)`seq(x1)") (("2" (PROPAX) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL))
   NIL (|updateReduce| SUBTYPE "rreduction.newref" "(rreduction.newdomain)"))
  (|updateReduce_TCC13-1| "" 3710695340
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "grS`store(oldref)`seq(x1)") (("" (GRIND) NIL NIL)) NIL))
    NIL)
   NIL SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.newref" "(rreduction.newdomain)")))
 (|updateReduce_TCC14| 0
  (|updateReduce_TCC14-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.copied`length"
    "naturalnumbers.upto(rreduction.copied`length)"))
  (|updateReduce_TCC14-1| NIL 3699107903 ("" (GRIND) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.copied`length"
    "naturalnumbers.upto(rreduction.copied`length)")))
 (|updateReduce_TCC15| 0
  (|updateReduce_TCC15-2| "" 3715619426
   ("" (SKEEP* :PREDS? T)
    (("" (REWRITE COUNT_COPY_DEF)
      (("1" (LIFT-IF)
        (("1" (SPLIT +)
          (("1" (FLATTEN)
            (("1" (REPLACE -1)
              (("1" (EXPAND REFCOUNT +)
                (("1" (ASSERT)
                  (("1" (EXPAND "refcountExpr")
                    (("1" (EXPAND REFS)
                      (("1" (CASE-REPLACE "refcountArray(copied)(newref) = 0")
                        (("1"
                          (CASE-REPLACE "refcountStack(nnstack)(newref) = 0")
                          (("1" (ASSERT)
                            (("1" (EXPAND REFCOUNTSTORE)
                              (("1" (EXPAND ALLCOUNT)
                                (("1" (REWRITE SIGMA_ZERO)
                                  (("1" (SKEEP* :PREDS? T)
                                    (("1" (EXPAND REFCOUNTARRAY)
                                      (("1" (REWRITE COUNT_NONE_ZERO)
                                        (("1" (SKEEP* :PREDS? T)
                                          (("1" (CASE-REPLACE "x = newref")
                                            (("1"
                                              (TYPEPRED
                                               "grS`store(oldref)`seq(i)")
                                              (("1" (GRIND) NIL NIL)
                                               ("2" (GRIND) NIL NIL))
                                              NIL)
                                             ("2"
                                              (TYPEPRED "grS`store(x)`seq(i)")
                                              (("1" (GRIND) NIL NIL)
                                               ("2" (GRIND) NIL NIL)
                                               ("3" (GRIND) NIL NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (EXPAND REFCOUNTSTACK)
                            (("2" (REWRITE COUNT_NONE_ZERO)
                              (("2" (SKEEP* :PREDS? T)
                                (("2" (TYPEPRED "nnstack")
                                  (("2" (EXPAND EVERY)
                                    (("2" (INST?) (("2" (GRIND) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (EXPAND REFCOUNTARRAY 1)
                          (("2" (REWRITE COUNT_NONE_ZERO)
                            (("2" (SKEEP :PREDS? T)
                              (("2" (TYPEPRED "grS`store(oldref)`seq(i)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (FLATTEN)
            (("2" (TYPEPRED "nncount(x1)")
              (("2" (REWRITE -1)
                (("2" (EXPAND REFCOUNT)
                  (("2" (EXPAND REFCOUNTEXPR)
                    (("2" (EXPAND REFS)
                      (("2" (ASSERT)
                        (("2" (EXPAND REFCOUNTSTORE +)
                          (("2" (EXPAND ALLCOUNT)
                            (("2" (LEMMA SIGMA_ADD)
                              (("2" (INST -1 "newdomain" _ "newref")
                                (("2" (INST?)
                                  (("1" (SPLIT -1)
                                    (("1" (REWRITE -1)
                                      (("1" (CASE "newdomain(newref)")
                                        (("1" (ASSERT)
                                          (("1"
                                            (CASE-REPLACE
                                             "nstore(newref) = copied")
                                            (("1" (ASSERT)
                                              (("1"
                                                (CASE-REPLACE
                                                 "remove(newref, newdomain) = grS`domain")
                                                (("1" (USE SIGMA_EQ)
                                                  (("1" (SPLIT -1)
                                                    (("1" (PROPAX) NIL NIL)
                                                     ("2" (SKEEP* :PREDS? T)
                                                      (("2" (ASSERT)
                                                        (("2"
                                                          (CASE "newdomain(x)")
                                                          (("1" (ASSERT) NIL
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (GRIND) NIL NIL))
                                                  NIL)
                                                 ("2" (HIDE-ALL-BUT (1 -))
                                                  (("2" (REPLACE*)
                                                    (("2"
                                                      (REWRITE
                                                       REMOVE_ADD_MEMBER +)
                                                      (("2" (GRIND) NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL)
                                         ("2" (GRIND) NIL NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count_copy_def| FORMULA-DECL NIL |rreduction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|sigma_zero| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|newdomain| SKOLEM-CONST-DECL "non_empty_finite_set[nat]" |rreduction|
     NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction|
     NIL)
    (|newref| SKOLEM-CONST-DECL "{n | NOT grS`domain(n)}" |rreduction| NIL)
    (|remove_add_member| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|sigma_eq| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE
    "rreduction.count_copy(rreduction.newdomain, rreduction.nncount WITH [(rreduction.newref) |-> 1], rreduction.copied, rreduction.copied`length)"
    "[i: (rreduction.newdomain) -> {j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.nstore, rreduction.nnstack, IExpression_adt.ref(rreduction.newref))(i)}]"))
  (|updateReduce_TCC15-1| NIL 3714529219
   ("" (SKEEP* :PREDS? T)
    (("" (REWRITE COUNT_COPY_DEF)
      (("1" (LIFT-IF)
        (("1" (SPLIT +)
          (("1" (FLATTEN)
            (("1" (REPLACE -1)
              (("1" (EXPAND REFCOUNT +)
                (("1" (ASSERT)
                  (("1" (EXPAND "refcountExpr")
                    (("1" (EXPAND REFS)
                      (("1" (CASE-REPLACE "refcountArray(copied)(newref) = 0")
                        (("1"
                          (CASE-REPLACE "refcountStack(nnstack)(newref) = 0")
                          (("1" (ASSERT)
                            (("1" (EXPAND REFCOUNTSTORE)
                              (("1" (EXPAND ALLCOUNT)
                                (("1" (REWRITE SIGMA_ZERO)
                                  (("1" (SKEEP* :PREDS? T)
                                    (("1" (EXPAND REFCOUNTARRAY)
                                      (("1" (REWRITE COUNT_NONE_ZERO)
                                        (("1" (SKEEP* :PREDS? T)
                                          (("1" (CASE-REPLACE "x = newref")
                                            (("1"
                                              (TYPEPRED
                                               "grS`store(oldref)`seq(i)")
                                              (("1" (GRIND) NIL NIL)
                                               ("2" (GRIND) NIL NIL))
                                              NIL)
                                             ("2"
                                              (TYPEPRED "grS`store(x)`seq(i)")
                                              (("1" (GRIND) NIL NIL)
                                               ("2" (GRIND) NIL NIL)
                                               ("3" (GRIND) NIL NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (EXPAND REFCOUNTSTACK)
                            (("2" (REWRITE COUNT_NONE_ZERO)
                              (("2" (SKEEP* :PREDS? T)
                                (("2" (TYPEPRED NNSTACK)
                                  (("2" (EXPAND EVERY)
                                    (("2" (INST?) (("2" (GRIND) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (EXPAND REFCOUNTARRAY 1)
                          (("2" (REWRITE COUNT_NONE_ZERO)
                            (("2" (SKEEP :PREDS? T)
                              (("2" (TYPEPRED "grS`store(oldref)`seq(i)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (FLATTEN)
            (("2" (TYPEPRED "nncount(x1)")
              (("2" (REWRITE -1)
                (("2" (EXPAND REFCOUNT)
                  (("2" (EXPAND REFCOUNTEXPR)
                    (("2" (EXPAND REFS)
                      (("2" (ASSERT)
                        (("2" (EXPAND REFCOUNTSTORE +)
                          (("2" (EXPAND ALLCOUNT)
                            (("2" (LEMMA SIGMA_ADD)
                              (("2" (INST -1 NEWDOMAIN _ NEWREF)
                                (("2" (INST?)
                                  (("1" (SPLIT -1)
                                    (("1" (REWRITE -1)
                                      (("1" (CASE "newdomain(newref)")
                                        (("1" (ASSERT)
                                          (("1"
                                            (CASE-REPLACE
                                             "nstore(newref) = copied")
                                            (("1" (ASSERT)
                                              (("1"
                                                (CASE-REPLACE
                                                 "remove(newref, newdomain) = grS`domain")
                                                (("1" (USE SIGMA_EQ)
                                                  (("1" (SPLIT -1)
                                                    (("1" (PROPAX) NIL NIL)
                                                     ("2" (SKEEP* :PREDS? T)
                                                      (("2" (ASSERT)
                                                        (("2"
                                                          (CASE "newdomain(x)")
                                                          (("1" (ASSERT) NIL
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (GRIND) NIL NIL))
                                                  NIL)
                                                 ("2" (HIDE-ALL-BUT (1 -))
                                                  (("2" (REPLACE*)
                                                    (("2"
                                                      (REWRITE
                                                       REMOVE_ADD_MEMBER +)
                                                      (("2" (GRIND) NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL)
                                         ("2" (GRIND) NIL NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|count_copy_def| FORMULA-DECL NIL |rreduction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (|sigma_zero| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL) NIL
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL) NIL NIL NIL
    (|remove_add_member| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|sigma_eq| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE
    "rreduction.count_copy(rreduction.newdomain, rreduction.nncount WITH [(rreduction.newref) |-> 1], rreduction.copied, rreduction.copied`length)"
    "[i: (rreduction.newdomain) -> {j | rreduction.j = rreduction.refcount(rreduction.newdomain, rreduction.nstore, rreduction.nnstack, IExpression_adt.ref(rreduction.newref))(i)}]")))
 (|updateReduce_TCC16| 0
  (|updateReduce_TCC16-2| "" 3714548825
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT +)
      (("1" (GRIND) NIL NIL)
       ("2" (SKEEP* :PREDS? T)
        (("2" (REPLACE -36)
          (("2" (EXPAND "add" 1)
            (("2" (ASSERT)
              (("2" (EXPAND "domainValue?")
                (("2" (ASSERT)
                  (("2" (FLATTEN)
                    (("2" (EXPAND "member")
                      (("2" (ASSERT)
                        (("2" (EXPAND "every")
                          (("2" (REPLACE -41)
                            (("2" (LIFT-IF)
                              (("2" (CASE-REPLACE "x1 = newref")
                                (("1" (REPLACE -39)
                                  (("1" (TYPEPRED "grS`store(oldref)`seq(x2)")
                                    (("1" (GRIND) NIL NIL)
                                     ("2" (PROPAX) NIL NIL))
                                    NIL))
                                  NIL)
                                 ("2" (ASSERT)
                                  (("2" (TYPEPRED "grS`store(x1)`seq(x2)")
                                    (("2" (GRIND) NIL NIL)) NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|pick_new| CONST-DECL "{j | NOT NS(j)}" |finite_set_theorems| NIL)
    (|least_out_rec| DEF-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction|
     NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|newdomain| SKOLEM-CONST-DECL "non_empty_finite_set[nat]" |rreduction|
     NIL)
    (|x2!1| SKOLEM-CONST-DECL "nat" |rreduction| NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.nstore"
    "reduction.Store(rreduction.newdomain)"))
  (|updateReduce_TCC16-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (REWRITE COUNT_COPY_DEF)
      (("1" (LIFT-IF)
        (("1" (SPLIT +)
          (("1" (FLATTEN)
            (("1" (REPLACE -1)
              (("1" (EXPAND REFCOUNT +)
                (("1" (ASSERT)
                  (("1" (EXPAND REFCOUNTEXPR)
                    (("1" (EXPAND REFS)
                      (("1" (CASE-REPLACE "refcountArray(copied)(newref) = 0")
                        (("1"
                          (CASE-REPLACE "refcountStack(nnstack)(newref) = 0")
                          (("1" (ASSERT)
                            (("1" (EXPAND REFCOUNTSTORE)
                              (("1" (EXPAND ALLCOUNT)
                                (("1" (REWRITE SIGMA_ZERO)
                                  (("1" (SKEEP* :PREDS? T)
                                    (("1" (EXPAND REFCOUNTARRAY)
                                      (("1" (REWRITE COUNT_NONE_ZERO)
                                        (("1" (SKEEP* :PREDS? T)
                                          (("1" (CASE-REPLACE "x = newref")
                                            (("1"
                                              (TYPEPRED
                                               "grS`store(oldref)`seq(i)")
                                              (("1" (GRIND) NIL NIL)
                                               ("2" (GRIND) NIL NIL))
                                              NIL)
                                             ("2"
                                              (TYPEPRED "grS`store(x)`seq(i)")
                                              (("1" (GRIND) NIL NIL)
                                               ("2" (GRIND) NIL NIL)
                                               ("3" (GRIND) NIL NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL)
                           ("2" (EXPAND REFCOUNTSTACK)
                            (("2" (REWRITE COUNT_NONE_ZERO)
                              (("2" (SKEEP* :PREDS? T)
                                (("2" (TYPEPRED NNSTACK)
                                  (("2" (EXPAND EVERY)
                                    (("2" (INST?) (("2" (GRIND) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL)
                         ("2" (EXPAND REFCOUNTARRAY 1)
                          (("2" (REWRITE COUNT_NONE_ZERO)
                            (("2" (SKEEP :PREDS? T)
                              (("2" (TYPEPRED "grS`store(oldref)`seq(i)")
                                (("2" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (FLATTEN)
            (("2" (TYPEPRED "nncount(x1)")
              (("2" (REWRITE -1)
                (("2" (EXPAND REFCOUNT)
                  (("2" (EXPAND REFCOUNTEXPR)
                    (("2" (EXPAND REFS)
                      (("2" (ASSERT)
                        (("2" (EXPAND REFCOUNTSTORE +)
                          (("2" (EXPAND ALLCOUNT)
                            (("2" (LEMMA SIGMA_ADD)
                              (("2" (INST -1 NEWDOMAIN _ NEWREF)
                                (("2" (INST?)
                                  (("1" (SPLIT -1)
                                    (("1" (REWRITE -1)
                                      (("1" (CASE "newdomain(newref)")
                                        (("1" (ASSERT)
                                          (("1"
                                            (CASE-REPLACE
                                             "nstore(newref) = copied")
                                            (("1" (ASSERT)
                                              (("1"
                                                (CASE-REPLACE
                                                 "remove(newref, newdomain) = grS`domain")
                                                (("1" (USE SIGMA_EQ)
                                                  (("1" (SPLIT -1)
                                                    (("1" (PROPAX) NIL NIL)
                                                     ("2" (SKEEP* :PREDS? T)
                                                      (("2" (ASSERT)
                                                        (("2"
                                                          (CASE "newdomain(x)")
                                                          (("1" (ASSERT) NIL
                                                            NIL)
                                                           ("2" (GRIND) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (GRIND) NIL NIL))
                                                  NIL)
                                                 ("2" (HIDE-ALL-BUT (1 -))
                                                  (("2" (REPLACE*)
                                                    (("2"
                                                      (REWRITE
                                                       REMOVE_ADD_MEMBER +)
                                                      (("2" (GRIND) NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL)
                                             ("2" (ASSERT) NIL NIL))
                                            NIL))
                                          NIL)
                                         ("2" (GRIND) NIL NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL)
       ("2" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|sigma_eq| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|remove_add_member| FORMULA-DECL NIL |sets_lemmas| NIL)
    (|sigma_add| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_none_zero| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|Sigma| DEF-DECL "nat" |finite_set_theorems| NIL)
    (|remove| CONST-DECL "set" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (/= CONST-DECL "boolean" |notequal| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|remove_preserves_bounded| APPLICATION-JUDGEMENT "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))"
     |countability| "sets_aux/")
    (|finite_remove| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|sigma_zero| FORMULA-DECL NIL |finite_set_theorems| NIL)
    (IF CONST-DECL
        "[boolean, T, T -> T]"
        |if_def|
        NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|count_copy_def| FORMULA-DECL NIL |rreduction| NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.nstore"
    "reduction.Store(rreduction.newdomain)")))
 (|updateReduce_TCC17| 0
  (|updateReduce_TCC17-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.value(rreduction.lval)"
    "naturalnumbers.below(rreduction.nstore(rreduction.newref)`length)")))
 (|updateReduce_TCC18| 0
  (|updateReduce_TCC18-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|domainValue?| CONST-DECL "bool" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.rval"
    "(IL.domainValue?(rreduction.newdomain))")))
 (|updateReduce_TCC19| 0
  (|updateReduce_TCC19-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|non_empty_finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.nnstack"
    "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.newdomain))(S)}")))
 (|updateReduce_TCC20| 0
  (|updateReduce_TCC20-2| "" 3714550945
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT +)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
       ("3" (ASSERT)
        (("3" (SKEEP)
          (("3" (TYPEPRED "grS`redex")
            (("3" (INST -3 "i") (("3" (GRIND) NIL NIL)) NIL)) NIL))
          NIL))
        NIL)
       ("4" (TYPEPRED "grS`redex") (("4" (GRIND) NIL NIL)) NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|refs| DEF-DECL "bool" IL NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|empty?| CONST-DECL "bool" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "IExpression_adt.ref(rreduction.newref)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|updateReduce_TCC20-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|updateReduce| SUBTYPE "IExpression_adt.ref(rreduction.newref)"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.newdomain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|updateReduce_TCC21| 0
  (|updateReduce_TCC21-2| "" 3715444981
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (INST?)
          (("1"
            (TYPEPRED
             "maybe_clear_stack_at(grS`domain, grS`store, nstack, expr, ncount,
                                target(expr))")
            (("1"
              (TYPEPRED
               "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                                rhs(expr))")
              (("1" (INST -1 "i")
                (("1" (INST -2 "i")
                  (("1" (REPLACE* -34 -39 :DIR RL)
                    (("1" (ASSERT)
                      (("1" (FLATTEN)
                        (("1" (ASSERT)
                          (("1" (ASSERT)
                            (("1" (FLATTEN)
                              (("1" (ASSERT)
                                (("1" (SPLIT -)
                                  (("1" (EXPAND CVARS -)
                                    (("1" (EXPAND VARS -)
                                      (("1" (EXPAND ADD -1)
                                        (("1" (EXPAND MEMBER)
                                          (("1" (TYPEPRED "grS`redex")
                                            (("1" (EXPAND MARK -)
                                              (("1" (DECOMPOSE-EQUALITY -6)
                                                (("1" (EXPAND POPDEPTH +)
                                                  (("1" (EXPAND BUMPN)
                                                    (("1"
                                                      (CASE-REPLACE
                                                       "i=index(rhs(grS`redex))")
                                                      (("1" (ASSERT)
                                                        (("1" (REPLACE -32)
                                                          (("1"
                                                            (REPLACE -4 :DIR
                                                                     RL)
                                                            (("1" (GRIND) NIL
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2" (ASSERT)
                                                        (("2"
                                                          (CASE-REPLACE
                                                           "i = index(lhs(grS`redex))")
                                                          (("1" (GRIND) NIL
                                                            NIL)
                                                           ("2" (REPLACE -32)
                                                            (("2"
                                                              (REPLACE -1 :DIR
                                                                       RL)
                                                              (("2" (GRIND) NIL
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (GRIND) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|i| SKOLEM-CONST-DECL "below(nnstack`length)" |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nnstack| SKOLEM-CONST-DECL "{newStack: Stack |
   every(domainValue?(grS`domain))(newStack) AND
    newStack`length = nstack`length}"
     |rreduction| NIL)
    (|nstack| SKOLEM-CONST-DECL "{newStack: Stack |
   every(domainValue?(grS`domain))(newStack) AND
    newStack`length = stack`length}"
     |rreduction| NIL)
    (|stack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S)}" |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction|
     NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|update| ADT-CONSTRUCTOR-DECL
     "[[(variable?), (variable?), (variable?)] -> (update?)]" |IExpression_adt|
     NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE
    "rreduction.grS WITH [`redex := IExpression_adt.ref(rreduction.newref), `domain := rreduction.newdomain, `store := rreduction.nnstore, `count := rreduction.nnnncount, `stack := rreduction.nnstack]"
    "(rreduction.noDanglingRefs?)"))
  (|updateReduce_TCC21-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (INST?)
          (("1"
            (TYPEPRED
             "maybe_clear_stack_at(grS`domain, grS`store, nstack, expr, ncount,
                            target(expr))")
            (("1"
              (TYPEPRED
               "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))")
              (("1" (INST -1 I)
                (("1" (INST -2 I)
                  (("1" (REPLACE* -34 -39 :DIR RL)
                    (("1" (ASSERT)
                      (("1" (FLATTEN)
                        (("1" (ASSERT)
                          (("1" (ASSERT)
                            (("1" (FLATTEN)
                              (("1" (ASSERT)
                                (("1" (SPLIT -)
                                  (("1" (EXPAND CVARS -)
                                    (("1" (EXPAND VARS -)
                                      (("1" (EXPAND ADD -1)
                                        (("1" (EXPAND MEMBER)
                                          (("1" (TYPEPRED "grS`redex")
                                            (("1" (EXPAND MARK -)
                                              (("1" (DECOMPOSE-EQUALITY -6)
                                                (("1" (EXPAND POPDEPTH +)
                                                  (("1" (EXPAND BUMPN)
                                                    (("1"
                                                      (CASE-REPLACE
                                                       "i=index(rhs(grS`redex))")
                                                      (("1" (ASSERT)
                                                        (("1" (REPLACE -32)
                                                          (("1"
                                                            (REPLACE -4 :DIR
                                                                     RL)
                                                            (("1" (GRIND) NIL
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2" (ASSERT)
                                                        (("2"
                                                          (CASE-REPLACE
                                                           "i = index(lhs(grS`redex))")
                                                          (("1" (GRIND) NIL
                                                            NIL)
                                                           ("2" (REPLACE -32)
                                                            (("2"
                                                              (REPLACE -1 :DIR
                                                                       RL)
                                                              (("2" (GRIND) NIL
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL)
                                   ("2" (GRIND) NIL NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (GRIND) NIL NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    NIL (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL NIL NIL NIL
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) NIL
    (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|injective?| CONST-DECL "bool" |functions| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|count_copy| DEF-DECL "[(dom) -> nat]" |rreduction| NIL)
    (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences|
     NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|update| ADT-CONSTRUCTOR-DECL
     "[[(variable?), (variable?), (variable?)] -> (update?)]" |IExpression_adt|
     NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL) NIL
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE
    "rreduction.grS WITH [`redex := IExpression_adt.ref(rreduction.newref), `domain := rreduction.newdomain, `store := rreduction.nnstore, `count := rreduction.nnnncount, `stack := rreduction.nnstack]"
    "(rreduction.noDanglingRefs?)")))
 (|updateReduce_TCC22| 0
  (|updateReduce_TCC22-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE "IExpression_adt.value(rreduction.lval)"
    "below[grS`store(oldref)`length]")))
 (|updateReduce_TCC23| 0
  (|updateReduce_TCC23-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL (|updateReduce| SUBTYPE "rreduction.oldref" "(rreduction.grS`domain)")))
 (|updateReduce_TCC24| 0
  (|updateReduce_TCC24-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE
    "(number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(IExpression_adt.target(rreduction.expr)))"
    "below[nstack`length]")))
 (|updateReduce_TCC25| 0
  (|updateReduce_TCC25-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|get| CONST-DECL "(value?)" IL NIL))
   NIL (|updateReduce| SUBTYPE "IExpression_adt.nil" "(IL.value?)")))
 (|updateReduce_TCC26| 0
  (|updateReduce_TCC26-1| NIL 3706028126 ("" (SUBTYPE-TCC) NIL NIL)
   ((|get| CONST-DECL "(value?)" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE
    "rreduction.nstack WITH [`seq((number_fields.-)((number_fields.-)(rreduction.stack`length, 1), IExpression_adt.index(IExpression_adt.target(rreduction.expr)))) := IExpression_adt.nil]"
    "{S: IL.Stack | booleans.AND(finseq_theorems[(IL.value?)].every(IL.domainValue?(rreduction.grS`domain))(S), S`length = rreduction.stack`length)}")))
 (|updateReduce_TCC27| 0
  (|updateReduce_TCC27-1| NIL 3699369652
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "ncount(x1)")
      (("" (REPLACE -1)
        (("" (EXPAND REFCOUNT)
          (("" (REPLACE -37)
            (("" (EXPAND REFCOUNTSTACK)
              (("" (REWRITE COUNT_UPDATE)
                (("1" (EXPAND REFCOUNTEXPR)
                  (("1" (EXPAND REFS 4 1) (("1" (GRIND) NIL NIL)) NIL)) NIL)
                 ("2" (GRIND) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|refcountStore| CONST-DECL "nat" |rreduction| NIL)
    (|allcount| CONST-DECL "nat" |rreduction| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|refcountArray| CONST-DECL "nat" |rreduction| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.ncount"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.nnstack, rreduction.aval)(i)}]"))
  (|updateReduce_TCC27-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (TYPEPRED "ncount(x1)")
      (("" (REWRITE -1)
        (("" (EXPAND REFCOUNT)
          (("" (EXPAND REFCOUNTEXPR)
            (("" (ASSERT)
              (("" (EXPAND REFS)
                (("" (LIFT-IF)
                  (("" (SPLIT)
                    (("1" (FLATTEN)
                      (("1" (REPLACE -1)
                        (("1" (EXPAND REFCOUNTSTACK)
                          (("1" (REPLACE -37)
                            (("1" (REWRITE COUNT_UPDATE)
                              (("1"
                                (CASE-REPLACE
                                 "nstack`seq(stack`length-1-index(target(expr))) = aval")
                                (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL))
                                NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (FLATTEN)
                      (("2" (EXPAND REFCOUNTSTACK)
                        (("2" (REPLACE -36)
                          (("2" (REWRITE COUNT_UPDATE)
                            (("1"
                              (CASE-REPLACE
                               "nstack`seq(stack`length - 1 - index(target(expr))) = aval")
                              (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|count| CONST-DECL "nat" |finseq_theorems| NIL)
    (|count| DEF-DECL "nat" |finseq_theorems| NIL)
    (|finseqtolist| DEF-DECL "list[T]" |finseq_theorems| NIL)
    (|tail| CONST-DECL "finseq[T]" |finseq_theorems| NIL)
    (|head| CONST-DECL "T" |finseq_theorems| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|nil| ADT-CONSTRUCTOR-DECL "(nil?)" |IExpression_adt| NIL)
    (|nil?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|count_update| FORMULA-DECL NIL |finseq_theorems| NIL)
    (|refcountStack| CONST-DECL "nat" |rreduction| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.ncount"
    "[i: (rreduction.grS`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.grS`domain, rreduction.grS`store, rreduction.nnstack, rreduction.aval)(i)}]")))
 (|updateReduce_TCC28| 0
  (|updateReduce_TCC28-3| "" 3714803882
   ("" (SKEEP* :PREDS? T)
    (("" (SPLIT +)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)
       ("3" (SKEEP)
        (("3" (REPLACE -36)
          (("3" (ASSERT)
            (("3" (TYPEPRED "grS`redex")
              (("3" (INST -3 "i") (("3" (GRIND) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("4" (TYPEPRED "grS`redex") (("4" (GRIND) NIL NIL)) NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|refs| DEF-DECL "bool" IL NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.aval"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|updateReduce_TCC28-2| "" 3714551441
   ("" (SKEEP* :PREDS? T)
    (("" (LEMMA DECREF1_CHK_NDR) (("" (INST?) (("" (POSTPONE) NIL NIL)) NIL))
      NIL))
    NIL)
   NIL SHOSTAK
   (|updateReduce| SUBTYPE "rreduction.aval"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}"))
  (|updateReduce_TCC28-1| NIL 3714529219 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL
   (|updateReduce| SUBTYPE "rreduction.aval"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.grS`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.nnstack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.grS`context)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.grS`context)), rreduction.nnstack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.grS`context))(rreduction.A) = rreduction.A)}")))
 (|updateReduce_TCC29| 0
  (|updateReduce_TCC29-2| "" 3715621471
   ("" (SKEEP* :PREDS? T)
    (("" (LEMMA DECREF1_CHK_NDR)
      (("" (INST?)
        (("1" (HIDE 5)
          (("1" (EXPAND NODANGLINGREFS?)
            (("1" (SKEEP* :PREDS? T)
              (("1" (ASSERT)
                (("1" (EXPAND POPDEPTH)
                  (("1" (EXPAND BUMPN)
                    (("1" (INST?)
                      (("1"
                        (TYPEPRED
                         "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                                rhs(expr))")
                        (("1" (INST -1 "i")
                          (("1" (REPLACE -35 :DIR RL)
                            (("1" (ASSERT)
                              (("1" (SPLIT -1)
                                (("1" (FLATTEN)
                                  (("1" (SPLIT -)
                                    (("1" (TYPEPRED "grS`redex")
                                      (("1" (REPLACE -31)
                                        (("1" (REPLACE -6 + :DIR RL)
                                          (("1"
                                            (CASE-REPLACE
                                             "i = index(rhs(grS`redex))")
                                            (("1" (GRIND) NIL NIL)
                                             ("2"
                                              (CASE-REPLACE
                                               "i = index(lhs(grS`redex))")
                                              (("1" (GRIND) NIL NIL)
                                               ("2"
                                                (CASE-REPLACE
                                                 "i = index(target(grS`redex))")
                                                (("1" (GRIND) NIL NIL)
                                                 ("2" (GRIND) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL)
                                 ("2" (REPLACE -37)
                                  (("2" (SPLIT)
                                    (("1" (ASSERT)
                                      (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (HIDE 5)
          (("2" (SPLIT)
            (("1" (SKEEP) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)
             ("2" (SKEEP) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)
             ("3" (SKEEP)
              (("3" (TYPEPRED "grS`redex")
                (("3" (INST -3 "i") (("3" (GRIND) NIL NIL)) NIL)) NIL))
              NIL)
             ("4" (ASSERT)
              (("4" (TYPEPRED "grS`redex") (("4" (GRIND) NIL NIL)) NIL)) NIL)
             ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|decref1_chk_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" |rreduction|
     NIL)
    (|aval| SKOLEM-CONST-DECL "(domainValue?(grS`domain))" |rreduction| NIL)
    (|stack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S)}" |rreduction| NIL)
    (|nnstack| SKOLEM-CONST-DECL
     "{S: Stack | every(domainValue?(grS`domain))(S) AND S`length = stack`length}"
     |rreduction| NIL)
    (|newstore| SKOLEM-CONST-DECL "Store(grS`domain)" |rreduction| NIL)
    (|nncount| SKOLEM-CONST-DECL "[i: (grS`domain) ->
   {j | j = refcount(grS`domain, newstore, nnstack, aval)(i)}]"
     |rreduction| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|updateReduce| SUBTYPE
    "rreduction.decref1_chk(rreduction.grS WITH [`redex := rreduction.aval, `store := rreduction.newstore, `stack := rreduction.nnstack, `count := rreduction.nncount], rreduction.oldvalue)"
    "(rreduction.noDanglingRefs?)"))
  (|updateReduce_TCC29-1| NIL 3706028126
   ("" (SKEEP* :PREDS? T)
    (("" (LEMMA DECREF1_CHK_NDR)
      (("" (INST?)
        (("1" (HIDE 5)
          (("1" (EXPAND NODANGLINGREFS?)
            (("1" (SKEEP* :PREDS? T)
              (("1" (ASSERT)
                (("1" (EXPAND POPDEPTH)
                  (("1" (EXPAND BUMPN)
                    (("1" (INST?)
                      (("1"
                        (TYPEPRED
                         "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))")
                        (("1" (INST -1 I)
                          (("1" (REPLACE -35 :DIR RL)
                            (("1" (ASSERT)
                              (("1" (SPLIT -1)
                                (("1" (FLATTEN)
                                  (("1" (SPLIT -)
                                    (("1" (TYPEPRED "grS`redex")
                                      (("1" (REPLACE -31)
                                        (("1" (REPLACE -6 + :DIR RL)
                                          (("1"
                                            (CASE-REPLACE
                                             "i = index(rhs(grS`redex))")
                                            (("1" (GRIND) NIL NIL)
                                             ("2"
                                              (CASE-REPLACE
                                               "i = index(lhs(grS`redex))")
                                              (("1" (GRIND) NIL NIL)
                                               ("2"
                                                (CASE-REPLACE
                                                 "i = index(target(grS`redex))")
                                                (("1" (GRIND) NIL NIL)
                                                 ("2" (GRIND) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL)
                                 ("2" (REPLACE -37)
                                  (("2" (SPLIT)
                                    (("1" (ASSERT)
                                      (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL))
                                        NIL))
                                      NIL)
                                     ("2" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (HIDE 5)
          (("2" (SPLIT)
            (("1" (SKEEP) (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)) NIL)
             ("2" (SKEEP) (("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)
             ("3" (SKEEP)
              (("3" (TYPEPRED "grS`redex")
                (("3" (INST -3 I) (("3" (GRIND) NIL NIL)) NIL)) NIL))
              NIL)
             ("4" (ASSERT)
              (("4" (TYPEPRED "grS`redex") (("4" (GRIND) NIL NIL)) NIL)) NIL)
             ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|decref1_chk_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|update_store| CONST-DECL "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}"
     |rreduction| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL) NIL
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (|maybe_clear_stack_at| CONST-DECL "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     |rreduction| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_gt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) NIL NIL NIL NIL NIL NIL
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|updateReduce| SUBTYPE
    "rreduction.decref1_chk(rreduction.grS WITH [`redex := rreduction.aval, `store := rreduction.newstore, `stack := rreduction.nnstack, `count := rreduction.nncount], rreduction.oldvalue)"
    "(rreduction.noDanglingRefs?)")))
 (|updateReduce_TCC30| 0
  (|updateReduce_TCC30-1| NIL 3699369652 ("" (SUBTYPE-TCC) NIL NIL)
   ((|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|update?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|target| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|lhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|rhs| ADT-ACCESSOR-DECL "[(update?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|updateReduce| SUBTYPE "rreduction.grS WITH [error := booleans.TRUE]"
    "(rreduction.noDanglingRefs?)")))
 (|variableReduce_ndr| 0
  (|variableReduce_ndr-1| NIL 3705848866
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (INST -2 I)
          (("1" (EXPAND VARIABLEREDUCE)
            (("1" (ASSERT)
              (("1" (LIFT-IF)
                (("1" (CASE-REPLACE "popDepth(get(grS`stack)(grS`redex)) = 0")
                  (("1" (EXPAND BUMPN)
                    (("1" (CASE-REPLACE "popDepth(grS`redex) = 0")
                      (("1" (ASSERT)
                        (("1" (GRIND)
                          (("1" (TYPEPRED "grS`redex")
                            (("1" (EXPAND MARK)
                              (("1" (EXPAND MARKV)
                                (("1" (REPLACE -6 2 :DIR RL)
                                  (("1" (ASSERT) NIL NIL)) NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (GRIND) NIL NIL))
                      NIL))
                    NIL)
                   ("2" (TYPEPRED "get(grS`stack)(grS`redex)")
                    (("2" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL)
           ("2" (EXPAND VARIABLEREDUCE) (("2" (ASSERT) NIL NIL)) NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|variableReduce| CONST-DECL "rstate" |rreduction| NIL)
    (D SKOLEM-CONST-DECL "Defs" |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL "below(variableReduce(D)(grS)`stack`length)"
     |rreduction| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | noDanglingRefs?(grS) AND variable?(grS`redex)}" |rreduction| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|singleton| CONST-DECL "(singleton?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL) (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|get| CONST-DECL "(value?)" IL NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|variableReduce_ndr| SUBTYPE
    "rreduction.variableReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|letReduce_ndr| 0
  (|letReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND LETREDUCE)
      (("" (EXPAND PUSH)
        (("" (EXPAND ADD)
          (("" (EXPAND NODANGLINGREFS?)
            (("" (SKEEP :PREDS? T)
              (("" (LIFT-IF)
                (("" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (CASE-REPLACE "i = 0")
                      (("1" (TYPEPRED "grS`redex")
                        (("1" (EXPAND CVARS 2)
                          (("1" (REWRITE CVARS_PURE 2)
                            (("1" (REPLACE -6 2 :DIR RL)
                              (("1" (EXPAND* PURELETREDEX? LETREDEX?)
                                (("1" (FLATTEN)
                                  (("1" (ASSERT)
                                    (("1" (EXPAND MARK +)
                                      (("1" (GRIND) NIL NIL)) NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (GRIND) NIL NIL))
                      NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (INST -3 "i-1")
                      (("1" (ASSERT)
                        (("1" (EXPAND CVARS 3 1)
                          (("1" (EXPAND POPDEPTH +)
                            (("1" (REWRITE PUREPOPDEPTH +)
                              (("1" (CASE-REPLACE "popDepth(grS`redex) = 0")
                                (("1" (EXPAND BUMPN)
                                  (("1" (ASSERT)
                                    (("1" (EXPAND PURELETREDEX?)
                                      (("1" (EXPAND LETREDEX?)
                                        (("1" (FLATTEN)
                                          (("1" (ASSERT)
                                            (("1" (EXPAND CVARS -)
                                              (("1" (EXPAND UNION)
                                                (("1" (EXPAND MEMBER)
                                                  (("1" (SPLIT)
                                                    (("1" (GRIND) NIL NIL)
                                                     ("2" (EXPAND* BUMPN DROP)
                                                      (("2" (FLATTEN)
                                                        (("2"
                                                          (REWRITE CVARS_PURE)
                                                          (("2"
                                                            (CASE-REPLACE
                                                             "popDepth(letrhs(grS`redex)) = 0")
                                                            (("1" (ASSERT) NIL
                                                              NIL)
                                                             ("2" (GRIND) NIL
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (GRIND) NIL NIL))
                                NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (GRIND) NIL NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|letReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|add| CONST-DECL "finseq[T]" |more_finseq| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|bump| CONST-DECL "finite_set[nat]" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|cvars_pure| FORMULA-DECL NIL |preprocess| NIL)
    (|letexpr?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|body| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|i| SKOLEM-CONST-DECL "below(1 + grS`stack`length)" |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | noDanglingRefs?(grS) AND pureLetRedex?(grS`redex)}" |rreduction|
     NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|mult_divides1| APPLICATION-JUDGEMENT "(divides(n))" |divides| NIL)
    (|mult_divides2| APPLICATION-JUDGEMENT "(divides(m))" |divides| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|drop| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|letrhs| ADT-ACCESSOR-DECL "[(letexpr?) -> IExpression]" |IExpression_adt|
     NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|push| CONST-DECL "Stack" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|letReduce_ndr| SUBTYPE
    "rreduction.letReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|applyReduce_ndr| 0
  (|applyReduce_ndr-2| "" 3715459963
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (EXPAND APPLYREDUCE)
          (("" (SIMPLIFY)
            (("" (INST -2 "i")
              (("" (SPLIT -2)
                (("1" (DELETE 3)
                  (("1" (GROUND)
                    (("1" (REWRITE CVARS_PURE)
                      (("1" (REWRITE VARS_LETAPPLY)
                        (("1" (REWRITE VARS_MARK)
                          (("1" (EXPAND APPLYREDEX?)
                            (("1"
                              (CASE-REPLACE
                               "grS`redex = application(fun(grS`redex), args(grS`redex))")
                              (("1" (EXPAND CVARS -4)
                                (("1" (EXPAND VARS -4) (("1" (GRIND) NIL NIL))
                                  NIL))
                                NIL)
                               ("2" (GRIND-WITH-EXT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (USE PURE_LETAPPLY)
                        (("2" (USE PURE_MARK)
                          (("2" (TYPEPRED "D`seq(fun(grS`redex))`body")
                            (("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (DELETE 2)
                  (("2" (CASE-REPLACE "popDepth(grS`redex) = 0")
                    (("1" (REWRITE PUREPOPDEPTH 2)
                      (("1" (SIMPLIFY) (("1" (PROPAX) NIL NIL)) NIL)
                       ("2" (USE PURE_LETAPPLY)
                        (("2" (USE PURE_MARK)
                          (("2" (TYPEPRED "D`seq(fun(grS`redex))`body")
                            (("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL)
                       ("3" (GRIND) NIL NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL))
                  NIL)
                 ("3" (PROPAX) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|applyReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL "below(applyReduce(D)(grS)`stack`length)"
     |rreduction| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | noDanglingRefs?(grS) AND applyRedex?(grS`redex)}" |rreduction|
     NIL)
    (D SKOLEM-CONST-DECL "Defs" |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|args| ADT-ACCESSOR-DECL "[(application?) -> list[(variable?)]]"
     |IExpression_adt| NIL)
    (|fun| ADT-ACCESSOR-DECL "[(application?) -> nat]" |IExpression_adt| NIL)
    (|application?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|every| ADT-DEF-DECL "boolean" |list_adt| NIL)
    (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|cvars_pure| FORMULA-DECL NIL |preprocess| NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|application| ADT-CONSTRUCTOR-DECL
     "[[nat, list[(variable?)]] -> (application?)]" |IExpression_adt| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|vars_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|pure_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|pure_letApply| RECURSIVE-JUDGEMENT-AXIOM NIL |rreduction| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|applyReduce_ndr| SUBTYPE
    "rreduction.applyReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (|applyReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (EXPAND APPLYREDUCE)
          (("" (SIMPLIFY)
            (("" (INST -2 I)
              (("" (SPLIT -2)
                (("1" (DELETE 3)
                  (("1" (GROUND)
                    (("1" (REWRITE CVARS_PURE)
                      (("1" (REWRITE VARS_LETAPPLY)
                        (("1" (REWRITE VARS_MARK)
                          (("1" (EXPAND APPLYREDEX?)
                            (("1"
                              (CASE-REPLACE
                               "grS`redex = application(fun(grS`redex), args(grS`redex))")
                              (("1" (EXPAND CVARS -4)
                                (("1" (EXPAND VARS -4) (("1" (GRIND) NIL NIL))
                                  NIL))
                                NIL)
                               ("2" (GRIND-WITH-EXT) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (USE PURE_LETAPPLY)
                        (("2" (USE PURE_MARK)
                          (("2" (TYPEPRED "D`seq(fun(grS`redex))`body")
                            (("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (DELETE 2)
                  (("2" (CASE-REPLACE "popDepth(grS`redex) = 0")
                    (("1" (REWRITE PUREPOPDEPTH 2)
                      (("1" (SIMPLIFY) (("1" (PROPAX) NIL NIL)) NIL)
                       ("2" (USE PURE_LETAPPLY)
                        (("2" (USE PURE_MARK)
                          (("2" (TYPEPRED "D`seq(fun(grS`redex))`body")
                            (("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL)
                       ("3" (GRIND) NIL NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL))
                  NIL)
                 ("3" (PROPAX) NIL NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|applyReduce| CONST-DECL "rstate" |rreduction| NIL) NIL
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL NIL
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL) NIL
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|args| ADT-ACCESSOR-DECL "[(application?) -> list[(variable?)]]"
     |IExpression_adt| NIL)
    (|fun| ADT-ACCESSOR-DECL "[(application?) -> nat]" |IExpression_adt| NIL)
    (|application?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|letApply| DEF-DECL "IExpression" |rreduction| NIL)
    (|length| DEF-DECL "nat" |list_props| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    NIL (PRED TYPE-EQ-DECL NIL |defined_types| NIL)
    (|list| TYPE-DECL NIL |list_adt| NIL)
    (|cvars_pure| FORMULA-DECL NIL |preprocess| NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|application| ADT-CONSTRUCTOR-DECL
     "[[nat, list[(variable?)]] -> (application?)]" |IExpression_adt| NIL)
    (|in_varlist| CONST-DECL "finite_set[nat]" IL NIL) NIL
    (|vars_letApply| FORMULA-DECL NIL |rreduction| NIL)
    (|pure_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|pure_letApply| RECURSIVE-JUDGEMENT-AXIOM NIL |rreduction| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|applyReduce_ndr| SUBTYPE
    "rreduction.applyReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|ifReduce_ndr| 0
  (|ifReduce_ndr-2| "" 3715463140
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND IFREDUCE)
      (("" (EXPAND NODANGLINGREFS?)
        (("" (SIMPLIFY)
          (("" (GROUND)
            (("1" (SKEEP* :PREDS? T)
              (("1" (INST -4 "i")
                (("1" (EXPAND RELEASE_MARKED)
                  (("1" (SIMPLIFY)
                    (("1" (SPLIT -4)
                      (("1" (TYPEPRED "grS`redex")
                        (("1" (DELETE -1 -2 -3 -4 -5)
                          (("1"
                            (CASE-REPLACE
                             "grS`redex = ift(condition(grS`redex), thenexpr(grS`redex), elseexpr(grS`redex))")
                            (("1" (EXPAND MARK -2)
                              (("1" (SIMPLIFY)
                                (("1" (DECOMPOSE-EQUALITY -2)
                                  (("1" (EXPAND CVARS -5)
                                    (("1" (EXPAND VARS -5)
                                      (("1" (EXPAND CVARS 1 1)
                                        (("1" (REWRITE CVARS_PURE 1)
                                          (("1" (EXPAND ADD 1)
                                            (("1" (EXPAND MEMBER 1)
                                              (("1" (EXPAND POPDEPTH 2 1)
                                                (("1" (REWRITE PUREPOPDEPTH 2)
                                                  (("1" (EXPAND BUMPN)
                                                    (("1"
                                                      (CASE
                                                          "vars(elseexpr(grS`redex))(i)")
                                                      (("1" (GRIND) NIL NIL)
                                                       ("2"
                                                        (REPLACE -3 1 :DIR RL)
                                                        (("2"
                                                          (REWRITE
                                                           VARS_RELEASE_SET)
                                                          (("2"
                                                            (REWRITE VARS_MARK)
                                                            (("2"
                                                              (EXPAND UNION 1)
                                                              (("2"
                                                                (EXPAND
                                                                 DIFFERENCE 1)
                                                                (("2"
                                                                  (EXPAND
                                                                   MEMBER 1)
                                                                  (("2"
                                                                    (EXPAND ADD
                                                                            -5)
                                                                    (("2"
                                                                      (EXPAND
                                                                       UNION
                                                                       -5)
                                                                      (("2"
                                                                        (EXPAND
                                                                         MEMBER)
                                                                        (("2"
                                                                          (SPLIT
                                                                           -5)
                                                                          (("1"
                                                                            (EXPAND
                                                                             MARKV
                                                                             -2)
                                                                            (("1"
                                                                              (EXPAND
                                                                               UNION
                                                                               -2)
                                                                              (("1"
                                                                                (EXPAND
                                                                                 MEMBER)
                                                                                (("1"
                                                                                  (REPLACE
                                                                                   -2
                                                                                   2
                                                                                   :DIR
                                                                                   RL)
                                                                                  (("1"
                                                                                    (SIMPLIFY)
                                                                                    (("1"
                                                                                      (SIMPLIFY)
                                                                                      (("1"
                                                                                        (LIFT-IF
                                                                                         2)
                                                                                        (("1"
                                                                                          (GRIND)
                                                                                          NIL
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL)
                                                                           ("2"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL)
                                                                           ("3"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (GRIND) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL)
                                           ("2" (GRIND) NIL NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (GRIND-WITH-EXT) NIL NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (EXPAND POPDEPTH 2 1)
                        (("2" (REWRITE PUREPOPDEPTH 2)
                          (("1" (REWRITE PUREPOPDEPTH -1)
                            (("1" (GRIND) NIL NIL)) NIL)
                           ("2" (GRIND) NIL NIL))
                          NIL))
                        NIL)
                       ("3" (PROPAX) NIL NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (GRIND) NIL NIL))
                NIL))
              NIL)
             ("2" (SKEEP* :PREDS? T)
              (("2" (EXPAND RELEASE_MARKED 2)
                (("2" (EXPAND CVARS 2 1)
                  (("2" (REWRITE CVARS_PURE 2)
                    (("1" (EXPAND RELEASE_MARKED 3)
                      (("1" (SIMPLIFY)
                        (("1" (EXPAND POPDEPTH 3 1)
                          (("1" (REWRITE PUREPOPDEPTH 3)
                            (("1" (INST -3 "i")
                              (("1" (REWRITE PUREPOPDEPTH -3)
                                (("1" (EXPAND RELEASE_MARKED -2)
                                  (("1" (SIMPLIFY)
                                    (("1" (EXPAND BUMPN)
                                      (("1" (EXPAND ADD 2)
                                        (("1" (EXPAND MEMBER)
                                          (("1" (EXPAND RELEASE_MARKED -1)
                                            (("1" (SIMPLIFY)
                                              (("1" (SPLIT -3)
                                                (("1" (TYPEPRED "grS`redex")
                                                  (("1" (DELETE -1 -2 -3 -4 -5)
                                                    (("1"
                                                      (CASE-REPLACE
                                                       "grS`redex = ift(condition(grS`redex), thenexpr(grS`redex), elseexpr(grS`redex))")
                                                      (("1" (SIMPLIFY)
                                                        (("1" (EXPAND MARK -2)
                                                          (("1"
                                                            (DECOMPOSE-EQUALITY
                                                             -2)
                                                            (("1"
                                                              (CASE
                                                                  "vars(thenexpr(grS`redex))(i)")
                                                              (("1" (GRIND) NIL
                                                                NIL)
                                                               ("2"
                                                                (REPLACE -2 1
                                                                         :DIR
                                                                         RL)
                                                                (("2"
                                                                  (REWRITE
                                                                   VARS_RELEASE_SET)
                                                                  (("2"
                                                                    (REWRITE
                                                                     VARS_MARK)
                                                                    (("2"
                                                                      (EXPAND
                                                                       UNION 1)
                                                                      (("2"
                                                                        (EXPAND
                                                                         DIFFERENCE
                                                                         1)
                                                                        (("2"
                                                                          (EXPAND
                                                                           MEMBER)
                                                                          (("2"
                                                                            (EXPAND
                                                                             CVARS
                                                                             -5)
                                                                            (("2"
                                                                              (EXPAND
                                                                               VARS
                                                                               -5)
                                                                              (("2"
                                                                                (EXPAND
                                                                                 ADD
                                                                                 -5)
                                                                                (("2"
                                                                                  (EXPAND
                                                                                   UNION
                                                                                   -5)
                                                                                  (("2"
                                                                                    (EXPAND
                                                                                     MEMBER)
                                                                                    (("2"
                                                                                      (SPLIT
                                                                                       -5)
                                                                                      (("1"
                                                                                        (REPLACE
                                                                                         -2
                                                                                         3
                                                                                         :DIR
                                                                                         RL)
                                                                                        (("1"
                                                                                          (EXPAND
                                                                                           MARKV)
                                                                                          (("1"
                                                                                            (LIFT-IF
                                                                                             3)
                                                                                            (("1"
                                                                                              (EXPAND
                                                                                               UNION
                                                                                               3)
                                                                                              (("1"
                                                                                                (EXPAND
                                                                                                 MEMBER)
                                                                                                (("1"
                                                                                                  (GRIND)
                                                                                                  NIL
                                                                                                  NIL))
                                                                                                NIL))
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL)
                                                                                       ("2"
                                                                                        (GRIND)
                                                                                        NIL
                                                                                        NIL)
                                                                                       ("3"
                                                                                        (GRIND)
                                                                                        NIL
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2" (GRIND-WITH-EXT)
                                                        NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (PROPAX) NIL NIL)
                                                 ("3" (PROPAX) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (HIDE-ALL-BUT (1 -4))
                                  (("2" (GRIND) NIL NIL)) NIL))
                                NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|ifReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL
     "below(release_marked(grS WITH [`redex := thenexpr(grS`redex)])
                    (condition(grS`redex))`stack`length)"
     |rreduction| NIL)
    (|IExpression_ift_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|cvars_pure| FORMULA-DECL NIL |preprocess| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|vars_release_set| FORMULA-DECL NIL |preprocess| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|release_marked| CONST-DECL "rstate" |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | noDanglingRefs?(grS) AND pureIftRedex?(grS`redex)}" |rreduction|
     NIL)
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|i| SKOLEM-CONST-DECL
     "below(release_marked(grS WITH [`redex := elseexpr(grS`redex)])
                    (condition(grS`redex))`stack`length)"
     |rreduction| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|ifReduce_ndr| SUBTYPE "rreduction.ifReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (|ifReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND IFREDUCE)
      (("" (EXPAND NODANGLINGREFS?)
        (("" (SIMPLIFY)
          (("" (GROUND)
            (("1" (SKEEP* :PREDS? T)
              (("1" (INST -4 I)
                (("1" (EXPAND RELEASE_MARKED)
                  (("1" (SIMPLIFY)
                    (("1" (SPLIT -4)
                      (("1" (TYPEPRED "grS`redex")
                        (("1" (DELETE -1 -2 -3 -4 -5)
                          (("1"
                            (CASE-REPLACE
                             "grS`redex = ift(condition(grS`redex), thenexpr(grS`redex), elseexpr(grS`redex))")
                            (("1" (EXPAND MARK -2)
                              (("1" (SIMPLIFY)
                                (("1" (DECOMPOSE-EQUALITY -2)
                                  (("1" (EXPAND CVARS -5)
                                    (("1" (EXPAND VARS -5)
                                      (("1" (EXPAND CVARS 1 1)
                                        (("1" (REWRITE CVARS_PURE 1)
                                          (("1" (EXPAND ADD 1)
                                            (("1" (EXPAND MEMBER 1)
                                              (("1" (EXPAND POPDEPTH 2 1)
                                                (("1" (REWRITE PUREPOPDEPTH 2)
                                                  (("1" (EXPAND BUMPN)
                                                    (("1"
                                                      (CASE
                                                          "vars(elseexpr(grS`redex))(i)")
                                                      (("1" (GRIND) NIL NIL)
                                                       ("2"
                                                        (REPLACE -3 1 :DIR RL)
                                                        (("2"
                                                          (REWRITE
                                                           VARS_RELEASE_SET)
                                                          (("2"
                                                            (REWRITE VARS_MARK)
                                                            (("2"
                                                              (EXPAND UNION 1)
                                                              (("2"
                                                                (EXPAND
                                                                 DIFFERENCE 1)
                                                                (("2"
                                                                  (EXPAND
                                                                   MEMBER 1)
                                                                  (("2"
                                                                    (EXPAND ADD
                                                                            -5)
                                                                    (("2"
                                                                      (EXPAND
                                                                       UNION
                                                                       -5)
                                                                      (("2"
                                                                        (EXPAND
                                                                         MEMBER)
                                                                        (("2"
                                                                          (SPLIT
                                                                           -5)
                                                                          (("1"
                                                                            (EXPAND
                                                                             MARKV
                                                                             -2)
                                                                            (("1"
                                                                              (EXPAND
                                                                               UNION
                                                                               -2)
                                                                              (("1"
                                                                                (EXPAND
                                                                                 MEMBER)
                                                                                (("1"
                                                                                  (REPLACE
                                                                                   -2
                                                                                   2
                                                                                   :DIR
                                                                                   RL)
                                                                                  (("1"
                                                                                    (SIMPLIFY)
                                                                                    (("1"
                                                                                      (SIMPLIFY)
                                                                                      (("1"
                                                                                        (LIFT-IF
                                                                                         2)
                                                                                        (("1"
                                                                                          (GRIND)
                                                                                          NIL
                                                                                          NIL))
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL)
                                                                           ("2"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL)
                                                                           ("3"
                                                                            (GRIND)
                                                                            NIL
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (GRIND) NIL NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL)
                                           ("2" (GRIND) NIL NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL)
                             ("2" (GRIND-WITH-EXT) NIL NIL))
                            NIL))
                          NIL))
                        NIL)
                       ("2" (EXPAND POPDEPTH 2 1)
                        (("2" (REWRITE PUREPOPDEPTH 2)
                          (("1" (REWRITE PUREPOPDEPTH -1)
                            (("1" (GRIND) NIL NIL)) NIL)
                           ("2" (GRIND) NIL NIL))
                          NIL))
                        NIL)
                       ("3" (PROPAX) NIL NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (GRIND) NIL NIL))
                NIL))
              NIL)
             ("2" (SKEEP* :PREDS? T)
              (("2" (EXPAND RELEASE_MARKED 2)
                (("2" (EXPAND CVARS 2 1)
                  (("2" (REWRITE CVARS_PURE 2)
                    (("1" (EXPAND RELEASE_MARKED 3)
                      (("1" (SIMPLIFY)
                        (("1" (EXPAND POPDEPTH 3 1)
                          (("1" (REWRITE PUREPOPDEPTH 3)
                            (("1" (INST -3 I)
                              (("1" (REWRITE PUREPOPDEPTH -3)
                                (("1" (EXPAND RELEASE_MARKED -2)
                                  (("1" (SIMPLIFY)
                                    (("1" (EXPAND BUMPN)
                                      (("1" (EXPAND ADD 2)
                                        (("1" (EXPAND MEMBER)
                                          (("1" (EXPAND RELEASE_MARKED -1)
                                            (("1" (SIMPLIFY)
                                              (("1" (SPLIT -3)
                                                (("1" (TYPEPRED "grS`redex")
                                                  (("1" (DELETE -1 -2 -3 -4 -5)
                                                    (("1"
                                                      (CASE-REPLACE
                                                       "grS`redex = ift(condition(grS`redex), thenexpr(grS`redex), elseexpr(grS`redex))")
                                                      (("1" (SIMPLIFY)
                                                        (("1" (EXPAND MARK -2)
                                                          (("1"
                                                            (DECOMPOSE-EQUALITY
                                                             -2)
                                                            (("1"
                                                              (CASE
                                                                  "vars(thenexpr(grS`redex))(i)")
                                                              (("1" (GRIND) NIL
                                                                NIL)
                                                               ("2"
                                                                (REPLACE -2 1
                                                                         :DIR
                                                                         RL)
                                                                (("2"
                                                                  (REWRITE
                                                                   VARS_RELEASE_SET)
                                                                  (("2"
                                                                    (REWRITE
                                                                     VARS_MARK)
                                                                    (("2"
                                                                      (EXPAND
                                                                       UNION 1)
                                                                      (("2"
                                                                        (EXPAND
                                                                         DIFFERENCE
                                                                         1)
                                                                        (("2"
                                                                          (EXPAND
                                                                           MEMBER)
                                                                          (("2"
                                                                            (EXPAND
                                                                             CVARS
                                                                             -5)
                                                                            (("2"
                                                                              (EXPAND
                                                                               VARS
                                                                               -5)
                                                                              (("2"
                                                                                (EXPAND
                                                                                 ADD
                                                                                 -5)
                                                                                (("2"
                                                                                  (EXPAND
                                                                                   UNION
                                                                                   -5)
                                                                                  (("2"
                                                                                    (EXPAND
                                                                                     MEMBER)
                                                                                    (("2"
                                                                                      (SPLIT
                                                                                       -5)
                                                                                      (("1"
                                                                                        (REPLACE
                                                                                         -2
                                                                                         3
                                                                                         :DIR
                                                                                         RL)
                                                                                        (("1"
                                                                                          (EXPAND
                                                                                           MARKV)
                                                                                          (("1"
                                                                                            (LIFT-IF
                                                                                             3)
                                                                                            (("1"
                                                                                              (EXPAND
                                                                                               UNION
                                                                                               3)
                                                                                              (("1"
                                                                                                (EXPAND
                                                                                                 MEMBER)
                                                                                                (("1"
                                                                                                  (GRIND)
                                                                                                  NIL
                                                                                                  NIL))
                                                                                                NIL))
                                                                                              NIL))
                                                                                            NIL))
                                                                                          NIL))
                                                                                        NIL)
                                                                                       ("2"
                                                                                        (GRIND)
                                                                                        NIL
                                                                                        NIL)
                                                                                       ("3"
                                                                                        (GRIND)
                                                                                        NIL
                                                                                        NIL))
                                                                                      NIL))
                                                                                    NIL))
                                                                                  NIL))
                                                                                NIL))
                                                                              NIL))
                                                                            NIL))
                                                                          NIL))
                                                                        NIL))
                                                                      NIL))
                                                                    NIL))
                                                                  NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL)
                                                       ("2" (GRIND-WITH-EXT)
                                                        NIL NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL)
                                                 ("2" (PROPAX) NIL NIL)
                                                 ("3" (PROPAX) NIL NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL)
                                 ("2" (HIDE-ALL-BUT (1 -4))
                                  (("2" (GRIND) NIL NIL)) NIL))
                                NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL)
                     ("2" (GRIND) NIL NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|ifReduce| CONST-DECL "rstate" |rreduction| NIL) NIL
    (|IExpression_ift_extensionality| FORMULA-DECL NIL |IExpression_adt| NIL)
    (|difference| CONST-DECL "set" |sets| NIL)
    (|release_set| DEF-DECL "IExpression" |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|cvars_pure| FORMULA-DECL NIL |preprocess| NIL)
    (|purePopDepth| FORMULA-DECL NIL IL NIL)
    (|vars_release_set| FORMULA-DECL NIL |preprocess| NIL)
    (|empty?| CONST-DECL "bool" |sets| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|vars_mark| FORMULA-DECL NIL |preprocess| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL) NIL
    (|finite_difference| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|ift| ADT-CONSTRUCTOR-DECL
     "[[(variable?), IExpression, IExpression] -> (ift?)]" |IExpression_adt|
     NIL)
    (|thenexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|release_marked| CONST-DECL "rstate" |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL) NIL
    (|ift?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|elseexpr| ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" |IExpression_adt|
     NIL)
    (|condition| ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" |IExpression_adt|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|ifReduce_ndr| SUBTYPE "rreduction.ifReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|lookupReduce_ndr| 0
  (|lookupReduce_ndr-2| "" 3715466184
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND LOOKUPREDUCE)
      (("" (SPLIT 2)
        (("1" (FLATTEN)
          (("1" (EXPAND NODANGLINGREFS?)
            (("1" (SKEEP* :PREDS? T)
              (("1" (INST -8 "i")
                (("1" (SPLIT -8)
                  (("1" (EXPAND RELEASE_MARKED 1)
                    (("1" (EXPAND CVARS 1 1)
                      (("1" (EXPAND SETREDEX 1)
                        (("1" (SIMPLIFY)
                          (("1" (EXPAND RELEASE_MARKED 2)
                            (("1" (EXPAND POPDEPTH 2 1)
                              (("1" (EXPAND SETREDEX 2)
                                (("1" (SIMPLIFY)
                                  (("1"
                                    (CASE-REPLACE "popDepth(grS`store
                                 (refindex(get(grS`stack)
                                              (arrayvalue(grS`redex))))`seq
                                 (value(get(grS`stack)(position(grS`redex))))) = 0")
                                    (("1" (EXPAND BUMPN)
                                      (("1" (EXPAND RELEASE_MARKED -9)
                                        (("1" (SIMPLIFY)
                                          (("1" (EXPAND SETREDEX -9)
                                            (("1" (SIMPLIFY)
                                              (("1" (TYPEPRED "grS`redex")
                                                (("1" (DELETE -1 -2 -3 -4 -5)
                                                  (("1"
                                                    (CASE-REPLACE
                                                     "grS`redex = lookup(arrayvalue(grS`redex), position(grS`redex))")
                                                    (("1" (SIMPLIFY)
                                                      (("1" (EXPAND MARK -2)
                                                        (("1"
                                                          (DECOMPOSE-EQUALITY
                                                           -2)
                                                          (("1"
                                                            (REPLACE -1 1 :DIR
                                                                     RL)
                                                            (("1"
                                                              (EXPAND MARKV)
                                                              (("1" (LIFT-IF 1)
                                                                (("1" (GRIND)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL)
                                                     ("2" (GRIND-WITH-EXT) NIL
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2"
                                      (TYPEPRED "grS`store
                             (refindex(get(grS`stack)(arrayvalue(grS`redex))))`seq
                             (value(get(grS`stack)(position(grS`redex))))")
                                      (("1" (HIDE-ALL-BUT (1 -1))
                                        (("1" (GRIND) NIL NIL)) NIL)
                                       ("2" (GRIND) NIL NIL))
                                      NIL)
                                     ("3" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (EXPAND RELEASE_MARKED 2)
                    (("2" (EXPAND POPDEPTH 2 1)
                      (("2" (EXPAND SETREDEX 2)
                        (("2" (SIMPLIFY)
                          (("2"
                            (TYPEPRED "grS`store
                                 (refindex(get(grS`stack)
                                              (arrayvalue(grS`redex))))`seq
                                 (value(get(grS`stack)(position(grS`redex))))")
                            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("3" (DELETE 2 3)
                    (("3" (EXPAND RELEASE_MARKED -7)
                      (("3" (EXPAND SETREDEX -7)
                        (("3" (SIMPLIFY) (("3" (PROPAX) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (DELETE 2 3)
                  (("2" (EXPAND RELEASE_MARKED -1)
                    (("2" (EXPAND SETREDEX -1)
                      (("2" (SIMPLIFY) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|lookupReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_lookup_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|lookup| ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]"
     |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|release_marked| CONST-DECL "rstate" |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|setRedex| CONST-DECL "rstate" |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | noDanglingRefs?(grS) AND lookupRedex?(grS`redex)}" |rreduction|
     NIL)
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|lookup?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|arrayvalue| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|constant?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|value| ADT-ACCESSOR-DECL "[(constant?) -> int]" |IExpression_adt| NIL)
    (|position| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|i| SKOLEM-CONST-DECL "below(release_marked(setRedex(grS,
                              grS`store
                                  (refindex(get(grS`stack)
                                               (arrayvalue(grS`redex))))`seq
                                  (value(get(grS`stack)
                                            (position(grS`redex))))))
                    (arrayvalue(grS`redex))`stack`length)"
     |rreduction| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|lookupReduce_ndr| SUBTYPE
    "rreduction.lookupReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (|lookupReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND LOOKUPREDUCE)
      (("" (SPLIT 2)
        (("1" (FLATTEN)
          (("1" (EXPAND NODANGLINGREFS?)
            (("1" (SKEEP* :PREDS? T)
              (("1" (INST -8 I)
                (("1" (SPLIT -8)
                  (("1" (EXPAND RELEASE_MARKED 1)
                    (("1" (EXPAND CVARS 1 1)
                      (("1" (EXPAND SETREDEX 1)
                        (("1" (SIMPLIFY)
                          (("1" (EXPAND RELEASE_MARKED 2)
                            (("1" (EXPAND POPDEPTH 2 1)
                              (("1" (EXPAND SETREDEX 2)
                                (("1" (SIMPLIFY)
                                  (("1"
                                    (CASE-REPLACE "popDepth(grS`store
                         (refindex(get(grS`stack)
                                      (arrayvalue(grS`redex))))`seq
                         (value(get(grS`stack)(position(grS`redex))))) = 0")
                                    (("1" (EXPAND BUMPN)
                                      (("1" (EXPAND RELEASE_MARKED -9)
                                        (("1" (SIMPLIFY)
                                          (("1" (EXPAND SETREDEX -9)
                                            (("1" (SIMPLIFY)
                                              (("1" (TYPEPRED "grS`redex")
                                                (("1" (DELETE -1 -2 -3 -4 -5)
                                                  (("1"
                                                    (CASE-REPLACE
                                                     "grS`redex = lookup(arrayvalue(grS`redex), position(grS`redex))")
                                                    (("1" (SIMPLIFY)
                                                      (("1" (EXPAND MARK -2)
                                                        (("1"
                                                          (DECOMPOSE-EQUALITY
                                                           -2)
                                                          (("1"
                                                            (REPLACE -1 1 :DIR
                                                                     RL)
                                                            (("1"
                                                              (EXPAND MARKV)
                                                              (("1" (LIFT-IF 1)
                                                                (("1" (GRIND)
                                                                  NIL NIL))
                                                                NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL)
                                                     ("2" (GRIND-WITH-EXT) NIL
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL)
                                     ("2"
                                      (TYPEPRED "grS`store
                   (refindex(get(grS`stack)(arrayvalue(grS`redex))))`seq
                   (value(get(grS`stack)(position(grS`redex))))")
                                      (("1" (HIDE-ALL-BUT (1 -1))
                                        (("1" (GRIND) NIL NIL)) NIL)
                                       ("2" (GRIND) NIL NIL))
                                      NIL)
                                     ("3" (GRIND) NIL NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("2" (EXPAND RELEASE_MARKED 2)
                    (("2" (EXPAND POPDEPTH 2 1)
                      (("2" (EXPAND SETREDEX 2)
                        (("2" (SIMPLIFY)
                          (("2"
                            (TYPEPRED "grS`store
                         (refindex(get(grS`stack)
                                      (arrayvalue(grS`redex))))`seq
                         (value(get(grS`stack)(position(grS`redex))))")
                            (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL)
                   ("3" (DELETE 2 3)
                    (("3" (EXPAND RELEASE_MARKED -7)
                      (("3" (EXPAND SETREDEX -7)
                        (("3" (SIMPLIFY) (("3" (PROPAX) NIL NIL)) NIL)) NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (DELETE 2 3)
                  (("2" (EXPAND RELEASE_MARKED -1)
                    (("2" (EXPAND SETREDEX -1)
                      (("2" (SIMPLIFY) (("2" (PROPAX) NIL NIL)) NIL)) NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (GRIND) NIL NIL))
        NIL))
      NIL))
    NIL)
   ((|lookupReduce| CONST-DECL "rstate" |rreduction| NIL) NIL
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|IExpression_lookup_extensionality| FORMULA-DECL NIL |IExpression_adt|
     NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|nonempty?| CONST-DECL "bool" |sets| NIL)
    (|markv| CONST-DECL "(variable?)" |preprocess| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|lookup| ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]"
     |IExpression_adt| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|index| ADT-ACCESSOR-DECL "[(variable?) -> nat]" |IExpression_adt| NIL)
    (|marked| ADT-ACCESSOR-DECL "[(variable?) -> bool]" |IExpression_adt| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|release_marked| CONST-DECL "rstate" |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|setRedex| CONST-DECL "rstate" |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL) NIL
    (|ref?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|refindex| ADT-ACCESSOR-DECL "[(ref?) -> nat]" |IExpression_adt| NIL)
    (|get| CONST-DECL "(value?)" IL NIL)
    (|lookup?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]" |IExpression_adt|
     NIL)
    (|arrayvalue| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|constant?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|value| ADT-ACCESSOR-DECL "[(constant?) -> int]" |IExpression_adt| NIL)
    (|position| ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]"
     |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|lookupReduce_ndr| SUBTYPE
    "rreduction.lookupReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|newintReduce_ndr| 0
  (|newintReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NEWINTREDUCE)
      (("" (EXPAND NODANGLINGREFS?) (("" (GRIND) NIL NIL)) NIL)) NIL))
    NIL)
   ((|newintReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL) (|popDepth| DEF-DECL "nat" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|newintReduce_ndr| SUBTYPE
    "rreduction.newintReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|newrefReduce_ndr| 0
  (|newrefReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NEWREFREDUCE) (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|newrefReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (|emptyset| CONST-DECL "set" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|least_out| CONST-DECL "{n | NOT NS(n)}" |finite_set_theorems| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|newrefReduce_ndr| SUBTYPE
    "rreduction.newrefReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|popReduce_ndr| 0
  (|popReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (SKEEP* :PREDS? T)
        (("" (EXPAND POPREDUCE)
          (("" (EXPAND POP)
            (("" (INST -2 "i+1")
              (("1" (ASSERT)
                (("1" (EXPAND POPREDEX?)
                  (("1" (FLATTEN)
                    (("1" (ASSERT)
                      (("1" (EXPAND CVARS -2 1)
                        (("1" (SPLIT)
                          (("1" (GRIND) NIL NIL)
                           ("2" (EXPAND BUMPN)
                            (("2" (CASE-REPLACE "popDepth(grS`redex) = 1")
                              (("1" (ASSERT) (("1" (GRIND) NIL NIL)) NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (GRIND) NIL NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|popReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|i| SKOLEM-CONST-DECL "below(popReduce(D)(grS)`stack`length)" |rreduction|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|grS| SKOLEM-CONST-DECL
     "{grS | noDanglingRefs?(grS) AND popRedex?(grS`redex)}" |rreduction| NIL)
    (D SKOLEM-CONST-DECL "Defs" |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers|
     NIL)
    (|pop| CONST-DECL "Stack" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|popReduce_ndr| SUBTYPE
    "rreduction.popReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|releaseReduce_ndr| 0
  (|releaseReduce_ndr-2| "" 3715469137
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND RELEASEREDUCE)
      (("" (SPLIT 2)
        (("1" (BASH) NIL NIL)
         ("2" (FLATTEN)
          (("2" (EXPAND NODANGLINGREFS?)
            (("2" (SKEEP* :PREDS? T)
              (("2" (INST -3 "i") (("2" (GRIND) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|releaseReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|releaseReduce_ndr| SUBTYPE
    "rreduction.releaseReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (|releaseReduce_ndr-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T)
    (("" (EXPAND RELEASEREDUCE)
      (("" (SPLIT 2)
        (("1" (BASH) NIL NIL)
         ("2" (FLATTEN)
          (("2" (EXPAND NODANGLINGREFS?)
            (("2" (SKEEP* :PREDS? T)
              (("2" (INST -3 I) (("2" (GRIND) NIL NIL)) NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|releaseReduce| CONST-DECL "rstate" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|nonempty_add_finite| APPLICATION-JUDGEMENT "non_empty_finite_set[nat]"
     |countability| "sets_aux/")
    (|add| CONST-DECL "(nonempty?)" |sets| NIL)
    (|member| CONST-DECL "bool" |sets| NIL) NIL
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) NIL
    (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|releaseReduce_ndr| SUBTYPE
    "rreduction.releaseReduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)")))
 (|make_redex_TCC1| 0
  (|make_redex_TCC1-1| NIL 3701197360
   ("" (SKEEP)
    (("" (SPLIT)
      (("1" (GRIND)
        (("1" (TYPEPRED "t`redex")
          (("1" (TYPEPRED "buildRedex(t`redex)")
            (("1" (REPLACE -1 - :DIR RL)
              (("1" (REWRITE CONTEXTPUREFILL) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL)
       ("2" (TYPEPRED "t`redex")
        (("2" (TYPEPRED "buildRedex(t`redex)")
          (("2" (REPLACE -1 - :DIR RL)
            (("2" (REWRITE MARK_FILL)
              (("2" (LEMMA FILL_MARK_INJ)
                (("2" (INST?)
                  (("2" (SPLIT -1)
                    (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|contextPurefill| FORMULA-DECL NIL IL NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|mark_fill| FORMULA-DECL NIL |preprocess| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|fill_mark_inj| FORMULA-DECL NIL |preprocess| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|make_redex| SUBTYPE "rreduction.ctx"
    "{K | booleans.AND(IL.cpure?(rreduction.K), preprocess.markc(sets[naturalnumbers.nat].emptyset)(rreduction.K) = rreduction.K)}")))
 (|make_redex_TCC2| 0
  (|make_redex_TCC2-2| "" 3715471944
   ("" (WITH-LABELS (SKEEP :PREDS? T) ((TTOP RDEF CDEF OBJ)))
    (("" (REWRITE RDEF)
      (("" (REWRITE CDEF)
        ((""
          (WITH-LABELS (TYPEPRED "t`redex") ((HREF HVAR HCVAR HSL HCP HMARK)))
          ((""
            (WITH-LABELS (TYPEPRED "buildRedex(t`redex)") ((HFILL HPURERED)))
            (("" (REPLACE HFILL - :DIR RL)
              (("" (REWRITE POPDEPTH_FILL)
                (("" (REWRITE REFS_FILL)
                  (("" (REWRITE CONTEXTPUREFILL)
                    (("" (REWRITE MARK_FILL)
                      (("" (USE FILL_MARK_INJ)
                        (("" (SPLIT OBJ)
                          (("1" (PROPAX) NIL NIL)
                           ("2" (SKEEP)
                            (("2"
                              (INST HVAR "i - popDepth(buildRedex(t`redex)`1)")
                              (("1" (REWRITE VARS_DECOMPOSE)
                                (("1" (GRIND) NIL NIL)) NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL))
                            NIL)
                           ("3" (SKEEP)
                            (("3" (INST HVAR "i")
                              (("3" (REWRITE VARS_DECOMPOSE)
                                (("3" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL)
                           ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)
                           ("6" (SPLIT -1)
                            (("1" (HIDE-ALL-BUT (OBJ TTOP -1))
                              (("1"
                                (CASE-REPLACE
                                 "union(cvars(buildRedex(t`redex)`1),
                         bumpn(cvars(t`context),
                               popDepth(buildRedex(t`redex)`1))) = cvars(buildRedex(t`redex)`1)")
                                (("1" (GRIND) NIL NIL)
                                 ("2" (GRIND-WITH-EXT) NIL NIL))
                                NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refs_fill| FORMULA-DECL NIL IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|mark_fill| FORMULA-DECL NIL |preprocess| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|i| SKOLEM-CONST-DECL "nat" |rreduction| NIL)
    (|t| SKOLEM-CONST-DECL "{t: rtopstate | NOT value?(t`redex)}" |rreduction|
     NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|vars_decompose| FORMULA-DECL NIL IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|fill_mark_inj| FORMULA-DECL NIL |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|contextPurefill| FORMULA-DECL NIL IL NIL)
    (|popdepth_fill| FORMULA-DECL NIL IL NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|make_redex| SUBTYPE "rreduction.redex"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.t`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.t`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.ctx)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.ctx)), rreduction.t`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.ctx)), rreduction.t`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.ctx))(rreduction.A) = rreduction.A)}"))
  (|make_redex_TCC2-1| NIL 3701197360
   ("" (WITH-LABELS (SKEEP :PREDS? T) ((TTOP RDEF CDEF OBJ)))
    (("" (REWRITE RDEF)
      (("" (REWRITE CDEF)
        ((""
          (WITH-LABELS (TYPEPRED "t`redex") ((HREF HVAR HCVAR HSL HCP HMARK)))
          ((""
            (WITH-LABELS (TYPEPRED "buildRedex(t`redex)") ((HFILL HPURERED)))
            (("" (REPLACE HFILL - :DIR RL)
              (("" (REWRITE POPDEPTH_FILL)
                (("" (REWRITE REFS_FILL)
                  (("" (REWRITE CONTEXTPUREFILL)
                    (("" (REWRITE MARK_FILL)
                      (("" (USE FILL_MARK_INJ)
                        (("" (SPLIT OBJ)
                          (("1" (PROPAX) NIL NIL)
                           ("2" (SKEEP)
                            (("2"
                              (INST HVAR "i - popDepth(buildRedex(t`redex)`1)")
                              (("1" (REWRITE VARS_DECOMPOSE)
                                (("1" (GRIND) NIL NIL)) NIL)
                               ("2" (GRIND) NIL NIL))
                              NIL))
                            NIL)
                           ("3" (SKEEP)
                            (("3" (INST HVAR I)
                              (("3" (REWRITE VARS_DECOMPOSE)
                                (("3" (GRIND) NIL NIL)) NIL))
                              NIL))
                            NIL)
                           ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL)
                           ("6" (SPLIT -1)
                            (("1" (HIDE-ALL-BUT (OBJ TTOP -1))
                              (("1"
                                (CASE-REPLACE
                                 "union(cvars(buildRedex(t`redex)`1),
                   bumpn(cvars(t`context),
                         popDepth(buildRedex(t`redex)`1))) = cvars(buildRedex(t`redex)`1)")
                                (("1" (GRIND) NIL NIL)
                                 ("2" (GRIND-WITH-EXT) NIL NIL))
                                NIL))
                              NIL)
                             ("2" (GRIND) NIL NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL) NIL
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refs_fill| FORMULA-DECL NIL IL NIL)
    (|vars_mark_type| APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}"
     |preprocess| NIL)
    (|finite_union| APPLICATION-JUDGEMENT "finite_set[nat]" |countability|
     "sets_aux/")
    (|mark_fill| FORMULA-DECL NIL |preprocess| NIL)
    (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|vars_decompose| FORMULA-DECL NIL IL NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|member| CONST-DECL "bool" |sets| NIL)
    (|fill_mark_inj| FORMULA-DECL NIL |preprocess| NIL)
    (|union| CONST-DECL "set" |sets| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|contextPurefill| FORMULA-DECL NIL IL NIL)
    (|popdepth_fill| FORMULA-DECL NIL IL NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|make_redex| SUBTYPE "rreduction.redex"
    "{A |      (FORALL i: booleans.IMPLIES(IL.refs(rreduction.A)(rreduction.i), rreduction.t`domain(rreduction.i))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.A)(rreduction.i), reals.<((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), rreduction.t`stack`length))) AND (FORALL i: booleans.IMPLIES(IL.vars(rreduction.ctx)(rreduction.i), reals.<((number_fields.+)((number_fields.+)(rreduction.i, IL.popDepth(rreduction.A)), IL.popDepth(rreduction.ctx)), rreduction.t`stack`length))) AND (reals.<=((number_fields.+)(IL.popDepth(rreduction.A), IL.popDepth(rreduction.ctx)), rreduction.t`stack`length)) AND IL.contextPure?(rreduction.A) AND (preprocess.mark(preprocess.cvars(rreduction.ctx))(rreduction.A) = rreduction.A)}")))
 (|make_redex_TCC3| 0
  (|make_redex_TCC3-1| NIL 3701197360
   ("" (SKEEP)
    (("" (SKEEP)
      (("" (TYPEPRED "t`count(x1)")
        (("" (REWRITE -1)
          (("" (EXPAND REFCOUNT)
            (("" (EXPAND REFCOUNTEXPR)
              (("" (TYPEPRED "buildRedex(t`redex)")
                (("" (REPLACE -1 1 :DIR RL)
                  (("" (REWRITE REFS_FILL) (("" (GRIND) NIL NIL)) NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|refcountExpr| CONST-DECL "nat" |rreduction| NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|refs_fill| FORMULA-DECL NIL IL NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|make_redex| SUBTYPE "(rreduction.t:: rreduction.rstate)`count"
    "[i: (rreduction.t`domain) -> {j | rreduction.j = rreduction.refcount(rreduction.t`domain, rreduction.t`store, rreduction.t`stack, rreduction.redex)(i)}]")))
 (|make_redex_TCC4| 0
  (|make_redex_TCC4-1| NIL 3701197360
   ("" (SKEEP :PREDS? T)
    (("" (TYPEPRED "buildRedex(t`redex)") (("" (GRIND) NIL NIL)) NIL)) NIL)
   ((|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|make_redex| SUBTYPE
    "(rreduction.t:: rreduction.rstate) WITH [`context := rreduction.ctx, `redex := rreduction.redex]"
    "{rS | IL.pureRedex?(rreduction.rS`redex)}")))
 (|to_topstate_make_redex| 0
  (|to_topstate_make_redex-1| NIL 3706457889
   ("" (SKEEP* :PREDS? T)
    (("" (DECOMPOSE-EQUALITY 2)
      (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)
       ("4" (EXPAND* TO_TOPSTATE MAKE_REDEX)
        (("4" (TYPEPRED "buildRedex(t`redex)") (("4" (PROPAX) NIL NIL)) NIL))
        NIL)
       ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL))
      NIL))
    NIL)
   ((|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|make_redex_idem_TCC1| 0
  (|make_redex_idem_TCC1-1| NIL 3701442113 ("" (SUBTYPE-TCC) NIL NIL)
   ((|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL))
   NIL
   (|make_redex_idem| SUBTYPE
    "rreduction.to_topstate(rreduction.make_redex(rreduction.t))"
    "{t: rreduction.rtopstate | }")))
 (|make_redex_idem| 0
  (|make_redex_idem-1| NIL 3701442114
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND MAKE_REDEX)
      (("" (EXPAND TO_TOPSTATE)
        (("" (TYPEPRED "buildRedex(t`redex)")
          (("" (REPLACE -1) (("" (PROPAX) NIL NIL)) NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK))
 (|make_redex_ndr| 0
  (|make_redex_ndr-2| "" 3715472020
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (EXPAND MAKE_REDEX)
        (("" (SKEEP)
          (("" (INST?)
            (("1" (ASSERT)
              (("1" (TYPEPRED "buildRedex(t`redex)")
                (("1" (REPLACE -1 - :DIR RL)
                  (("1" (REWRITE CVARS_FILL) (("1" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (TYPEPRED "i") (("2" (GRIND) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|cvars_fill| FORMULA-DECL NIL |preprocess| NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|t| SKOLEM-CONST-DECL
     "{t: rtopstate | noDanglingRefs?(t) AND NOT value?(t`redex)}" |rreduction|
     NIL)
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|i| SKOLEM-CONST-DECL "below(make_redex(t)`stack`length)" |rreduction|
     NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   SHOSTAK
   (|make_redex_ndr| SUBTYPE "rreduction.make_redex(rreduction.t)"
    "(rreduction.noDanglingRefs?)"))
  (|make_redex_ndr-1| NIL 3701197360
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND NODANGLINGREFS?)
      (("" (EXPAND MAKE_REDEX)
        (("" (SKEEP)
          (("" (INST?)
            (("1" (ASSERT)
              (("1" (TYPEPRED "buildRedex(t`redex)")
                (("1" (REPLACE -1 - :DIR RL)
                  (("1" (REWRITE CVARS_FILL) (("1" (GRIND) NIL NIL)) NIL))
                  NIL))
                NIL))
              NIL)
             ("2" (TYPEPRED I) (("2" (GRIND) NIL NIL)) NIL))
            NIL))
          NIL))
        NIL))
      NIL))
    NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])"
     |real_props| NIL)
    (|finite_emptyset| NAME-JUDGEMENT "finite_set[T]" |countability|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |countable_props|
     "sets_aux/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |sigma_set| "sigma_set/")
    (|finite_emptyset| NAME-JUDGEMENT "finite_set" |finite_sets| NIL)
    (|cvars_fill| FORMULA-DECL NIL |preprocess| NIL)
    (|fill| DEF-DECL "IExpression" IL NIL)
    (|buildRedex| DEF-DECL "{(K, B) | fill(K, B) = A}" IL NIL)
    (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) NIL
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) NIL
    NIL NIL (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL) NIL
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL) NIL
    (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) NIL
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|make_redex_ndr| SUBTYPE "rreduction.make_redex(rreduction.t)"
    "(rreduction.noDanglingRefs?)")))
 (|reduce_TCC1| 0
  (|reduce_TCC1-1| NIL 3699648459
   ("" (SKEEP)
    (("" (LEMMA MAKE_REDEX_NDR) (("" (INST?) (("" (ASSERT) NIL NIL)) NIL))
      NIL))
    NIL)
   ((|make_redex_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|t| SKOLEM-CONST-DECL "rtopstate" |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.make_redex(rreduction.t)"
    "(rreduction.noDanglingRefs?)")))
 (|reduce_TCC2| 0
  (|reduce_TCC2-1| NIL 3699648459
   ("" (SKEEP* :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IExpression_adt.variable?(rreduction.grS`redex)}")))
 (|reduce_TCC3| 0
  (|reduce_TCC3-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IL.pureLetRedex?(rreduction.grS`redex)}")))
 (|reduce_TCC4| 0
  (|reduce_TCC4-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IL.applyRedex?(rreduction.grS`redex)}")))
 (|reduce_TCC5| 0
  (|reduce_TCC5-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))
 (|reduce_TCC6| 0
  (|reduce_TCC6-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | booleans.AND(IL.updateRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (|reduce_TCC7| 0
  (|reduce_TCC7-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))
 (|reduce_TCC8| 0
  (|reduce_TCC8-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IL.newintRedex?(rreduction.grS`redex)}")))
 (|reduce_TCC9| 0
  (|reduce_TCC9-1| NIL 3699648459
   ("" (SKEEP :PREDS? T) (("" (GRIND) NIL NIL)) NIL)
   ((|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|value?| CONST-DECL "bool" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|real_lt_is_strict_total_order| NAME-JUDGEMENT
     "(strict_total_order?[real])" |real_props| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))
 (|reduce_TCC10| 0
  (|reduce_TCC10-1| NIL 3699648459
   ("" (SKEEP :PREDS? T)
    (("" (SKEEP :PREDS? T)
      (("" (CASE "pureRedex?(nS`redex)")
        (("1" (GRIND) NIL NIL)
         ("2" (TYPEPRED "make_redex(t)") (("2" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | booleans.AND(IL.popRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (|reduce_TCC11| 0
  (|reduce_TCC11-1| NIL 3705848866
   ("" (SKEEP :PREDS? T)
    (("" (SKEEP :PREDS? T)
      (("" (CASE "pureRedex?(nS`redex)")
        (("1" (GRIND) NIL NIL)
         ("2" (TYPEPRED "make_redex(t)") (("2" (GRIND) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|letRedex?| CONST-DECL "bool" IL NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|iftRedex?| CONST-DECL "bool" IL NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|releaseRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|bumpn| CONST-DECL "finite_set[nat]" IL NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|buildRedexPure| REC-APPLICATION-JUDGEMENT "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}"
     IL NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL) (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL))
   NIL
   (|reduce| SUBTYPE "rreduction.nS"
    "{grS | booleans.AND(IL.pureReleaseRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (|reduce_ndr| 0
  (|reduce_ndr-3| "" 3715473317
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND REDUCE)
      (("" (CASE "noDanglingRefs?(to_topstate(grS))")
        (("1" (SPLIT)
          (("1" (GRIND) NIL NIL)
           ("2" (FLATTEN)
            (("2" (CASE "noDanglingRefs?(make_redex(to_topstate(grS)))")
              (("1" (NAME-REPLACE "rS" "make_redex(to_topstate(grS))")
                (("1" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (USE VARIABLEREDUCE_NDR)
                      (("1" (SPLIT)
                        (("1" (PROPAX) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL))
                      NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (SPLIT)
                      (("1" (FLATTEN)
                        (("1" (USE LETREDUCE_NDR) (("1" (GRIND) NIL NIL)) NIL))
                        NIL)
                       ("2" (FLATTEN)
                        (("2" (SPLIT)
                          (("1" (FLATTEN)
                            (("1" (USE APPLYREDUCE_NDR) (("1" (GRIND) NIL NIL))
                              NIL))
                            NIL)
                           ("2" (FLATTEN)
                            (("2" (SPLIT)
                              (("1" (FLATTEN)
                                (("1" (USE IFREDUCE_NDR)
                                  (("1" (GRIND) NIL NIL)) NIL))
                                NIL)
                               ("2" (FLATTEN)
                                (("2" (SPLIT)
                                  (("1" (FLATTEN)
                                    (("1" (TYPEPRED "updateReduce(D)(rS)")
                                      (("1" (PROPAX) NIL NIL)) NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SPLIT)
                                      (("1" (FLATTEN)
                                        (("1" (USE LOOKUPREDUCE_NDR)
                                          (("1" (GRIND) NIL NIL)) NIL))
                                        NIL)
                                       ("2" (FLATTEN)
                                        (("2" (SPLIT)
                                          (("1" (FLATTEN)
                                            (("1" (USE NEWINTREDUCE_NDR)
                                              (("1" (GRIND) NIL NIL)) NIL))
                                            NIL)
                                           ("2" (FLATTEN)
                                            (("2" (SPLIT)
                                              (("1" (FLATTEN)
                                                (("1" (USE NEWREFREDUCE_NDR)
                                                  (("1" (GRIND) NIL NIL)) NIL))
                                                NIL)
                                               ("2" (FLATTEN)
                                                (("2" (SPLIT)
                                                  (("1" (FLATTEN)
                                                    (("1" (USE POPREDUCE_NDR)
                                                      (("1" (GRIND) NIL NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (FLATTEN)
                                                    (("2"
                                                      (CASE
                                                          "pureReleaseRedex?(rS`redex)")
                                                      (("1"
                                                        (USE RELEASEREDUCE_NDR)
                                                        (("1" (GRIND) NIL NIL))
                                                        NIL)
                                                       ("2"
                                                        (CASE
                                                            "pureRedex?(rS`redex)")
                                                        (("1"
                                                          (EXPAND PUREREDEX?)
                                                          (("1" (PROP) NIL
                                                            NIL))
                                                          NIL)
                                                         ("2" (EXPAND RS)
                                                          (("2"
                                                            (TYPEPRED
                                                             "make_redex(to_topstate(grS))")
                                                            (("2" (PROPAX) NIL
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL))
                NIL)
               ("2" (LEMMA MAKE_REDEX_NDR) (("2" (INST?) NIL NIL)) NIL)
               ("3" (PROPAX) NIL NIL))
              NIL))
            NIL))
          NIL)
         ("2" (LEMMA TO_TOPSTATE_DANGLING) (("2" (INST?) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|reduce| CONST-DECL "rstate" |rreduction| NIL)
    (|to_topstate_dangling| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|rS| SKOLEM-CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|variableReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|applyReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|ifReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|updateReduce| CONST-DECL "(noDanglingRefs?)" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|lookupReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newintReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|newrefReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|popReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|releaseReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|grS| SKOLEM-CONST-DECL "{grS | noDanglingRefs?(grS)}" |rreduction| NIL)
    (|make_redex_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|cvars| DEF-DECL "finite_set[nat]" |preprocess| NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL)
    (|popDepth| DEF-DECL "nat" IL NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL)
    (|vars| DEF-DECL "finite_set[nat]" IL NIL) (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   SHOSTAK
   (|reduce_ndr| SUBTYPE "rreduction.reduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (|reduce_ndr-2| NIL 3705860166
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND REDUCE)
      (("" (CASE "noDanglingRefs?(to_topstate(grS))")
        (("1" (SPLIT)
          (("1" (GRIND) NIL NIL)
           ("2" (FLATTEN)
            (("2" (CASE "noDanglingRefs?(make_redex(to_topstate(grS)))")
              (("1" (NAME-REPLACE RS "make_redex(to_topstate(grS))")
                (("1" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (USE VARIABLEREDUCE_NDR)
                      (("1" (SPLIT)
                        (("1" (PROPAX) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL))
                      NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (SPLIT)
                      (("1" (FLATTEN)
                        (("1" (USE LETREDUCE_NDR) (("1" (GRIND) NIL NIL)) NIL))
                        NIL)
                       ("2" (FLATTEN)
                        (("2" (SPLIT)
                          (("1" (FLATTEN)
                            (("1" (USE APPLYREDUCE_NDR) (("1" (GRIND) NIL NIL))
                              NIL))
                            NIL)
                           ("2" (FLATTEN)
                            (("2" (SPLIT)
                              (("1" (FLATTEN)
                                (("1" (USE IFREDUCE_NDR)
                                  (("1" (GRIND) NIL NIL)) NIL))
                                NIL)
                               ("2" (FLATTEN)
                                (("2" (SPLIT)
                                  (("1" (FLATTEN)
                                    (("1" (TYPEPRED "updateReduce(D)(rS)")
                                      (("1" (PROPAX) NIL NIL)) NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SPLIT)
                                      (("1" (FLATTEN)
                                        (("1" (USE LOOKUPREDUCE_NDR)
                                          (("1" (GRIND) NIL NIL)) NIL))
                                        NIL)
                                       ("2" (FLATTEN)
                                        (("2" (SPLIT)
                                          (("1" (FLATTEN)
                                            (("1" (USE NEWINTREDUCE_NDR)
                                              (("1" (GRIND) NIL NIL)) NIL))
                                            NIL)
                                           ("2" (FLATTEN)
                                            (("2" (SPLIT)
                                              (("1" (FLATTEN)
                                                (("1" (USE NEWREFREDUCE_NDR)
                                                  (("1" (GRIND) NIL NIL)) NIL))
                                                NIL)
                                               ("2" (FLATTEN)
                                                (("2" (SPLIT)
                                                  (("1" (FLATTEN)
                                                    (("1" (USE POPREDUCE_NDR)
                                                      (("1" (GRIND) NIL NIL))
                                                      NIL))
                                                    NIL)
                                                   ("2" (FLATTEN)
                                                    (("2"
                                                      (CASE
                                                          "pureReleaseRedex?(rS`redex)")
                                                      (("1"
                                                        (USE RELEASEREDUCE_NDR)
                                                        (("1" (GRIND) NIL NIL))
                                                        NIL)
                                                       ("2"
                                                        (CASE
                                                            "pureRedex?(rS`redex)")
                                                        (("1"
                                                          (EXPAND PUREREDEX?)
                                                          (("1" (PROP) NIL
                                                            NIL))
                                                          NIL)
                                                         ("2" (EXPAND RS)
                                                          (("2"
                                                            (TYPEPRED
                                                             "make_redex(to_topstate(grS))")
                                                            (("1" (PROPAX) NIL
                                                              NIL)
                                                             ("2"
                                                              (EXPAND
                                                               TO_TOPSTATE)
                                                              (("2" (PROPAX)
                                                                NIL NIL))
                                                              NIL))
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND TO_TOPSTATE) (("2" (PROPAX) NIL NIL)) NIL))
                NIL)
               ("2" (LEMMA MAKE_REDEX_NDR)
                (("2" (INST?)
                  (("2" (SPLIT)
                    (("1" (PROPAX) NIL NIL)
                     ("2" (EXPAND TO_TOPSTATE) (("2" (PROPAX) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (SPLIT)
                (("1" (PROPAX) NIL NIL)
                 ("2" (EXPAND TO_TOPSTATE) (("2" (PROPAX) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (LEMMA TO_TOPSTATE_DANGLING) (("2" (INST?) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|reduce| CONST-DECL "rstate" |rreduction| NIL)
    (|to_topstate_dangling| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    NIL
    (|variable?| ADT-RECOGNIZER-DECL "[IExpression -> boolean]"
     |IExpression_adt| NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|variableReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|letReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|applyReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|ifReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|updateReduce| CONST-DECL "(noDanglingRefs?)" |rreduction| NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|lookupReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newintReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|newrefReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|popReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|releaseReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL) NIL
    (|make_redex_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL) NIL
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|contextPure?| DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" |reals| NIL)
    NIL NIL NIL
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (< CONST-DECL "bool" |reals| NIL) NIL (|refs| DEF-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|Stack| TYPE-EQ-DECL NIL IL NIL) (|value?| CONST-DECL "bool" IL NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|IContext| TYPE-DECL NIL IL NIL))
   NIL
   (|reduce_ndr| SUBTYPE "rreduction.reduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))
  (|reduce_ndr-1| NIL 3701438337
   ("" (SKEEP :PREDS? T)
    (("" (EXPAND REDUCE)
      (("" (CASE "noDanglingRefs?(to_topstate(grS))")
        (("1" (SPLIT)
          (("1" (GRIND) NIL NIL)
           ("2" (FLATTEN)
            (("2" (CASE "noDanglingRefs?(make_redex(to_topstate(grS)))")
              (("1" (NAME-REPLACE RS "make_redex(to_topstate(grS))")
                (("1" (SPLIT)
                  (("1" (FLATTEN)
                    (("1" (USE LETREDUCE_NDR) (("1" (GRIND) NIL NIL)) NIL))
                    NIL)
                   ("2" (FLATTEN)
                    (("2" (SPLIT)
                      (("1" (FLATTEN)
                        (("1" (USE APPLYREDUCE_NDR) (("1" (GRIND) NIL NIL))
                          NIL))
                        NIL)
                       ("2" (FLATTEN)
                        (("2" (SPLIT)
                          (("1" (FLATTEN)
                            (("1" (USE IFREDUCE_NDR) (("1" (GRIND) NIL NIL))
                              NIL))
                            NIL)
                           ("2" (FLATTEN)
                            (("2" (SPLIT)
                              (("1" (FLATTEN)
                                (("1" (TYPEPRED "updateReduce(D)(rS)")
                                  (("1" (PROPAX) NIL NIL)) NIL))
                                NIL)
                               ("2" (FLATTEN)
                                (("2" (SPLIT)
                                  (("1" (FLATTEN)
                                    (("1" (USE LOOKUPREDUCE_NDR)
                                      (("1" (GRIND) NIL NIL)) NIL))
                                    NIL)
                                   ("2" (FLATTEN)
                                    (("2" (SPLIT)
                                      (("1" (FLATTEN)
                                        (("1" (USE NEWINTREDUCE_NDR)
                                          (("1" (GRIND) NIL NIL)) NIL))
                                        NIL)
                                       ("2" (FLATTEN)
                                        (("2" (SPLIT)
                                          (("1" (FLATTEN)
                                            (("1" (USE NEWREFREDUCE_NDR)
                                              (("1" (GRIND) NIL NIL)) NIL))
                                            NIL)
                                           ("2" (FLATTEN)
                                            (("2" (SPLIT)
                                              (("1" (FLATTEN)
                                                (("1" (USE POPREDUCE_NDR)
                                                  (("1" (GRIND) NIL NIL)) NIL))
                                                NIL)
                                               ("2" (FLATTEN)
                                                (("2"
                                                  (CASE
                                                      "pureReleaseRedex?(rS`redex)")
                                                  (("1" (USE RELEASEREDUCE_NDR)
                                                    (("1" (GRIND) NIL NIL))
                                                    NIL)
                                                   ("2"
                                                    (CASE
                                                        "pureRedex?(rS`redex)")
                                                    (("1" (EXPAND PUREREDEX?)
                                                      (("1" (PROP) NIL NIL))
                                                      NIL)
                                                     ("2" (EXPAND RS)
                                                      (("2"
                                                        (TYPEPRED
                                                         "make_redex(to_topstate(grS))")
                                                        (("1" (PROPAX) NIL NIL)
                                                         ("2"
                                                          (EXPAND TO_TOPSTATE)
                                                          (("2" (PROPAX) NIL
                                                            NIL))
                                                          NIL))
                                                        NIL))
                                                      NIL))
                                                    NIL))
                                                  NIL))
                                                NIL))
                                              NIL))
                                            NIL))
                                          NIL))
                                        NIL))
                                      NIL))
                                    NIL))
                                  NIL))
                                NIL))
                              NIL))
                            NIL))
                          NIL))
                        NIL))
                      NIL))
                    NIL))
                  NIL)
                 ("2" (EXPAND TO_TOPSTATE) (("2" (PROPAX) NIL NIL)) NIL))
                NIL)
               ("2" (LEMMA MAKE_REDEX_NDR)
                (("2" (INST?)
                  (("2" (SPLIT)
                    (("1" (PROPAX) NIL NIL)
                     ("2" (EXPAND TO_TOPSTATE) (("2" (PROPAX) NIL NIL)) NIL))
                    NIL))
                  NIL))
                NIL)
               ("3" (SPLIT)
                (("1" (PROPAX) NIL NIL)
                 ("2" (EXPAND TO_TOPSTATE) (("2" (PROPAX) NIL NIL)) NIL))
                NIL))
              NIL))
            NIL))
          NIL)
         ("2" (LEMMA TO_TOPSTATE_DANGLING) (("2" (INST?) NIL NIL)) NIL))
        NIL))
      NIL))
    NIL)
   ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers|
     NIL)
    (|reduce| CONST-DECL "rstate" |rreduction| NIL)
    (|to_topstate_dangling| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|make_redex| CONST-DECL "{rS | pureRedex?(rS`redex)}" |rreduction| NIL)
    (|pureRedex?| CONST-DECL "bool" IL NIL) (|atom?| CONST-DECL "bool" IL NIL)
    (|to_topstate_dangling| APPLICATION-JUDGEMENT "(noDanglingRefs?)"
     |rreduction| NIL)
    (|letReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pure?| DEF-DECL "bool" IL NIL)
    (|Definition| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|Defs| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|pureLetRedex?| CONST-DECL "bool" IL NIL)
    (|applyReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|applyRedex?| CONST-DECL "bool" IL NIL)
    (|ifReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|pureIftRedex?| CONST-DECL "bool" IL NIL)
    (|updateRedex?| CONST-DECL "bool" IL NIL)
    (|updateReduce| CONST-DECL "(noDanglingRefs?)" |rreduction| NIL)
    (|lookupReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|lookupRedex?| CONST-DECL "bool" IL NIL)
    (|newintReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|newintRedex?| CONST-DECL "bool" IL NIL)
    (|newrefReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|newrefRedex?| CONST-DECL "bool" IL NIL)
    (|popReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|popRedex?| CONST-DECL "bool" IL NIL)
    (|pureReleaseRedex?| CONST-DECL "bool" IL NIL)
    (|releaseReduce_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|make_redex_ndr| JUDGEMENT-TCC NIL |rreduction| NIL)
    (|IContext| TYPE-DECL NIL IL NIL)
    (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)
    (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL)
    (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|cpure?| DEF-DECL "bool" IL NIL)
    (= CONST-DECL "[T, T -> boolean]" |equalities| NIL)
    (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)
    (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL)
    (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL)
    (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL)
    (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL)
    (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL)
    (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL)
    (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL)
    (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL)
    (>= CONST-DECL "bool" |reals| NIL)
    (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL)
    (|set| TYPE-EQ-DECL NIL |sets| NIL)
    (|is_finite| CONST-DECL "bool" |finite_sets| NIL)
    (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL)
    (|markc| DEF-DECL "IContext" |preprocess| NIL)
    (|emptyset| CONST-DECL "set" |sets| NIL)
    (|below| TYPE-EQ-DECL NIL |nat_types| NIL)
    (|IExpression| TYPE-DECL NIL |IExpression_adt| NIL)
    (|value?| CONST-DECL "bool" IL NIL) (|Stack| TYPE-EQ-DECL NIL IL NIL)
    (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL)
    (|every| CONST-DECL "bool" |finseq_theorems| NIL)
    (|domainValue?| CONST-DECL "bool" IL NIL)
    (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL)
    (|refs| DEF-DECL "bool" IL NIL) (< CONST-DECL "bool" |reals| NIL)
    (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL)
    (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL)
    (<= CONST-DECL "bool" |reals| NIL) (|contextPure?| DEF-DECL "bool" IL NIL)
    (|mark| DEF-DECL "IExpression" |preprocess| NIL)
    (|Store| TYPE-EQ-DECL NIL |reduction| NIL)
    (|refcount| CONST-DECL "nat" |rreduction| NIL)
    (|rstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|noDanglingRefs?| CONST-DECL "bool" |rreduction| NIL)
    (|hole?| ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL)
    (|hole| ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL)
    (|rtopstate| TYPE-EQ-DECL NIL |rreduction| NIL)
    (|to_topstate| CONST-DECL "rtopstate" |rreduction| NIL)
    (NOT CONST-DECL "[bool -> bool]" |booleans| NIL)
    (|goodrstate| TYPE-EQ-DECL NIL |rreduction| NIL))
   NIL
   (|reduce_ndr| SUBTYPE "rreduction.reduce(rreduction.D)(rreduction.grS)"
    "(rreduction.noDanglingRefs?)"))))

