(itranslation
 (newvar_TCC1 0
  (newvar_TCC1-1 nil 3706971834 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (newvar subtype "i - 1" "nat")))
 (translate_statement_TCC1 0
  (translate_statement_TCC1-1 nil 3706971834
   ("" (use pure_contextPure) (("" (grind) nil nil)) nil)
   ((pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_contextPure formula-decl nil IL nil))
   nil (translate_statement subtype "A" "(IL.contextPure?)")))
 (translate_statement_TCC2 0
  (translate_statement_TCC2-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite purePopDepth)
      (("" (assert)
        (("" (split) (("1" (assert) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | IL.popDepth(A) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(A)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))
 (translate_statement_TCC3 0
  (translate_statement_TCC3-1 nil 3706971834
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "tA" "(typeinfo_adt.lett?)")))
 (translate_statement_TCC4 0
  (translate_statement_TCC4-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (translate_statement subtype "B" "(IL.pure?)")))
 (translate_statement_TCC5 0
  (translate_statement_TCC5-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(B)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC6 0
  (translate_statement_TCC6-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_statement subtype "typeinfo_adt.lrhs(tA)"
    "{tA | typed_reduction.is_well_typed(B, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC7 0
  (translate_statement_TCC7-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (translate_statement termination
    "translate_statement(B, ireduction.ivar(0, FALSE), stypes, dom_types, tD, typeinfo_adt.lrhs(tA), shift(translate_vars))"
    "nil")))
 (translate_statement_TCC8 0
  (translate_statement_TCC8-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (translate_statement subtype "C" "(IL.pure?)")))
 (translate_statement_TCC9 0
  (translate_statement_TCC9-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_statement subtype
    "more_finseq[nat].add(typeinfo_adt.lettype(tA), stypes)"
    "{stypes | FORALL i: preprocess.cvars(C)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC10 0
  (translate_statement_TCC10-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand is_well_typed -)
        (("" (flatten)
          (("" (rewrite purePopDepth)
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn_zero formula-decl nil typed_reduction nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil))
   nil
   (translate_statement subtype "typeinfo_adt.lbody(tA)"
    "{tA_1 | typed_reduction.is_well_typed(C, tA_1, more_finseq[nat].add(typeinfo_adt.lettype(tA), stypes), dom_types, tD)}")))
 (translate_statement_TCC11 0
  (translate_statement_TCC11-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (translate_statement termination
    "translate_statement(C, ireduction.ivar(ireduction.vindex(rv) + 1, FALSE), more_finseq[nat].add(typeinfo_adt.lettype(tA), stypes), dom_types, tD, typeinfo_adt.lbody(tA), newvar(translate_vars))"
    "nil")))
 (translate_statement_TCC12 0
  (translate_statement_TCC12-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "B" "(IL.pure?)")))
 (translate_statement_TCC13 0
  (translate_statement_TCC13-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(B)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC14 0
  (translate_statement_TCC14-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "tA" "(typeinfo_adt.iftt?)")))
 (translate_statement_TCC15 0
  (translate_statement_TCC15-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_statement subtype "typeinfo_adt.tthen(tA)"
    "{tA | typed_reduction.is_well_typed(B, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC16 0
  (translate_statement_TCC16-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_statement termination
    "translate_statement(B, rv, stypes, dom_types, tD, typeinfo_adt.tthen(tA), translate_vars)"
    "nil")))
 (translate_statement_TCC17 0
  (translate_statement_TCC17-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "C" "(IL.pure?)")))
 (translate_statement_TCC18 0
  (translate_statement_TCC18-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(C)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC19 0
  (translate_statement_TCC19-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_statement subtype "typeinfo_adt.telse(tA)"
    "{tA | typed_reduction.is_well_typed(C, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC20 0
  (translate_statement_TCC20-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_statement termination
    "translate_statement(C, rv, stypes, dom_types, tD, typeinfo_adt.telse(tA), translate_vars)"
    "nil")))
 (translate_statement_TCC21 0
  (translate_statement_TCC21-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_statement subtype "B" "(IL.pure?)")))
 (translate_statement_TCC22 0
  (translate_statement_TCC22-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(B)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC23 0
  (translate_statement_TCC23-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil
   (translate_statement subtype "tA"
    "{tA | typed_reduction.is_well_typed(B, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC24 0
  (translate_statement_TCC24-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_statement termination
    "translate_statement(B, rv, stypes, dom_types, tD, tA, translate_vars)"
    "nil")))
 (translate_statement_TCC25 0
  (translate_statement_TCC25-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (emptyset const-decl "set" sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil
   (translate_statement cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (translate_length_TCC1 0
  (translate_length_TCC1-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil (translate_length subtype "B" "(IL.pure?)")))
 (translate_length_TCC2 0
  (translate_length_TCC2-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(B)" "nil")))
 (translate_length_TCC3 0
  (translate_length_TCC3-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil (translate_length subtype "C" "(IL.pure?)")))
 (translate_length_TCC4 0
  (translate_length_TCC4-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(C)" "nil")))
 (translate_length_TCC5 0
  (translate_length_TCC5-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_length subtype "B" "(IL.pure?)")))
 (translate_length_TCC6 0
  (translate_length_TCC6-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(B)" "nil")))
 (translate_length_TCC7 0
  (translate_length_TCC7-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_length subtype "C" "(IL.pure?)")))
 (translate_length_TCC8 0
  (translate_length_TCC8-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(C)" "nil")))
 (translate_length_TCC9 0
  (translate_length_TCC9-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_length subtype "B" "(IL.pure?)")))
 (translate_length_TCC10 0
  (translate_length_TCC10-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(B)" "nil")))
 (translate_length_TCC11 0
  (translate_length_TCC11-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil
   (translate_length cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (translate_length_def 0
  (translate_length_def-1 nil 3706987949
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_statement +)
        (("6" (split -4)
          (("1" (split -5)
            (("1" (inst? -1)
              (("1" (inst? -2) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_statement +)
        (("7" (split -6)
          (("1" (split -7)
            (("1" (inst? -1)
              (("1" (inst? -2) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (split -6)
          (("1" (inst? -1) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite purePopDepth) (("15" (grind) nil nil)) nil))
        nil))
      nil)
     ("16" (delete 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (FALSE const-decl "bool" booleans nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (newvar const-decl "nat" itranslation nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (shift const-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_statement def-decl "istat" itranslation nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (istat type-decl nil ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_stack_size_at_TCC1 0
  (translate_stack_size_at_TCC1-1 nil 3706985635
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_stack_size_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_stack_size_at_TCC2 0
  (translate_stack_size_at_TCC2-1 nil 3706985635
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_stack_size_at subtype "pc - 2 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_stack_size_at_TCC3 0
  (translate_stack_size_at_TCC3-1 nil 3706985635
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_stack_size_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_stack_size_at_TCC4 0
  (translate_stack_size_at_TCC4-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_stack_size_at subtype "pc - 1 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_stack_size_at_TCC5 0
  (translate_stack_size_at_TCC5-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_stack_size_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_stack_size_at_zero_TCC1 0
  (translate_stack_size_at_zero_TCC1-1 nil 3706985970
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_stack_size_at_zero subtype "0"
    "upto(translate_length(A))")))
 (translate_stack_size_at_zero 0
  (translate_stack_size_at_zero-1 nil 3706986023
   ("" (induct-and-simplify A) nil nil)
   ((translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (translate_stack_size_at_end_TCC1 0
  (translate_stack_size_at_end_TCC1-1 nil 3706985970
   ("" (subtype-tcc) nil nil) nil nil
   (translate_stack_size_at_end subtype "translate_length(A)"
    "upto(translate_length(A))")))
 (translate_stack_size_at_end 0
  (translate_stack_size_at_end-1 nil 3706986034
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (translate_stack_size_at_def_TCC1 0
  (translate_stack_size_at_def_TCC1-1 nil 3706988256
   ("" (subtype-tcc) nil nil)
   ((translate_length_def formula-decl nil itranslation nil)) nil
   (translate_stack_size_at_def subtype "pc"
    "upto(ireduction.slength(translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars)))")))
 (translate_stack_size_at_def 0
  (translate_stack_size_at_def-1 nil 3706988256
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (split -5)
        (("1" (split -6)
          (("1" (expand translate_statement +)
            (("1" (inst? -1)
              (("1" (inst? -2)
                (("1" (expand translate_stack_size_at +)
                  (("1" (case "pc = 0")
                    (("1" (grind) nil nil)
                     ("2"
                      (case "pc <= 1 + translate_length(letexpr1_var)")
                      (("1" (inst? -2)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2"
                        (case "pc = 2 + translate_length(letexpr1_var)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_statement +)
        (("7" (split -7)
          (("1" (split -8)
            (("1" (expand translate_stack_size_at +)
              (("1" (lift-if)
                (("1" (split +)
                  (("1" (grind) nil nil)
                   ("2" (flatten)
                    (("2" (split +)
                      (("1" (flatten)
                        (("1" (inst? -3) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (inst? -2) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (expand translate_stack_size_at +)
          (("14" (lift-if)
            (("14" (split +)
              (("1" (grind) nil nil)
               ("2" (case-replace "pc = 1")
                (("1" (grind) nil nil)
                 ("2" (flatten)
                  (("2" (split -7)
                    (("1" (inst? -1)
                      (("1" (inst? -1)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2) (("15" (grind) nil nil)) nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite purePopDepth) (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (pc skolem-const-decl
     "upto(translate_length(release(release1_var, release2_var)))"
     itranslation nil)
    (release2_var skolem-const-decl "IExpression" itranslation nil)
    (release1_var skolem-const-decl "(variable?)" itranslation nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (ift3_var skolem-const-decl "IExpression" itranslation nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (ift1_var skolem-const-decl "(variable?)" itranslation nil)
    (ift2_var skolem-const-decl "IExpression" itranslation nil)
    (stypes skolem-const-decl "{stypes |
   FORALL i:
     cvars(ift(ift1_var, ift2_var, ift3_var))(i) IMPLIES i < stypes`length}"
     itranslation nil)
    (dom_types skolem-const-decl "[nat -> nat]" itranslation nil)
    (tD skolem-const-decl "finseq[tdef]" itranslation nil)
    (tA skolem-const-decl "{tA |
   is_well_typed(ift(ift1_var, ift2_var, ift3_var), tA, stypes, dom_types,
                 tD)}" itranslation nil)
    (rv skolem-const-decl "(ivar?)" itranslation nil)
    (translate_vars skolem-const-decl "[nat -> nat]" itranslation nil)
    (pc skolem-const-decl
     "upto(translate_length(ift(ift1_var, ift2_var, ift3_var)))"
     itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (newvar const-decl "nat" itranslation nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (FALSE const-decl "bool" booleans nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_length_def formula-decl nil itranslation nil)
    (pc skolem-const-decl
     "upto(translate_length(letexpr(letexpr1_var, letexpr2_var)))"
     itranslation nil)
    (letexpr2_var skolem-const-decl "IExpression" itranslation nil)
    (letexpr1_var skolem-const-decl "IExpression" itranslation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (shift const-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (slength def-decl "posnat" ireduction nil)
    (translate_statement def-decl "istat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_is_fun_call_at_TCC1 0
  (translate_is_fun_call_at_TCC1-1 nil 3706987300
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_is_fun_call_at_TCC2 0
  (translate_is_fun_call_at_TCC2-1 nil 3706987300
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 2 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_is_fun_call_at_TCC3 0
  (translate_is_fun_call_at_TCC3-1 nil 3706987300
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_is_fun_call_at_TCC4 0
  (translate_is_fun_call_at_TCC4-1 nil 3706987300 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_is_fun_call_at_TCC5 0
  (translate_is_fun_call_at_TCC5-1 nil 3706987300 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_is_fun_call_at_end 0
  (translate_is_fun_call_at_end-1 nil 3706987301
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (translate_is_fun_call_at_def 0
  (translate_is_fun_call_at_def-1 nil 3706989046
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_statement +)
        (("6" (expand translate_is_fun_call_at +)
          (("6" (lift-if)
            (("6" (split +)
              (("1" (grind) nil nil)
               ("2" (flatten)
                (("2" (split +)
                  (("1" (split -6)
                    (("1" (flatten)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (flatten) (("1" (grind) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (split -8)
                              (("1"
                                (inst?)
                                (("1"
                                  (inst?)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (flatten) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_is_fun_call_at +)
        (("7" (lift-if)
          (("7" (split +)
            (("1" (flatten) (("1" (grind) nil nil)) nil)
             ("2" (flatten)
              (("2" (expand translate_statement +)
                (("2" (split +)
                  (("1" (flatten)
                    (("1" (split -9)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split -9)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (expand translate_is_fun_call_at +)
          (("14" (case "pc = 0")
            (("1" (grind) nil nil)
             ("2" (split -8)
              (("1" (inst? -1)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2) (("15" (grind) nil nil)) nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite purePopDepth) (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (release1_var skolem-const-decl "(variable?)" itranslation nil)
    (release2_var skolem-const-decl "IExpression" itranslation nil)
    (pc skolem-const-decl
     "upto(translate_length(release(release1_var, release2_var)))"
     itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (ift1_var skolem-const-decl "(variable?)" itranslation nil)
    (ift2_var skolem-const-decl "IExpression" itranslation nil)
    (ift3_var skolem-const-decl "IExpression" itranslation nil)
    (pc skolem-const-decl
     "upto(translate_length(ift(ift1_var, ift2_var, ift3_var)))"
     itranslation nil)
    (add const-decl "(nonempty?)" sets nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_length_def formula-decl nil itranslation nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (letexpr1_var skolem-const-decl "IExpression" itranslation nil)
    (letexpr2_var skolem-const-decl "IExpression" itranslation nil)
    (pc skolem-const-decl
     "upto(translate_length(letexpr(letexpr1_var, letexpr2_var)))"
     itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (shift const-decl "nat" itranslation nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (newvar const-decl "nat" itranslation nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (seq type-eq-decl nil more_finseq nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (extract_stat def-decl
     "{s1, j | j < slength(s1) AND executable_stat?(s1, j)}" ireduction
     nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (slength def-decl "posnat" ireduction nil)
    (translate_statement def-decl "istat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (reconstruct_state_TCC1 0
  (reconstruct_state_TCC1-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   nil nil
   (reconstruct_state subtype "pc" "upto(translate_length(A))")))
 (reconstruct_state_TCC2 0
  (reconstruct_state_TCC2-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1" "below(translate_length(B))")))
 (reconstruct_state_TCC3 0
  (reconstruct_state_TCC3-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "ireduction.ivar(0, FALSE)"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(B, pc - 1) < S`length}")))
 (reconstruct_state_TCC4 0
  (reconstruct_state_TCC4-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (reconstruct_state subtype "0" "below(S`length)")))
 (reconstruct_state_TCC5 0
  (reconstruct_state_TCC5-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1 - lb1 - lb2"
    "below(translate_length(C))")))
 (reconstruct_state_TCC6 0
  (reconstruct_state_TCC6-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype
    "ireduction.ivar(ireduction.vindex(rv) + 1, FALSE)"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(C, pc - 1 - lb1 - lb2) < S`length}")))
 (reconstruct_state_TCC7 0
  (reconstruct_state_TCC7-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (reconstruct_state subtype "ireduction.vindex(rv) + 1"
    "below(S`length)")))
 (reconstruct_state_TCC8 0
  (reconstruct_state_TCC8-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1" "below(translate_length(B))")))
 (reconstruct_state_TCC9 0
  (reconstruct_state_TCC9-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(B, pc - 1) < S`length}")))
 (reconstruct_state_TCC10 0
  (reconstruct_state_TCC10-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1 - lb1"
    "below(translate_length(C))")))
 (reconstruct_state_TCC11 0
  (reconstruct_state_TCC11-1 nil 3706985635
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand translate_stack_size_at -)
        (("" (case-replace "pc = 1 + lb1")
          (("1" (assert) (("1" (postpone) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at def-decl "nat" itranslation nil))
   nil
   (reconstruct_state subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(C, pc - 1 - lb1) < S`length}")))
 (reconstruct_state_TCC12 0
  (reconstruct_state_TCC12-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reconstruct_state subtype "ireduction.vindex(rv)"
    "below(S`length)")))
 (reconstruct_state_TCC13 0
  (reconstruct_state_TCC13-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1" "below(translate_length(B))")))
 (reconstruct_state_TCC14 0
  (reconstruct_state_TCC14-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(B, pc - 1) < S`length}")))
 (call_reconstruct_state_TCC1 0
  (call_reconstruct_state_TCC1-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (call_reconstruct_state subtype "pc - 1"
    "{pc: upto(translate_length(B)) | translate_is_fun_call_at(B, pc, f)}")))
 (call_reconstruct_state_TCC2 0
  (call_reconstruct_state_TCC2-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (call_reconstruct_state subtype "pc - 2 - lb1"
    "{pc: upto(translate_length(C)) | translate_is_fun_call_at(C, pc, f)}")))
 (call_reconstruct_state_TCC3 0
  (call_reconstruct_state_TCC3-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (call_reconstruct_state subtype "pc - 1"
    "{pc: upto(translate_length(B)) | translate_is_fun_call_at(B, pc, f)}")))
 (call_reconstruct_state_TCC4 0
  (call_reconstruct_state_TCC4-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (call_reconstruct_state subtype "pc - 1 - lb1"
    "{pc: upto(translate_length(C)) | translate_is_fun_call_at(C, pc, f)}")))
 (call_reconstruct_state_TCC5 0
  (call_reconstruct_state_TCC5-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (call_reconstruct_state subtype "pc - 1"
    "{pc: upto(translate_length(B)) | translate_is_fun_call_at(B, pc, f)}")))
 (call_reconstruct_state_TCC6 0
  (call_reconstruct_state_TCC6-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (call_reconstruct_state cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression"))))

