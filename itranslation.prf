(itranslation
 (newvar_TCC1 0
  (newvar_TCC1-1 nil 3706971834 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (newvar subtype "i - 1" "nat")))
 (translate_statement_TCC1 0
  (translate_statement_TCC1-1 nil 3706971834
   ("" (use pure_contextPure) (("" (grind) nil nil)) nil)
   ((pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure_contextPure formula-decl nil IL nil))
   nil (translate_statement subtype "A" "(IL.contextPure?)")))
 (translate_statement_TCC2 0
  (translate_statement_TCC10-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand is_well_typed -)
        (("" (flatten)
          (("" (rewrite purePopDepth)
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn_zero formula-decl nil typed_reduction nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil))
   nil
   (translate_statement subtype "typeinfo_adt.lbody(tA)"
    "{tA_1 | typed_reduction.is_well_typed(C, tA_1, more_finseq[nat].add(typeinfo_adt.lettype(tA), stypes), dom_types, tD)}")))
 (translate_statement_TCC3 0
  (translate_statement_TCC12-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "B" "(IL.pure?)")))
 (translate_statement_TCC4 0
  (translate_statement_TCC18-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil) nil
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(C)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC5 0
  (translate_statement_TCC14-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "tA" "(typeinfo_adt.iftt?)")))
 (translate_statement_TCC6 0
  (translate_statement_TCC21-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil)
   nil (translate_statement subtype "B" "(IL.pure?)")))
 (translate_statement_TCC7 0
  (translate_statement_TCC11-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (translate_statement termination
    "translate_statement(C, ireduction.ivar(ireduction.vindex(rv) + 1, FALSE), more_finseq[nat].add(typeinfo_adt.lettype(tA), stypes), dom_types, tD, typeinfo_adt.lbody(tA), newvar(translate_vars))"
    "nil")))
 (translate_statement_TCC8 0
  (translate_statement_TCC17-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand is_well_typed -)
        (("" (rewrite purePopDepth)
          (("1" (assert) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (pure? def-decl "bool" IL nil) nil nil
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (is_well_typed def-decl "bool" typed_reduction nil))
   nil (translate_statement subtype "C" "(IL.pure?)")))
 (translate_statement_TCC9 0
  (translate_statement_TCC23-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil) nil
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_statement subtype "tA"
    "{tA | typed_reduction.is_well_typed(B, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC10 0
  (translate_statement_TCC19-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand is_well_typed -4)
        (("" (flatten)
          (("" (assert)
            (("" (case-replace "popDepth(letrhs(A)) = 0")
              (("1" (assert) (("1" (grind) nil nil)) nil)
               ("2" (use purePopDepth) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil) nil nil
    (pure? def-decl "bool" IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil))
   nil
   (translate_statement subtype "typeinfo_adt.telse(tA)"
    "{tA | typed_reduction.is_well_typed(C, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC11 0
  (translate_statement_TCC16-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_statement termination
    "translate_statement(B, rv, stypes, dom_types, tD, typeinfo_adt.tthen(tA), translate_vars)"
    "nil")))
 (translate_statement_TCC12 0
  (translate_statement_TCC2-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite purePopDepth) (("" (grind) nil nil)) nil)) nil)
   ((purePopDepth formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | IL.popDepth(A) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(A)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))
 (translate_statement_TCC13 0
  (translate_statement_TCC4-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) nil)
   nil (translate_statement subtype "B" "(IL.pure?)")))
 (translate_statement_TCC14 0
  (translate_statement_TCC22-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite purePopDepth) (("" (grind) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil) nil
    (pure? def-decl "bool" IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(B)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC15 0
  (translate_statement_TCC6-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil
   (translate_statement subtype "typeinfo_adt.lrhs(tA)"
    "{tA | typed_reduction.is_well_typed(B, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC16 0
  (translate_statement_TCC20-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_statement termination
    "translate_statement(C, rv, stypes, dom_types, tD, typeinfo_adt.telse(tA), translate_vars)"
    "nil")))
 (translate_statement_TCC17 0
  (translate_statement_TCC3-1 nil 3706971834
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (pure? def-decl "bool" IL nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil (translate_statement subtype "tA" "(typeinfo_adt.lett?)")))
 (translate_statement_TCC18 0
  (translate_statement_TCC9-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil) (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_statement subtype
    "more_finseq[nat].add(typeinfo_adt.lettype(tA), stypes)"
    "{stypes | FORALL i: preprocess.cvars(C)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC19 0
  (translate_statement_TCC5-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(B)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC20 0
  (translate_statement_TCC24-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_statement termination
    "translate_statement(B, rv, stypes, dom_types, tD, tA, translate_vars)"
    "nil")))
 (translate_statement_TCC21 0
  (translate_statement_TCC13-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite cvars_pure)
      (("" (rewrite cvars_pure)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((cvars_pure formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_statement subtype "stypes"
    "{stypes | FORALL i: preprocess.cvars(B)(i) IMPLIES i < stypes`length}")))
 (translate_statement_TCC22 0
  (translate_statement_TCC8-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (rewrite purePopDepth) (("" (grind) nil nil)) nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (pure? def-decl "bool" IL nil))
   nil (translate_statement subtype "C" "(IL.pure?)")))
 (translate_statement_TCC23 0
  (translate_statement_TCC15-1 nil 3706971834
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (rewrite cvars_pure)
        (("" (rewrite cvars_pure)
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil
   (translate_statement subtype "typeinfo_adt.tthen(tA)"
    "{tA | typed_reduction.is_well_typed(B, tA, stypes, dom_types, tD)}")))
 (translate_statement_TCC24 0
  (translate_statement_TCC7-1 nil 3706971834
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil))
   nil
   (translate_statement termination
    "translate_statement(B, ireduction.ivar(0, FALSE), stypes, dom_types, tD, typeinfo_adt.lrhs(tA), shift(translate_vars))"
    "nil")))
 (translate_statement_TCC25 0
  (translate_statement_TCC25-1 nil 3706971834 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (emptyset const-decl "set" sets nil) nil
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/"))
   nil
   (translate_statement cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (translate_ivars_TCC1 0
  (translate_ivars_TCC1-1 nil 3707051227 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil))
   nil (translate_ivars subtype "B" "(IL.pure?)")))
 (translate_ivars_TCC2 0
  (translate_ivars_TCC10-1 nil 3707051227
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_ivars termination
    "translate_ivars(B, rv, translate_vars)" "nil")))
 (translate_ivars_TCC3 0
  (translate_ivars_TCC3-1 nil 3707051227 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (translate_ivars subtype "C" "(IL.pure?)")))
 (translate_ivars_TCC4 0
  (translate_ivars_TCC2-1 nil 3707051227 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_ivars termination
    "translate_ivars(B, ireduction.ivar(0, FALSE), shift(translate_vars))"
    "nil")))
 (translate_ivars_TCC5 0
  (translate_ivars_TCC5-1 nil 3707051227 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (translate_ivars subtype "B" "(IL.pure?)")))
 (translate_ivars_TCC6 0
  (translate_ivars_TCC4-1 nil 3707051227 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_ivars termination
    "translate_ivars(C, ireduction.ivar(ireduction.vindex(rv) + 1, FALSE), newvar(translate_vars))"
    "nil")))
 (translate_ivars_TCC7 0
  (translate_ivars_TCC7-1 nil 3707051227 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (translate_ivars subtype "C" "(IL.pure?)")))
 (translate_ivars_TCC8 0
  (translate_ivars_TCC6-1 nil 3707051227 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_ivars termination
    "translate_ivars(B, rv, translate_vars)" "nil")))
 (translate_ivars_TCC9 0
  (translate_ivars_TCC9-1 nil 3707051227 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (translate_ivars subtype "B" "(IL.pure?)")))
 (translate_ivars_TCC10 0
  (translate_ivars_TCC8-1 nil 3707051227 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (translate_ivars termination
    "translate_ivars(C, rv, translate_vars)" "nil")))
 (translate_ivars_TCC11 0
  (translate_ivars_TCC11-1 nil 3707051227 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil))
   nil
   (translate_ivars cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (translate_ivars_def 0
  (translate_ivars_def-1 nil 3707051228
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (skeep* :preds? t)
      (("5" (expand translate_statement +)
        (("5" (expand vars +)
          (("5" (expand translate_ivars +)
            (("5" (expand vars +)
              (("5" (rewrite some_map)
                (("5" (expand o)
                  (("5" (assert)
                    (("5" (case "i = vindex(rv)")
                      (("1" (grind) nil nil)
                       ("2" (assert)
                        (("2"
                          (case-replace
                           "(LAMBDA (x_1: (variable?)): translate_vars(index(x_1)) = i) = (LAMBDA x: i = translate_vars(index(x)))")
                          (("2" (decompose-equality)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_statement +)
        (("6" (expand translate_ivars +)
          (("6" (expand vars +)
            (("6" (expand vars +)
              (("6" (expand vars + 2)
                (("6" (expand vars + 2)
                  (("6" (split -5)
                    (("1" (split -6)
                      (("1" (inst? -1)
                        (("1" (inst? -2)
                          (("1" (replace -1)
                            (("1" (replace -2) (("1" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_statement +)
        (("7" (expand translate_ivars +)
          (("7" (expand vars +)
            (("7" (split -7)
              (("1" (split -8)
                (("1" (inst? -1)
                  (("1" (inst? -2)
                    (("1" (replace -1)
                      (("1" (replace -2) (("1" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (expand translate_ivars +)
          (("14" (expand vars +)
            (("14" (expand vars + 1)
              (("14" (split -7)
                (("1" (inst? -1)
                  (("1" (replace -1) (("1" (propax) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite purePopDepth) (("15" (grind) nil nil)) nil))
        nil))
      nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil) nil
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (shift const-decl "nat" itranslation nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (newvar const-decl "nat" itranslation nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (FALSE const-decl "bool" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "T3" function_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (some_map formula-decl nil finseq_theorems nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (vars const-decl "bool" ireduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_ivars def-decl "bool" itranslation nil)
    (translate_statement def-decl "istat" itranslation nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_ivars_vars 0
  (translate_ivars_vars-1 nil 3707051744
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil)
     ("5" (skeep* :preds? t)
      (("5" (expand translate_ivars +)
        (("5" (expand vars +)
          (("5" (expand in_varlist +)
            (("5" (iff)
              (("5" (split +)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (propax) nil nil)
                     ("2" (rewrite some_nth)
                      (("2" (skeep)
                        (("2" (inst?)
                          (("2" (rewrite some_nth)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (propax) nil nil)
                     ("2" (skeep)
                      (("2" (rewrite some_nth)
                        (("2" (rewrite some_nth)
                          (("2" (skeep)
                            (("2" (inst?) (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_ivars +)
        (("6" (expand vars +)
          (("6" (expand union)
            (("6" (expand drop)
              (("6" (expand member)
                (("6" (split -3)
                  (("1" (split -4)
                    (("1" (inst? -1)
                      (("1" (inst? -2)
                        (("1" (replace -1)
                          (("1" (replace -2)
                            (("1" (assert)
                              (("1"
                                (iff)
                                (("1"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (expand shift)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil)
                                       ("3"
                                        (skeep)
                                        (("3"
                                          (expand newvar)
                                          (("3"
                                            (lift-if -2)
                                            (("3"
                                              (split -2)
                                              (("1" (grind) nil nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (inst 3 "j-1")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (skeep)
                                        (("2"
                                          (split)
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_ivars +)
        (("7" (expand vars +)
          (("7" (expand add)
            (("7" (expand union)
              (("7" (expand member)
                (("7" (split -5)
                  (("1" (split -6)
                    (("1" (inst? -1)
                      (("1" (inst? -2)
                        (("1" (replace -1)
                          (("1" (replace -2)
                            (("1" (assert)
                              (("1"
                                (iff +)
                                (("1"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split)
                                      (("1" (grind) nil nil)
                                       ("2" (propax) nil nil)
                                       ("3"
                                        (skeep)
                                        (("3"
                                          (inst?)
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("4" (propax) nil nil)
                                       ("5"
                                        (skeep)
                                        (("5"
                                          (inst?)
                                          (("5" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (skeep)
                                        (("2"
                                          (split)
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil)
                                           ("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand translate_ivars +)
        (("8" (case "i = vindex(rv)")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (iff)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (inst?) (("1" (grind) nil nil)) nil)
                     ("2" (inst?) (("2" (grind) nil nil)) nil)
                     ("3" (inst?) (("3" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skeep* :preds? t)
      (("9" (expand translate_ivars +)
        (("9" (case "i = vindex(rv)")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (iff)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_ivars +)
        (("14" (split -5)
          (("1" (inst? -1)
            (("1" (rewrite -1)
              (("1" (expand vars + 2)
                (("1" (expand add)
                  (("1" (iff)
                    (("1" (split +)
                      (("1" (flatten)
                        (("1" (split)
                          (("1" (grind) nil nil) ("2" (propax) nil nil)
                           ("3" (skeep)
                            (("3" (inst?) (("3" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (skeep)
                            (("2" (split)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (newvar const-decl "nat" itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (int_plus_int_is_int application-judgement "int" integers nil)
    (shift const-decl "nat" itranslation nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    nil (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (emptyset const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (translate_ivars def-decl "bool" itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_definitions_TCC1 0
  (translate_definitions_TCC1-1 nil 3707050345
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (translate_definitions subtype "i" "below[tD`length]")))
 (translate_definitions_TCC2 0
  (translate_definitions_TCC2-1 nil 3707050345
   ("" (skeep* :preds? t)
    (("" (typepred "D`seq(i)`body")
      (("" (rewrite cvars_pure)
        (("" (inst -2 "i_1")
          (("" (rewrite -2) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil
   (translate_definitions subtype "tD`seq(i)`args_type"
    "{stypes | FORALL (i_1: nat): preprocess.cvars(D`seq(i)`body)(i_1) IMPLIES i_1 < stypes`length}")))
 (translate_definitions_TCC3 0
  (translate_definitions_TCC3-1 nil 3707050345
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_definitions subtype "tD`seq(i)`body_type"
    "{tA | typed_reduction.is_well_typed(D`seq(i)`body, tA, tD`seq(i)`args_type, (LAMBDA j: 0), tD)}")))
 (translate_definitions_TCC4 0
  (translate_definitions_TCC4-1 nil 3707050345
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (rewrite translate_ivars_vars)
        (("" (skeep)
          (("" (typepred "D`seq(i)`body") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_ivars_def formula-decl nil itranslation nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (translate_ivars_vars formula-decl nil itranslation nil))
   nil
   (translate_definitions subtype
    "translate_statement(D`seq(i)`body, ireduction.ivar(D`seq(i)`arity, FALSE), tD`seq(i)`args_type, (LAMBDA j: 0), tD, tD`seq(i)`body_type, (LAMBDA j: j))"
    "{s | FORALL (i_1: nat): ireduction.vars(ireduction.s)(i_1) IMPLIES i_1 < 1 + D`seq(i)`arity}")))
 (translate_length_TCC1 0
  (translate_length_TCC1-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil (translate_length subtype "B" "(IL.pure?)")))
 (translate_length_TCC2 0
  (translate_length_TCC10-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(B)" "nil")))
 (translate_length_TCC3 0
  (translate_length_TCC3-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil (translate_length subtype "C" "(IL.pure?)")))
 (translate_length_TCC4 0
  (translate_length_TCC2-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(B)" "nil")))
 (translate_length_TCC5 0
  (translate_length_TCC5-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_length subtype "B" "(IL.pure?)")))
 (translate_length_TCC6 0
  (translate_length_TCC4-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(C)" "nil")))
 (translate_length_TCC7 0
  (translate_length_TCC7-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_length subtype "C" "(IL.pure?)")))
 (translate_length_TCC8 0
  (translate_length_TCC6-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(B)" "nil")))
 (translate_length_TCC9 0
  (translate_length_TCC9-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil))
   nil (translate_length subtype "B" "(IL.pure?)")))
 (translate_length_TCC10 0
  (translate_length_TCC8-1 nil 3706985635
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (translate_length termination "translate_length(C)" "nil")))
 (translate_length_TCC11 0
  (translate_length_TCC11-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil))
   nil
   (translate_length cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (translate_length_def 0
  (translate_length_def-1 nil 3706987949
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_statement +)
        (("6" (split -4)
          (("1" (split -5)
            (("1" (inst? -1)
              (("1" (inst? -2) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_statement +)
        (("7" (split -6)
          (("1" (split -7)
            (("1" (inst? -1)
              (("1" (inst? -2) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (split -6)
          (("1" (inst? -1) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite purePopDepth) (("15" (grind) nil nil)) nil))
        nil))
      nil)
     ("16" (delete 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (FALSE const-decl "bool" booleans nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (newvar const-decl "nat" itranslation nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (shift const-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_statement def-decl "istat" itranslation nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (istat type-decl nil ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_stack_size_at_TCC1 0
  (translate_stack_size_at_TCC1-1 nil 3706985635
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_stack_size_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_stack_size_at_TCC2 0
  (translate_stack_size_at_TCC2-1 nil 3706985635
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_stack_size_at subtype "pc - 2 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_stack_size_at_TCC3 0
  (translate_stack_size_at_TCC3-1 nil 3706985635
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_stack_size_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_stack_size_at_TCC4 0
  (translate_stack_size_at_TCC4-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_stack_size_at subtype "pc - 1 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_stack_size_at_TCC5 0
  (translate_stack_size_at_TCC5-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_stack_size_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_stack_size_at_zero_TCC1 0
  (translate_stack_size_at_zero_TCC1-1 nil 3706985970
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_stack_size_at_zero subtype "0"
    "upto(translate_length(A))")))
 (translate_stack_size_at_zero 0
  (translate_stack_size_at_zero-1 nil 3706986023
   ("" (induct-and-simplify A) nil nil)
   ((translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (translate_stack_size_at_end_TCC1 0
  (translate_stack_size_at_end_TCC1-1 nil 3706985970
   ("" (subtype-tcc) nil nil) nil nil
   (translate_stack_size_at_end subtype "translate_length(A)"
    "upto(translate_length(A))")))
 (translate_stack_size_at_end 0
  (translate_stack_size_at_end-1 nil 3706986034
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (translate_stack_size_at_def_TCC1 0
  (translate_stack_size_at_def_TCC1-1 nil 3706988256
   ("" (subtype-tcc) nil nil)
   ((translate_length_def formula-decl nil itranslation nil)) nil
   (translate_stack_size_at_def subtype "pc"
    "upto(ireduction.slength(translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars)))")))
 (translate_stack_size_at_def 0
  (translate_stack_size_at_def-1 nil 3706988256
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (split -5)
        (("1" (split -6)
          (("1" (expand translate_statement +)
            (("1" (inst? -1)
              (("1" (inst? -2)
                (("1" (expand translate_stack_size_at +)
                  (("1" (case "pc = 0")
                    (("1" (grind) nil nil)
                     ("2"
                      (case "pc <= 1 + translate_length(letexpr1_var)")
                      (("1" (inst? -2)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2"
                        (case "pc = 2 + translate_length(letexpr1_var)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_statement +)
        (("7" (split -7)
          (("1" (split -8)
            (("1" (expand translate_stack_size_at +)
              (("1" (lift-if)
                (("1" (split +)
                  (("1" (grind) nil nil)
                   ("2" (flatten)
                    (("2" (split +)
                      (("1" (flatten)
                        (("1" (inst? -3) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (inst? -2) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (expand translate_stack_size_at +)
          (("14" (lift-if)
            (("14" (split +)
              (("1" (grind) nil nil)
               ("2" (case-replace "pc = 1")
                (("1" (grind) nil nil)
                 ("2" (flatten)
                  (("2" (split -7)
                    (("1" (inst? -1)
                      (("1" (inst? -1)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2) (("15" (grind) nil nil)) nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite purePopDepth) (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil) nil nil nil
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (add const-decl "(nonempty?)" sets nil) nil
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    nil nil nil nil nil nil nil nil nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (newvar const-decl "nat" itranslation nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (FALSE const-decl "bool" booleans nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_length_def formula-decl nil itranslation nil) nil nil
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (shift const-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (slength def-decl "posnat" ireduction nil)
    (translate_statement def-decl "istat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_is_fun_call_at_TCC1 0
  (translate_is_fun_call_at_TCC1-1 nil 3706987300
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_is_fun_call_at_TCC2 0
  (translate_is_fun_call_at_TCC2-1 nil 3706987300
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 2 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_is_fun_call_at_TCC3 0
  (translate_is_fun_call_at_TCC3-1 nil 3706987300
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_is_fun_call_at_TCC4 0
  (translate_is_fun_call_at_TCC4-1 nil 3706987300 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1 - translate_length(B)"
    "upto(translate_length(C))")))
 (translate_is_fun_call_at_TCC5 0
  (translate_is_fun_call_at_TCC5-1 nil 3706987300 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_fun_call_at subtype "pc - 1"
    "upto(translate_length(B))")))
 (translate_is_fun_call_at_end 0
  (translate_is_fun_call_at_end-1 nil 3706987301
   ("" (induct-and-simplify A) nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (translate_is_fun_call_at_def 0
  (translate_is_fun_call_at_def-1 nil 3706989046
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_statement +)
        (("6" (expand translate_is_fun_call_at +)
          (("6" (lift-if)
            (("6" (split +)
              (("1" (grind) nil nil)
               ("2" (flatten)
                (("2" (split +)
                  (("1" (split -6)
                    (("1" (flatten)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (flatten) (("1" (grind) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (split -8)
                              (("1"
                                (inst?)
                                (("1"
                                  (inst?)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (flatten) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_is_fun_call_at +)
        (("7" (lift-if)
          (("7" (split +)
            (("1" (flatten) (("1" (grind) nil nil)) nil)
             ("2" (flatten)
              (("2" (expand translate_statement +)
                (("2" (split +)
                  (("1" (flatten)
                    (("1" (split -9)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split -9)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (expand translate_is_fun_call_at +)
          (("14" (case "pc = 0")
            (("1" (grind) nil nil)
             ("2" (split -8)
              (("1" (inst? -1)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2) (("15" (grind) nil nil)) nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite purePopDepth) (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil) nil nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    nil nil nil nil (add const-decl "(nonempty?)" sets nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (translate_length_def formula-decl nil itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (shift const-decl "nat" itranslation nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (seq type-eq-decl nil more_finseq nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (newvar const-decl "nat" itranslation nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (in_varlist const-decl "finite_set[nat]" IL nil) nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (extract_stat def-decl
     "{s1, j | j < slength(s1) AND executable_stat?(s1, j)}" ireduction
     nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (slength def-decl "posnat" ireduction nil)
    (translate_statement def-decl "istat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_next_pc_TCC1 0
  (translate_next_pc_TCC1-1 nil 3706990348 ("" (subtype-tcc) nil nil)
   nil nil
   (translate_next_pc subtype "1" "upto(translate_length(A))")))
 (translate_next_pc_TCC2 0
  (translate_next_pc_TCC11-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_next_pc subtype
    "1 + translate_length(B) + translate_next_pc(C, pc - 1 - translate_length(B))"
    "upto(translate_length(A))")))
 (translate_next_pc_TCC3 0
  (translate_next_pc_TCC13-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_next_pc subtype "pc - 1" "below(translate_length(B))")))
 (translate_next_pc_TCC4 0
  (translate_next_pc_TCC14-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_next_pc subtype "1 + translate_next_pc(B, pc - 1)"
    "upto(translate_length(A))")))
 (translate_next_pc_TCC5 0
  (translate_next_pc_TCC2-1 nil 3706990348 ("" (grind) nil nil) nil nil
   (translate_next_pc subtype "pc - 1" "below(translate_length(B))")))
 (translate_next_pc_TCC6 0
  (translate_next_pc_TCC3-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_next_pc subtype "1 + translate_next_pc(B, pc - 1)"
    "upto(translate_length(A))")))
 (translate_next_pc_TCC7 0
  (translate_next_pc_TCC12-1 nil 3706990348 ("" (subtype-tcc) nil nil)
   nil nil
   (translate_next_pc subtype "1" "upto(translate_length(A))")))
 (translate_next_pc_TCC8 0
  (translate_next_pc_TCC4-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_next_pc subtype "2 + translate_length(B)"
    "upto(translate_length(A))")))
 (translate_next_pc_TCC9 0
  (translate_next_pc_TCC5-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_next_pc subtype "pc - 2 - translate_length(B)"
    "below(translate_length(C))")))
 (translate_next_pc_TCC10 0
  (translate_next_pc_TCC6-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_next_pc subtype
    "2 + translate_length(B) + translate_next_pc(C, pc - 2 - translate_length(B))"
    "upto(translate_length(A))")))
 (translate_next_pc_TCC11 0
  (translate_next_pc_TCC8-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_next_pc subtype "pc - 1" "below(translate_length(B))")))
 (translate_next_pc_TCC12 0
  (translate_next_pc_TCC15-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (translate_next_pc subtype "1" "upto(translate_length(A))")))
 (translate_next_pc_TCC13 0
  (translate_next_pc_TCC7-1 nil 3706990348 ("" (grind) nil nil) nil nil
   (translate_next_pc subtype "1" "upto(translate_length(A))")))
 (translate_next_pc_TCC14 0
  (translate_next_pc_TCC9-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_next_pc subtype "1 + translate_next_pc(B, pc - 1)"
    "upto(translate_length(A))")))
 (translate_next_pc_TCC15 0
  (translate_next_pc_TCC10-1 nil 3706990348 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_next_pc subtype "pc - 1 - translate_length(B)"
    "below(translate_length(C))")))
 (translate_next_pc_def_TCC1 0
  (translate_next_pc_def_TCC1-1 nil 3706990348
   ("" (subtype-tcc) nil nil)
   ((translate_length_def formula-decl nil itranslation nil)) nil
   (translate_next_pc_def subtype "pc"
    "below(ireduction.slength(translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars)))")))
 (translate_next_pc_def 0
  (translate_next_pc_def-1 nil 3706990349
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_statement +)
        (("6" (expand translate_next_pc +)
          (("6" (lift-if +)
            (("6" (split +)
              (("1" (grind) nil nil)
               ("2" (flatten)
                (("2" (split +)
                  (("1" (flatten)
                    (("1" (split -6)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split +)
                      (("1" (flatten) (("1" (grind) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (split +)
                          (("1" (flatten)
                            (("1" (split -7)
                              (("1"
                                (inst? -1)
                                (("1"
                                  (inst? -1)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_next_pc +)
        (("7" (expand translate_statement +)
          (("7" (lift-if +)
            (("7" (split +)
              (("1" (grind) nil nil)
               ("2" (flatten)
                (("2" (split +)
                  (("1" (flatten)
                    (("1" (split -8)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (expand next_pc +)
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil)
                         ("4" (rewrite cvars_pure)
                          (("1" (rewrite cvars_pure)
                            (("1" (skeep)
                              (("1"
                                (inst?)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split -8)
                      (("1" (inst? -1)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_statement +)
        (("14" (expand translate_next_pc +)
          (("14" (lift-if)
            (("14" (split +)
              (("1" (grind) nil nil)
               ("2" (flatten)
                (("2" (split -7)
                  (("1" (inst? -1)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2) (("15" (grind) nil nil)) nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite purePopDepth) (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cvars_pure formula-decl nil preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (add const-decl "(nonempty?)" sets nil) nil nil
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    nil nil nil
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (next_pc_pos rec-application-judgement "posnat" ireduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (translate_length_def formula-decl nil itranslation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (shift const-decl "nat" itranslation nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (seq type-eq-decl nil more_finseq nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (newvar const-decl "nat" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (next_pc def-decl "upto(slength(s))" ireduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (slength def-decl "posnat" ireduction nil)
    (translate_statement def-decl "istat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_extract_decl_begin_TCC1 0
  (translate_extract_decl_begin_TCC1-1 nil 3707237742
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_extract_decl_begin subtype "pc - 1"
    "below(translate_length(B))")))
 (translate_extract_decl_begin_def 0
  (translate_extract_decl_begin_def-1 nil 3707510940
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1 + translate_length(letexpr1_var)")
          (("1" (expand translate_extract_decl_begin +)
            (("1" (assert)
              (("1" (expand translate_statement +)
                (("1" (expand extract_stat +)
                  (("1" (assert)
                    (("1" (split -6)
                      (("1" (inst? -1)
                        (("1" (grind) nil nil)
                         ("2" (hide 3)
                          (("2" (expand is_well_typed -)
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("3" (hide 3)
                          (("3" (expand is_well_typed -)
                            (("3" (grind) nil nil)) nil))
                          nil)
                         ("4" (hide 3)
                          (("4" (skeep)
                            (("4" (inst?)
                              (("4"
                                (rewrite cvars_pure)
                                (("1"
                                  (rewrite cvars_pure)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 3) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2"
            (case-replace "pc = 1 + translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc < 2 + translate_length(letexpr1_var) + translate_length(letexpr2_var)")
              (("1" (split -7)
                (("1" (expand translate_statement +)
                  (("1" (expand translate_extract_decl_begin +)
                    (("1" (assert)
                      (("1" (inst? -1)
                        (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                         ("2" (hide 5)
                          (("2" (expand is_well_typed -)
                            (("2" (rewrite purePopDepth)
                              (("1"
                                (flatten)
                                (("1" (assert) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (hide 5)
                          (("3" (skeep*)
                            (("3" (rewrite cvars_pure)
                              (("1"
                                (rewrite cvars_pure)
                                (("1"
                                  (inst -4 "i-1")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("4" (hide 5) (("4" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 5) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_statement +)
        (("7" (expand translate_extract_decl_begin +)
          (("7" (case "pc = 0")
            (("1" (grind) nil nil)
             ("2" (assert)
              (("2" (case "pc < 1 + translate_length(ift2_var)")
                (("1" (assert)
                  (("1" (expand extract_stat +)
                    (("1" (assert)
                      (("1" (lift-if +)
                        (("1" (split +)
                          (("1" (flatten)
                            (("1" (split -9)
                              (("1" (inst?) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (expand extract_stat +)
                    (("2" (assert)
                      (("2" (lift-if +)
                        (("2" (split +)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten)
                            (("2" (split -8)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil)
                                 ("4"
                                  (rewrite cvars_pure)
                                  (("1"
                                    (rewrite cvars_pure)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (inst?)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (expand translate_extract_decl_begin +)
          (("2" (assert)
            (("2" (expand translate_statement +)
              (("2" (expand extract_stat +)
                (("2" (assert)
                  (("2" (lift-if +)
                    (("2" (split +)
                      (("1" (grind) nil nil)
                       ("2" (flatten)
                        (("2" (split -7)
                          (("1" (inst?)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil)
                             ("4" (rewrite cvars_pure)
                              (("1"
                                (rewrite cvars_pure)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst?)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (grind) nil nil) ("16" (grind) nil nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (rewrite purePopDepth) (("17" (grind) nil nil)) nil))
        nil))
      nil)
     ("18" (hide 2)
      (("18" (skeep* :preds? t)
        (("18" (rewrite pure_contextPure) nil nil)) nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt
     nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    nil
    (irelease adt-constructor-decl "[(ivar?) -> (irelease?)]"
     ireduction nil)
    (irelease? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    nil nil nil nil nil nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil) nil nil nil nil
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    nil nil nil nil
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_pure formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (translate_length_def formula-decl nil itranslation nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (shift const-decl "nat" itranslation nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    nil nil nil
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    nil nil nil nil (purePopDepth formula-decl nil IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (newvar const-decl "nat" itranslation nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (seq type-eq-decl nil more_finseq nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (idecl? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (executable_stat? const-decl "bool" ireduction nil)
    (extract_stat def-decl
     "{s1, j | j < slength(s1) AND executable_stat?(s1, j)}" ireduction
     nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (slength def-decl "posnat" ireduction nil)
    (translate_statement def-decl "istat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil))
   shostak))
 (translate_extract_decl_begin_decl_end 0
  (translate_extract_decl_begin_decl_end-1 nil 3707250475
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_decl_end def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_extract_decl_begin_skip 0
  (translate_extract_decl_begin_skip-1 nil 3707250573
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_extract_decl_end_skip 0
  (translate_extract_decl_end_skip-1 nil 3707250599
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_decl_end def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_extract_decl_begin_is_assign 0
  (translate_extract_decl_begin_is_assign-1 nil 3707250645
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_extract_decl_end_is_assign 0
  (translate_extract_decl_end_is_assign-1 nil 3707250662
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_decl_end def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_extract_skip_is_assign 0
  (translate_extract_skip_is_assign-1 nil 3707251028
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_extract_assign_TCC1 0
  (translate_extract_assign_TCC1-1 nil 3707237742 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_extract_assign subtype "pc - 1"
    "{pc: below(translate_length(B)) | translate_extract_is_assign(B, pc)}")))
 (translate_extract_assign_TCC2 0
  (translate_extract_assign_TCC2-1 nil 3707237742 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_extract_assign subtype "pc - 2 - translate_length(B)"
    "{pc: below(translate_length(C)) | translate_extract_is_assign(C, pc)}")))
 (translate_extract_assign_TCC3 0
  (translate_extract_assign_TCC3-1 nil 3707237742 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_extract_assign subtype "pc - 1"
    "{pc: below(translate_length(B)) | translate_extract_is_assign(B, pc)}")))
 (translate_extract_assign_TCC4 0
  (translate_extract_assign_TCC4-1 nil 3707237742 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_extract_assign subtype "pc - 1 - translate_length(B)"
    "{pc: below(translate_length(C)) | translate_extract_is_assign(C, pc)}")))
 (translate_extract_assign_TCC5 0
  (translate_extract_assign_TCC5-1 nil 3707237742 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_extract_assign subtype "pc - 1"
    "{pc: below(translate_length(B)) | translate_extract_is_assign(B, pc)}")))
 (val_to_ival_TCC1 0
  (val_to_ival_TCC2-1 nil 3707055204 ("" (cases-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil))
   nil
   (val_to_ival cases "v" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (reconstruct_state_TCC1 0
  (reconstruct_state_TCC1-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   nil nil
   (reconstruct_state subtype "pc" "upto(translate_length(A))")))
 (reconstruct_state_TCC2 0
  (reconstruct_state_TCC11-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(C, pc - 1 - lb1) < S`length}")))
 (reconstruct_state_TCC3 0
  (reconstruct_state_TCC12-1 nil 3706985635
   ("" (skeep* :preds? t)
    (("" (case "pc-1-lb1=0")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (reconstruct_state subtype "ireduction.vindex(rv)"
    "below(S`length)")))
 (reconstruct_state_TCC4 0
  (reconstruct_state_TCC4-1 nil 3706985635 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (reconstruct_state subtype "0" "below(S`length)")))
 (reconstruct_state_TCC5 0
  (reconstruct_state_TCC14-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reconstruct_state subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(B, pc - 1) < S`length}")))
 (reconstruct_state_TCC6 0
  (reconstruct_state_TCC2-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1" "below(translate_length(B))")))
 (reconstruct_state_TCC7 0
  (reconstruct_state_TCC3-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "ireduction.ivar(0, FALSE)"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(B, pc - 1) < S`length}")))
 (reconstruct_state_TCC8 0
  (reconstruct_state_TCC5-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1 - lb1 - lb2"
    "below(translate_length(C))")))
 (reconstruct_state_TCC9 0
  (reconstruct_state_TCC6-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (odd_posnat nonempty-type-eq-decl nil naturalnumbers nil)
    (odd? const-decl "bool" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype
    "ireduction.ivar(ireduction.vindex(rv) + 1, FALSE)"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(C, pc - 1 - lb1 - lb2) < S`length}")))
 (reconstruct_state_TCC10 0
  (reconstruct_state_TCC7-1 nil 3706985635
   ("" (skeep* :preds? t)
    (("" (case-replace "pc = 1 + lb1")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd? const-decl "bool" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (reconstruct_state subtype "ireduction.vindex(rv) + 1"
    "below(S`length)")))
 (reconstruct_state_TCC11 0
  (reconstruct_state_TCC8-1 nil 3706985635
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd? const-decl "bool" integers nil)
    (pure? def-decl "bool" IL nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil))
   nil
   (reconstruct_state subtype "pc - 1" "below(translate_length(B))")))
 (reconstruct_state_TCC12 0
  (reconstruct_state_TCC9-1 nil 3706985635
   ("" (skeep* :preds? t)
    (("" (case "pc = 1 + lb1")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(B, pc - 1) < S`length}")))
 (reconstruct_state_TCC13 0
  (reconstruct_state_TCC10-1 nil 3706985635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state subtype "pc - 1 - lb1"
    "below(translate_length(C))")))
 (translate_is_result_defined_TCC1 0
  (translate_is_result_defined_TCC1-1 nil 3707580139
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (translate_is_result_defined subtype
    "ireduction.ivar(0, booleans.FALSE)"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.B, (number_fields.-)(itranslation.pc, 1))), itranslation.S`length)}")))
 (translate_is_result_defined_TCC2 0
  (translate_is_result_defined_TCC2-1 nil 3707580139
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_is_result_defined subtype "0"
    "naturalnumbers.below(itranslation.S`length)")))
 (translate_is_result_defined_TCC3 0
  (translate_is_result_defined_TCC3-1 nil 3707580139
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (translate_is_result_defined subtype
    "ireduction.ivar((number_fields.+)(ireduction.vindex(itranslation.rv), 1), booleans.FALSE)"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.C, (number_fields.-)((number_fields.-)(itranslation.pc, 2), itranslation.translate_length(itranslation.B)))), itranslation.S`length)}")))
 (translate_is_result_defined_TCC4 0
  (translate_is_result_defined_TCC4-1 nil 3707580139
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_is_result_defined subtype
    "ireduction.vindex(itranslation.rv)"
    "naturalnumbers.below(itranslation.S`length)")))
 (translate_is_result_defined_TCC5 0
  (translate_is_result_defined_TCC5-1 nil 3707580139
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (translate_is_result_defined subtype "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.B, (number_fields.-)(itranslation.pc, 1))), itranslation.S`length)}")))
 (translate_is_result_defined_TCC6 0
  (translate_is_result_defined_TCC6-1 nil 3707580139
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand translate_stack_size_at -)
        (("" (case "-1 - translate_length(B) + pc = 0")
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at def-decl "nat" itranslation nil))
   nil
   (translate_is_result_defined subtype "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.C, (number_fields.-)((number_fields.-)(itranslation.pc, 1), itranslation.translate_length(itranslation.B)))), itranslation.S`length)}")))
 (translate_is_result_defined_TCC7 0
  (translate_is_result_defined_TCC7-1 nil 3707580139
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_is_result_defined subtype
    "ireduction.vindex(itranslation.rv)"
    "naturalnumbers.below(itranslation.S`length)")))
 (reconstruct_state_tv_high_TCC1 0
  (reconstruct_state_tv_high_TCC1-1 nil 3707074906
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (reconstruct_state_tv_high subtype
    "j - IL.popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2)"
    "nat")))
 (reconstruct_state_tv_high 0
  (reconstruct_state_tv_high-1 nil 3707074906
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (flatten)
              (("1" (rewrite purePopDepth) (("1" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -6)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split +)
                    (("1" (flatten)
                      (("1" (expand translate_stack_size_at +)
                        (("1"
                          (case-replace
                           "pc = 1 + translate_length(letexpr1_var)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split +)
                        (("1" (flatten)
                          (("1" (split -7)
                            (("1" (inst? -1)
                              (("1"
                                (expand popDepth 1 1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2"
                            (case-replace
                             "pc = 2 + translate_length(letexpr1_var) + translate_length(letexpr2_var)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (flatten) (("1" (grind) nil nil)) nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -8)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split -8)
                    (("1" (inst? -1)
                      (("1"
                        (case-replace
                         "pc = 1 + translate_length(ift2_var)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (lift-if +)
          (("14" (split +)
            (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
             ("2" (flatten)
              (("2" (split -7)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (grind) nil nil))
    nil)
   (nil nil nil
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil nil (newvar const-decl "nat" itranslation nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (purePopDepth formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil) nil
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (reconstruct_state_tv_low 0
  (reconstruct_state_tv_low-2 nil 3707244859
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (flatten)
              (("1" (expand reconstruct_state -9)
                (("1" (assert)
                  (("1" (rewrite purePopDepth) (("1" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -6)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split +)
                    (("1"
                      (case-replace
                       "pc = 1 + translate_length(letexpr1_var)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split +)
                        (("1" (flatten)
                          (("1" (split -7)
                            (("1" (inst? -1)
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (expand reconstruct_state -8)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand popDepth -8)
                                      (("2"
                                        (case-replace
                                         "j = popDepth(reconstruct_state(letexpr2_var, newvar(translate_vars), S,
                                                    -2 - translate_length(letexpr1_var) + pc,
                                                    ivar(1 + vindex(rv), FALSE))`2) + popDepth(reconstruct_state(letexpr2_var, newvar(translate_vars), S,
                                                    -2 - translate_length(letexpr1_var) + pc,
                                                    ivar(1 + vindex(rv), FALSE))`1)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (rewrite
                                             reconstruct_state_tv_high)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2"
                            (case-replace
                             "pc = 2 + translate_length(letexpr1_var) + translate_length(letexpr2_var)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (split -7)
                  (("1" (inst? -1)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split -8)
                    (("1" (inst? -1)
                      (("1"
                        (case-replace
                         "pc = 1 + translate_length(ift2_var)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (lift-if +)
          (("14" (split +)
            (("1" (expand reconstruct_state -9)
              (("1" (assert)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (rewrite purePopDepth)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split -7)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   (nil nil nil
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    nil nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (newvar const-decl "nat" itranslation nil)
    (reconstruct_state_tv_high formula-decl nil itranslation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil) nil
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    nil (IContext type-decl nil IL nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (reconstruct_state_tv_low-1 nil 3707075241
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -6)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split +)
                    (("1"
                      (case-replace
                       "pc = 1 + translate_length(letexpr1_var)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split +)
                        (("1" (flatten)
                          (("1" (split -7)
                            (("1" (inst? -1)
                              (("1"
                                (split -1)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (expand reconstruct_state -8)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand popDepth -8)
                                      (("2"
                                        (case-replace
                                         "j = popDepth(reconstruct_state(letexpr2_var, newvar(translate_vars), S,
                                  -2 - translate_length(letexpr1_var) + pc,
                                  ivar(1 + vindex(rv), FALSE))`2)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (rewrite
                                             reconstruct_state_tv_high)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2"
                            (case-replace
                             "pc = 2 + translate_length(letexpr1_var) + translate_length(letexpr2_var)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (split -7)
                  (("1" (inst? -1)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split -8)
                    (("1" (inst? -1)
                      (("1"
                        (case-replace
                         "pc = 1 + translate_length(ift2_var)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (lift-if +)
          (("14" (split +)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split -7)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (newvar const-decl "nat" itranslation nil)
    (reconstruct_state_tv_high formula-decl nil itranslation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_popDepth 0
  (reconstruct_state_popDepth-1 nil 3707076668
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (lift-if)
          (("6" (split +)
            (("1" (flatten)
              (("1" (rewrite purePopDepth) (("1" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (flatten) (("1" (grind) nil nil)) nil)
                     ("2" (flatten)
                      (("2" (split)
                        (("1" (flatten) (("1" (grind) nil nil)) nil)
                         ("2" (flatten) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (lift-if)
          (("7" (split +)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (grind) nil nil)
                 ("2" (flatten)
                  (("2" (split -7)
                    (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (lift-if)
          (("14" (split +)
            (("1" (flatten)
              (("1" (rewrite purePopDepth) (("1" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (newvar const-decl "nat" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil) nil
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (translate_stack_size_at_next_pc_TCC1 0
  (translate_stack_size_at_next_pc_TCC1-1 nil 3707242393
   ("" (subtype-tcc) nil nil) nil nil
   (translate_stack_size_at_next_pc subtype "pc"
    "upto(translate_length(A))")))
 (translate_stack_size_at_next_pc 0
  (translate_stack_size_at_next_pc-1 nil 3707242394
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_stack_size_at +)
        (("6" (case "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (case "pc < 1 + translate_length(letexpr1_var)")
              (("1" (assert)
                (("1" (assert)
                  (("1" (split -3)
                    (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (case "pc = 1 + translate_length(letexpr1_var)")
                  (("1" (assert) (("1" (grind) nil nil)) nil)
                   ("2"
                    (case "pc <
              2 + translate_length(letexpr1_var) +
               translate_length(letexpr2_var)")
                    (("1" (assert)
                      (("1" (assert)
                        (("1" (split -4)
                          (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_stack_size_at +)
        (("7" (case "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (case "pc < 1 + translate_length(ift2_var)")
              (("1" (assert)
                (("1"
                  (case "translate_next_pc(ift2_var, pc - 1) <
                translate_length(ift2_var)")
                  (("1" (assert)
                    (("1" (split -6)
                      (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (expand translate_length 6 1)
                      (("2" (assert)
                        (("2" (assert)
                          (("2" (expand translate_length 6 1)
                            (("2"
                              (case-replace
                               "translate_stack_size_at(ift2_var, pc - 1) = 0")
                              (("1" (grind) nil nil)
                               ("2"
                                (split -5)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (case-replace
                                     "translate_next_pc(ift2_var, pc - 1) = translate_length(ift2_var)")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2"
                  (case-replace "pc = 1 + translate_length(ift2_var)")
                  (("1" (assert)
                    (("1" (split -6)
                      (("1" (inst? -1)
                        (("1"
                          (case-replace
                           "translate_next_pc(ift3_var, 0) = 0")
                          (("1" (assert) nil nil)
                           ("2" (assert) (("2" (grind) nil nil)) nil)
                           ("3" (grind) nil nil) ("4" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (split -5)
                      (("1" (inst? -1)
                        (("1"
                          (case-replace
                           "translate_next_pc(ift3_var, -1 - translate_length(ift2_var) + pc) = 0")
                          (("1" (grind) nil nil)
                           ("2" (assert) (("2" (grind) nil nil)) nil)
                           ("3" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_stack_size_at +)
        (("14" (case-replace "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (assert)
              (("2" (split -4)
                (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil) nil
    (- const-decl "[numfield -> numfield]" number_fields nil) nil nil
    nil
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (translate_extract_decl_end def-decl "bool" itranslation nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (decl_begin_next_pc 0
  (decl_begin_next_pc-1 nil 3707506190
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_stack_size_at_next_pc_decl_begin_TCC1 0
  (translate_stack_size_at_next_pc_decl_begin_TCC1-1 nil 3707506190
   ("" (subtype-tcc) nil nil) nil nil
   (translate_stack_size_at_next_pc_decl_begin subtype
    "itranslation.pc"
    "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))
 (translate_stack_size_at_next_pc_decl_begin 0
  (translate_stack_size_at_next_pc_decl_begin-1 nil 3707506342
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (skeep* :preds? t)
      (("7" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1 + translate_length(ift2_var)")
          (("1" (expand translate_stack_size_at +)
            (("1" (assert)
              (("1" (assert)
                (("1"
                  (case "translate_next_pc(ift2_var, pc - 1) <
                translate_length(ift2_var)")
                  (("1" (assert)
                    (("1" (split -6)
                      (("1" (inst?) (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (lemma decl_begin_next_pc)
                    (("2" (inst -1 ift2_var "pc-1")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand translate_stack_size_at +)
            (("2" (expand translate_next_pc +)
              (("2" (assert)
                (("2" (split -5)
                  (("1" (inst? -1)
                    (("1" (split -1)
                      (("1"
                        (case-replace
                         "pc = 1 + translate_length(ift2_var)")
                        (("1" (grind)
                          (("1" (expand translate_next_pc -9)
                            (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (grind)
                          (("2" (expand translate_next_pc -8)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (decl_begin_next_pc formula-decl nil itranslation nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil) nil
    nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (skip_next_pc 0
  (skip_next_pc-1 nil 3707572315
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_stack_size_at_next_pc_skip_TCC1 0
  (translate_stack_size_at_next_pc_skip_TCC1-1 nil 3707572314
   ("" (subtype-tcc) nil nil) nil nil
   (translate_stack_size_at_next_pc_skip subtype "itranslation.pc"
    "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))
 (translate_stack_size_at_next_pc_skip 0
  (translate_stack_size_at_next_pc_skip-1 nil 3707572396
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(ift2_var)")
          (("1"
            (case "translate_next_pc(ift
                                                (ift1_var,
                                                 ift2_var,
                                                 ift3_var),
                                                pc) < 1+translate_length(ift2_var)")
            (("1" (grind) nil nil)
             ("2" (expand translate_next_pc +)
              (("2" (assert)
                (("2" (use skip_next_pc) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (case "pc = 1 + translate_length(ift2_var)")
            (("1" (expand translate_stack_size_at +)
              (("1" (assert)
                (("1" (assert)
                  (("1"
                    (case "translate_next_pc(ift3_var, -1 - translate_length(ift2_var) + pc) > 0")
                    (("1" (assert)
                      (("1" (split -7)
                        (("1" (inst?) (("1" (grind) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil)
                     ("4" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand translate_stack_size_at +)
              (("2" (assert)
                (("2"
                  (case "translate_next_pc(ift3_var,
                               -1 - translate_length(ift2_var) + pc) > 0")
                  (("1" (assert)
                    (("1" (split -6)
                      (("1" (inst?) (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind)
                    (("2" (expand translate_next_pc 1)
                      (("2" (lift-if 1) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (skip_next_pc formula-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (reconstruct_state_zero_TCC1 0
  (reconstruct_state_zero_TCC1-1 nil 3707240197
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (reconstruct_state_zero subtype "0" "below(translate_length(A))")))
 (reconstruct_state_zero_TCC2 0
  (reconstruct_state_zero_TCC2-1 nil 3707240197
   ("" (subtype-tcc) nil nil)
   ((translate_stack_size_at_zero formula-decl nil itranslation nil))
   nil
   (reconstruct_state_zero subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(A, 0) < S`length}")))
 (reconstruct_state_zero 0
  (reconstruct_state_zero-1 nil 3707240758
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil) ("15" (grind) nil nil)
     ("16" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil))
   shostak))
 (reconstruct_state_tv_next_pc_overflow 0
  (reconstruct_state_tv_next_pc_overflow-1 nil 3707240198
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (split +)
                    (("1" (grind) nil nil)
                     ("2" (flatten)
                      (("2" (split +)
                        (("1" (flatten) (("1" (grind) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -7)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split -7)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (lift-if)
          (("14" (split +)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split -6)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    nil nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (translate_extract_decl_end def-decl "bool" itranslation nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_tv_next_pc_TCC1 0
  (reconstruct_state_tv_next_pc_TCC2-1 nil 3707497386
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc) nil nil)) nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (reconstruct_state_tv_next_pc subtype "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.A, itranslation.pc)), itranslation.S2`length)}")))
 (reconstruct_state_tv_next_pc_TCC2 0
  (reconstruct_state_tv_next_pc_TCC1-1 nil 3707238548
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (reconstruct_state_tv_next_pc subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(A, translate_next_pc(A, pc)) < S`length}")))
 (reconstruct_state_tv_next_pc 0
  (reconstruct_state_tv_next_pc-1 nil 3707238549
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (case-replace "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (case "pc < 1 + translate_length(letexpr1_var)")
              (("1" (assert)
                (("1"
                  (case "translate_next_pc(letexpr1_var, pc - 1) <
         translate_length(letexpr1_var)")
                  (("1" (assert)
                    (("1" (split -7)
                      (("1" (inst?)
                        (("1" (assert) (("1" (grind) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (use reconstruct_state_tv_next_pc_overflow)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2"
                (case-replace
                 "pc = 1 + translate_length(letexpr1_var)")
                (("1" (assert)
                  (("1" (expand translate_extract_skip)
                    (("1" (propax) nil nil)) nil))
                  nil)
                 ("2" (assert)
                  (("2" (assert)
                    (("2"
                      (case "pc < 2 + translate_length(letexpr1_var) +
            translate_length(letexpr2_var)")
                      (("1" (assert)
                        (("1" (lift-if +)
                          (("1" (split +)
                            (("1" (flatten)
                              (("1"
                                (split -7)
                                (("1"
                                  (inst? -1)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (use
                                 reconstruct_state_tv_next_pc_overflow)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil)
                       ("3" (assert) (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (case "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (case "pc < 1 + translate_length(ift2_var)")
              (("1" (assert)
                (("1" (assert)
                  (("1"
                    (case "translate_next_pc(ift2_var, pc - 1) <
             translate_length(ift2_var)")
                    (("1" (assert)
                      (("1" (split -8)
                        (("1" (inst? -1)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (split -8)
                  (("1" (inst?)
                    (("1" (grind) nil nil)
                     ("2"
                      (case "-1 - translate_length(ift2_var) + pc = 0")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("3" (assert) (("3" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (case-replace "pc = 0")
          (("1" (expand translate_next_pc +) (("1" (grind) nil nil))
            nil)
           ("2" (assert)
            (("2" (split -7)
              (("1" (inst?)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite translate_stack_size_at_next_pc) nil nil))
        nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (reconstruct_state_zero formula-decl nil itranslation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    nil nil nil nil nil
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (shift const-decl "nat" itranslation nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil) nil nil nil nil
    (reconstruct_state_tv_next_pc_overflow formula-decl nil
     itranslation nil)
    (newvar const-decl "nat" itranslation nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    nil (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (translate_extract_decl_end def-decl "bool" itranslation nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (avar_assign_vindex_bound 0
  (avar_assign_vindex_bound-1 nil 3707250712
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_extract_assign +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2"
                (case "-1 - translate_length(ift2_var)
                                           +
                                           pc = 0")
                (("1" (grind) nil nil)
                 ("2" (expand translate_stack_size_at +)
                  (("2" (assert)
                    (("2" (split -6)
                      (("1" (inst? -1) (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (shift const-decl "nat" itranslation nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil) nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newvar const-decl "nat" itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (translate_extract_assign def-decl "(iassign?)" itranslation nil)
    (avar adt-accessor-decl "[(iassign?) -> (ivar?)]" ireduction nil)
    (iassign? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    (istat type-decl nil ireduction nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (avar_assign_next_pc_overflow 0
  (avar_assign_next_pc_overflow-1 nil 3707249430
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand translate_extract_assign +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (flatten)
              (("1" (split -4)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand translate_extract_assign +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (flatten)
              (("1" (split -6)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split -6)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand translate_extract_assign +)
        (("14" (split -5)
          (("1" (inst? -1)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    nil nil nil (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_extract_assign def-decl "(iassign?)" itranslation nil)
    (avar adt-accessor-decl "[(iassign?) -> (ivar?)]" ireduction nil)
    (iassign? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    (istat type-decl nil ireduction nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (translate_is_result_defined_assign_next_pc_TCC1 0
  (translate_is_result_defined_assign_next_pc_TCC1-1 nil 3707585622
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc)
      (("1" (use translate_extract_decl_begin_is_assign)
        (("1" (assert) nil nil)) nil)
       ("2" (use translate_extract_decl_end_is_assign)
        (("2" (assert) nil nil)) nil)
       ("3" (use translate_extract_skip_is_assign)
        (("3" (assert) nil nil)) nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil))
   nil
   (translate_is_result_defined_assign_next_pc subtype
    "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.A, itranslation.translate_next_pc(itranslation.A, itranslation.pc))), itranslation.S`length)}")))
 (translate_is_result_defined_assign_next_pc_TCC2 0
  (translate_is_result_defined_assign_next_pc_TCC1-1 nil 3707585227
   ("" (skeep* :preds? t)
    (("" (use avar_assign_vindex_bound) (("" (grind) nil nil)) nil))
    nil)
   ((avar_assign_vindex_bound formula-decl nil itranslation nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (translate_is_result_defined_assign_next_pc subtype
    "ireduction.vindex(ireduction.avar(itranslation.translate_extract_assign(itranslation.A, itranslation.rv, itranslation.translate_vars, itranslation.pc)))"
    "naturalnumbers.below(itranslation.S`length)")))
 (translate_is_result_defined_assign_next_pc 0
  (translate_is_result_defined_assign_next_pc-1 nil 3707585227
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (expand translate_extract_assign +)
            (("1" (assert)
              (("1" (expand translate_is_result_defined +)
                (("1" (lift-if +)
                  (("1" (split +)
                    (("1" (flatten)
                      (("1" (split -6)
                        (("1" (inst?)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (assert)
                        (("2" (rewrite avar_assign_next_pc_overflow)
                          (("1" (assert) nil nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (case "pc = 1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc < 2+translate_length(letexpr1_var)+translate_length(letexpr2_var)")
              (("1" (expand translate_extract_assign +)
                (("1" (assert)
                  (("1" (expand translate_is_result_defined +)
                    (("1" (lift-if +)
                      (("1" (split +)
                        (("1" (flatten)
                          (("1" (split -7)
                            (("1" (inst?)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (rewrite avar_assign_next_pc_overflow)
                            (("1" (assert) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1 + translate_length(ift2_var)")
          (("1" (expand translate_extract_assign +)
            (("1" (assert)
              (("1"
                (case "translate_next_pc(ift2_var, pc - 1)
                                     <
                                     translate_length(ift2_var)")
                (("1" (assert)
                  (("1" (split -8)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil)
           ("2" (expand translate_extract_assign +)
            (("2" (assert)
              (("2" (split -7)
                (("1" (inst?)
                  (("1" (grind) nil nil)
                   ("2"
                    (case "-1 - translate_length(ift2_var) + pc = 0")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil)
     ("9" (skeep* :preds? t)
      (("9" (case-replace "pc = 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil)
     ("15" (hide 2)
      (("15" (skeep :preds? t)
        (("15" (skeep :preds? t)
          (("15" (use avar_assign_vindex_bound)
            (("15" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite translate_stack_size_at_next_pc)
          (("1" (use translate_extract_decl_begin_is_assign)
            (("1" (assert) nil nil)) nil)
           ("2" (use translate_extract_decl_end_is_assign)
            (("2" (assert) nil nil)) nil)
           ("3" (use translate_extract_skip_is_assign)
            (("3" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (avar_assign_vindex_bound formula-decl nil itranslation nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    nil nil nil nil nil nil
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (avar_assign_next_pc_overflow formula-decl nil itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    (newvar const-decl "nat" itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (endi const-decl "T" ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (vundef? adt-recognizer-decl "[ivalue -> boolean]" ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_is_result_defined def-decl "bool" itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (istat type-decl nil ireduction nil)
    (iassign? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    (avar adt-accessor-decl "[(iassign?) -> (ivar?)]" ireduction nil)
    (translate_extract_assign def-decl "(iassign?)" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (translate_is_result_defined_zero 0
  (translate_is_result_defined_zero-1 nil 3707588477
   ("" (induct-and-simplify A) nil nil)
   ((translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_is_result_defined def-decl "bool" itranslation nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (translate_is_result_defined_decl_begin_next_pc_TCC1 0
  (translate_is_result_defined_decl_begin_next_pc_TCC1-1 nil 3707588477
   ("" (skeep* :preds? t) (("" (rewrite decl_begin_next_pc) nil nil))
    nil)
   ((decl_begin_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_is_result_defined_decl_begin_next_pc subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "naturalnumbers.below(itranslation.translate_length(itranslation.A))")))
 (translate_is_result_defined_decl_begin_next_pc_TCC2 0
  (translate_is_result_defined_decl_begin_next_pc_TCC2-1 nil 3707588477
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc_decl_begin)
      (("" (grind) nil nil)) nil))
    nil)
   ((translate_stack_size_at_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_is_result_defined_decl_begin_next_pc subtype
    "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.A, itranslation.translate_next_pc(itranslation.A, itranslation.pc))), itranslation.S`length)}")))
 (translate_is_result_defined_decl_begin_next_pc 0
  (translate_is_result_defined_decl_begin_next_pc-1 nil 3707588493
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (expand translate_next_pc +)
            (("1" (assert)
              (("1" (expand translate_is_result_defined +)
                (("1"
                  (case "translate_next_pc(letexpr1_var, pc - 1) < translate_length(letexpr1_var)")
                  (("1" (assert) (("1" (grind) nil nil)) nil)
                   ("2" (rewrite decl_begin_next_pc)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (case "pc = 1 + translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc < 2 + translate_length(letexpr1_var) + translate_length(letexpr2_var)")
              (("1" (expand translate_next_pc +)
                (("1" (assert)
                  (("1" (expand translate_is_result_defined +)
                    (("1"
                      (case "translate_next_pc(letexpr2_var,
                            -2 - translate_length(letexpr1_var) + pc) < translate_length(letexpr2_var)")
                      (("1" (assert)
                        (("1" (split -7)
                          (("1" (inst?)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (rewrite decl_begin_next_pc)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(ift2_var)")
          (("1" (expand translate_next_pc +)
            (("1" (assert)
              (("1"
                (case "translate_next_pc(ift2_var, pc - 1) < translate_length(ift2_var)")
                (("1" (grind) nil nil)
                 ("2" (rewrite decl_begin_next_pc)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand translate_next_pc +)
            (("2" (assert)
              (("2" (expand translate_is_result_defined +)
                (("2" (split -7)
                  (("1" (inst?)
                    (("1" (grind) nil nil)
                     ("2"
                      (case "-1 - translate_length(ift2_var) + pc = 0")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite translate_stack_size_at_next_pc_decl_begin)
          (("15" (grind) nil nil)) nil))
        nil))
      nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite decl_begin_next_pc) nil nil)) nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    nil nil nil nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (decl_begin_next_pc formula-decl nil itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil nil
    nil nil nil
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (translate_is_result_defined_zero formula-decl nil itranslation
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (endi const-decl "T" ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_is_result_defined def-decl "bool" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil))
   shostak))
 (translate_is_result_defined_skip_TCC1 0
  (translate_is_result_defined_skip_TCC1-1 nil 3707588477
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (translate_is_result_defined_skip subtype "0"
    "naturalnumbers.below(itranslation.S`length)")))
 (translate_is_result_defined_skip 0
  (translate_is_result_defined_skip-1 nil 3707589320
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (grind) nil nil)
           ("2" (case "pc = 1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil) ("15" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil nil nil nil
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (endi const-decl "T" ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (vundef? adt-recognizer-decl "[ivalue -> boolean]" ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_is_result_defined def-decl "bool" itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (translate_is_result_defined_skip_next_pc_TCC1 0
  (translate_is_result_defined_skip_next_pc_TCC1-1 nil 3707588477
   ("" (skeep* :preds? t) (("" (rewrite skip_next_pc) nil nil)) nil)
   ((skip_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (translate_is_result_defined_skip_next_pc subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "naturalnumbers.below(itranslation.translate_length(itranslation.A))")))
 (translate_is_result_defined_skip_next_pc_TCC2 0
  (translate_is_result_defined_skip_next_pc_TCC2-1 nil 3707588477
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc_skip) nil nil)) nil)
   ((translate_stack_size_at_next_pc_skip formula-decl nil itranslation
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (translate_is_result_defined_skip_next_pc subtype "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.A, itranslation.translate_next_pc(itranslation.A, itranslation.pc))), itranslation.S`length)}")))
 (translate_is_result_defined_skip_next_pc 0
  (translate_is_result_defined_skip_next_pc-1 nil 3707589419
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (expand translate_next_pc +)
            (("1" (assert)
              (("1" (expand translate_is_result_defined +)
                (("1"
                  (case "translate_next_pc(letexpr1_var, pc - 1) < translate_length(letexpr1_var)")
                  (("1" (grind) nil nil)
                   ("2" (rewrite skip_next_pc) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (case "pc = 1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc < 2+translate_length(letexpr1_var)+translate_length(letexpr2_var)")
              (("1" (expand translate_next_pc +)
                (("1" (assert)
                  (("1" (expand translate_is_result_defined +)
                    (("1"
                      (case " translate_next_pc(letexpr2_var,
                            -2 - translate_length(letexpr1_var) + pc) < translate_length(letexpr2_var)")
                      (("1" (assert) (("1" (grind) nil nil)) nil)
                       ("2" (rewrite skip_next_pc)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(ift2_var)")
          (("1" (expand translate_next_pc +)
            (("1" (assert)
              (("1"
                (case "translate_next_pc(ift2_var, pc - 1)
                                     <
                                     translate_length(ift2_var)")
                (("1" (grind) nil nil)
                 ("2" (rewrite skip_next_pc) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand translate_next_pc +)
            (("2" (assert)
              (("2" (expand translate_is_result_defined +)
                (("2" (assert)
                  (("2" (split -7)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil)
                       ("2"
                        (case "-1 - translate_length(ift2_var) + pc = 0")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite translate_stack_size_at_next_pc_skip) nil nil))
        nil))
      nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t) (("16" (rewrite skip_next_pc) nil nil))
        nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc_skip formula-decl nil itranslation
     nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    nil nil nil nil nil nil
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (skip_next_pc formula-decl nil itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil nil
    nil nil nil
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (translate_is_result_defined_zero formula-decl nil itranslation
     nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (endi const-decl "T" ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_is_result_defined def-decl "bool" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_assign_hole_pc_overflow 0
  (reconstruct_state_assign_hole_pc_overflow-1 nil 3707249790
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil nil
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_ctx_stack 0
  (reconstruct_state_ctx_stack-1 nil 3707249191
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (lift-if)
          (("6" (split +)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -6)
                    (("1" (decompose-equality 1)
                      (("1" (inst? -1) (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split +)
                    (("1" (propax) nil nil)
                     ("2" (flatten)
                      (("2" (split +)
                        (("1" (flatten)
                          (("1" (decompose-equality +)
                            (("1" (split -7)
                              (("1"
                                (inst? -1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split +)
                (("1" (flatten)
                  (("1" (split -8)
                    (("1" (inst? -1)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split -8)
                    (("1" (inst? -1)
                      (("1"
                        (case-replace
                         "-1 - translate_length(ift2_var) + pc = 0")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (case "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (split -7)
              (("1" (inst? -1) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    nil nil nil nil nil nil
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil nil nil nil nil nil nil nil
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (IContext_popc_extensionality formula-decl nil IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (newvar const-decl "nat" itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    nil nil nil (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (IContext_letc_extensionality formula-decl nil IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_next_pc_TCC1 0
  (reconstruct_state_next_pc_TCC1-1 nil 3707247394
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc)
      (("1" (use translate_extract_decl_begin_is_assign)
        (("1" (grind) nil nil)) nil)
       ("2" (use translate_extract_decl_end_is_assign)
        (("2" (grind) nil nil)) nil)
       ("3" (use translate_extract_skip_is_assign)
        (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (reconstruct_state_next_pc subtype "rv"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(A, translate_next_pc(A, pc)) < S`length}")))
 (reconstruct_state_next_pc 0
  (reconstruct_state_next_pc-1 nil 3707247394
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand reconstruct_state +)
        (("6" (case-replace "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (case "pc < 1 + translate_length(letexpr1_var)")
              (("1" (assert)
                (("1"
                  (case "translate_next_pc(letexpr1_var, pc - 1) < translate_length(letexpr1_var)")
                  (("1" (assert)
                    (("1" (expand fill 3)
                      (("1" (decompose-equality 3)
                        (("1" (split -7)
                          (("1" (inst? -1)
                            (("1" (split -1)
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil)
                               ("3" (grind) nil nil)
                               ("4" (propax) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (expand fill +)
                      (("2" (decompose-equality 4)
                        (("2" (expand translate_extract_assign 1)
                          (("2" (rewrite avar_assign_next_pc_overflow)
                            (("1" (assert)
                              (("1"
                                (rewrite
                                 reconstruct_state_assign_hole_pc_overflow)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2"
                  (case-replace
                   "pc = 1 + translate_length(letexpr1_var)")
                  (("1" (grind) nil nil)
                   ("2" (assert)
                    (("2"
                      (case "pc <
                2 + translate_length(letexpr1_var) +
                 translate_length(letexpr2_var)")
                      (("1" (assert)
                        (("1"
                          (case "translate_next_pc(letexpr2_var,
                                 -2 - translate_length(letexpr1_var) + pc) < translate_length(letexpr2_var)")
                          (("1" (assert)
                            (("1" (expand fill +)
                              (("1"
                                (decompose-equality 5)
                                (("1"
                                  (split -8)
                                  (("1"
                                    (inst? -1)
                                    (("1"
                                      (split -1)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (grind) nil nil)
                                       ("4" (propax) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (expand fill 6)
                              (("2"
                                (decompose-equality 6)
                                (("2"
                                  (rewrite
                                   reconstruct_state_assign_hole_pc_overflow)
                                  (("1"
                                    (expand translate_extract_assign 1)
                                    (("1"
                                      (rewrite
                                       avar_assign_next_pc_overflow)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil)
                       ("3" (assert) (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand reconstruct_state +)
        (("7" (case "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (case "pc < 1 + translate_length(ift2_var)")
              (("1" (assert)
                (("1"
                  (case "translate_next_pc(ift2_var, pc - 1) <
                  translate_length(ift2_var)")
                  (("1" (assert)
                    (("1" (split -9)
                      (("1" (inst? -1)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (split -8)
                  (("1" (inst? -1)
                    (("1" (grind) nil nil)
                     ("2"
                      (case-replace
                       "-1 - translate_length(ift2_var) + pc = 0")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand reconstruct_state +)
        (("14" (case "pc = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (split -7)
              (("1" (inst? -1)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (use avar_assign_vindex_bound) (("15" (grind) nil nil))
          nil))
        nil))
      nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite translate_stack_size_at_next_pc)
          (("1" (use translate_extract_decl_begin_is_assign)
            (("1" (grind) nil nil)) nil)
           ("2" (use translate_extract_decl_end_is_assign)
            (("2" (grind) nil nil)) nil)
           ("3" (use translate_extract_skip_is_assign)
            (("3" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (avar_assign_vindex_bound formula-decl nil itranslation nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil nil nil nil
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil nil
    (IExpression_letexpr_extensionality formula-decl nil
     IExpression_adt nil)
    (shift const-decl "nat" itranslation nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (reconstruct_state_assign_hole_pc_overflow formula-decl nil
     itranslation nil)
    (avar_assign_next_pc_overflow formula-decl nil itranslation nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression_pop_extensionality formula-decl nil IExpression_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (newvar const-decl "nat" itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (endi const-decl "T" ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (avar adt-accessor-decl "[(iassign?) -> (ivar?)]" ireduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ilookup? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (istat type-decl nil ireduction nil)
    (iassign? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    (aexpr adt-accessor-decl "[(iassign?) -> iexpr]" ireduction nil)
    (translate_extract_assign def-decl "(iassign?)" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_decl_begin_letexpr 0
  (reconstruct_state_decl_begin_letexpr-1 nil 3707506691
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1" (split -5)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2"
            (case-replace "pc = 1 + translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc < 2+translate_length(letexpr1_var) + translate_length(letexpr2_var)")
              (("1" (split -6)
                (("1" (expand reconstruct_state +)
                  (("1" (assert)
                    (("1" (inst?) (("1" (grind) nil nil)) nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(ift2_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (expand reconstruct_state +)
            (("2" (assert)
              (("2" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (expand reconstruct_state +)
          (("2" (assert)
            (("2" (split -6)
              (("1" (inst?) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newvar const-decl "nat" itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_next_pc_decl_begin_TCC1 0
  (reconstruct_state_next_pc_decl_begin_TCC1-1 nil 3707504998
   ("" (skeep* :preds? t) (("" (rewrite decl_begin_next_pc) nil nil))
    nil)
   ((decl_begin_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (reconstruct_state_next_pc_decl_begin subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "naturalnumbers.below(itranslation.translate_length(itranslation.A))")))
 (reconstruct_state_next_pc_decl_begin_TCC2 0
  (reconstruct_state_next_pc_decl_begin_TCC2-1 nil 3707504998
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc_decl_begin)
      (("" (grind) nil nil)) nil))
    nil)
   ((translate_stack_size_at_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reconstruct_state_next_pc_decl_begin subtype "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.A, itranslation.translate_next_pc(itranslation.A, itranslation.pc))), itranslation.S`length)}")))
 (reconstruct_state_next_pc_decl_begin_TCC3 0
  (reconstruct_state_next_pc_decl_begin_TCC3-1 nil 3707504998
   ("" (skeep* :preds? t)
    (("" (use reconstruct_state_decl_begin_letexpr)
      (("" (grind) nil nil)) nil))
    nil)
   ((reconstruct_state_decl_begin_letexpr formula-decl nil itranslation
     nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil
   (reconstruct_state_next_pc_decl_begin subtype
    "itranslation.reconstruct_state(itranslation.A, itranslation.translate_vars, itranslation.S, itranslation.pc, itranslation.rv)`1"
    "(IExpression_adt.letexpr?)")))
 (reconstruct_state_next_pc_decl_begin 0
  (reconstruct_state_next_pc_decl_begin-1 nil 3707504998
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case-replace "pc = 0")
        (("1" (expand reconstruct_state +)
          (("1" (assert)
            (("1" (assert)
              (("1" (rewrite reconstruct_state_zero)
                (("1" (assert)
                  (("1" (expand compose) (("1" (propax) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1" (assert)
                (("1"
                  (case "translate_next_pc(letexpr1_var, pc - 1) < translate_length(letexpr1_var)")
                  (("1" (assert)
                    (("1" (split -7)
                      (("1" (inst?)
                        (("1" (split -1)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (expand compose 2 1)
                                (("1" (decompose-equality 2) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (hide 3) (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (hide 3) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide 3)
                    (("2" (lemma decl_begin_next_pc)
                      (("2" (inst -1 letexpr1_var "pc-1")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (case-replace "pc = 1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case-replace
               "pc < 2+translate_length(letexpr1_var) + translate_length(letexpr2_var)")
              (("1" (expand reconstruct_state +)
                (("1" (assert)
                  (("1" (assert)
                    (("1"
                      (case "translate_next_pc(letexpr2_var,
                              -2 - translate_length(letexpr1_var) + pc) < translate_length(letexpr2_var)")
                      (("1" (assert)
                        (("1" (split -8)
                          (("1" (inst? -1)
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand compose 4 1)
                                    (("1"
                                      (decompose-equality 4)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (lemma decl_begin_next_pc)
                        (("2"
                          (inst -1 "letexpr2_var"
                           "-2 - translate_length(letexpr1_var) + pc")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(ift2_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1"
                (case "translate_next_pc(ift2_var, pc - 1) <
                    translate_length(ift2_var)")
                (("1" (assert)
                  (("1" (split -9)
                    (("1" (inst? -1)
                      (("1" (split -1)
                        (("1" (propax) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (lemma decl_begin_next_pc)
                  (("2" (inst -1 "ift2_var" "pc-1")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand reconstruct_state +)
            (("2" (assert)
              (("2" (assert)
                (("2" (split -8)
                  (("1" (inst? -1)
                    (("1" (split -1)
                      (("1" (propax) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2"
                      (case "-1 - translate_length(ift2_var) + pc = 0")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (expand reconstruct_state +)
          (("2" (assert)
            (("2" (assert)
              (("2" (split -7)
                (("1" (inst? -1)
                  (("1" (split -1)
                    (("1" (propax) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (hide 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite translate_stack_size_at_next_pc_decl_begin)
          (("15" (grind) nil nil)) nil))
        nil))
      nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (use decl_begin_next_pc) (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t)
        (("17" (use reconstruct_state_decl_begin_letexpr)
          (("17" (grind) nil nil)) nil))
        nil))
      nil)
     ("18" (hide 2)
      (("18" (skeep* :preds? t)
        (("18" (rewrite translate_stack_size_at_next_pc_decl_begin)
          (("18" (grind) nil nil)) nil))
        nil))
      nil)
     ("19" (hide 2)
      (("19" (skeep* :preds? t)
        (("19" (use decl_begin_next_pc) (("19" (grind) nil nil)) nil))
        nil))
      nil)
     ("20" (hide 2)
      (("20" (skeep* :preds? t)
        (("20" (use reconstruct_state_decl_begin_letexpr)
          (("20" (grind) nil nil)) nil))
        nil))
      nil)
     ("21" (hide 2)
      (("21" (skeep* :preds? t)
        (("21" (rewrite translate_stack_size_at_next_pc_decl_begin)
          (("21" (grind) nil nil)) nil))
        nil))
      nil)
     ("22" (hide 2)
      (("22" (skeep* :preds? t)
        (("22" (use decl_begin_next_pc) (("22" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((reconstruct_state_decl_begin_letexpr formula-decl nil itranslation
     nil)
    (translate_stack_size_at_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil nil nil nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil) nil nil nil
    nil nil nil
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IContext_letc_extensionality formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil nil
    (decl_begin_next_pc formula-decl nil itranslation nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (IContext_popc_extensionality formula-decl nil IL nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (newvar const-decl "nat" itranslation nil) nil
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reconstruct_state_zero formula-decl nil itranslation nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (shift const-decl "nat" itranslation nil)
    (compose def-decl "IContext" IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_extract_decl_begin def-decl "bool" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_skip_letexpr 0
  (reconstruct_state_skip_letexpr-1 nil 3707593714
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (grind) nil nil)
           ("2" (case "pc=1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc < 2+translate_length(letexpr1_var)+translate_length(letexpr2_var)")
              (("1" (expand reconstruct_state +)
                (("1" (assert)
                  (("1" (split -6)
                    (("1" (inst?) (("1" (grind) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc<1+translate_length(ift2_var)")
          (("1" (grind) nil nil)
           ("2" (expand reconstruct_state +)
            (("2" (assert)
              (("2" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (shift const-decl "nat" itranslation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (newvar const-decl "nat" itranslation nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_skip_letrhs_TCC1 0
  (reconstruct_state_skip_letrhs_TCC1-1 nil 3707580139
   ("" (skeep* :preds? t)
    (("" (use reconstruct_state_skip_letexpr) (("" (grind) nil nil))
      nil))
    nil)
   ((reconstruct_state_skip_letexpr formula-decl nil itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil
   (reconstruct_state_skip_letrhs subtype
    "itranslation.reconstruct_state(itranslation.A, itranslation.translate_vars, itranslation.S, itranslation.pc, itranslation.rv)`1"
    "(IExpression_adt.letexpr?)")))
 (reconstruct_state_skip_letrhs 0
  (reconstruct_state_skip_letrhs-1 nil 3707593484
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (grind) nil nil)
           ("2" (case "pc = 1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc <2+translate_length(letexpr1_var)+translate_length(letexpr2_var)")
              (("1" (expand reconstruct_state +)
                (("1" (assert)
                  (("1" (split -6)
                    (("1" (inst?) (("1" (grind) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc<1+translate_length(ift2_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (expand reconstruct_state +)
            (("2" (assert)
              (("2" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil)
     ("15" (grind) nil nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (use reconstruct_state_skip_letexpr)
          (("16" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((reconstruct_state_skip_letexpr formula-decl nil itranslation nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (shift const-decl "nat" itranslation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (newvar const-decl "nat" itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (endi const-decl "T" ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_skip_pureLetRedex 0
  (reconstruct_state_skip_pureLetRedex-1 nil 3707594247
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case "pc=0")
        (("1" (grind) nil nil)
         ("2" (case "pc<1+translate_length(letexpr1_var)")
          (("1" (grind) nil nil)
           ("2" (case "pc=1+translate_length(letexpr1_var)")
            (("1" (grind) nil nil)
             ("2"
              (case "pc<2+translate_length(letexpr1_var)+translate_length(letexpr2_var)")
              (("1" (expand reconstruct_state +)
                (("1" (assert)
                  (("1" (split -6)
                    (("1" (inst?) (("1" (grind) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc=0")
        (("1" (grind) nil nil)
         ("2" (case "pc<1+translate_length(ift2_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (expand reconstruct_state +)
            (("2" (assert)
              (("2" (split -7)
                (("1" (inst?) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil))
    nil)
   ((release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (shift const-decl "nat" itranslation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (newvar const-decl "nat" itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (endi const-decl "T" ireduction nil)
    (value? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (translate_is_result_defined def-decl "bool" itranslation nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (reconstruct_state_next_pc_skip_TCC1 0
  (reconstruct_state_next_pc_skip_TCC2-1 nil 3707571076
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc_skip)
      (("" (grind) nil nil)) nil))
    nil)
   ((translate_stack_size_at_next_pc_skip formula-decl nil itranslation
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (reconstruct_state_next_pc_skip subtype "itranslation.rv"
    "{rv: (ireduction.ivar?) | reals.<((number_fields.+)(ireduction.vindex(rv), itranslation.translate_stack_size_at(itranslation.A, itranslation.translate_next_pc(itranslation.A, itranslation.pc))), itranslation.S2`length)}")))
 (reconstruct_state_next_pc_skip 0
  (reconstruct_state_next_pc_skip-1 nil 3707571076
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (case-replace "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(letexpr1_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1"
                (case "translate_next_pc(letexpr1_var, pc - 1) < translate_length(letexpr1_var)")
                (("1" (assert)
                  (("1" (split -7)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (expand compose +)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (hide 3)
                  (("2" (lemma skip_next_pc)
                    (("2" (inst -1 letexpr1_var "pc-1")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2"
            (case-replace "pc = 1 + translate_length(letexpr1_var)")
            (("1" (expand reconstruct_state +)
              (("1" (assert)
                (("1" (assert)
                  (("1" (rewrite reconstruct_state_zero +)
                    (("1" (assert)
                      (("1" (expand compose +)
                        (("1" (decompose-equality 3)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2"
              (case "pc < 2 + translate_length(letexpr1_var) + translate_length(letexpr2_var)")
              (("1" (expand reconstruct_state +)
                (("1" (assert)
                  (("1" (assert)
                    (("1"
                      (case "translate_next_pc(letexpr2_var,
                              -2 - translate_length(letexpr1_var) + pc) < translate_length(letexpr2_var)")
                      (("1" (assert)
                        (("1" (split -8)
                          (("1" (inst? -1)
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand compose +)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (hide 5)
                        (("2" (lemma skip_next_pc)
                          (("2" (inst? :where 1)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (case "pc = 0")
        (("1" (grind) nil nil)
         ("2" (case "pc < 1+translate_length(ift2_var)")
          (("1" (expand reconstruct_state +)
            (("1" (assert)
              (("1"
                (case "translate_next_pc(ift2_var, pc - 1) <
                    translate_length(ift2_var)")
                (("1" (assert)
                  (("1" (split -9)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (propax) nil nil)
                         ("2" (assert) (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (hide 3)
                  (("2" (lemma skip_next_pc)
                    (("2" (inst? :where +) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (expand reconstruct_state +)
              (("2" (assert)
                (("2" (split -8)
                  (("1" (inst? -1)
                    (("1" (split -1)
                      (("1" (propax) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("2"
                      (case "-1 - translate_length(ift2_var) + pc=0")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil) ("14" (grind) nil nil)
     ("15" (grind) nil nil)
     ("16" (hide 2)
      (("16" (skeep* :preds? t)
        (("16" (rewrite translate_stack_size_at_next_pc_skip)
          (("16" (grind) nil nil)) nil))
        nil))
      nil)
     ("17" (hide 2)
      (("17" (skeep* :preds? t) (("17" (rewrite skip_next_pc) nil nil))
        nil))
      nil)
     ("18" (hide 2)
      (("18" (skeep* :preds? t)
        (("18" (rewrite translate_stack_size_at_next_pc_skip)
          (("18" (grind) nil nil)) nil))
        nil))
      nil)
     ("19" (hide 2)
      (("19" (skeep* :preds? t) (("19" (rewrite skip_next_pc) nil nil))
        nil))
      nil)
     ("20" (hide 2)
      (("20" (skeep* :preds? t)
        (("20" (use reconstruct_state_skip_letexpr)
          (("20" (grind) nil nil)) nil))
        nil))
      nil)
     ("21" (hide 2)
      (("21" (skeep* :preds? t)
        (("21" (rewrite translate_stack_size_at_next_pc_skip)
          (("21" (grind) nil nil)) nil))
        nil))
      nil)
     ("22" (hide 2)
      (("22" (skeep* :preds? t) (("22" (rewrite skip_next_pc) nil nil))
        nil))
      nil))
    nil)
   ((reconstruct_state_skip_letexpr formula-decl nil itranslation nil)
    (translate_stack_size_at_next_pc_skip formula-decl nil itranslation
     nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil nil (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil) nil nil nil
    nil nil nil
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (skip_next_pc formula-decl nil itranslation nil) nil nil nil nil
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (shift const-decl "nat" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (reconstruct_state_zero formula-decl nil itranslation nil)
    (newvar const-decl "nat" itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (compose def-decl "IContext" IL nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_extract_skip def-decl "bool" itranslation nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (npopcs_TCC1 0
  (npopcs_TCC1-1 nil 3707050345 ("" (termination-tcc) nil nil) nil nil
   (npopcs termination "npopcs(n - 1, K)" "nil")))
 (npopcs_popDepth 0
  (npopcs_popDepth-1 nil 3707078560
   ("" (induct k) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (npopcs def-decl "IContext" itranslation nil) nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (npopcs_fill 0
  (npopcs_fill-1 nil 3707483618 ("" (induct-and-simplify k) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fill def-decl "IExpression" IL nil)
    (npopcs def-decl "IContext" itranslation nil)
    (npops def-decl "IExpression" iareduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npopcs_compose 0
  (npopcs_compose-1 nil 3707508591 ("" (induct-and-simplify k) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (compose def-decl "IContext" IL nil)
    (npopcs def-decl "IContext" itranslation nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npops_end 0
  (npops_end-1 nil 3707483632 ("" (induct-and-simplify k) nil nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (npops def-decl "IExpression" iareduction nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (fct_reconstruct_state_TCC1 0
  (fct_reconstruct_state_TCC1-1 nil 3707055204
   ("" (subtype-tcc) nil nil) nil nil
   (fct_reconstruct_state subtype "fdepth - 1" "below(S`length)")))
 (fct_reconstruct_state_TCC2 0
  (fct_reconstruct_state_TCC2-1 nil 3707055204
   ("" (subtype-tcc) nil nil) nil nil
   (fct_reconstruct_state subtype "fdepth - 1" "below(S`length)")))
 (fct_reconstruct_state_TCC3 0
  (fct_reconstruct_state_TCC3-1 nil 3707055204
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (fct_reconstruct_state subtype "fdepth - 2" "nat")))
 (fct_reconstruct_state_TCC4 0
  (fct_reconstruct_state_TCC4-1 nil 3707055204
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (fct_reconstruct_state subtype "pc" "below(translate_length(A))")))
 (fct_reconstruct_state_TCC5 0
  (fct_reconstruct_state_TCC5-1 nil 3707055204
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (fct_reconstruct_state subtype "ireduction.ivar(arity, FALSE)"
    "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(A, pc) < S`length}")))
 (fct_is_result_defined_TCC1 0
  (fct_is_result_defined_TCC1-1 nil 3707580139
   ("" (subtype-tcc) nil nil) nil nil
   (fct_is_result_defined subtype
    "(number_fields.-)(itranslation.fdepth, 1)"
    "naturalnumbers.below(itranslation.S`length)")))
 (fct_is_result_defined_assign_next_pc_TCC1 0
  (fct_is_result_defined_assign_next_pc_TCC1-1 nil 3707587626
   ("" (subtype-tcc) nil nil) nil nil
   (fct_is_result_defined_assign_next_pc subtype "itranslation.pc"
    "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))
 (fct_is_result_defined_assign_next_pc_TCC2 0
  (fct_is_result_defined_assign_next_pc_TCC2-1 nil 3707587626
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc)
      (("1" (grind) nil nil)
       ("2" (use translate_extract_decl_begin_is_assign)
        (("2" (grind) nil nil)) nil)
       ("3" (use translate_extract_decl_end_is_assign)
        (("3" (assert) nil nil)) nil)
       ("4" (use translate_extract_skip_is_assign)
        (("4" (assert) nil nil)) nil))
      nil))
    nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_is_result_defined_assign_next_pc subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_is_result_defined_assign_next_pc_TCC3 0
  (fct_is_result_defined_assign_next_pc_TCC3-1 nil 3707587626
   ("" (skeep* :preds? t)
    (("" (use avar_assign_vindex_bound) (("" (grind) nil nil)) nil))
    nil)
   ((avar_assign_vindex_bound formula-decl nil itranslation nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_is_result_defined_assign_next_pc subtype
    "ireduction.vindex(ireduction.avar(itranslation.translate_extract_assign(itranslation.A, ireduction.ivar(itranslation.arity, booleans.FALSE), (LAMBDA j: itranslation.j), itranslation.pc)))"
    "naturalnumbers.below(itranslation.S`length)")))
 (fct_is_result_defined_assign_next_pc 0
  (fct_is_result_defined_assign_next_pc-1 nil 3707587626
   ("" (skeep* :preds? t)
    (("" (expand fct_is_result_defined +)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (rewrite avar_assign_next_pc_overflow)
              (("1" (assert)
                (("1" (case "translate_stack_size_at(A, pc) = 0")
                  (("1" (grind) nil nil)
                   ("2"
                    (case "translate_stack_size_at(A, translate_next_pc(A, pc)) = 0")
                    (("1" (rewrite translate_stack_size_at_next_pc)
                      (("1"
                        (use translate_extract_decl_begin_is_assign)
                        (("1" (assert) nil nil)) nil)
                       ("2" (use translate_extract_decl_end_is_assign)
                        (("2" (assert) nil nil)) nil)
                       ("3" (use translate_extract_skip_is_assign)
                        (("3" (assert) nil nil)) nil))
                      nil)
                     ("2" (assert)
                      (("2" (replace -1) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (use translate_is_result_defined_assign_next_pc)
              (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fct_is_result_defined const-decl "bool" itranslation nil)
    (avar_assign_next_pc_overflow formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_is_result_defined_assign_next_pc formula-decl nil
     itranslation nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (fct_reconstruct_state_tv_TCC1 0
  (fct_reconstruct_state_tv_TCC1-1 nil 3707075743
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_tv subtype "pc"
    "{pc: upto(translate_length(A)) | pc = translate_length(A) OR 1 + arity + translate_stack_size_at(A, pc) = fdepth}")))
 (fct_reconstruct_state_tv 0
  (fct_reconstruct_state_tv-2 nil 3707245894
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state)
      (("" (lift-if)
        (("" (split +)
          (("1" (flatten)
            (("1" (assert)
              (("1" (case-replace "fdepth = 1")
                (("1" (grind) nil nil)
                 ("2" (assert)
                  (("2" (rewrite npopcs_popDepth)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (assert)
              (("2" (rewrite npopcs_popDepth)
                (("2"
                  (case "j < popDepth(reconstruct_state(A,
                                             (LAMBDA j: j),
                                             S,
                                             pc,
                                             ivar(arity, FALSE))`2) +  popDepth(reconstruct_state(A,
                                             (LAMBDA j: j),
                                             S,
                                             pc,
                                             ivar(arity, FALSE))`1)")
                  (("1" (use reconstruct_state_popDepth)
                    (("1" (use reconstruct_state_tv_low)
                      (("1" (grind) nil nil)) nil))
                    nil)
                   ("2" (rewrite reconstruct_state_tv_high)
                    (("2" (use reconstruct_state_popDepth)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (npopcs_popDepth formula-decl nil itranslation nil)
    (IContext type-decl nil IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil) nil nil
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (reconstruct_state_tv_low formula-decl nil itranslation nil)
    (reconstruct_state_popDepth formula-decl nil itranslation nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (reconstruct_state_tv_high formula-decl nil itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (< const-decl "bool" reals nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil)
  (fct_reconstruct_state_tv-1 nil 3707075744
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state)
      (("" (lift-if)
        (("" (split +)
          (("1" (flatten)
            (("1" (assert)
              (("1" (case-replace "fdepth = 1")
                (("1" (grind) nil nil)
                 ("2" (assert)
                  (("2" (rewrite npopcs_popDepth)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (assert)
              (("2" (rewrite npopcs_popDepth)
                (("2"
                  (case "j < popDepth(reconstruct_state(A,
                                    (LAMBDA j: j),
                                    S,
                                    pc,
                                    ivar(arity, FALSE))`2)")
                  (("1" (use reconstruct_state_popDepth)
                    (("1" (use reconstruct_state_tv_low)
                      (("1" (grind) nil nil)) nil))
                    nil)
                   ("2" (rewrite reconstruct_state_tv_high)
                    (("2" (use reconstruct_state_popDepth)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (npopcs_popDepth formula-decl nil itranslation nil)
    (IContext type-decl nil IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (reconstruct_state_tv_low formula-decl nil itranslation nil)
    (reconstruct_state_popDepth formula-decl nil itranslation nil)
    (reconstruct_state_tv_high formula-decl nil itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (< const-decl "bool" reals nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (fct_reconstruct_state_tv_next_pc_TCC1 0
  (fct_reconstruct_state_tv_next_pc_TCC2-1 nil 3707496355
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc)
      (("" (assert) nil nil)) nil))
    nil)
   ((translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_tv_next_pc subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_tv_next_pc_TCC2 0
  (fct_reconstruct_state_tv_next_pc_TCC3-1 nil 3707497163
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (fct_reconstruct_state_tv_next_pc subtype "itranslation.fdepth"
    "{fdepth: integers.posnat | reals.<=(fdepth, itranslation.S2`length)}")))
 (fct_reconstruct_state_tv_next_pc_TCC3 0
  (fct_reconstruct_state_tv_next_pc_TCC3-1 nil 3707496355
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_tv_next_pc subtype "itranslation.pc"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_tv_next_pc 0
  (fct_reconstruct_state_tv_next_pc-1 nil 3707496356
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state)
      (("" (lift-if)
        (("" (split)
          (("1" (flatten)
            (("1" (use reconstruct_state_tv_next_pc_overflow)
              (("1" (assert) nil nil)) nil))
            nil)
           ("2" (flatten)
            (("2" (use reconstruct_state_tv_next_pc)
              (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (reconstruct_state_tv_next_pc_overflow formula-decl nil
     itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reconstruct_state_tv_next_pc formula-decl nil itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (fct_reconstruct_state_next_pc_TCC1 0
  (fct_reconstruct_state_next_pc_TCC1-1 nil 3707482641
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc)
      (("1" (assert) nil nil)
       ("2" (use translate_extract_decl_begin_is_assign)
        (("2" (assert) nil nil)) nil)
       ("3" (assert)
        (("3" (use translate_extract_decl_end_is_assign)
          (("3" (assert) nil nil)) nil))
        nil)
       ("4" (use translate_extract_skip_is_assign)
        (("4" (assert) nil nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc subtype "pc"
    "upto(translate_length(A))")))
 (fct_reconstruct_state_next_pc_TCC2 0
  (fct_reconstruct_state_next_pc_TCC3-1 nil 3707496512
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc subtype "itranslation.pc"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_next_pc 0
  (fct_reconstruct_state_next_pc-1 nil 3707482642
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state +)
      (("" (lift-if +)
        (("" (split +)
          (("1" (flatten)
            (("1" (split)
              (("1" (flatten)
                (("1" (rewrite npopcs_fill)
                  (("1" (expand fill 1 1)
                    (("1" (case-replace "arity = 0")
                      (("1" (expand npops)
                        (("1"
                          (rewrite
                           reconstruct_state_assign_hole_pc_overflow)
                          (("1" (expand fill 1)
                            (("1"
                              (rewrite avar_assign_next_pc_overflow)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (rewrite npopcs_fill)
                  (("2" (rewrite npopcs_fill)
                    (("2" (expand fill 2 1)
                      (("2"
                        (rewrite
                         reconstruct_state_assign_hole_pc_overflow)
                        (("2" (expand fill 2)
                          (("2" (replace -8 :dir RL)
                            (("2" (assert)
                              (("2"
                                (case-replace
                                 "translate_stack_size_at(A, pc) = 0")
                                (("1"
                                  (assert)
                                  (("1"
                                    (rewrite
                                     avar_assign_next_pc_overflow)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (rewrite npops_end)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (case-replace
                                   "translate_stack_size_at(A, pc) = translate_stack_size_at(A, translate_next_pc(A, pc))")
                                  (("1"
                                    (replace -2)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (rewrite
                                     translate_stack_size_at_next_pc)
                                    (("1"
                                      (use
                                       translate_extract_decl_begin_is_assign)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2"
                                      (use
                                       translate_extract_decl_end_is_assign)
                                      (("2" (grind) nil nil))
                                      nil)
                                     ("3"
                                      (use
                                       translate_extract_skip_is_assign)
                                      (("3" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (use reconstruct_state_next_pc)
              (("2" (split)
                (("1" (rewrite npopcs_fill)
                  (("1" (rewrite npopcs_fill) (("1" (assert) nil nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil) ("3" (propax) nil nil)
                 ("4" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (npopcs_fill formula-decl nil itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (ivalue type-decl nil ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (endi const-decl "T" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (istat type-decl nil ireduction nil)
    (iassign? adt-recognizer-decl "[istat -> boolean]" ireduction nil)
    (avar adt-accessor-decl "[(iassign?) -> (ivar?)]" ireduction nil)
    (pure? def-decl "bool" IL nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_extract_is_assign def-decl "bool" itranslation nil)
    (translate_extract_assign def-decl "(iassign?)" itranslation nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (reconstruct_state_assign_hole_pc_overflow formula-decl nil
     itranslation nil)
    (avar_assign_next_pc_overflow formula-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (npops def-decl "IExpression" iareduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fill def-decl "IExpression" IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (translate_stack_size_at_next_pc formula-decl nil itranslation nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (npops_end formula-decl nil itranslation nil)
    (reconstruct_state_next_pc formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (fct_reconstruct_state_next_pc_decl_begin_TCC1 0
  (fct_reconstruct_state_next_pc_decl_begin_TCC2-1 nil 3707508336
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_decl_begin subtype
    "(number_fields.+)(itranslation.fdepth, 1)"
    "{fdepth: integers.posnat | reals.<=(fdepth, itranslation.S2`length)}")))
 (fct_reconstruct_state_next_pc_decl_begin_TCC2 0
  (fct_reconstruct_state_next_pc_decl_begin_TCC3-1 nil 3707508336
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc_decl_begin)
      (("" (grind) nil nil)) nil))
    nil)
   ((translate_stack_size_at_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_decl_begin subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)(itranslation.arity, itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_next_pc_decl_begin_TCC3 0
  (fct_reconstruct_state_next_pc_decl_begin_TCC4-1 nil 3707508336
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_decl_begin subtype "itranslation.pc"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_next_pc_decl_begin_TCC4 0
  (fct_reconstruct_state_next_pc_decl_begin_TCC5-1 nil 3707508336
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state)
      (("" (use reconstruct_state_decl_begin_letexpr)
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (reconstruct_state_decl_begin_letexpr formula-decl nil itranslation
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_decl_begin subtype
    "itranslation.fct_reconstruct_state(itranslation.A, itranslation.S, itranslation.arity, itranslation.fdepth, itranslation.pc)`1"
    "(IExpression_adt.letexpr?)")))
 (fct_reconstruct_state_next_pc_decl_begin 0
  (fct_reconstruct_state_next_pc_decl_begin-1 nil 3707508336
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state)
      (("" (case "translate_next_pc(A, pc) < translate_length(A)")
        (("1" (assert)
          (("1" (use reconstruct_state_next_pc_decl_begin)
            (("1" (assert)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (rewrite npopcs_compose)
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (use decl_begin_next_pc) (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (decl_begin_next_pc formula-decl nil itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (npopcs_compose formula-decl nil itranslation nil)
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (reconstruct_state_next_pc_decl_begin formula-decl nil itranslation
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (fct_reconstruct_state_next_pc_skip_TCC1 0
  (fct_reconstruct_state_next_pc_skip_TCC1-1 nil 3707573408
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_skip subtype "itranslation.fdepth"
    "{fdepth: integers.posnat | reals.<=(fdepth, itranslation.S2`length)}")))
 (fct_reconstruct_state_next_pc_skip_TCC2 0
  (fct_reconstruct_state_next_pc_skip_TCC2-1 nil 3707573408
   ("" (skeep* :preds? t)
    (("" (rewrite translate_stack_size_at_next_pc_skip)
      (("" (grind) nil nil)) nil))
    nil)
   ((translate_stack_size_at_next_pc_skip formula-decl nil itranslation
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_skip subtype
    "itranslation.translate_next_pc(itranslation.A, itranslation.pc)"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_next_pc_skip_TCC3 0
  (fct_reconstruct_state_next_pc_skip_TCC3-1 nil 3707573408
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_skip subtype "itranslation.pc"
    "{pc: naturalnumbers.upto(itranslation.translate_length(itranslation.A)) | booleans.OR(pc = itranslation.translate_length(itranslation.A), (number_fields.+)((number_fields.+)(1, itranslation.arity), itranslation.translate_stack_size_at(itranslation.A, pc)) = itranslation.fdepth)}")))
 (fct_reconstruct_state_next_pc_skip_TCC4 0
  (fct_reconstruct_state_next_pc_skip_TCC4-1 nil 3707573408
   ("" (skeep* :preds? t)
    (("" (expand fct_reconstruct_state)
      (("" (use reconstruct_state_skip_letexpr) (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (iexpr type-decl nil ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (FALSE const-decl "bool" booleans nil)
    (reconstruct_state_skip_letexpr formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (fct_reconstruct_state_next_pc_skip subtype
    "itranslation.fct_reconstruct_state(itranslation.A, itranslation.S, itranslation.arity, itranslation.fdepth, itranslation.pc)`1"
    "(IExpression_adt.letexpr?)")))
 (fct_reconstruct_state_next_pc_skip 0
  (fct_reconstruct_state_next_pc_skip-1 nil 3707573409
   ("" (skeep* :preds? t)
    (("" (case "translate_next_pc(A, pc) < translate_length(A)")
      (("1" (expand fct_reconstruct_state)
        (("1" (assert)
          (("1" (use reconstruct_state_next_pc_skip)
            (("1" (split -1)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (rewrite npopcs_compose)
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use skip_next_pc) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (below type-eq-decl nil nat_types nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (npopcs_compose formula-decl nil itranslation nil)
    (IContext type-decl nil IL nil)
    (reconstruct_state def-decl "[IExpression, IContext, [nat -> nat]]"
     itranslation nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (reconstruct_state_next_pc_skip formula-decl nil itranslation nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (skip_next_pc formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (call_reconstruct_state_TCC1 0
  (call_reconstruct_state_TCC1-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (call_reconstruct_state subtype "pc - 1"
    "{pc: upto(translate_length(B)) | translate_is_fun_call_at(B, pc, f)}")))
 (call_reconstruct_state_TCC2 0
  (call_reconstruct_state_TCC2-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (call_reconstruct_state subtype "pc - 2 - lb1"
    "{pc: upto(translate_length(C)) | translate_is_fun_call_at(C, pc, f)}")))
 (call_reconstruct_state_TCC3 0
  (call_reconstruct_state_TCC3-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (call_reconstruct_state subtype "pc - 1"
    "{pc: upto(translate_length(B)) | translate_is_fun_call_at(B, pc, f)}")))
 (call_reconstruct_state_TCC4 0
  (call_reconstruct_state_TCC4-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (call_reconstruct_state subtype "pc - 1 - lb1"
    "{pc: upto(translate_length(C)) | translate_is_fun_call_at(C, pc, f)}")))
 (call_reconstruct_state_TCC5 0
  (call_reconstruct_state_TCC5-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (call_reconstruct_state subtype "pc - 1"
    "{pc: upto(translate_length(B)) | translate_is_fun_call_at(B, pc, f)}")))
 (call_reconstruct_state_TCC6 0
  (call_reconstruct_state_TCC6-1 nil 3706987728 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (call_reconstruct_state cases "A" "IExpression: DATATYPE
 BEGIN
  variable(index: nat, marked: bool): variable?
  constant(value: int): constant?
  nil: nil?
  application(fun: nat, args: list[(variable?)]): application?
  letexpr(letrhs: IExpression, body: IExpression): letexpr?
  ift(condition: (variable?), thenexpr, elseexpr: IExpression): ift?
  update(target, lhs, rhs: (variable?)): update?
  lookup(arrayvalue, position: (variable?)): lookup?
  newint(size: nat): newint?
  newref(size: nat): newref?
  pop(pbody: IExpression): pop?
  ref(refindex: nat): ref?
  release(rvar: (variable?), rexpr: IExpression): release?
 END IExpression")))
 (call_reconstruct_state_tv_high_TCC1 0
  (call_reconstruct_state_tv_high_TCC1-1 nil 3707073824
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (call_reconstruct_state_tv_high subtype
    "j - IL.popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1)"
    "nat")))
 (call_reconstruct_state_tv_high 0
  (call_reconstruct_state_tv_high-1 nil 3707073824
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand call_reconstruct_state +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (flatten)
              (("1" (expand translate_stack_size_at +)
                (("1" (lift-if +)
                  (("1" (split +)
                    (("1" (grind) nil nil)
                     ("2" (flatten)
                      (("2" (assert)
                        (("2" (split -6)
                          (("1" (inst? -1)
                            (("1" (split)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (expand translate_stack_size_at +)
                (("2" (assert)
                  (("2" (lift-if +)
                    (("2" (split +)
                      (("1" (flatten)
                        (("1"
                          (case-replace
                           "pc = 1 + translate_length(letexpr1_var)")
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split +)
                          (("1" (flatten)
                            (("1" (split -7)
                              (("1"
                                (inst? -1)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand call_reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (flatten)
              (("1" (split -8)
                (("1" (inst?)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split -8)
                (("1" (inst? -1)
                  (("1" (expand translate_stack_size_at +)
                    (("1" (assert)
                      (("1"
                        (case-replace
                         "pc = 1 + translate_length(ift2_var)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand call_reconstruct_state +)
        (("14" (split -7)
          (("1" (inst? -1)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("15" (grind) nil nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt
     nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt
     nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (translate_stack_size_at_end formula-decl nil itranslation nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (newvar const-decl "nat" itranslation nil) nil nil nil nil
    (shift const-decl "nat" itranslation nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (IContext type-decl nil IL nil) nil
    (call_reconstruct_state def-decl "[IContext, [nat -> nat]]"
     itranslation nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (call_reconstruct_state_tv_low 0
  (call_reconstruct_state_tv_low-1 nil 3707074289
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep* :preds? t)
      (("6" (expand call_reconstruct_state +)
        (("6" (lift-if +)
          (("6" (split +)
            (("1" (flatten)
              (("1" (split -6)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (expand translate_stack_size_at +)
                (("2" (assert)
                  (("2"
                    (case-replace
                     "pc = 1 + translate_length(letexpr1_var)")
                    (("1" (grind) nil nil)
                     ("2" (assert)
                      (("2" (lift-if +)
                        (("2" (split +)
                          (("1" (flatten)
                            (("1" (split -7)
                              (("1"
                                (inst? -1)
                                (("1"
                                  (split -1)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand call_reconstruct_state -8)
                                    (("2"
                                      (expand popDepth -8)
                                      (("2"
                                        (case-replace
                                         "j = popDepth(call_reconstruct_state(letexpr2_var,
                                       newvar(translate_vars),
                                       f,
                                       -2 - translate_length(letexpr1_var)
                                       +
                                       pc)`1)")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (rewrite
                                             call_reconstruct_state_tv_high)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand call_reconstruct_state +)
        (("7" (lift-if +)
          (("7" (split +)
            (("1" (flatten)
              (("1" (split -8)
                (("1" (inst? -1)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split -8)
                (("1" (inst? -1)
                  (("1" (expand translate_stack_size_at +)
                    (("1"
                      (case-replace
                       "pc = 1 + translate_length(ift2_var)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (skeep* :preds? t)
      (("14" (expand call_reconstruct_state +)
        (("14" (split -7)
          (("1" (inst? -1)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    nil nil nil nil
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt
     nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt
     nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (translate_stack_size_at_zero formula-decl nil itranslation nil)
    nil nil nil nil nil
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (call_reconstruct_state_tv_high formula-decl nil itranslation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (newvar const-decl "nat" itranslation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    nil nil nil nil (shift const-decl "nat" itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (call_reconstruct_state def-decl "[IContext, [nat -> nat]]"
     itranslation nil)
    nil (IContext type-decl nil IL nil) (< const-decl "bool" reals nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (translate_length def-decl "posnat" itranslation nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (compose_all_TCC1 0
  (compose_all_TCC1-1 nil 3707050345 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (compose_all subtype "l"
    "{S: finseq[IL.IContext] | S`length > 0}")))
 (compose_all_TCC2 0
  (compose_all_TCC2-1 nil 3707050345 ("" (termination-tcc) nil nil)
   ((pop const-decl "finseq[T]" ireduction nil)) nil
   (compose_all termination "compose_all(ireduction.pop(l))" "nil")))
 (compose_all_TCC3 0
  (compose_all_TCC3-1 nil 3707050345 ("" (subtype-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (compose_all subtype "0" "below(l`length)")))
 (compose_popDepth 0
  (compose_popDepth-1 nil 3707057890
   ("" (induct-and-simplify K1) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (compose def-decl "IContext" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IContext_induction formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (pop_add_TCC1 0
  (pop_add_TCC1-1 nil 3707059166 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil))
   nil
   (pop_add subtype "more_finseq[T].add(x, l)"
    "{S: finseq[T] | S`length > 0}")))
 (pop_add 0
  (pop_add-1 nil 3707059166
   ("" (skeep* :preds? t)
    (("" (decompose-equality)
      (("1" (grind) nil nil)
       ("2" (decompose-equality) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (finseq type-eq-decl nil finite_sequences nil) nil
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil))
   shostak))
 (sum_TCC1 0
  (sum_TCC1-1 nil 3707058798
   ("" (skeep) (("" (use below_finite) nil nil)) nil)
   ((finseq type-eq-decl nil finite_sequences nil) nil
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_finite formula-decl nil finite_set_theorems nil))
   nil (sum subtype "(LAMBDA i: i < l`length)" "finite_set[nat]")))
 (sum_pop_TCC1 0
  (sum_pop_TCC1-1 nil 3707058798 ("" (subtype-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (sum_pop subtype "0" "below(l`length)")))
 (sum_pop 0
  (sum_pop-1 nil 3707063509
   ("" (skeep* :preds? t)
    (("" (expand sum)
      (("" (lemma sigma_add)
        (("" (inst -1 "LAMBDA i: i < l`length" _ "l`length - 1")
          (("1" (inst?)
            (("1" (split)
              (("1" (rewrite -1)
                (("1" (expand endi)
                  (("1"
                    (case-replace
                     "remove(l`length - 1, LAMBDA i: i < l`length) = LAMBDA i: i < pop(l)`length")
                    (("1" (use sigma_eq)
                      (("1" (split)
                        (("1" (propax) nil nil) ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil)
                       ("3" (lemma below_finite)
                        (("3" (inst -1 "pop(l)`length") nil nil)) nil))
                      nil)
                     ("2" (grind)
                      (("2" (grind)
                        (("2" (grind)
                          (("2" (decompose-equality)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil) ("3" (use below_finite) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((sum const-decl "nat" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil) nil
    (finseq type-eq-decl nil finite_sequences nil) nil
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (endi const-decl "T" ireduction nil)
    (/= const-decl "boolean" notequal nil)
    (sigma_eq formula-decl nil finite_set_theorems nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below_finite formula-decl nil finite_set_theorems nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (remove const-decl "set" sets nil) (> const-decl "bool" reals nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma_add formula-decl nil finite_set_theorems nil))
   shostak))
 (sum_add 0
  (sum_add-1 nil 3707063728
   ("" (skeep)
    (("" (rewrite sum_pop)
      (("1" (rewrite pop_add) (("1" (grind) nil nil)) nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((sum_pop formula-decl nil itranslation nil) nil
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (endi const-decl "T" ireduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (sum const-decl "nat" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (pop_add formula-decl nil itranslation nil))
   shostak))
 (sum_emptyseq 0
  (sum_emptyseq-1 nil 3707063745
   ("" (skeep*)
    (("" (expand sum) (("" (expand Sigma) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((sum const-decl "nat" itranslation nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (Sigma def-decl "nat" finite_set_theorems nil))
   shostak))
 (sum_eq_TCC1 0
  (sum_eq_TCC1-1 nil 3707058798 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil) nil
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil (sum_eq subtype "i" "below[l2`length]")))
 (sum_eq 0
  (sum_eq-1 nil 3707063762
   ("" (skeep* :preds? t)
    (("" (expand sum)
      (("" (replace -1)
        (("" (use sigma_eq)
          (("1" (split) (("1" (propax) nil nil) ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil) ("3" (use below_finite) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((sum const-decl "nat" itranslation nil)
    (sigma_eq formula-decl nil finite_set_theorems nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil nil
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil) nil
    (finseq type-eq-decl nil finite_sequences nil) nil
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below_finite formula-decl nil finite_set_theorems nil))
   shostak))
 (sum_map 0
  (sum_map-1 nil 3707066146
   ("" (skeep* :preds? t)
    (("" (use "sum_eq[T,nat]") (("" (grind) nil nil)) nil)) nil)
   ((sum_eq formula-decl nil itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) nil
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (sum const-decl "nat" itranslation nil))
   shostak))
 (fdepth_sum_sum 0
  (fdepth_sum_sum-1 nil 3707066181
   ("" (skeep* :preds? t)
    (("" (expand fdepth_sum)
      (("" (expand sum) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((fdepth_sum const-decl "nat" ireduction nil)
    (sum const-decl "nat" itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (istate_stack_length 0
  (istate_stack_length-1 nil 3707065237
   ("" (skeep*)
    (("" (typepred "iS`stack")
      (("" (rewrite -1)
        (("" (expand fdepth_sum)
          (("" (expand sum) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (sum const-decl "nat" itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (compose_all_popDepth 0
  (compose_all_popDepth-1 nil 3707057653
   ("" (induct l :name "finseq_induct[IContext]")
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (rewrite sum_add)
        (("2" (expand compose_all 1)
          (("2" (rewrite pop_add)
            (("2" (rewrite compose_popDepth)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (endi const-decl "T" ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop_add formula-decl nil itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sum_add formula-decl nil itranslation nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (Sigma def-decl "nat" finite_set_theorems nil)
    (finseq_induct formula-decl nil finseq_theorems nil)
    (IContext type-decl nil IL nil)
    (sum const-decl "nat" itranslation nil)
    (compose_all def-decl "IContext" itranslation nil) nil
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (compose_translate_vars_TCC1 0
  (compose_translate_vars_TCC1-1 nil 3707057647
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (compose_translate_vars subtype "i - pdepth" "nat")))
 (compose_all_tv_TCC1 0
  (compose_all_tv_TCC1-1 nil 3707057647 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (endi const-decl "T" ireduction nil))
   nil
   (compose_all_tv subtype "l"
    "{S: finseq[[[nat -> nat], nat, nat]] | S`length > 0}")))
 (compose_all_tv_TCC2 0
  (compose_all_tv_TCC2-1 nil 3707057647 ("" (termination-tcc) nil nil)
   ((endi const-decl "T" ireduction nil)
    (pop const-decl "finseq[T]" ireduction nil))
   nil
   (compose_all_tv termination "compose_all_tv(ireduction.pop(l))"
    "nil")))
 (compose_all_tv_TCC3 0
  (compose_all_tv_TCC3-1 nil 3707057647 ("" (subtype-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (compose_all_tv subtype "0" "below(l`length)")))
 (compose_all_tv_bound 0
  (compose_all_tv_bound-1 nil 3707058799
   ("" (induct l :name "finseq_induct[[[nat->nat],nat,nat]]")
    (("1" (assert)
      (("1" (skeep)
        (("1" (assert)
          (("1" (rewrite sum_emptyseq) (("1" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (rewrite sum_add)
        (("2" (rewrite sum_add)
          (("2" (expand compose_all_tv +)
            (("2" (assert)
              (("2" (rewrite pop_add)
                (("2" (expand add +)
                  (("2" (expand endi +)
                    (("2" (assert)
                      (("2" (assert)
                        (("2" (expand compose_translate_vars +)
                          (("2" (lift-if)
                            (("2" (split)
                              (("1"
                                (inst -3 "S`length")
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst -4 k)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (inst?)
                                  (("1"
                                    (split)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (skeep* :preds? t)
                                      (("2"
                                        (inst -4 i j)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil)
                                         ("3" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("3" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil nil (seq type-eq-decl nil more_finseq nil) nil
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    nil nil (endi const-decl "T" ireduction nil)
    (pop_add formula-decl nil itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sum_add formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sum_emptyseq formula-decl nil itranslation nil)
    (finseq_induct formula-decl nil finseq_theorems nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (compose_all_tv def-decl "[nat -> nat]" itranslation nil)
    (sum const-decl "nat" itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil))
   shostak))
 (store_matches_TCC1 0
  (store_matches_TCC1-1 nil 3707055204 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil))
   nil (store_matches subtype "j" "below[str2(i)`length]")))
 (translate_defs_funcall_TCC1 0
  (translate_defs_funcall_TCC2-1 nil 3707071271
   ("" (subtype-tcc) nil nil)
   ((translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil))
   nil
   (translate_defs_funcall subtype "i" "below[iS`callstack`length]")))
 (translate_defs_funcall_TCC2 0
  (translate_defs_funcall_TCC3-1 nil 3707071271
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil))
   nil
   (translate_defs_funcall subtype "iS`callstack`seq(i)`ffct"
    "below[D`length]")))
 (translate_defs_funcall_TCC3 0
  (translate_defs_funcall_TCC4-1 nil 3707071271
   ("" (skeep* :preds? t)
    (("" (typepred "iS`callstack`seq(i)`fpc")
      (("" (replace -4)
        (("" (expand translate_definitions -1) (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (translate_length_def formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (translate_defs_funcall subtype "iS`callstack`seq(i)`fpc"
    "upto(translate_length(D`seq(iS`callstack`seq(i)`ffct)`body))")))
 (translate_defs_funcall_TCC4 0
  (translate_defs_funcall_TCC5-1 nil 3707071271
   ("" (subtype-tcc) nil nil)
   ((translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil))
   nil
   (translate_defs_funcall subtype "i + 1"
    "below[iS`callstack`length]")))
 (translate_defs_funcall 0
  (translate_defs_funcall-1 nil 3707078626
   ("" (skeep* :preds? t)
    (("" (typepred "iS`callstack")
      (("" (inst -1 i)
        (("" (replace -4)
          (("" (expand translate_definitions -1)
            (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (istat type-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_is_fun_call_at_def formula-decl nil itranslation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (translate_defs_funcall2 0
  (translate_defs_funcall2-1 nil 3707078663
   ("" (skeep* :preds? t)
    (("" (typepred "iS`callstack`seq(i)`fpc")
      (("" (replace -4)
        (("" (expand translate_definitions -1)
          (("" (assert)
            (("" (use translate_defs_funcall) (("" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (translate_defs_funcall formula-decl nil itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (translate_length_def formula-decl nil itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (extract_call_context_TCC1 0
  (extract_call_context_TCC5-1 nil 3707137495
   ("" (subtype-tcc) nil nil) nil nil
   (extract_call_context subtype "ireduction.i"
    "below[ireduction.C`length]")))
 (extract_call_context_TCC2 0
  (extract_call_context_TCC6-1 nil 3707137495
   ("" (subtype-tcc) nil nil) nil nil
   (extract_call_context subtype "ireduction.i + 1"
    "below[ireduction.C`length]")))
 (extract_call_context_TCC3 0
  (extract_call_context_TCC7-1 nil 3707137495
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (extract_call_context subtype "iS`callstack`length - 1" "nat")))
 (extract_call_context_TCC4 0
  (extract_call_context_TCC8-1 nil 3707137495
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context subtype "i" "below[iS`callstack`length]")))
 (extract_call_context_TCC5 0
  (extract_call_context_TCC9-1 nil 3707137495
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil itranslation nil)
    (> const-decl "bool" reals nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Definition type-eq-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context subtype "iS`callstack`seq(i)`ffct"
    "below[D`length]")))
 (extract_call_context_TCC6 0
  (extract_call_context_TCC10-1 nil 3707137495
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context subtype "i + 1"
    "below[iS`callstack`length]")))
 (extract_call_context_TCC7 0
  (extract_call_context_TCC11-1 nil 3707137495
   ("" (skeep* :preds? t)
    (("" (use translate_defs_funcall2) (("" (grind) nil nil)) nil))
    nil)
   ((translate_defs_funcall2 formula-decl nil itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context subtype "iS`callstack`seq(i)`fpc"
    "{pc: upto(translate_length(D`seq(iS`callstack`seq(i)`ffct)`body)) | translate_is_fun_call_at(D`seq(iS`callstack`seq(i)`ffct)`body, pc, iS`callstack`seq(1 + i)`ffct)}")))
 (extract_call_context_eq_TCC1 0
  (extract_call_context_eq_TCC1-1 nil 3707141038
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context_eq subtype "iS`callstack"
    "{S: finseq[ireduction.stack_frame(iS`defs)] | S`length > 0}")))
 (extract_call_context_eq_TCC2 0
  (extract_call_context_eq_TCC2-1 nil 3707141038
   ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context_eq subtype "iS2`callstack"
    "{S: finseq[ireduction.stack_frame(iS2`defs)] | S`length > 0}")))
 (extract_call_context_eq_TCC3 0
  (extract_call_context_eq_TCC3-1 nil 3707141125
   ("" (subtype-tcc) nil nil)
   ((pop const-decl "finseq[T]" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context_eq subtype "0" "below(iS`callstack`length)")))
 (extract_call_context_eq_TCC4 0
  (extract_call_context_eq_TCC4-1 nil 3707141125
   ("" (subtype-tcc) nil nil)
   ((pop const-decl "finseq[T]" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_context_eq subtype "0"
    "below(iS2`callstack`length)")))
 (extract_call_context_eq 0
  (extract_call_context_eq-1 nil 3707141038
   ("" (skeep* :preds? t)
    (("" (expand extract_call_context)
      (("" (case-replace "iS2`callstack`length = iS`callstack`length")
        (("1"
          (case-replace "(LAMBDA (i: below(iS`callstack`length - 1)):
                            npopcs(D`seq(iS`callstack`seq(i)`ffct)`arity,
                                   call_reconstruct_state(D`seq
                                                          (iS`callstack`seq
                                                           (i)`ffct)`body,
                                                          (LAMBDA j: j),
                                                          iS`callstack`seq
                                                          (1 + i)`ffct,
                                                          iS`callstack`seq
                                                          (i)`fpc)`1)) = (LAMBDA (i: below(iS2`callstack`length - 1)):
                             npopcs(D`seq(iS2`callstack`seq(i)`ffct)`arity,
                                    call_reconstruct_state
                                    (D`seq(iS2`callstack`seq(i)`ffct)`body,
                                     (LAMBDA j: j),
                                     iS2`callstack`seq(1 + i)`ffct,
                                     iS2`callstack`seq(i)`fpc)`1))")
          (("1" (hide 2)
            (("1" (decompose-equality)
              (("1" (typepred "x!1")
                (("1"
                  (case-replace
                   "iS2`callstack`seq(x!1) = iS`callstack`seq(x!1)")
                  (("1"
                    (case-replace
                     "iS2`callstack`seq(1 + x!1)`ffct = iS`callstack`seq(1 + x!1)`ffct")
                    (("1" (assert) nil nil)
                     ("2"
                      (case-replace "x!1 = iS`callstack`length - 2")
                      (("1" (grind) nil nil)
                       ("2"
                        (case-replace
                         "pop(iS`callstack)`seq(1+x!1) = pop(iS2`callstack)`seq(1+x!1)")
                        (("1" (grind) nil nil)
                         ("2" (replace -9) (("2" (assert) nil nil))
                          nil)
                         ("3" (grind) nil nil) ("4" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (case "pop(iS2`callstack)`seq(x!1) = pop(iS`callstack)`seq(x!1)")
                    (("1" (grind) nil nil)
                     ("2" (replace -8) (("2" (assert) nil nil)) nil)
                     ("3" (grind) nil nil) ("4" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil)
               ("3" (lemma translate_defs_funcall2)
                (("3" (inst -1 D tD iS2) (("3" (grind) nil nil)) nil))
                nil)
               ("4" (grind) nil nil)
               ("5" (use translate_defs_funcall2)
                (("5" (grind) nil nil)) nil)
               ("6" (grind) nil nil))
              nil))
            nil)
           ("2" (grind) nil nil)
           ("3" (hide 2)
            (("3" (lemma translate_defs_funcall2)
              (("3" (inst -1 D tD iS2) (("3" (grind) nil nil)) nil))
              nil))
            nil)
           ("4" (hide 2) (("4" (grind) nil nil)) nil)
           ("5" (hide 2)
            (("5" (use translate_defs_funcall2) (("5" (grind) nil nil))
              nil))
            nil)
           ("6" (hide 2) (("6" (grind) nil nil)) nil))
          nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((extract_call_context const-decl "IContext" itranslation nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IContext type-decl nil IL nil)
    (npopcs def-decl "IContext" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (call_reconstruct_state def-decl "[IContext, [nat -> nat]]"
     itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil nil (pop const-decl "finseq[T]" ireduction nil)
    (endi const-decl "T" ireduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_defs_funcall2 formula-decl nil itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (extract_call_tv_eq 0
  (extract_call_tv_eq-1 nil 3707499068
   ("" (skeep* :preds? t)
    (("" (expand extract_call_tv)
      ((""
        (case-replace "(LAMBDA (i: below(iS`callstack`length - 1)):
                               (call_reconstruct_state(D`seq
                                                       (iS`callstack`seq
                                                        (i)`ffct)`body,
                                                       (LAMBDA j: j),
                                                       iS`callstack`seq
                                                       (1 + i)`ffct,
                                                       iS`callstack`seq
                                                       (i)`fpc)`2,
                                D`seq(iS`callstack`seq(i)`ffct)`arity +
                                 popDepth(call_reconstruct_state
                                          (D`seq
                                           (iS`callstack`seq(i)`ffct)`body,
                                           (LAMBDA j: j),
                                           iS`callstack`seq(1 + i)`ffct,
                                           iS`callstack`seq(i)`fpc)`1),
                                iS`callstack`seq(i)`fdepth)) = LAMBDA (i: below(iS2`callstack`length - 1)):
                                (call_reconstruct_state(D`seq
                                                        (iS2`callstack`seq
                                                         (i)`ffct)`body,
                                                        (LAMBDA j: j),
                                                        iS2`callstack`seq
                                                        (1 + i)`ffct,
                                                        iS2`callstack`seq
                                                        (i)`fpc)`2,
                                 D`seq(iS2`callstack`seq(i)`ffct)`arity +
                                  popDepth(call_reconstruct_state
                                           (D`seq
                                            (iS2`callstack`seq
                                             (i)`ffct)`body,
                                            (LAMBDA j: j),
                                            iS2`callstack`seq(1 + i)`ffct,
                                            iS2`callstack`seq(i)`fpc)`1),
                                 iS2`callstack`seq(i)`fdepth)")
        (("1" (assert)
          (("1"
            (case-replace "iS2`callstack`length = iS`callstack`length")
            (("1" (grind) nil nil)) nil))
          nil)
         ("2" (hide 2)
          (("2" (decompose-equality 1)
            (("1"
              (case-replace
               "iS`callstack`seq(x!1)`fdepth = iS2`callstack`seq(x!1)`fdepth")
              (("1"
                (case-replace
                 "iS`callstack`seq(x!1)`ffct = iS2`callstack`seq(x!1)`ffct")
                (("1"
                  (case-replace
                   "iS`callstack`seq(1+x!1)`ffct = iS2`callstack`seq(1+x!1)`ffct")
                  (("1"
                    (case-replace
                     "iS`callstack`seq(x!1)`fpc = iS2`callstack`seq(x!1)`fpc")
                    (("1" (assert) nil nil)
                     ("2" (hide 2)
                      (("2"
                        (case "pop(iS`callstack)`seq(x!1)`fpc = pop(iS2`callstack)`seq(x!1)`fpc")
                        (("1" (grind) nil nil)
                         ("2" (replace -9) (("2" (assert) nil nil))
                          nil)
                         ("3" (grind) nil nil) ("4" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2"
                      (case-replace
                       "x!1 + 1 = iS`callstack`length - 1")
                      (("1" (grind) nil nil)
                       ("2"
                        (case "pop(iS`callstack)`seq(1 + x!1)`ffct = pop(iS2`callstack)`seq(1 + x!1)`ffct")
                        (("1" (grind) nil nil)
                         ("2" (replace -8) (("2" (assert) nil nil))
                          nil)
                         ("3" (grind) nil nil) ("4" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide 2) (("3" (grind) nil nil)) nil))
                  nil)
                 ("2" (hide 2)
                  (("2"
                    (case "pop(iS`callstack)`seq(x!1)`ffct = pop(iS2`callstack)`seq(x!1)`ffct")
                    (("1" (grind) nil nil)
                     ("2" (replace -7) (("2" (assert) nil nil)) nil)
                     ("3" (grind) nil nil) ("4" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2"
                  (case "pop(iS`callstack)`seq(x!1)`fdepth = pop(iS2`callstack)`seq(x!1)`fdepth")
                  (("1" (grind) nil nil)
                   ("2" (replace -6) (("2" (assert) nil nil)) nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil)
               ("3" (hide 2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (grind) nil nil)
             ("3" (skeep* :preds? t)
              (("3" (typepred "iS`callstack`seq(i)`fdepth")
                (("3"
                  (case "iS2`callstack`seq(i)`fdepth = iS`callstack`seq(i)`fdepth")
                  (("1" (grind) nil nil)
                   ("2"
                    (case "pop(iS2`callstack)`seq(i)`fdepth = pop(iS`callstack)`seq(i)`fdepth")
                    (("1" (grind) nil nil)
                     ("2" (replace -8) (("2" (assert) nil nil)) nil)
                     ("3" (grind) nil nil) ("4" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (lemma translate_defs_funcall2)
              (("4" (inst -1 D tD iS2) (("4" (grind) nil nil)) nil))
              nil)
             ("5" (grind) nil nil)
             ("6" (lemma translate_defs_funcall2)
              (("6" (inst -1 D tD iS) (("6" (grind) nil nil)) nil))
              nil)
             ("7" (grind) nil nil))
            nil))
          nil)
         ("3" (hide 2) (("3" (grind) nil nil)) nil)
         ("4" (hide 2)
          (("4" (lemma translate_defs_funcall2)
            (("4" (inst -1 D tD iS2) (("4" (grind) nil nil)) nil))
            nil))
          nil)
         ("5" (hide 2) (("5" (grind) nil nil)) nil)
         ("6" (hide 2)
          (("6" (lemma translate_defs_funcall2)
            (("6" (inst -1 D tD iS) (("6" (grind) nil nil)) nil)) nil))
          nil)
         ("7" (hide 2) (("7" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (translate_defs_funcall2 formula-decl nil itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (endi const-decl "T" ireduction nil) nil nil nil nil
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pop const-decl "finseq[T]" ireduction nil) nil
    (call_reconstruct_state def-decl "[IContext, [nat -> nat]]"
     itranslation nil)
    (IContext type-decl nil IL nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (istat type-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (extract_call_tv_bound_TCC1 0
  (extract_call_tv_bound_TCC1-1 nil 3707137852
   ("" (subtype-tcc) nil nil)
   ((extract_call_context const-decl "IContext" itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (extract_call_tv_bound subtype "iS`callstack"
    "{S: finseq[ireduction.stack_frame(iS`defs)] | S`length > 0}")))
 (extract_call_tv_bound 0
  (extract_call_tv_bound-1 nil 3707137852
   ("" (skeep* :preds? t)
    (("" (expand extract_call_tv)
      (("" (use compose_all_tv_bound)
        (("1" (split)
          (("1" (rewrite sum_map)
            (("1" (rewrite fdepth_sum_sum)
              (("1" (expand pop)
                (("1" (rewrite sum_map +)
                  (("1" (hide 2)
                    (("1" (skeep* :preds? t)
                      (("1" (typepred "iS`callstack`seq(i)`fpc")
                        (("1" (typepred "iS`callstack`seq(i)`ffct")
                          (("1" (typepred "iS`callstack`seq(i)`fdepth")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (use translate_defs_funcall2)
                (("2" (grind) nil nil)) nil))
              nil)
             ("3" (hide 2)
              (("3" (skeep* :preds? t) (("3" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skeep* :preds? t)
              (("2" (rewrite call_reconstruct_state_tv_high)
                (("1" (typepred "iS`callstack`seq(i_1)`fdepth")
                  (("1" (split)
                    (("1" (replace -7 -1)
                      (("1" (expand translate_definitions -1)
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (flatten)
                      (("2" (typepred "iS`callstack")
                        (("2" (inst -1 "i_1")
                          (("2" (replace -2) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (use call_reconstruct_state_tv_low)
                  (("2" (split)
                    (("1" (typepred "iS`callstack`seq(i_1)`fdepth")
                      (("1" (split)
                        (("1" (replace -8 -1)
                          (("1" (expand translate_definitions -1)
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (flatten)
                          (("2" (typepred "iS`callstack")
                            (("2" (inst -1 "i_1")
                              (("2"
                                (replace -2)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (expand extract_call_context)
              (("3" (rewrite compose_all_popDepth)
                (("1" (rewrite sum_map -5)
                  (("1" (rewrite sum_map 1)
                    (("1"
                      (case-replace
                       "(LAMBDA (i_1: below(iS`callstack`length - 1)):
                     popDepth(npopcs(D`seq
                                     (iS`callstack`seq(i_1)`ffct)`arity,
                                     call_reconstruct_state
                                     (D`seq
                                      (iS`callstack`seq(i_1)`ffct)`body,
                                      (LAMBDA j: j),
                                      iS`callstack`seq(1 + i_1)`ffct,
                                      iS`callstack`seq(i_1)`fpc)`1))) = LAMBDA (i_1: below(iS`callstack`length - 1)):
                     D`seq(iS`callstack`seq(i_1)`ffct)`arity +
                      popDepth(call_reconstruct_state(D`seq
                                                      (iS`callstack`seq
                                                       (i_1)`ffct)`body,
                                                      (LAMBDA j: j),
                                                      iS`callstack`seq
                                                      (1 + i_1)`ffct,
                                                      iS`callstack`seq
                                                      (i_1)`fpc)`1)")
                      (("1" (decompose-equality)
                        (("1" (rewrite npopcs_popDepth) nil nil)
                         ("2" (hide 2)
                          (("2" (use translate_defs_funcall2)
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("3" (grind) nil nil))
                        nil)
                       ("2" (use translate_defs_funcall2)
                        (("2" (grind) nil nil)) nil)
                       ("3" (grind) nil nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (use translate_defs_funcall2)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("3" (hide 2) (("3" (grind) nil nil)) nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (use translate_defs_funcall2)
                      (("2" (grind) nil nil)) nil))
                    nil)
                   ("3" (hide 2) (("3" (grind) nil nil)) nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (use translate_defs_funcall2)
                    (("2" (grind) nil nil)) nil))
                  nil)
                 ("3" (hide 2) (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (use translate_defs_funcall2) (("2" (grind) nil nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep* :preds? t) (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (compose_all_tv def-decl "[nat -> nat]" itranslation nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (sum const-decl "nat" itranslation nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (translate_defs_funcall2 formula-decl nil itranslation nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (fdepth_sum_sum formula-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sum_map formula-decl nil itranslation nil)
    (call_reconstruct_state_tv_low formula-decl nil itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (call_reconstruct_state_tv_high formula-decl nil itranslation nil)
    (npopcs_popDepth formula-decl nil itranslation nil)
    (compose_all_popDepth formula-decl nil itranslation nil)
    (npopcs def-decl "IContext" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil) nil
    nil nil
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (istat type-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (translate_is_fun_call_at def-decl "bool" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (IContext type-decl nil IL nil)
    (call_reconstruct_state def-decl "[IContext, [nat -> nat]]"
     itranslation nil)
    nil (compose_all_tv_bound formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (redex_matches_TCC1 0
  (redex_matches_TCC1-1 nil 3707160549 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_matches subtype "typed_rreduction.i"
    "below[typed_rreduction.state`stack`length]")))
 (redex_matches_TCC2 0
  (redex_matches_TCC2-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex")
      (("" (assert)
        (("" (skeep)
          (("" (inst -2 "i-popDepth(state`redex)")
            (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil) nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_matches subtype "typed_rreduction.stack_types"
    "{stypes | IL.popDepth(typed_rreduction.state`redex) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`redex)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))
 (redex_matches_TCC3 0
  (redex_matches_TCC3-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_matches subtype "IL.popDepth(typed_rreduction.state`redex)"
    "upto(typed_rreduction.stack_types`length)")))
 (redex_matches_TCC4 0
  (redex_matches_TCC4-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (typepred "state`redex")
          (("2" (inst -3 "i-popDepth(state`context)")
            (("1" (rewrite cvars_vars_ctx)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_matches subtype
    "typed_reduction.popn(typed_rreduction.stack_types, IL.popDepth(typed_rreduction.state`redex))"
    "{stypes | IL.popDepth(typed_rreduction.state`context) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`context)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))
 (redex_matches_TCC5 0
  (redex_matches_TCC10-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (replace -12)
      (("" (expand compose_translate_vars)
        (("" (lift-if)
          (("" (split)
            (("1" (flatten)
              (("1" (use fct_reconstruct_state_tv)
                (("1" (split)
                  (("1" (case "fv`fdepth <= iS`stack`length")
                    (("1" (grind) nil nil)
                     ("2" (typepred "iS`stack")
                      (("2" (rewrite fdepth_sum_pop)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (replace -10)
                (("2" (use extract_call_tv_bound)
                  (("1" (split)
                    (("1" (typepred "iS`stack")
                      (("1" (rewrite fdepth_sum_pop)
                        (("1" (grind) nil nil)) nil))
                      nil)
                     ("2"
                      (case-replace
                       "popDepth(fill(compose(K1, K), A)) = popDepth(fill(trS`state`context, trS`state`redex))")
                      (("1" (rewrite popdepth_fill)
                        (("1" (rewrite popdepth_fill)
                          (("1" (rewrite compose_popDepth)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((extract_call_tv_bound formula-decl nil itranslation nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil nil nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (compose def-decl "IContext" IL nil)
    (fill def-decl "IExpression" IL nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "bool" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Definition type-eq-decl nil ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) nil nil nil
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (fct_reconstruct_state_tv formula-decl nil itranslation nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (redex_matches subtype "tv2(i)" "below(iS`stack`length)")))
 (redex_matches_TCC6 0
  (redex_matches_TCC6-1 nil 3707160549 ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (redex_matches subtype "0" "below(iS`callstack`length)")))
 (redex_matches_TCC7 0
  (redex_matches_TCC11-1 nil 3707160549 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (endi const-decl "T" ireduction nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (redex_matches subtype "i" "below(trS`state`stack`length)")))
 (redex_matches_TCC8 0
  (redex_matches_TCC5-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "fv`fdepth") (("1" (grind) nil nil)) nil)
       ("2" (typepred "iS`stack")
        (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   nil nil
   (redex_matches subtype "trS`def_types"
    "{tD | typed_reduction.defs_well_typed(D, tD)}")))
 (redex_matches_TCC9 0
  (redex_matches_TCC7-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "fv`fpc")
        (("1" (replace -3)
          (("1" (expand translate_definitions) (("1" (assert) nil nil))
            nil))
          nil))
        nil)
       ("2" (typepred "fv`fdepth")
        (("2" (replace -3)
          (("2" (expand translate_definitions)
            (("2" (assert)
              (("2" (split)
                (("1" (assert) nil nil)
                 ("2" (assert) (("2" (flatten) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_length_def formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (redex_matches subtype "fv`ffct" "below[D`length]")))
 (redex_matches_TCC10 0
  (redex_matches_TCC8-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "fv`fdepth") (("1" (grind) nil nil)) nil)
       ("2" (typepred "iS`stack")
        (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "bool" ireduction nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Definition type-eq-decl nil ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) nil nil nil
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (endi const-decl "T" ireduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (redex_matches subtype "fv`fdepth"
    "{fdepth: posnat | fdepth <= iS`stack`length}")))
 (redex_matches_TCC11 0
  (redex_matches_TCC9-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (typepred "fv`fpc")
      (("" (typepred "fv`fdepth")
        (("" (replace -4)
          (("" (expand translate_definitions)
            (("" (assert) (("" (assert) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_length_def formula-decl nil itranslation nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (endi const-decl "T" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (redex_matches subtype "fv`fpc"
    "{pc: upto(translate_length(D`seq(fv`ffct)`body)) | pc = translate_length(D`seq(fv`ffct)`body) OR 1 + D`seq(fv`ffct)`arity + translate_stack_size_at(D`seq(fv`ffct)`body, pc) = fv`fdepth}")))
 (redex_matches_l_TCC1 0
  (redex_matches_l_TCC1-1 nil 3707163796
   ("" (skeep* :preds? t)
    (("" (replace -10)
      (("" (expand compose_translate_vars +)
        (("" (lift-if)
          (("" (split)
            (("1" (flatten)
              (("1" (use fct_reconstruct_state_tv)
                (("1" (assert)
                  (("1" (assert)
                    (("1" (case "fv`fdepth <= iS`stack`length")
                      (("1" (assert) nil nil)
                       ("2" (typepred "iS`stack")
                        (("2" (rewrite fdepth_sum_pop)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2"
                (name-replace k "-1 * popDepth(A) - popDepth(K) + i")
                (("2" (replace -9)
                  (("2" (use extract_call_tv_bound)
                    (("1" (typepred "iS`stack")
                      (("1" (rewrite fdepth_sum_pop)
                        (("1" (split)
                          (("1" (grind) nil nil)
                           ("2"
                            (case "popDepth(fill(compose(K1, K), A)) = popDepth(fill(trS`state`context, trS`state`redex))")
                            (("1" (rewrite popdepth_fill)
                              (("1"
                                (rewrite popdepth_fill)
                                (("1"
                                  (rewrite compose_popDepth)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand k)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand k) (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (compose def-decl "IContext" IL nil)
    (fill def-decl "IExpression" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (extract_call_tv_bound formula-decl nil itranslation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "bool" ireduction nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Definition type-eq-decl nil ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) nil nil nil
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (fct_reconstruct_state_tv formula-decl nil itranslation nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (redex_matches_l subtype "fv`ffct" "below[D`length]")))
 (redex_matches_l_TCC2 0
  (redex_matches_l_TCC2-1 nil 3707163796
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "fv`fdepth") (("1" (grind) nil nil)) nil)
       ("2" (typepred "iS`stack")
        (("2" (rewrite -1)
          (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (endi const-decl "T" ireduction nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_matches_l subtype "fv`fdepth"
    "{fdepth: posnat | fdepth <= iS`stack`length}")))
 (redex_matches_l 0
  (redex_matches_l-1 nil 3707230113
   ("" (skeep* :preds? t)
    (("" (iff)
      (("" (split)
        (("1" (flatten)
          (("1" (skeep* :preds? t)
            (("1" (expand redex_matches)
              (("1" (assert)
                (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (expand redex_matches)
            (("2" (name-replace "fv" "endi(iS`callstack, 0)")
              (("2"
                (name-replace "K1"
                 "extract_call_context(D, trS`def_types, iS)")
                (("2"
                  (name-replace "tv1"
                   "extract_call_tv(D, trS`def_types, iS)")
                  (("2" (inst -1 fv _ _ K1 _ tv1 _)
                    (("2"
                      (name-replace u
                       "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                               D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc)")
                      (("1" (name-replace A "u`1")
                        (("1" (name-replace K "u`2")
                          (("1" (name-replace "tv" "u`3")
                            (("1" (inst -1 A K tv _)
                              (("1"
                                (name-replace
                                 tv2
                                 "compose_translate_vars(tv, tv1, popDepth(K) + popDepth(A),
                                 fv`fdepth)")
                                (("1"
                                  (inst -1 tv2)
                                  (("1"
                                    (split)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (flatten)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (decompose-equality)
                                      (("1"
                                        (expand A)
                                        (("1" (propax) nil nil))
                                        nil)
                                       ("2"
                                        (expand K)
                                        (("2" (propax) nil nil))
                                        nil)
                                       ("3"
                                        (expand tv)
                                        (("3" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (typepred "fv`fpc")
                          (("2" (typepred "fv`fdepth")
                            (("2" (replace -5)
                              (("2"
                                (expand translate_definitions)
                                (("2"
                                  (assert)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (hide 2)
                        (("3" (split)
                          (("1" (typepred "fv`fdepth")
                            (("1" (grind) nil nil)) nil)
                           ("2" (typepred "iS`stack")
                            (("2" (rewrite fdepth_sum_pop)
                              (("2"
                                (expand fv)
                                (("2"
                                  (expand endi)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (hide 2) (("4" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (redex_matches const-decl "bool" itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil) nil
    (int_minus_int_is_int application-judgement "int" integers nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (translate_length_def formula-decl nil itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (compose_translate_vars const-decl "nat" itranslation nil) nil nil
    nil (translate_length def-decl "posnat" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (redex_stillmatch1_TCC1 0
  (redex_stillmatch1_TCC1-1 nil 3707160549 ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (redex_stillmatch1 subtype "iS`callstack"
    "{S: finseq[ireduction.stack_frame(iS`defs)] | S`length > 0}")))
 (redex_stillmatch1_TCC2 0
  (redex_stillmatch1_TCC16-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (typepred "iS2`stack")
      (("" (rewrite -1)
        (("" (rewrite fdepth_sum_pop)
          (("" (typepred "iS`stack")
            (("" (rewrite fdepth_sum_pop)
              (("" (expand endi) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (endi const-decl "T" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch1 subtype "trS2"
    "{trS | typed_reduction.defs_well_typed(D, trS`def_types)}")))
 (redex_stillmatch1_TCC3 0
  (redex_stillmatch1_TCC3-1 nil 3707160549 ("" (subtype-tcc) nil nil)
   ((endi const-decl "T" ireduction nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (redex_stillmatch1 subtype "0" "below(iS2`callstack`length)")))
 (redex_stillmatch1_TCC4 0
  (redex_stillmatch1_TCC17-1 nil 3707160549
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (redex_stillmatch1 subtype "iS2"
    "{iS | iS`defs = translate_definitions(D, trS2`def_types) AND iS`callstack`length > 0}")))
 (redex_stillmatch1_TCC5 0
  (redex_stillmatch1_TCC2-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (case "popDepth(K1) = popDepth(compose(K2, K3))")
      (("1"
        (case "popDepth(fill(K3, trS2`state`redex)) = popDepth(A2)")
        (("1" (case "popDepth(K1) <= popDepth(trS`state`context)")
          (("1" (typepred "trS`state`redex")
            (("1" (rewrite popdepth_fill)
              (("1" (rewrite compose_popDepth) (("1" (assert) nil nil))
                nil))
              nil))
            nil)
           ("2" (expand redex_matches)
            (("2" (replace -21 :dir RL)
              (("2" (replace -17 :dir RL)
                (("2" (assert)
                  (("2"
                    (case "popDepth(fill(compose(extract_call_context(D, trS`def_types, iS), K1), A1)) =
       popDepth(fill(trS`state`context, trS`state`redex))")
                    (("1" (rewrite popdepth_fill)
                      (("1" (rewrite popdepth_fill)
                        (("1" (rewrite compose_popDepth)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((compose def-decl "IContext" IL nil) nil
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (popdepth_fill formula-decl nil IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tdef type-eq-decl nil itranslation nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (redex_matches const-decl "bool" itranslation nil)
    (IExpression type-decl nil IExpression_adt nil) nil
    (fill def-decl "IExpression" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (redex_stillmatch1 subtype "iS2`callstack"
    "{S: finseq[ireduction.stack_frame(iS2`defs)] | S`length > 0}")))
 (redex_stillmatch1_TCC6 0
  (redex_stillmatch1_TCC4-1 nil 3707160549
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (redex_stillmatch1 subtype "fv1`ffct" "below[D`length]")))
 (redex_stillmatch1_TCC7 0
  (redex_stillmatch1_TCC5-1 nil 3707160549
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (redex_stillmatch1 subtype "fv1`fdepth"
    "{fdepth: posnat | fdepth <= iS`stack`length}")))
 (redex_stillmatch1_TCC8 0
  (redex_stillmatch1_TCC6-1 nil 3707160549
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (redex_stillmatch1 subtype "fv1`fpc"
    "{pc: upto(translate_length(D`seq(fv1`ffct)`body)) | pc = translate_length(D`seq(fv1`ffct)`body) OR 1 + D`seq(fv1`ffct)`arity + translate_stack_size_at(D`seq(fv1`ffct)`body, pc) = fv1`fdepth}")))
 (redex_stillmatch1_TCC9 0
  (redex_stillmatch1_TCC10-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (typepred "fv2`ffct")
      (("" (expand translate_definitions) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (redex_stillmatch1 subtype "tv2(i)" "below(iS`stack`length)")))
 (redex_stillmatch1_TCC10 0
  (redex_stillmatch1_TCC11-1 nil 3707224077
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (typepred "fv2`fdepth") (("1" (grind) nil nil)) nil)
       ("2" (typepred "iS2`stack")
        (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (istat type-decl nil ireduction nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "bool" ireduction nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Definition type-eq-decl nil ireduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil) nil
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) nil nil nil
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (redex_matches const-decl "bool" itranslation nil)
    (fct_is_result_defined const-decl "bool" itranslation nil)
    (val_to_ival const-decl "ivalue" itranslation nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (redex_stillmatch1 subtype "i" "below(trS2`state`stack`length)")))
 (redex_stillmatch1_TCC11 0
  (redex_stillmatch1_TCC12-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (typepred "fv2`fpc")
      (("" (typepred "fv2`fdepth")
        (("" (replace -5)
          (("" (expand translate_definitions)
            (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_length_def formula-decl nil itranslation nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (redex_stillmatch1 subtype "i + fv1`fdepth"
    "below(iS`stack`length)")))
 (redex_stillmatch1_TCC12 0
  (redex_stillmatch1_TCC13-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (use fct_reconstruct_state_tv)
      (("" (split -1)
        (("1" (typepred "iS2`stack")
          (("1" (rewrite fdepth_sum_pop)
            (("1" (rewrite -1)
              (("1" (case "tv2(i) < fv2`fdepth")
                (("1" (expand endi) (("1" (assert) nil nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state_tv formula-decl nil itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (istat type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (endi const-decl "T" ireduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch1 subtype "i + fv2`fdepth"
    "below(iS2`stack`length)")))
 (redex_stillmatch1_TCC13 0
  (redex_stillmatch1_TCC14-1 nil 3707160549
   ("" (skeep* :preds? t)
    (("" (case "popDepth(fill(K3, trS2`state`redex)) = popDepth(A2)")
      (("1" (case "popDepth(K1) = popDepth(compose(K2, K3))")
        (("1" (rewrite compose_popDepth)
          (("1" (rewrite popdepth_fill)
            (("1" (case "popDepth(K1) <= popDepth(trS`state`context)")
              (("1" (typepred "trS`state`redex")
                (("1" (assert) nil nil)) nil)
               ("2" (expand redex_matches)
                (("2" (replace -19 :dir RL)
                  (("2" (replace -15 :dir RL)
                    (("2" (assert)
                      (("2"
                        (case "popDepth(fill(compose(extract_call_context(D, trS`def_types, iS), K1), A1)) =
       popDepth(fill(trS`state`context, trS`state`redex))")
                        (("1" (rewrite popdepth_fill)
                          (("1" (rewrite popdepth_fill)
                            (("1" (rewrite compose_popDepth)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil) nil
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tdef type-eq-decl nil itranslation nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (redex_matches const-decl "bool" itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (compose def-decl "IContext" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch1 subtype "i + IL.popDepth(A1) + IL.popDepth(K1)"
    "below(trS`state`stack`length)")))
 (redex_stillmatch1_TCC14 0
  (redex_stillmatch1_TCC15-1 nil 3707160549
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch1 subtype "i + IL.popDepth(A2) + IL.popDepth(K2)"
    "below(trS2`state`stack`length)")))
 (redex_stillmatch1 0
  (redex_stillmatch1-4 "" 3707583505
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 ist1d ist1l ist2d ist2l ctxe cpope fv1d fv2d ffcte rm
       fct1 fct2 a1e k1e a2e sle eqlo isame rsame resdef obj)))
    (("" (rewrite redex_matches_l +)
      ((""
        (with-labels (skeep* + :preds? t)
         ((fve fct2b callk callt ctv obj)))
        (("" (case-replace "fv = fv2")
          (("1" (case-replace "A = A2")
            (("1" (case-replace "K = K2")
              (("1" (case-replace "tv = tv2")
                (("1" (split obj)
                  (("1" (replace a2e obj :dir RL)
                    (("1" (rewrite context_composition obj :dir RL)
                      (("1"
                        (case-replace
                         "compose(compose(K1!1, K2), K3) = trS`state`context")
                        (("1" (assert) nil nil)
                         ("2" (hide obj)
                          (("2" (label obj 1)
                            (("2" (expand redex_matches)
                              (("2"
                                (with-labels (flatten rm) ((frm srm)))
                                (("2"
                                  (replace fv1d :dir RL)
                                  (("2"
                                    (replace fct1 :dir RL)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (replace a1e)
                                        (("2"
                                          (use fill_eq_ctx)
                                          (("2"
                                            (split -1)
                                            (("1"
                                              (replace -1 obj :dir RL)
                                              (("1"
                                                (replace k1e obj)
                                                (("1"
                                                  (case-replace
                                                   "extract_call_context(D, trS`def_types, iS) = K1!1")
                                                  (("1"
                                                    (rewrite
                                                     compose_assoc)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (replace callk)
                                                    (("2"
                                                      (use
                                                       extract_call_context_eq)
                                                      (("2"
                                                        (use
                                                         extract_call_context_eq)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (with-labels (skeep :preds? t) ((ih obj)))
                    (("2" (case "i < popDepth(A2) + popDepth(K2)")
                      (("1" (inst eqlo i)
                        (("1" (replace ctv)
                          (("1" (expand compose_translate_vars)
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (replace ctv)
                        (("2" (expand compose_translate_vars obj)
                          (("2" (assert)
                            (("2" (expand redex_matches rm)
                              (("2"
                                (with-labels (flatten rm) ((frm srm)))
                                (("2"
                                  (replace fv1d :dir RL)
                                  (("2"
                                    (replace fct1 :dir RL)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (case-replace
                                         "tv1!1 = extract_call_tv(D, trS`def_types, iS)")
                                        (("1"
                                          (name-replace
                                           k
                                           "i - popDepth(A2) - popDepth(K2)")
                                          (("1"
                                            (inst rsame k)
                                            (("1"
                                              (case-replace
                                               "i = k + popDepth(A2) + popDepth(K2)")
                                              (("1"
                                                (replace
                                                 rsame
                                                 obj
                                                 :dir
                                                 RL)
                                                (("1"
                                                  (inst
                                                   srm
                                                   "k + popDepth(A1) + popDepth(K1)")
                                                  (("1"
                                                    (expand
                                                     compose_translate_vars
                                                     srm)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace
                                                         srm
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (inst? isame)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (use
                                                             extract_call_tv_bound)
                                                            (("2"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (typepred
                                                                 "iS`stack")
                                                                (("1"
                                                                  (rewrite
                                                                   -1)
                                                                  (("1"
                                                                    (rewrite
                                                                     fdepth_sum_pop
                                                                     1)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (expand
                                                                 k)
                                                                (("2"
                                                                  (hide
                                                                   2)
                                                                  (("2"
                                                                    (hide
                                                                     obj)
                                                                    (("2"
                                                                      (case-replace
                                                                       "popDepth(A2) = popDepth(trS2`state`redex) + popDepth(K1) - popDepth(K2)")
                                                                      (("1"
                                                                        (assert)
                                                                        (("1"
                                                                          (case-replace
                                                                           "trS2`state`context = compose(extract_call_context(D, trS`def_types, iS), K1)")
                                                                          (("1"
                                                                            (rewrite
                                                                             compose_popDepth)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (replace
                                                                             ctxe
                                                                             :dir
                                                                             RL)
                                                                            (("2"
                                                                              (replace
                                                                               a1e)
                                                                              (("2"
                                                                                (use
                                                                                 fill_eq_ctx)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (replace
                                                                         a2e
                                                                         :dir
                                                                         RL)
                                                                        (("2"
                                                                          (rewrite
                                                                           popdepth_fill)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (replace
                                                                               k1e)
                                                                              (("2"
                                                                                (rewrite
                                                                                 compose_popDepth)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (split)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (replace a1e)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (expand k)
                                                          (("2"
                                                            (hide obj)
                                                            (("2"
                                                              (replace
                                                               ctxe)
                                                              (("2"
                                                                (case-replace
                                                                 "popDepth(A2) = popDepth(fill(K3, trS2`state`redex))")
                                                                (("1"
                                                                  (rewrite
                                                                   popdepth_fill)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (replace
                                                                       k1e)
                                                                      (("1"
                                                                        (rewrite
                                                                         compose_popDepth)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand k)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand k)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand k)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (case
                                                     "i < trS2`state`stack`length")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case-replace
                                                         "popDepth(A2) = popDepth(trS2`state`redex) + popDepth(K1) - popDepth(K2)")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (case-replace
                                                           "popDepth(K1) = popDepth(compose(K2, K3))")
                                                          (("1"
                                                            (case-replace
                                                             "popDepth(fill(K3, trS2`state`redex)) = popDepth(A2)")
                                                            (("1"
                                                              (rewrite
                                                               compose_popDepth)
                                                              (("1"
                                                                (rewrite
                                                                 popdepth_fill)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "trS`state`redex")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (replace callt)
                                          (("2"
                                            (use extract_call_tv_eq)
                                            (("2"
                                              (split -1)
                                              (("1" (assert) nil nil)
                                               ("2" (assert) nil nil)
                                               ("3"
                                                (expand endi)
                                                (("3"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (assert) nil nil))
                  nil)
                 ("2" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil)
             ("2" (assert) nil nil))
            nil)
           ("2" (replace fve)
            (("2" (replace fv2d) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((redex_matches_l formula-decl nil itranslation nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (compose def-decl "IContext" IL nil)
    (context_composition formula-decl nil IL nil)
    (redex_matches const-decl "bool" itranslation nil)
    (fill_eq_ctx formula-decl nil IL nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (compose_assoc formula-decl nil IL nil)
    (extract_call_context_eq formula-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    nil nil nil nil nil nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (extract_call_tv_eq formula-decl nil itranslation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    nil nil (endi const-decl "T" ireduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (extract_call_tv_bound formula-decl nil itranslation nil)
    (fill def-decl "IExpression" IL nil) nil nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil)
  (redex_stillmatch1-3 "" 3707502667
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 ist1d ist1l ist2d ist2l ctxe cpope fv1d fv2d ffcte rm
       fct1 fct2 a1e k1e a2e sle eqlo isame rsame obj)))
    (("" (rewrite redex_matches_l +)
      ((""
        (with-labels (skeep* + :preds? t)
         ((fve fct2b callk callt ctv obj)))
        (("" (case-replace "fv = fv2")
          (("1" (case-replace "A = A2")
            (("1" (case-replace "K = K2")
              (("1" (case-replace "tv = tv2")
                (("1" (split obj)
                  (("1" (replace a2e obj :dir RL)
                    (("1" (rewrite context_composition obj :dir RL)
                      (("1"
                        (case-replace
                         "compose(compose(K1!1, K2), K3) = trS`state`context")
                        (("1" (assert) nil nil)
                         ("2" (hide obj)
                          (("2" (label obj 1)
                            (("2" (expand redex_matches)
                              (("2"
                                (with-labels (flatten rm) ((frm srm)))
                                (("2"
                                  (replace fv1d :dir RL)
                                  (("2"
                                    (replace fct1 :dir RL)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (replace a1e)
                                        (("2"
                                          (use fill_eq_ctx)
                                          (("2"
                                            (split -1)
                                            (("1"
                                              (replace -1 obj :dir RL)
                                              (("1"
                                                (replace k1e obj)
                                                (("1"
                                                  (case-replace
                                                   "extract_call_context(D, trS`def_types, iS) = K1!1")
                                                  (("1"
                                                    (rewrite
                                                     compose_assoc)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (replace callk)
                                                    (("2"
                                                      (use
                                                       extract_call_context_eq)
                                                      (("2"
                                                        (use
                                                         extract_call_context_eq)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (with-labels (skeep :preds? t) ((ih obj)))
                    (("2" (case "i < popDepth(A2) + popDepth(K2)")
                      (("1" (inst eqlo i)
                        (("1" (replace ctv)
                          (("1" (expand compose_translate_vars)
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (replace ctv)
                        (("2" (expand compose_translate_vars obj)
                          (("2" (assert)
                            (("2" (expand redex_matches rm)
                              (("2"
                                (with-labels (flatten rm) ((frm srm)))
                                (("2"
                                  (replace fv1d :dir RL)
                                  (("2"
                                    (replace fct1 :dir RL)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (case-replace
                                         "tv1!1 = extract_call_tv(D, trS`def_types, iS)")
                                        (("1"
                                          (name-replace
                                           k
                                           "i - popDepth(A2) - popDepth(K2)")
                                          (("1"
                                            (inst rsame k)
                                            (("1"
                                              (case-replace
                                               "i = k + popDepth(A2) + popDepth(K2)")
                                              (("1"
                                                (replace
                                                 rsame
                                                 obj
                                                 :dir
                                                 RL)
                                                (("1"
                                                  (inst
                                                   srm
                                                   "k + popDepth(A1) + popDepth(K1)")
                                                  (("1"
                                                    (expand
                                                     compose_translate_vars
                                                     srm)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace
                                                         srm
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (inst? isame)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (use
                                                             extract_call_tv_bound)
                                                            (("2"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (typepred
                                                                 "iS`stack")
                                                                (("1"
                                                                  (rewrite
                                                                   -1)
                                                                  (("1"
                                                                    (rewrite
                                                                     fdepth_sum_pop
                                                                     1)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (expand
                                                                 k)
                                                                (("2"
                                                                  (hide
                                                                   2)
                                                                  (("2"
                                                                    (hide
                                                                     obj)
                                                                    (("2"
                                                                      (case-replace
                                                                       "popDepth(A2) = popDepth(trS2`state`redex) + popDepth(K1) - popDepth(K2)")
                                                                      (("1"
                                                                        (assert)
                                                                        (("1"
                                                                          (case-replace
                                                                           "trS2`state`context = compose(extract_call_context(D, trS`def_types, iS), K1)")
                                                                          (("1"
                                                                            (rewrite
                                                                             compose_popDepth)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (replace
                                                                             ctxe
                                                                             :dir
                                                                             RL)
                                                                            (("2"
                                                                              (replace
                                                                               a1e)
                                                                              (("2"
                                                                                (use
                                                                                 fill_eq_ctx)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (replace
                                                                         a2e
                                                                         :dir
                                                                         RL)
                                                                        (("2"
                                                                          (rewrite
                                                                           popdepth_fill)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (replace
                                                                               k1e)
                                                                              (("2"
                                                                                (rewrite
                                                                                 compose_popDepth)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (split)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (replace a1e)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (expand k)
                                                          (("2"
                                                            (hide obj)
                                                            (("2"
                                                              (replace
                                                               ctxe)
                                                              (("2"
                                                                (case-replace
                                                                 "popDepth(A2) = popDepth(fill(K3, trS2`state`redex))")
                                                                (("1"
                                                                  (rewrite
                                                                   popdepth_fill)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (replace
                                                                       k1e)
                                                                      (("1"
                                                                        (rewrite
                                                                         compose_popDepth)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand k)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand k)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand k)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (case
                                                     "i < trS2`state`stack`length")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case-replace
                                                         "popDepth(A2) = popDepth(trS2`state`redex) + popDepth(K1) - popDepth(K2)")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (case-replace
                                                           "popDepth(K1) = popDepth(compose(K2, K3))")
                                                          (("1"
                                                            (case-replace
                                                             "popDepth(fill(K3, trS2`state`redex)) = popDepth(A2)")
                                                            (("1"
                                                              (rewrite
                                                               compose_popDepth)
                                                              (("1"
                                                                (rewrite
                                                                 popdepth_fill)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "trS`state`redex")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (replace callt)
                                          (("2"
                                            (use extract_call_tv_eq)
                                            (("2"
                                              (split -1)
                                              (("1" (assert) nil nil)
                                               ("2" (assert) nil nil)
                                               ("3"
                                                (expand endi)
                                                (("3"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil)
             ("2" (assert) nil nil))
            nil)
           ("2" (replace fve)
            (("2" (replace fv2d) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (redex_stillmatch1-2 "" 3707164986
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 ist1d ist1l ist2d ist2l ctxe cpope fv1d fv2d ffcte rm
       fct1 fct2 a1e k1e a2e sle eqlo isame rsame obj)))
    (("" (rewrite redex_matches_l +)
      ((""
        (with-labels (skeep* + :preds? t)
         ((fve fct2b callk callt ctv obj)))
        (("" (case-replace "fv = fv2")
          (("1" (case-replace "A = A2")
            (("1" (case-replace "K = K2")
              (("1" (case-replace "tv = tv2")
                (("1" (split obj)
                  (("1" (replace a2e obj :dir RL)
                    (("1" (rewrite context_composition obj :dir RL)
                      (("1"
                        (case-replace
                         "compose(compose(K1!1, K2), K3) = trS`state`context")
                        (("1" (assert) nil nil)
                         ("2" (hide obj)
                          (("2" (label obj 1)
                            (("2" (expand redex_matches)
                              (("2"
                                (with-labels (flatten rm) ((frm srm)))
                                (("2"
                                  (replace fv1d :dir RL)
                                  (("2"
                                    (replace fct1 :dir RL)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (replace a1e)
                                        (("2"
                                          (use fill_eq_ctx)
                                          (("2"
                                            (split -1)
                                            (("1"
                                              (replace -1 obj :dir RL)
                                              (("1"
                                                (replace k1e obj)
                                                (("1"
                                                  (case-replace
                                                   "extract_call_context(D, trS`def_types, iS) = K1!1")
                                                  (("1"
                                                    (rewrite
                                                     compose_assoc)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (replace callk)
                                                    (("2"
                                                      (use
                                                       extract_call_context_eq)
                                                      (("2"
                                                        (use
                                                         extract_call_context_eq)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (replace
                                                             cpope)
                                                            (("2"
                                                              (split)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (expand
                                                                   pop
                                                                   :assert?
                                                                   none)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                (("2"
                                                                  (expand
                                                                   endi)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (with-labels (skeep :preds? t) ((ih obj)))
                    (("2" (case "i < popDepth(A2) + popDepth(K2)")
                      (("1" (inst eqlo i)
                        (("1" (replace ctv)
                          (("1" (expand compose_translate_vars)
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (replace ctv)
                        (("2" (expand compose_translate_vars obj)
                          (("2" (assert)
                            (("2" (expand redex_matches rm)
                              (("2"
                                (with-labels (flatten rm) ((frm srm)))
                                (("2"
                                  (replace fv1d :dir RL)
                                  (("2"
                                    (replace fct1 :dir RL)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (case-replace
                                         "tv1!1 = extract_call_tv(D, trS`def_types, iS)")
                                        (("1"
                                          (name-replace
                                           k
                                           "i - popDepth(A2) - popDepth(K2)")
                                          (("1"
                                            (inst rsame k)
                                            (("1"
                                              (case-replace
                                               "i = k + popDepth(A2) + popDepth(K2)")
                                              (("1"
                                                (replace
                                                 rsame
                                                 obj
                                                 :dir
                                                 RL)
                                                (("1"
                                                  (inst
                                                   srm
                                                   "k + popDepth(A1) + popDepth(K1)")
                                                  (("1"
                                                    (expand
                                                     compose_translate_vars
                                                     srm)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace
                                                         srm
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (inst? isame)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (use
                                                             extract_call_tv_bound)
                                                            (("2"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (typepred
                                                                 "iS`stack")
                                                                (("1"
                                                                  (rewrite
                                                                   -1)
                                                                  (("1"
                                                                    (rewrite
                                                                     fdepth_sum_pop
                                                                     1)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (expand
                                                                 k)
                                                                (("2"
                                                                  (hide
                                                                   2)
                                                                  (("2"
                                                                    (hide
                                                                     obj)
                                                                    (("2"
                                                                      (case-replace
                                                                       "popDepth(A2) = popDepth(trS2`state`redex) + popDepth(K1) - popDepth(K2)")
                                                                      (("1"
                                                                        (assert)
                                                                        (("1"
                                                                          (case-replace
                                                                           "trS2`state`context = compose(extract_call_context(D, trS`def_types, iS), K1)")
                                                                          (("1"
                                                                            (rewrite
                                                                             compose_popDepth)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (replace
                                                                             ctxe
                                                                             :dir
                                                                             RL)
                                                                            (("2"
                                                                              (replace
                                                                               a1e)
                                                                              (("2"
                                                                                (use
                                                                                 fill_eq_ctx)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (replace
                                                                         a2e
                                                                         :dir
                                                                         RL)
                                                                        (("2"
                                                                          (rewrite
                                                                           popdepth_fill)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (replace
                                                                               k1e)
                                                                              (("2"
                                                                                (rewrite
                                                                                 compose_popDepth)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (split)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (replace a1e)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (expand k)
                                                          (("2"
                                                            (hide obj)
                                                            (("2"
                                                              (replace
                                                               ctxe)
                                                              (("2"
                                                                (case-replace
                                                                 "popDepth(A2) = popDepth(fill(K3, trS2`state`redex))")
                                                                (("1"
                                                                  (rewrite
                                                                   popdepth_fill)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (replace
                                                                       k1e)
                                                                      (("1"
                                                                        (rewrite
                                                                         compose_popDepth)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand k)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand k)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand k)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (case
                                                     "i < trS2`state`stack`length")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (case-replace
                                                         "popDepth(A2) = popDepth(trS2`state`redex) + popDepth(K1) - popDepth(K2)")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (case-replace
                                                           "popDepth(K1) = popDepth(compose(K2, K3))")
                                                          (("1"
                                                            (case-replace
                                                             "popDepth(fill(K3, trS2`state`redex)) = popDepth(A2)")
                                                            (("1"
                                                              (rewrite
                                                               compose_popDepth)
                                                              (("1"
                                                                (rewrite
                                                                 popdepth_fill)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "trS`state`redex")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (replace callt)
                                          (("2"
                                            (use extract_call_tv_eq)
                                            (("2"
                                              (split -1)
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (replace cpope)
                                                  (("2"
                                                    (expand
                                                     pop
                                                     :assert?
                                                     none)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (expand endi)
                                                (("3"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil)
             ("2" (assert) nil nil))
            nil)
           ("2" (replace fve)
            (("2" (replace fv2d)
              (("2" (expand endi) (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fill def-decl "IExpression" IL nil)
    (extract_call_tv_bound formula-decl nil itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (endi const-decl "T" ireduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (extract_call_tv_eq formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (extract_call_context_eq formula-decl nil itranslation nil)
    (compose_assoc formula-decl nil IL nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (fill_eq_ctx formula-decl nil IL nil)
    (redex_matches const-decl "bool" itranslation nil)
    (context_composition formula-decl nil IL nil)
    (compose def-decl "IContext" IL nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (tdef type-eq-decl nil itranslation nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Definition type-eq-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (redex_matches_l formula-decl nil itranslation nil))
   shostak)
  (redex_stillmatch1-1 nil 3707160550
   ("" (skeep* :preds? t)
    (("" (expand redex_matches)
      (("" (rewrite context_composition)
        (("" (rewrite context_composition)
          (("1" (split)
            (("1"
              (case-replace
               "extract_call_context(D, trS2`def_types, iS2) = extract_call_context(D, trS`def_types, iS)")
              (("1" (replace -8)
                (("1" (simplify :let-reduce? t)
                  (("1" (flatten)
                    (("1" (replace -13)
                      (("1" (rewrite context_composition - :dir RL)
                        (("1" (skeep)
                          (("1" (replace -15 :dir RL)
                            (("1"
                              (rewrite context_composition + :dir RL)
                              (("1"
                                (replace -14 :dir RL)
                                (("1"
                                  (rewrite
                                   context_composition
                                   +
                                   :dir
                                   RL)
                                  (("1" (postpone) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (use extract_call_context_eq)
                  (("2" (split)
                    (("1" (assert) nil nil)
                     ("2" (assert)
                      (("2" (replace -8)
                        (("2" (expand pop :assert? none)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil)
                     ("3" (assert)
                      (("3" (replace -9)
                        (("3" (expand endi) (("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep :preds? t)
              (("2"
                (case-replace
                 "extract_call_tv(D, trS2`def_types, iS2) = extract_call_tv(D, trS`def_types, iS)")
                (("1" (simplify :let-reduce? t)
                  (("1" (flatten)
                    (("1" (expand compose_translate_vars +)
                      (("1" (lift-if +)
                        (("1" (split +)
                          (("1" (flatten)
                            (("1" (inst -18 i)
                              (("1" (postpone) nil nil)
                               ("2"
                                (assert)
                                (("2"
                                  (hide-all-but (1 -1))
                                  (("2"
                                    (expand endi)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2"
                              (name-replace "u"
                               "fct_reconstruct_state(D`seq
                                              (endi
                                               (iS2`callstack,
                                                0)`ffct)`body,
                                              iS2`stack,
                                              D`seq
                                              (endi
                                               (iS2`callstack,
                                                0)`ffct)`arity,
                                              endi
                                              (iS2`callstack, 0)`fdepth,
                                              endi
                                              (iS2`callstack, 0)`fpc)")
                              (("1"
                                (inst
                                 -19
                                 "i-popDepth(u`1)-popDepth(u`2)")
                                (("1" (postpone) nil nil)
                                 ("2"
                                  (assert)
                                  (("2" (postpone) nil nil))
                                  nil))
                                nil)
                               ("2" (postpone) nil nil)
                               ("3" (postpone) nil nil)
                               ("4" (postpone) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (use extract_call_tv_eq)
                  (("2" (split)
                    (("1" (assert) nil nil)
                     ("2" (replace -9)
                      (("2" (expand pop :assert? none)
                        (("2" (propax) nil nil)) nil))
                      nil)
                     ("3" (replace -10)
                      (("3" (expand endi) (("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2) (("2" (postpone) nil nil)) nil)
           ("3" (hide 2) (("3" (postpone) nil nil)) nil)
           ("4" (hide 2) (("4" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (fill_fill_eq 0
  (fill_fill_eq-1 nil 3707486632
   ("" (induct K1)
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (induct K2)
        (("1" (skeep* :preds? t)
          (("1" (inst 1 "letc(letc1_var, letc2_var)")
            (("1" (grind) nil nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand fill -2)
              (("2" (decompose-equality -2)
                (("2" (inst? -4)
                  (("2" (assert)
                    (("2" (split -4)
                      (("1" (skeep)
                        (("1" (expand compose 1)
                          (("1" (inst 1 K) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst 3 K) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (grind) nil nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (induct K2)
        (("1" (skeep)
          (("1" (inst 1 "popc(popc1_var)") (("1" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil)
         ("3" (skeep)
          (("3" (skeep)
            (("3" (expand fill -2)
              (("3" (decompose-equality -2)
                (("3" (inst? -3)
                  (("3" (assert)
                    (("3" (split)
                      (("1" (skeep)
                        (("1" (inst 1 K) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst 3 K) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (compose def-decl "IContext" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   shostak))
 (fill_fill_eq2 0
  (fill_fill_eq2-1 nil 3707486984
   ("" (skeep)
    (("" (use fill_fill_eq)
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep)
          (("2" (case "popc?(K)")
            (("1" (grind) nil nil)
             ("2" (case "letc?(K)")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil)
         ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((fill_fill_eq formula-decl nil itranslation nil)
    (IContext type-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (fill def-decl "IExpression" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil))
   shostak))
 (redex_stillmatch_assign_TCC1 0
  (redex_stillmatch_assign_TCC1-1 nil 3707485006
   ("" (skeep* :preds? t)
    (("" (typepred "iS2`stack")
      (("" (rewrite fdepth_sum_pop)
        (("" (typepred "fv1`fdepth")
          (("" (assert)
            (("" (split -1)
              (("1" (use avar_assign_vindex_bound)
                (("1" (replace -6)
                  (("1" (expand translate_definitions)
                    (("1" (assert)
                      (("1" (expand endi) (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (assert)
                  (("2" (replace -6)
                    (("2" (expand translate_definitions)
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (endi const-decl "T" ireduction nil)
    (translate_length def-decl "posnat" itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (avar_assign_vindex_bound formula-decl nil itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (translate_length_def formula-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "0"
    "below(iS2`callstack`length)")))
 (redex_stillmatch_assign_TCC2 0
  (redex_stillmatch_assign_TCC10-1 nil 3707485006
   ("" (skeep* :preds? t)
    (("" (use fct_reconstruct_state_tv)
      (("" (split)
        (("1" (assert)
          (("1" (typepred "iS2`stack")
            (("1" (rewrite fdepth_sum_pop)
              (("1" (assert)
                (("1" (expand endi) (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((fct_reconstruct_state_tv formula-decl nil itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (istat type-decl nil ireduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (endi const-decl "T" ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "i + IL.popDepth(K1)"
    "below(trS`state`stack`length)")))
 (redex_stillmatch_assign_TCC3 0
  (redex_stillmatch_assign_TCC11-1 nil 3707485006
   ("" (skeep* :preds? t)
    (("" (typepred "trS2`state`redex")
      (("" (assert)
        (("" (assert)
          (("" (case "popDepth(K1) <= popDepth(trS`state`context)")
            (("1" (assert) nil nil)
             ("2" (expand redex_matches)
              (("2" (flatten)
                (("2" (replace -28 :dir RL)
                  (("2" (replace -19 :dir RL)
                    (("2" (assert)
                      (("2"
                        (case "popDepth(fill(compose(extract_call_context(D, trS`def_types, iS), K1), A1)) = 
       popDepth(fill(trS`state`context, trS`state`redex))")
                        (("1" (rewrite popdepth_fill)
                          (("1" (rewrite popdepth_fill)
                            (("1" (rewrite compose_popDepth)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (redex_matches const-decl "bool" itranslation nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Definition type-eq-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (compose def-decl "IContext" IL nil)
    (fill def-decl "IExpression" IL nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "i + IL.popDepth(K1)"
    "below(trS2`state`stack`length)")))
 (redex_stillmatch_assign_TCC4 0
  (redex_stillmatch_assign_TCC12-1 nil 3707485006
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "trS2"
    "{trS | typed_reduction.defs_well_typed(D, trS`def_types)}")))
 (redex_stillmatch_assign_TCC5 0
  (redex_stillmatch_assign_TCC13-1 nil 3707485006
   ("" (skeep* :preds? t)
    (("" (typepred "iS2`stack")
      (("" (rewrite -1)
        (("" (rewrite fdepth_sum_pop)
          (("" (typepred "iS`stack")
            (("" (rewrite fdepth_sum_pop)
              (("" (expand endi) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil) nil
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (endi const-decl "T" ireduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "iS2"
    "{iS | iS`defs = translate_definitions(D, trS2`def_types) AND iS`callstack`length > 0}")))
 (redex_stillmatch_assign_TCC6 0
  (redex_stillmatch_assign_TCC2-1 nil 3707485006 ("" (assert) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil (redex_stillmatch_assign subtype "fv1`ffct" "below[D`length]")))
 (redex_stillmatch_assign_TCC7 0
  (redex_stillmatch_assign_TCC3-1 nil 3707485006
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "fv1`fdepth"
    "{fdepth: posnat | fdepth <= iS`stack`length}")))
 (redex_stillmatch_assign_TCC8 0
  (redex_stillmatch_assign_TCC4-1 nil 3707485006
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (redex_stillmatch_assign subtype "fv1`fpc"
    "{pc: upto(translate_length(D`seq(fv1`ffct)`body)) | pc = translate_length(D`seq(fv1`ffct)`body) OR 1 + D`seq(fv1`ffct)`arity + translate_stack_size_at(D`seq(fv1`ffct)`body, pc) = fv1`fdepth}")))
 (redex_stillmatch_assign_TCC9 0
  (redex_stillmatch_assign_TCC10-1 nil 3707580139
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fct_is_result_defined const-decl "bool" itranslation nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (endi const-decl "T" ireduction nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (redex_matches const-decl "bool" itranslation nil)
    (value? const-decl "bool" IL nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (redex_stillmatch_assign subtype "itranslation.iS2"
    "{iS | booleans.AND(itranslation.iS`defs = itranslation.translate_definitions(itranslation.D, itranslation.trS2`def_types), reals.>(itranslation.iS`callstack`length, 0))}")))
 (redex_stillmatch_assign 0
  (redex_stillmatch_assign-4 "" 3707584169
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 i1e i1l i2e i2l ctxe pope fv1d fv2d ffcte fpclo
       fpcnext fdeq assign nlkup rdm rec1 a1e dp1 dp2 sl r2v r2e var1
       var2 var3 obj)))
    (("" (lemma redex_stillmatch1)
      (("" (inst -1 D trS trS2 iS iS2 fv1 fv2 A1 _ K1 _ _ tv1 _)
        (("" (assert)
          ((""
            (name-replace "tv2"
             "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                              iS2`stack,
                                              D`seq(fv2`ffct)`arity,
                                              fv2`fdepth,
                                              fv2`fpc)`3")
            (("1"
              (name-replace "K2"
               "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                  iS2`stack,
                                                  D`seq(fv2`ffct)`arity,
                                                  fv2`fdepth,
                                                  fv2`fpc)`2")
              (("1"
                (name-replace "A2"
                 "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                  iS2`stack,
                                                  D`seq(fv2`ffct)`arity,
                                                  fv2`fdepth,
                                                  fv2`fpc)`1")
                (("1" (inst -4 A2 K2 _ tv2)
                  (("1" (replace rec1 -4 :dir RL)
                    (("1"
                      (case-replace
                       "fct_reconstruct_state(D`seq(fv2`ffct)`body, iS2`stack,
                                    D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc) = (A2, K2, tv2)")
                      (("1" (assert)
                        (("1" (replace pope)
                          (("1" (lemma fill_fill_eq2)
                            (("1" (inst -1 "trS2`state`redex" A2 K1 K2)
                              (("1"
                                (split -1)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst -4 K)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (split 1)
                                         ((o1) (o2) (o3) (rdef)))
                                        (("1"
                                          (with-labels
                                           (skeep :preds? t)
                                           ((ih o1)))
                                          (("1"
                                            (inst var1 i)
                                            (("1"
                                              (case-replace
                                               "tv2 = tv1")
                                              (("1"
                                                (lemma
                                                 fct_reconstruct_state_tv_next_pc)
                                                (("1"
                                                  (inst
                                                   -1
                                                   "D`seq(fv2`ffct)`body"
                                                   "iS2`stack"
                                                   "iS`stack"
                                                   "D`seq(fv2`ffct)`arity"
                                                   "fv1`fdepth"
                                                   "fv1`fpc")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (replace ffcte)
                                                      (("1"
                                                        (replace fdeq)
                                                        (("1"
                                                          (split)
                                                          (("1"
                                                            (use
                                                             translate_extract_decl_begin_is_assign)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             translate_extract_decl_end_is_assign)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (use
                                                             translate_extract_skip_is_assign)
                                                            (("3"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (typepred
                                                     "fv1`fdepth")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (replace i1e)
                                                        (("2"
                                                          (expand
                                                           translate_definitions)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (typepred
                                                     "iS2`stack")
                                                    (("3"
                                                      (rewrite
                                                       fdepth_sum_pop)
                                                      (("3"
                                                        (expand endi)
                                                        (("3"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("4"
                                                    (typepred
                                                     "iS2`stack")
                                                    (("4"
                                                      (rewrite -1)
                                                      (("4"
                                                        (rewrite
                                                         fdepth_sum_pop)
                                                        (("4"
                                                          (typepred
                                                           "iS`stack")
                                                          (("4"
                                                            (rewrite
                                                             fdepth_sum_pop)
                                                            (("4"
                                                              (rewrite
                                                               -1)
                                                              (("4"
                                                                (assert)
                                                                (("4"
                                                                  (case-replace
                                                                   "iS2`defs = iS`defs")
                                                                  (("1"
                                                                    (expand
                                                                     endi)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (case
                                                 "popDepth(A2) + popDepth(K2) = popDepth(K1)")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (case
                                                   "popDepth(K1) = popDepth(compose(K2, K))")
                                                  (("1"
                                                    (case
                                                     "popDepth(A2) = popDepth(fill(K, trS2`state`redex))")
                                                    (("1"
                                                      (rewrite
                                                       popdepth_fill)
                                                      (("1"
                                                        (rewrite
                                                         compose_popDepth)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skeep)
                                          (("2"
                                            (inst var2 i)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (with-labels
                                           (skeep :preds? t)
                                           ((ih o3)))
                                          (("3"
                                            (inst var3 i)
                                            (("3"
                                              (case
                                               "popDepth(A2) + popDepth(K2) = popDepth(K1)")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (case
                                                 "popDepth(K1) = popDepth(compose(K2, K))")
                                                (("1"
                                                  (case
                                                   "popDepth(A2) = popDepth(fill(K, trS2`state`redex))")
                                                  (("1"
                                                    (rewrite
                                                     compose_popDepth)
                                                    (("1"
                                                      (rewrite
                                                       popdepth_fill)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("4"
                                          (replace fpcnext)
                                          (("4"
                                            (replace ffcte)
                                            (("4"
                                              (replace ffcte :dir RL)
                                              (("4"
                                                (replace fdeq :dir RL)
                                                (("4"
                                                  (lemma
                                                   fct_is_result_defined_assign_next_pc)
                                                  (("4"
                                                    (inst?)
                                                    (("1"
                                                      (rewrite -1)
                                                      (("1"
                                                        (hide-all-but
                                                         (r2v
                                                          r2e
                                                          rdef))
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             ival_to_val)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "fv1`fdepth")
                                                      (("2"
                                                        (split -1)
                                                        (("1"
                                                          (replace -1)
                                                          (("1"
                                                            (replace
                                                             i1e)
                                                            (("1"
                                                              (expand
                                                               translate_definitions)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (replace
                                                             i1e)
                                                            (("2"
                                                              (expand
                                                               translate_definitions)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma fct_reconstruct_state_next_pc)
                                  (("2"
                                    (inst
                                     -1
                                     "D`seq(fv1`ffct)`body"
                                     "iS2`stack"
                                     "iS`stack"
                                     "D`seq(fv1`ffct)`arity"
                                     "fv1`fdepth"
                                     "fv1`fpc")
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (replace ffcte)
                                        (("1"
                                          (replace fpcnext)
                                          (("1"
                                            (case-replace
                                             "fv1`fdepth = fv2`fdepth")
                                            (("1"
                                              (replace -3)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil)
                                       ("3" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (typepred "fv1`fdepth")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replace i1e)
                                          (("2"
                                            (expand
                                             translate_definitions)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split -1)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (replace fdeq)
                                      (("3"
                                        (typepred "iS2`stack")
                                        (("3"
                                          (rewrite fdepth_sum_pop)
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4"
                                      (typepred "iS`stack")
                                      (("4"
                                        (rewrite -1)
                                        (("4"
                                          (rewrite fdepth_sum_pop)
                                          (("4"
                                            (typepred "iS2`stack")
                                            (("4"
                                              (rewrite fdepth_sum_pop)
                                              (("4"
                                                (rewrite -1)
                                                (("4"
                                                  (case-replace
                                                   "iS2`defs = iS`defs")
                                                  (("1"
                                                    (replace
                                                     pope
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (case-replace
                                                       "fdepth_sum(iS`defs)(pop(iS`callstack)) = fdepth_sum(iS`defs)(pop(iS2`callstack))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("3"
                                                        (skeep)
                                                        (("3"
                                                          (typepred
                                                           "pop(iS2`callstack)`seq(x1)`fpc")
                                                          (("3"
                                                            (typepred
                                                             "pop(iS2`callstack)`seq(x1)`ffct")
                                                            (("3"
                                                              (typepred
                                                               "pop(iS2`callstack)`seq(x1)`fdepth")
                                                              (("3"
                                                                (assert)
                                                                (("3"
                                                                  (flatten)
                                                                  (("3"
                                                                    (assert)
                                                                    (("3"
                                                                      (flatten)
                                                                      (("3"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide-all-but (-1 r2e))
                                  (("3" (grind) nil nil))
                                  nil)
                                 ("4"
                                  (hide-all-but (-1 r2e))
                                  (("4" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (decompose-equality 1) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "fv2`fdepth")
              (("2" (replace i1e)
                (("2" (expand translate_definitions)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (split)
                          (("1" (assert) (("1" (assert) nil nil)) nil)
                           ("2" (assert)
                            (("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (split)
              (("1" (assert)
                (("1" (typepred "fv2`fdepth") (("1" (grind) nil nil))
                  nil))
                nil)
               ("2" (typepred "iS2`stack")
                (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "fv2`ffct") (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (fill_fill_eq2 formula-decl nil itranslation nil) nil nil nil nil
    (fct_reconstruct_state_tv_next_pc formula-decl nil itranslation
     nil)
    (endi const-decl "T" ireduction nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_length_def formula-decl nil itranslation nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    nil nil nil nil nil nil (fill def-decl "IExpression" IL nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (compose def-decl "IContext" IL nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (fct_is_result_defined_assign_next_pc formula-decl nil itranslation
     nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fct_reconstruct_state_next_pc formula-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (redex_stillmatch1 formula-decl nil itranslation nil))
   shostak)
  (redex_stillmatch_assign-3 nil 3707584018
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 i1e i1l i2e i2l ctxe pope fv1d fv2d ffcte fpclo
       fpcnext fdeq assign nlkup rdm rec1 a1e dp1 dp2 sl r2v r2e var1
       var2 var3 obj)))
    (("" (lemma redex_stillmatch1)
      (("" (inst -1 D trS trS2 iS iS2 fv1 fv2 A1 _ K1 _ _ tv1 _)
        (("" (assert)
          ((""
            (name-replace "tv2"
             "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                              iS2`stack,
                                              D`seq(fv2`ffct)`arity,
                                              fv2`fdepth,
                                              fv2`fpc)`3")
            (("1"
              (name-replace "K2"
               "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                  iS2`stack,
                                                  D`seq(fv2`ffct)`arity,
                                                  fv2`fdepth,
                                                  fv2`fpc)`2")
              (("1"
                (name-replace "A2"
                 "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                  iS2`stack,
                                                  D`seq(fv2`ffct)`arity,
                                                  fv2`fdepth,
                                                  fv2`fpc)`1")
                (("1" (inst -4 A2 K2 _ tv2)
                  (("1" (replace rec1 -4 :dir RL)
                    (("1"
                      (case-replace
                       "fct_reconstruct_state(D`seq(fv2`ffct)`body, iS2`stack,
                                    D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc) = (A2, K2, tv2)")
                      (("1" (assert)
                        (("1" (replace pope)
                          (("1" (lemma fill_fill_eq2)
                            (("1" (inst -1 "trS2`state`redex" A2 K1 K2)
                              (("1"
                                (split -1)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst -4 K)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (split 1)
                                         ((o1) (o2) (o3) (rdef)))
                                        (("1"
                                          (with-labels
                                           (skeep :preds? t)
                                           ((ih o1)))
                                          (("1"
                                            (inst var1 i)
                                            (("1"
                                              (case-replace
                                               "tv2 = tv1")
                                              (("1"
                                                (lemma
                                                 fct_reconstruct_state_tv_next_pc)
                                                (("1"
                                                  (inst
                                                   -1
                                                   "D`seq(fv2`ffct)`body"
                                                   "iS2`stack"
                                                   "iS`stack"
                                                   "D`seq(fv2`ffct)`arity"
                                                   "fv1`fdepth"
                                                   "fv1`fpc")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (replace ffcte)
                                                      (("1"
                                                        (replace fdeq)
                                                        (("1"
                                                          (split)
                                                          (("1"
                                                            (use
                                                             translate_extract_decl_begin_is_assign)
                                                            (("1"
                                                              (assert)
                                                              nil)))
                                                           ("2"
                                                            (use
                                                             translate_extract_decl_end_is_assign)
                                                            (("2"
                                                              (assert)
                                                              nil)))
                                                           ("3"
                                                            (use
                                                             translate_extract_skip_is_assign)
                                                            (("3"
                                                              (assert)
                                                              nil)))))))))))
                                                   ("2"
                                                    (typepred
                                                     "fv1`fdepth")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (replace i1e)
                                                        (("2"
                                                          (expand
                                                           translate_definitions)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil)))))))))))))
                                                   ("3"
                                                    (typepred
                                                     "iS2`stack")
                                                    (("3"
                                                      (rewrite
                                                       fdepth_sum_pop)
                                                      (("3"
                                                        (expand endi)
                                                        (("3"
                                                          (assert)
                                                          nil)))))))
                                                   ("4"
                                                    (typepred
                                                     "iS2`stack")
                                                    (("4"
                                                      (rewrite -1)
                                                      (("4"
                                                        (rewrite
                                                         fdepth_sum_pop)
                                                        (("4"
                                                          (typepred
                                                           "iS`stack")
                                                          (("4"
                                                            (rewrite
                                                             fdepth_sum_pop)
                                                            (("4"
                                                              (rewrite
                                                               -1)
                                                              (("4"
                                                                (assert)
                                                                (("4"
                                                                  (case-replace
                                                                   "iS2`defs = iS`defs")
                                                                  (("1"
                                                                    (expand
                                                                     endi)
                                                                    (("1"
                                                                      (assert)
                                                                      nil)))
                                                                   ("2"
                                                                    (assert)
                                                                    nil)))))))))))))))))))))))
                                             ("2"
                                              (assert)
                                              (("2"
                                                (case
                                                 "popDepth(A2) + popDepth(K2) = popDepth(K1)")
                                                (("1" (assert) nil)
                                                 ("2"
                                                  (case
                                                   "popDepth(K1) = popDepth(compose(K2, K))")
                                                  (("1"
                                                    (case
                                                     "popDepth(A2) = popDepth(fill(K, trS2`state`redex))")
                                                    (("1"
                                                      (rewrite
                                                       popdepth_fill)
                                                      (("1"
                                                        (rewrite
                                                         compose_popDepth)
                                                        (("1"
                                                          (assert)
                                                          nil)))))
                                                     ("2"
                                                      (assert)
                                                      nil)))
                                                   ("2"
                                                    (assert)
                                                    nil)))))))))))
                                         ("2"
                                          (skeep)
                                          (("2"
                                            (inst var2 i)
                                            (("2" (assert) nil)))))
                                         ("3"
                                          (with-labels
                                           (skeep :preds? t)
                                           ((ih o3)))
                                          (("3"
                                            (inst var3 i)
                                            (("3"
                                              (case
                                               "popDepth(A2) + popDepth(K2) = popDepth(K1)")
                                              (("1" (assert) nil)
                                               ("2"
                                                (case
                                                 "popDepth(K1) = popDepth(compose(K2, K))")
                                                (("1"
                                                  (case
                                                   "popDepth(A2) = popDepth(fill(K, trS2`state`redex))")
                                                  (("1"
                                                    (rewrite
                                                     compose_popDepth)
                                                    (("1"
                                                      (rewrite
                                                       popdepth_fill)
                                                      (("1"
                                                        (assert)
                                                        nil)))))
                                                   ("2" (assert) nil)))
                                                 ("2"
                                                  (assert)
                                                  nil)))))))))))))))))
                                 ("2"
                                  (lemma fct_reconstruct_state_next_pc)
                                  (("2"
                                    (inst
                                     -1
                                     "D`seq(fv1`ffct)`body"
                                     "iS2`stack"
                                     "iS`stack"
                                     "D`seq(fv1`ffct)`arity"
                                     "fv1`fdepth"
                                     "fv1`fpc")
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (replace ffcte)
                                        (("1"
                                          (replace fpcnext)
                                          (("1"
                                            (case-replace
                                             "fv1`fdepth = fv2`fdepth")
                                            (("1"
                                              (replace -3)
                                              (("1"
                                                (assert)
                                                nil)))))))))
                                       ("2" (propax) nil)
                                       ("3" (propax) nil)))
                                     ("2"
                                      (typepred "fv1`fdepth")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replace i1e)
                                          (("2"
                                            (expand
                                             translate_definitions)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split -1)
                                                (("1" (assert) nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil)))))))))))))))
                                     ("3"
                                      (replace fdeq)
                                      (("3"
                                        (typepred "iS2`stack")
                                        (("3"
                                          (rewrite fdepth_sum_pop)
                                          (("3" (grind) nil)))))))
                                     ("4"
                                      (typepred "iS`stack")
                                      (("4"
                                        (rewrite -1)
                                        (("4"
                                          (rewrite fdepth_sum_pop)
                                          (("4"
                                            (typepred "iS2`stack")
                                            (("4"
                                              (rewrite fdepth_sum_pop)
                                              (("4"
                                                (rewrite -1)
                                                (("4"
                                                  (case-replace
                                                   "iS2`defs = iS`defs")
                                                  (("1"
                                                    (replace
                                                     pope
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (case-replace
                                                       "fdepth_sum(iS`defs)(pop(iS`callstack)) = fdepth_sum(iS`defs)(pop(iS2`callstack))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (grind)
                                                          nil)))
                                                       ("2"
                                                        (assert)
                                                        nil)
                                                       ("3"
                                                        (skeep)
                                                        (("3"
                                                          (typepred
                                                           "pop(iS2`callstack)`seq(x1)`fpc")
                                                          (("3"
                                                            (typepred
                                                             "pop(iS2`callstack)`seq(x1)`ffct")
                                                            (("3"
                                                              (typepred
                                                               "pop(iS2`callstack)`seq(x1)`fdepth")
                                                              (("3"
                                                                (assert)
                                                                (("3"
                                                                  (flatten)
                                                                  (("3"
                                                                    (assert)
                                                                    (("3"
                                                                      (flatten)
                                                                      (("3"
                                                                        (assert)
                                                                        nil)))))))))))))))))))))
                                                   ("2"
                                                    (assert)
                                                    nil)))))))))))))))))))
                                 ("3"
                                  (hide-all-but (-1 r2e))
                                  (("3" (grind) nil)))
                                 ("4"
                                  (hide-all-but (-1 r2e))
                                  (("4" (grind) nil)))))))))))))
                       ("2" (decompose-equality 1) nil)))))))))))
             ("2" (typepred "fv2`fdepth")
              (("2" (replace i1e)
                (("2" (expand translate_definitions)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (split)
                          (("1" (assert) (("1" (assert) nil)))
                           ("2" (assert)
                            (("2" (flatten)
                              (("2" (assert) nil)))))))))))))))))))
             ("3" (split)
              (("1" (assert)
                (("1" (typepred "fv2`fdepth") (("1" (grind) nil)))))
               ("2" (typepred "iS2`stack")
                (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil)))))))
             ("4" (typepred "fv2`ffct") (("4" (grind) nil))))))))))))
    nil)
   nil nil)
  (redex_stillmatch_assign-2 nil 3707487855
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 i1e i1l i2e i2l ctxe pope fv1d fv2d ffcte fpclo
       fpcnext fdeq assign nlkup rdm rec1 a1e dp1 dp2 sl r2e var1 var2
       var3 obj)))
    (("" (lemma redex_stillmatch1)
      (("" (inst -1 D trS trS2 iS iS2 fv1 fv2 A1 _ K1 _ _ tv1 _)
        (("" (assert)
          ((""
            (name-replace "tv2"
             "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                            iS2`stack,
                                            D`seq(fv2`ffct)`arity,
                                            fv2`fdepth,
                                            fv2`fpc)`3")
            (("1"
              (name-replace "K2"
               "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                              iS2`stack,
                                              D`seq(fv2`ffct)`arity,
                                              fv2`fdepth,
                                              fv2`fpc)`2")
              (("1"
                (name-replace "A2"
                 "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                              iS2`stack,
                                              D`seq(fv2`ffct)`arity,
                                              fv2`fdepth,
                                              fv2`fpc)`1")
                (("1" (inst -4 A2 K2 _ tv2)
                  (("1" (replace rec1 -4 :dir RL)
                    (("1"
                      (case-replace
                       "fct_reconstruct_state(D`seq(fv2`ffct)`body, iS2`stack,
                                D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc) = (A2, K2, tv2)")
                      (("1" (assert)
                        (("1" (replace pope)
                          (("1" (lemma fill_fill_eq2)
                            (("1" (inst -1 "trS2`state`redex" A2 K1 K2)
                              (("1"
                                (split -1)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst -4 K)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (with-labels
                                         (split 1)
                                         ((o1) (o2) (o3)))
                                        (("1"
                                          (with-labels
                                           (skeep :preds? t)
                                           ((ih o1)))
                                          (("1"
                                            (inst var1 i)
                                            (("1"
                                              (case-replace
                                               "tv2 = tv1")
                                              (("1"
                                                (lemma
                                                 fct_reconstruct_state_tv_next_pc)
                                                (("1"
                                                  (inst
                                                   -1
                                                   "D`seq(fv2`ffct)`body"
                                                   "iS2`stack"
                                                   "iS`stack"
                                                   "D`seq(fv2`ffct)`arity"
                                                   "fv1`fdepth"
                                                   "fv1`fpc")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (replace ffcte)
                                                      (("1"
                                                        (replace fdeq)
                                                        (("1"
                                                          (split)
                                                          (("1"
                                                            (use
                                                             translate_extract_decl_begin_is_assign)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (use
                                                             translate_extract_decl_end_is_assign)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (use
                                                             translate_extract_skip_is_assign)
                                                            (("3"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (typepred
                                                     "fv1`fdepth")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (replace i1e)
                                                        (("2"
                                                          (expand
                                                           translate_definitions)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (split
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (typepred
                                                     "iS2`stack")
                                                    (("3"
                                                      (rewrite
                                                       fdepth_sum_pop)
                                                      (("3"
                                                        (expand endi)
                                                        (("3"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("4"
                                                    (typepred
                                                     "iS2`stack")
                                                    (("4"
                                                      (rewrite -1)
                                                      (("4"
                                                        (rewrite
                                                         fdepth_sum_pop)
                                                        (("4"
                                                          (typepred
                                                           "iS`stack")
                                                          (("4"
                                                            (rewrite
                                                             fdepth_sum_pop)
                                                            (("4"
                                                              (rewrite
                                                               -1)
                                                              (("4"
                                                                (assert)
                                                                (("4"
                                                                  (case-replace
                                                                   "iS2`defs = iS`defs")
                                                                  (("1"
                                                                    (expand
                                                                     endi)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (case
                                                 "popDepth(A2) + popDepth(K2) = popDepth(K1)")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (case
                                                   "popDepth(K1) = popDepth(compose(K2, K))")
                                                  (("1"
                                                    (case
                                                     "popDepth(A2) = popDepth(fill(K, trS2`state`redex))")
                                                    (("1"
                                                      (rewrite
                                                       popdepth_fill)
                                                      (("1"
                                                        (rewrite
                                                         compose_popDepth)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (skeep)
                                          (("2"
                                            (inst var2 i)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (with-labels
                                           (skeep :preds? t)
                                           ((ih o3)))
                                          (("3"
                                            (inst var3 i)
                                            (("3"
                                              (case
                                               "popDepth(A2) + popDepth(K2) = popDepth(K1)")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (case
                                                 "popDepth(K1) = popDepth(compose(K2, K))")
                                                (("1"
                                                  (case
                                                   "popDepth(A2) = popDepth(fill(K, trS2`state`redex))")
                                                  (("1"
                                                    (rewrite
                                                     compose_popDepth)
                                                    (("1"
                                                      (rewrite
                                                       popdepth_fill)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma fct_reconstruct_state_next_pc)
                                  (("2"
                                    (inst
                                     -1
                                     "D`seq(fv1`ffct)`body"
                                     "iS2`stack"
                                     "iS`stack"
                                     "D`seq(fv1`ffct)`arity"
                                     "fv1`fdepth"
                                     "fv1`fpc")
                                    (("1"
                                      (split -1)
                                      (("1"
                                        (replace ffcte)
                                        (("1"
                                          (replace fpcnext)
                                          (("1"
                                            (case-replace
                                             "fv1`fdepth = fv2`fdepth")
                                            (("1"
                                              (replace -3)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil)
                                       ("3" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (typepred "fv1`fdepth")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replace i1e)
                                          (("2"
                                            (expand
                                             translate_definitions)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split -1)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (replace fdeq)
                                      (("3"
                                        (typepred "iS2`stack")
                                        (("3"
                                          (rewrite fdepth_sum_pop)
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("4"
                                      (typepred "iS`stack")
                                      (("4"
                                        (rewrite -1)
                                        (("4"
                                          (rewrite fdepth_sum_pop)
                                          (("4"
                                            (typepred "iS2`stack")
                                            (("4"
                                              (rewrite fdepth_sum_pop)
                                              (("4"
                                                (rewrite -1)
                                                (("4"
                                                  (case-replace
                                                   "iS2`defs = iS`defs")
                                                  (("1"
                                                    (replace
                                                     pope
                                                     :dir
                                                     RL)
                                                    (("1"
                                                      (case-replace
                                                       "fdepth_sum(iS`defs)(pop(iS`callstack)) = fdepth_sum(iS`defs)(pop(iS2`callstack))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("3"
                                                        (skeep)
                                                        (("3"
                                                          (typepred
                                                           "pop(iS2`callstack)`seq(x1)`fpc")
                                                          (("3"
                                                            (typepred
                                                             "pop(iS2`callstack)`seq(x1)`ffct")
                                                            (("3"
                                                              (typepred
                                                               "pop(iS2`callstack)`seq(x1)`fdepth")
                                                              (("3"
                                                                (assert)
                                                                (("3"
                                                                  (flatten)
                                                                  (("3"
                                                                    (assert)
                                                                    (("3"
                                                                      (flatten)
                                                                      (("3"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide-all-but (-1 r2e))
                                  (("3" (grind) nil nil))
                                  nil)
                                 ("4"
                                  (hide-all-but (-1 r2e))
                                  (("4" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (decompose-equality 1) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "fv2`fdepth")
              (("2" (replace i1e)
                (("2" (expand translate_definitions)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (split)
                          (("1" (assert) (("1" (assert) nil nil)) nil)
                           ("2" (assert)
                            (("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (split)
              (("1" (assert)
                (("1" (typepred "fv2`fdepth") (("1" (grind) nil nil))
                  nil))
                nil)
               ("2" (typepred "iS2`stack")
                (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "fv2`ffct") (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (istat type-decl nil ireduction nil)
    (vars def-decl "bool" ireduction nil)
    (Definition type-eq-decl nil ireduction nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (slength def-decl "posnat" ireduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (istate type-eq-decl nil ireduction nil)
    (tdef type-eq-decl nil itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (fill_fill_eq2 formula-decl nil itranslation nil)
    (fct_reconstruct_state_tv_next_pc formula-decl nil itranslation
     nil)
    (endi const-decl "T" ireduction nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (translate_length_def formula-decl nil itranslation nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (translate_extract_skip_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_decl_end_is_assign formula-decl nil itranslation
     nil)
    (translate_extract_decl_begin_is_assign formula-decl nil
     itranslation nil)
    (fill def-decl "IExpression" IL nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (popdepth_fill formula-decl nil IL nil)
    (compose def-decl "IContext" IL nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (ival_to_val const-decl "IExpression" itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fct_reconstruct_state_next_pc formula-decl nil itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (redex_stillmatch1 formula-decl nil itranslation nil))
   nil)
  (redex_stillmatch_assign-1 nil 3707485006
   (""
    (with-labels (skeep* :preds? t)
     ((dwt1 dwt2 i1e i1l i2e i2l ctxe pope fv1d fv2d ffcte fpclo
       fpcnext assign nlkup rdm rec1 a1e dp1 dp2 sl r2e var1 var2 var3
       obj)))
    (("" (lemma redex_stillmatch1)
      (("" (inst -1 D trS trS2 iS iS2 fv1 fv2 A1 _ K1 _ _ tv1 _)
        (("" (assert)
          ((""
            (name-replace "tv2"
             "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                          iS2`stack,
                                          D`seq(fv2`ffct)`arity,
                                          fv2`fdepth,
                                          fv2`fpc)`3")
            (("1"
              (name-replace "K2"
               "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                          iS2`stack,
                                          D`seq(fv2`ffct)`arity,
                                          fv2`fdepth,
                                          fv2`fpc)`2")
              (("1"
                (name-replace "A2"
                 "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                          iS2`stack,
                                          D`seq(fv2`ffct)`arity,
                                          fv2`fdepth,
                                          fv2`fpc)`1")
                (("1" (inst -4 A2 K2 _ tv2)
                  (("1" (replace rec1 -4 :dir RL)
                    (("1" (replace fv1d -4 :dir RL)
                      (("1" (replace fv2d -4 :dir RL)
                        (("1"
                          (case-replace
                           "fct_reconstruct_state(D`seq(fv2`ffct)`body, iS2`stack,
                            D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc) = (A2, K2, tv2)")
                          (("1" (assert)
                            (("1" (replace pope)
                              (("1"
                                (lemma fill_fill_eq2)
                                (("1"
                                  (inst -1 "trS2`state`redex" A2 K1 K2)
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (inst -4 K)
                                        (("1"
                                          (assert)
                                          (("1" (postpone) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma
                                       fct_reconstruct_state_next_pc)
                                      (("2"
                                        (inst
                                         -1
                                         "D`seq(fv1`ffct)`body"
                                         "iS2`stack"
                                         "iS`stack"
                                         "D`seq(fv1`ffct)`arity"
                                         "fv1`fdepth"
                                         "fv1`fpc")
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (replace ffcte)
                                            (("1"
                                              (replace fpcnext)
                                              (("1"
                                                (case-replace
                                                 "fv1`fdepth = fv2`fdepth")
                                                (("1"
                                                  (replace -3)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (typepred
                                                   "fv1`fdepth")
                                                  (("2"
                                                    (postpone)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (propax) nil nil)
                                           ("3" (propax) nil nil))
                                          nil)
                                         ("2"
                                          (typepred "fv1`fdepth")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (replace i1e)
                                              (("2"
                                                (expand
                                                 translate_definitions)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (split -1)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3" (postpone) nil nil)
                                         ("4" (postpone) nil nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (hide-all-but (-1 r2e))
                                      (("3" (grind) nil nil))
                                      nil)
                                     ("4"
                                      (hide-all-but (-1 r2e))
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (decompose-equality 1) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (postpone) nil nil)
             ("3" (split)
              (("1" (assert)
                (("1" (typepred "fv2`fdepth") (("1" (grind) nil nil))
                  nil))
                nil)
               ("2" (typepred "iS2`stack")
                (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "fv2`ffct") (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (state_matches_TCC1 0
  (state_matches_TCC6-1 nil 3707055204 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil))
   nil
   (state_matches subtype "iS`store"
    "[(trS`state`domain) -> finseq[ireduction.ivalue]]")))
 (state_matches_TCC2 0
  (state_matches_TCC8-1 nil 3707055204
   ("" (skeep* :preds? t)
    (("" (typepred "iS`stack") (("" (assert) nil nil)) nil)) nil)
   ((istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "bool" ireduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (istat type-decl nil ireduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil (state_matches subtype "0" "below[iS`stack`length]")))
 (state_matches_TCC3 0
  (state_matches_TCC1-1 nil 3707055204
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (state_matches subtype "typed_rreduction.i"
    "below[typed_rreduction.state`stack`length]")))
 (pushReduce_match_TCC1 0
  (pushReduce_match_TCC1-1 nil 3707136743 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil itranslation nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (store_matches const-decl "bool" itranslation nil)
    (count_matches const-decl "bool" itranslation nil)
    (value? const-decl "bool" IL nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (redex_matches const-decl "bool" itranslation nil)
    (state_matches const-decl "bool" itranslation nil)
    (pushRedex? const-decl "bool" ireduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (pushReduce_match subtype "iS"
    "{iS | ireduction.iS`callstack`length > 0 AND ireduction.pushRedex?(ireduction.iS)}")))
 (pushReduce_match 0
  (pushReduce_match-2 nil 3707584201
   (""
    (with-labels (skeep* :preds? t) ((dwt terr ierr stm cll push obj)))
    (("" (expand state_matches)
      (("" (with-labels (flatten stm) ((defm domm stom cntm rdm)))
        (("" (assert)
          (("" (split obj)
            (("1" (expand pushReduce) (("1" (propax) nil nil)) nil)
             ("2" (expand pushReduce) (("2" (propax) nil nil)) nil)
             ("3" (expand pushReduce) (("3" (propax) nil nil)) nil)
             ("4" (expand pushReduce) (("4" (propax) nil nil)) nil)
             ("5" (expand pushReduce) (("5" (propax) nil nil)) nil)
             ("6" (with-labels (flatten) ((useless obj)))
              (("6" (hide useless)
                (("6" (expand redex_matches rdm)
                  (("6" (with-labels (flatten rdm) ((rdf rds rdd)))
                    (("6"
                      (name-replace K
                       "extract_call_context(D, trS`def_types, iS)")
                      (("6"
                        (name-replace "tv1"
                         "extract_call_tv(D, trS`def_types, iS)")
                        (("6" (name-replace fv "endi(iS`callstack, 0)")
                          (("6"
                            (name-replace u
                             "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                                     D`seq(fv`ffct)`arity, fv`fdepth,
                                     fv`fpc)")
                            (("1" (expand redex_matches)
                              (("1"
                                (case-replace
                                 "extract_call_context(D, trS`def_types, pushReduce(iS)) = K")
                                (("1"
                                  (case-replace
                                   "extract_call_tv
                                             (D, trS`def_types, pushReduce(iS)) = tv1")
                                  (("1"
                                    (case-replace
                                     "endi(pushReduce(iS)`callstack, 0)`fdepth = fv`fdepth + 1")
                                    (("1"
                                      (case-replace
                                       "endi(pushReduce(iS)`callstack, 0)`ffct = fv`ffct")
                                      (("1"
                                        (case-replace
                                         "endi(pushReduce(iS)`callstack, 0)`fpc = translate_next_pc(D`seq(fv`ffct)`body, fv`fpc)")
                                        (("1"
                                          (lemma
                                           fct_reconstruct_state_next_pc_decl_begin)
                                          (("1"
                                            (inst
                                             -1
                                             "D`seq(fv`ffct)`body"
                                             "iS`stack"
                                             "pushReduce(iS)`stack"
                                             "D`seq(fv`ffct)`arity"
                                             "fv`fdepth"
                                             "fv`fpc")
                                            (("1"
                                              (split -1)
                                              (("1"
                                                (with-labels
                                                 (flatten -1)
                                                 ((nxtr nxtc nxtt)))
                                                (("1"
                                                  (replace nxtr)
                                                  (("1"
                                                    (replace nxtc)
                                                    (("1"
                                                      (replace nxtt)
                                                      (("1"
                                                        (split obj)
                                                        (("1"
                                                          (rewrite
                                                           context_composition)
                                                          (("1"
                                                            (replace
                                                             rdf
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (rewrite
                                                               context_composition)
                                                              (("1"
                                                                (rewrite
                                                                 context_composition)
                                                                (("1"
                                                                  (expand
                                                                   fill
                                                                   obj
                                                                   3)
                                                                  (("1"
                                                                    (expand
                                                                     fill
                                                                     obj
                                                                     3)
                                                                    (("1"
                                                                      (apply-eta
                                                                       "u`1"
                                                                       "(letexpr?)")
                                                                      (("1"
                                                                        (expand
                                                                         u)
                                                                        (("1"
                                                                          (replace
                                                                           -1)
                                                                          (("1"
                                                                            (propax)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         obj)
                                                                        (("2"
                                                                          (expand
                                                                           u)
                                                                          (("2"
                                                                            (expand
                                                                             fct_reconstruct_state
                                                                             1)
                                                                            (("2"
                                                                              (case
                                                                               "fv`fpc < translate_length(D`seq(fv`ffct)`body)")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (use
                                                                                   reconstruct_state_decl_begin_letexpr)
                                                                                  (("1"
                                                                                    (assert)
                                                                                    (("1"
                                                                                      (expand
                                                                                       pushRedex?)
                                                                                      (("1"
                                                                                        (expand
                                                                                         state_extract_stat)
                                                                                        (("1"
                                                                                          (lift-if
                                                                                           push)
                                                                                          (("1"
                                                                                            (split
                                                                                             push)
                                                                                            (("1"
                                                                                              (grind)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (flatten)
                                                                                              (("2"
                                                                                                (replace
                                                                                                 defm
                                                                                                 push)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   translate_definitions
                                                                                                   push)
                                                                                                  (("2"
                                                                                                    (use
                                                                                                     translate_extract_decl_begin_def)
                                                                                                    (("1"
                                                                                                      (expand
                                                                                                       fv)
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         -1
                                                                                                         :dir
                                                                                                         RL)
                                                                                                        (("1"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil)
                                                                                                     ("2"
                                                                                                      (assert)
                                                                                                      (("2"
                                                                                                        (expand
                                                                                                         fv)
                                                                                                        (("2"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (hide
                                                                                 2)
                                                                                (("2"
                                                                                  (case
                                                                                   "fv`fpc < slength(iS`defs`seq(fv`ffct)`body)")
                                                                                  (("1"
                                                                                    (replace
                                                                                     defm)
                                                                                    (("1"
                                                                                      (expand
                                                                                       translate_definitions)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (expand
                                                                                     fv)
                                                                                    (("2"
                                                                                      (hide-all-but
                                                                                       (1
                                                                                        push))
                                                                                      (("2"
                                                                                        (grind)
                                                                                        (("2"
                                                                                          (typepred
                                                                                           "iS`callstack`seq(iS`callstack`length - 1)`fpc")
                                                                                          (("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (with-labels
                                                           (skeep
                                                            :preds?
                                                            t)
                                                           ((ih obj)))
                                                          (("2"
                                                            (rewrite
                                                             compose_popDepth)
                                                            (("2"
                                                              (expand
                                                               popDepth
                                                               obj
                                                               2)
                                                              (("2"
                                                                (apply-eta
                                                                 "u`1"
                                                                 "(letexpr?)")
                                                                (("1"
                                                                  (inst
                                                                   rds
                                                                   i)
                                                                  (("1"
                                                                    (case-replace
                                                                     "fct_reconstruct_state
                                                                    (D`seq(fv`ffct)`body,
                                                                     iS`stack,
                                                                     D`seq(fv`ffct)`arity,
                                                                     fv`fdepth,
                                                                     fv`fpc) = u")
                                                                    (("1"
                                                                      (case
                                                                       "i < popDepth(u`1) + popDepth(u`2)")
                                                                      (("1"
                                                                        (expand
                                                                         compose_translate_vars
                                                                         rds)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (expand
                                                                             popDepth
                                                                             -1
                                                                             1)
                                                                            (("1"
                                                                              (expand
                                                                               compose_translate_vars
                                                                               obj)
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (expand
                                                                                   pushReduce)
                                                                                  (("1"
                                                                                    (expand
                                                                                     shift)
                                                                                    (("1"
                                                                                      (expand
                                                                                       endi)
                                                                                      (("1"
                                                                                        (expand
                                                                                         add)
                                                                                        (("1"
                                                                                          (propax)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         compose_translate_vars
                                                                         rds)
                                                                        (("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (expand
                                                                             popDepth
                                                                             1
                                                                             1)
                                                                            (("2"
                                                                              (expand
                                                                               compose_translate_vars
                                                                               obj)
                                                                              (("2"
                                                                                (assert)
                                                                                (("2"
                                                                                  (expand
                                                                                   popDepth
                                                                                   obj
                                                                                   3)
                                                                                  (("2"
                                                                                    (expand
                                                                                     popDepth
                                                                                     obj
                                                                                     3)
                                                                                    (("2"
                                                                                      (expand
                                                                                       pushReduce)
                                                                                      (("2"
                                                                                        (expand
                                                                                         endi)
                                                                                        (("2"
                                                                                          (expand
                                                                                           add)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            (("2"
                                                                                              (lift-if)
                                                                                              (("2"
                                                                                                (split)
                                                                                                (("1"
                                                                                                  (flatten)
                                                                                                  (("1"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (flatten)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       popDepth
                                                                                                       rds
                                                                                                       1)
                                                                                                      (("2"
                                                                                                        (assert)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       u)
                                                                      (("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (hide
                                                                   obj)
                                                                  (("2"
                                                                    (expand
                                                                     u)
                                                                    (("2"
                                                                      (expand
                                                                       fct_reconstruct_state
                                                                       +)
                                                                      (("2"
                                                                        (lift-if
                                                                         +)
                                                                        (("2"
                                                                          (case
                                                                           "fv`fpc < translate_length(D`seq(fv`ffct)`body)")
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (rewrite
                                                                               reconstruct_state_decl_begin_letexpr)
                                                                              (("1"
                                                                                (expand
                                                                                 pushRedex?)
                                                                                (("1"
                                                                                  (expand
                                                                                   state_extract_stat)
                                                                                  (("1"
                                                                                    (lift-if
                                                                                     push)
                                                                                    (("1"
                                                                                      (split
                                                                                       push)
                                                                                      (("1"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil)
                                                                                       ("2"
                                                                                        (replace
                                                                                         defm
                                                                                         push)
                                                                                        (("2"
                                                                                          (expand
                                                                                           translate_definitions
                                                                                           push)
                                                                                          (("2"
                                                                                            (use
                                                                                             translate_extract_decl_begin_def)
                                                                                            (("1"
                                                                                              (flatten)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   fv)
                                                                                                  (("1"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil)
                                                                                             ("2"
                                                                                              (flatten)
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   fv)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (typepred
                                                                               "fv`fpc")
                                                                              (("2"
                                                                                (expand
                                                                                 pushRedex?)
                                                                                (("2"
                                                                                  (expand
                                                                                   state_extract_stat)
                                                                                  (("2"
                                                                                    (expand
                                                                                     fv)
                                                                                    (("2"
                                                                                      (replace
                                                                                       defm
                                                                                       -1)
                                                                                      (("2"
                                                                                        (expand
                                                                                         translate_definitions
                                                                                         -1)
                                                                                        (("2"
                                                                                          (assert)
                                                                                          (("2"
                                                                                            (lift-if
                                                                                             push)
                                                                                            (("2"
                                                                                              (split
                                                                                               push)
                                                                                              (("1"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil)
                                                                                               ("2"
                                                                                                (flatten)
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (replace
                                                                                                     defm
                                                                                                     push)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       translate_definitions
                                                                                                       push)
                                                                                                      (("2"
                                                                                                        (assert)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (expand
                                                           fct_is_result_defined)
                                                          (("3"
                                                            (case
                                                             "translate_next_pc(D`seq(fv`ffct)`body, fv`fpc) < translate_length(D`seq(fv`ffct)`body)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (use
                                                                 translate_is_result_defined_decl_begin_next_pc)
                                                                (("1"
                                                                  (split
                                                                   -1)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (hide
                                                                     obj)
                                                                    (("2"
                                                                      (expand
                                                                       pushRedex?)
                                                                      (("2"
                                                                        (expand
                                                                         state_extract_stat
                                                                         push)
                                                                        (("2"
                                                                          (lift-if
                                                                           push)
                                                                          (("2"
                                                                            (split
                                                                             push)
                                                                            (("1"
                                                                              (grind)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (typepred
                                                                                 "endi(iS`callstack, 0)`fpc")
                                                                                (("2"
                                                                                  (replace
                                                                                   defm
                                                                                   (-1
                                                                                    push))
                                                                                  (("2"
                                                                                    (expand
                                                                                     translate_definitions
                                                                                     (-1
                                                                                      push))
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (lemma
                                                                                         translate_extract_decl_begin_def)
                                                                                        (("2"
                                                                                          (inst?
                                                                                           :where
                                                                                           push)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            (("2"
                                                                                              (expand
                                                                                               fv)
                                                                                              (("2"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (hide
                                                                   obj)
                                                                  (("2"
                                                                    (expand
                                                                     pushReduce
                                                                     +)
                                                                    (("2"
                                                                      (expand
                                                                       add)
                                                                      (("2"
                                                                        (typepred
                                                                         "fv`fdepth")
                                                                        (("2"
                                                                          (split
                                                                           -1)
                                                                          (("1"
                                                                            (replace
                                                                             defm
                                                                             -1)
                                                                            (("1"
                                                                              (expand
                                                                               translate_definitions
                                                                               -1)
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (typepred
                                                                                   "iS`stack")
                                                                                  (("1"
                                                                                    (rewrite
                                                                                     fdepth_sum_pop)
                                                                                    (("1"
                                                                                      (expand
                                                                                       fv)
                                                                                      (("1"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (expand
                                                                               pushRedex?)
                                                                              (("2"
                                                                                (expand
                                                                                 state_extract_stat)
                                                                                (("2"
                                                                                  (lift-if
                                                                                   push)
                                                                                  (("2"
                                                                                    (split
                                                                                     push)
                                                                                    (("1"
                                                                                      (grind)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (replace
                                                                                         defm
                                                                                         push)
                                                                                        (("2"
                                                                                          (expand
                                                                                           translate_definitions
                                                                                           push)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            (("2"
                                                                                              (expand
                                                                                               fv)
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (replace
                                                                                                   defm)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     translate_definitions)
                                                                                                    (("2"
                                                                                                      (assert)
                                                                                                      nil
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("3"
                                                                  (typepred
                                                                   "fv`fpc")
                                                                  (("3"
                                                                    (replace
                                                                     defm
                                                                     -1)
                                                                    (("3"
                                                                      (expand
                                                                       translate_definitions
                                                                       -1)
                                                                      (("3"
                                                                        (assert)
                                                                        (("3"
                                                                          (expand
                                                                           pushRedex?)
                                                                          (("3"
                                                                            (expand
                                                                             state_extract_stat)
                                                                            (("3"
                                                                              (lift-if
                                                                               push)
                                                                              (("3"
                                                                                (split
                                                                                 push)
                                                                                (("1"
                                                                                  (grind)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (replace
                                                                                   defm
                                                                                   push)
                                                                                  (("2"
                                                                                    (expand
                                                                                     translate_definitions
                                                                                     push)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (expand
                                                                                         fv)
                                                                                        (("2"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide
                                                               obj)
                                                              (("2"
                                                                (rewrite
                                                                 decl_begin_next_pc)
                                                                (("2"
                                                                  (hide
                                                                   2)
                                                                  (("2"
                                                                    (expand
                                                                     pushRedex?)
                                                                    (("2"
                                                                      (expand
                                                                       state_extract_stat)
                                                                      (("2"
                                                                        (lift-if
                                                                         push)
                                                                        (("2"
                                                                          (split
                                                                           push)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (lemma
                                                                               translate_extract_decl_begin_def)
                                                                              (("2"
                                                                                (replace
                                                                                 defm
                                                                                 push)
                                                                                (("2"
                                                                                  (expand
                                                                                   translate_definitions
                                                                                   push)
                                                                                  (("2"
                                                                                    (inst?
                                                                                     :where
                                                                                     push)
                                                                                    (("1"
                                                                                      (assert)
                                                                                      (("1"
                                                                                        (expand
                                                                                         fv)
                                                                                        (("1"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (typepred
                                                                                       "endi(iS`callstack, 0)`fpc")
                                                                                      (("2"
                                                                                        (replace
                                                                                         defm
                                                                                         -1)
                                                                                        (("2"
                                                                                          (expand
                                                                                           translate_definitions
                                                                                           -1)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide obj)
                                                (("2"
                                                  (expand pushRedex?)
                                                  (("2"
                                                    (expand
                                                     state_extract_stat)
                                                    (("2"
                                                      (lift-if push)
                                                      (("2"
                                                        (split push)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (replace
                                                             defm
                                                             push)
                                                            (("2"
                                                              (expand
                                                               translate_definitions
                                                               push)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (typepred
                                                                   "endi(iS`callstack, 0)`fpc")
                                                                  (("2"
                                                                    (replace
                                                                     defm
                                                                     -1)
                                                                    (("2"
                                                                      (expand
                                                                       translate_definitions
                                                                       -1)
                                                                      (("2"
                                                                        (assert)
                                                                        (("2"
                                                                          (use
                                                                           translate_extract_decl_begin_def)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (expand
                                                                               fv)
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide obj)
                                              (("2"
                                                (typepred "fv`fdepth")
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (rewrite -1)
                                                    (("1"
                                                      (replace defm)
                                                      (("1"
                                                        (expand
                                                         translate_definitions)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (replace defm)
                                                      (("2"
                                                        (expand
                                                         translate_definitions)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             pushRedex?)
                                                            (("2"
                                                              (expand
                                                               state_extract_stat)
                                                              (("2"
                                                                (replace
                                                                 defm)
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (lift-if
                                                                     push)
                                                                    (("2"
                                                                      (split
                                                                       push)
                                                                      (("1"
                                                                        (expand
                                                                         fv)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         fv)
                                                                        (("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide obj)
                                              (("3"
                                                (split)
                                                (("1"
                                                  (typepred
                                                   "fv`fdepth")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (typepred "iS`stack")
                                                  (("2"
                                                    (rewrite
                                                     fdepth_sum_pop)
                                                    (("2"
                                                      (expand fv)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("4"
                                              (hide obj)
                                              (("4" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide obj)
                                          (("2"
                                            (expand pushReduce)
                                            (("2"
                                              (expand endi)
                                              (("2"
                                                (expand get_frame_body)
                                                (("2"
                                                  (expand fv)
                                                  (("2"
                                                    (replace defm)
                                                    (("2"
                                                      (expand
                                                       translate_definitions)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (rewrite
                                                           translate_next_pc_def)
                                                          (("1"
                                                            (expand
                                                             endi)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide 2)
                                                            (("2"
                                                              (expand
                                                               pushRedex?)
                                                              (("2"
                                                                (expand
                                                                 state_extract_stat)
                                                                (("2"
                                                                  (lift-if
                                                                   push)
                                                                  (("2"
                                                                    (replace
                                                                     defm)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (typepred
                                                                         "endi(iS`callstack, 0)`fpc")
                                                                        (("2"
                                                                          (split
                                                                           push)
                                                                          (("1"
                                                                            (propax)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (replace
                                                                             defm)
                                                                            (("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (hide obj)
                                          (("3"
                                            (typepred "fv`fpc")
                                            (("3"
                                              (expand*
                                               pushRedex?
                                               state_extract_stat)
                                              (("3"
                                                (lift-if push)
                                                (("3"
                                                  (assert)
                                                  (("3"
                                                    (split push)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (replace defm)
                                                      (("2"
                                                        (expand
                                                         translate_definitions)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand fv)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide obj)
                                        (("2"
                                          (expand* pushReduce endi)
                                          (("2"
                                            (expand* fv get_frame_body)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide obj)
                                      (("2"
                                        (expand*
                                         pushReduce
                                         fv
                                         endi
                                         get_frame_body)
                                        (("2"
                                          (expand endi)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (hide obj)
                                      (("3" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide obj)
                                    (("2"
                                      (expand tv1)
                                      (("2"
                                        (use extract_call_tv_eq)
                                        (("2"
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (expand pushReduce)
                                            (("2"
                                              (expand pop)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide obj)
                                  (("2"
                                    (expand K)
                                    (("2"
                                      (use extract_call_context_eq)
                                      (("2"
                                        (split -1)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (expand* pushReduce pop)
                                          nil
                                          nil)
                                         ("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide obj)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "fv`fpc")
                              (("2"
                                (typepred "fv`fdepth")
                                (("2"
                                  (replace defm)
                                  (("2"
                                    (expand translate_definitions)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (flatten)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (split)
                              (("1"
                                (typepred "fv`fdepth")
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (typepred "iS`stack")
                                (("2"
                                  (rewrite fdepth_sum_pop)
                                  (("2"
                                    (expand fv)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pushReduce const-decl "istate" ireduction nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (pushRedex? const-decl "bool" ireduction nil)
    (extract_call_tv_eq formula-decl nil itranslation nil) nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    nil nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state_extract_stat const-decl
     "{s1, j | j < slength(s1) AND executable_stat?(s1, j)}" ireduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (translate_extract_decl_begin_def formula-decl nil itranslation
     nil)
    (translate_length_def formula-decl nil itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (reconstruct_state_decl_begin_letexpr formula-decl nil itranslation
     nil)
    nil (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (fill def-decl "IExpression" IL nil)
    (context_composition formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (compose def-decl "IContext" IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (next_pc_pos rec-application-judgement "posnat" ireduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (shift const-decl "nat" itranslation nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (translate_is_result_defined_decl_begin_next_pc formula-decl nil
     itranslation nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (decl_begin_next_pc formula-decl nil itranslation nil)
    (fct_is_result_defined const-decl "bool" itranslation nil)
    (get_frame_body const-decl "[stack_frame(iS`defs), istat]"
     ireduction nil)
    (fct_reconstruct_state_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (translate_next_pc_def formula-decl nil itranslation nil) nil
    (extract_call_context_eq formula-decl nil itranslation nil)
    (endi const-decl "T" ireduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil) nil
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (redex_matches const-decl "bool" itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (state_matches const-decl "bool" itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (pushReduce_match-1 nil 3707136744
   (""
    (with-labels (skeep* :preds? t) ((dwt terr ierr stm cll push obj)))
    (("" (expand state_matches)
      (("" (with-labels (flatten stm) ((defm domm stom cntm rdm)))
        (("" (assert)
          (("" (split obj)
            (("1" (expand pushReduce) (("1" (propax) nil nil)) nil)
             ("2" (expand pushReduce) (("2" (propax) nil nil)) nil)
             ("3" (expand pushReduce) (("3" (propax) nil nil)) nil)
             ("4" (expand pushReduce) (("4" (propax) nil nil)) nil)
             ("5" (expand pushReduce) (("5" (propax) nil nil)) nil)
             ("6" (with-labels (flatten) ((useless obj)))
              (("6" (hide useless)
                (("6" (expand redex_matches rdm)
                  (("6" (with-labels (flatten rdm) ((rdf rds)))
                    (("6"
                      (name-replace K
                       "extract_call_context(D, trS`def_types, iS)")
                      (("6"
                        (name-replace "tv1"
                         "extract_call_tv(D, trS`def_types, iS)")
                        (("6" (name-replace fv "endi(iS`callstack, 0)")
                          (("6"
                            (name-replace u
                             "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                                 D`seq(fv`ffct)`arity, fv`fdepth,
                                 fv`fpc)")
                            (("1" (expand redex_matches)
                              (("1"
                                (case-replace
                                 "extract_call_context(D, trS`def_types, pushReduce(iS)) = K")
                                (("1"
                                  (case-replace
                                   "extract_call_tv
                                     (D, trS`def_types, pushReduce(iS)) = tv1")
                                  (("1"
                                    (case-replace
                                     "endi(pushReduce(iS)`callstack, 0)`fdepth = fv`fdepth + 1")
                                    (("1"
                                      (case-replace
                                       "endi(pushReduce(iS)`callstack, 0)`ffct = fv`ffct")
                                      (("1"
                                        (case-replace
                                         "endi(pushReduce(iS)`callstack, 0)`fpc = translate_next_pc(D`seq(fv`ffct)`body, fv`fpc)")
                                        (("1"
                                          (lemma
                                           fct_reconstruct_state_next_pc_decl_begin)
                                          (("1"
                                            (inst
                                             -1
                                             "D`seq(fv`ffct)`body"
                                             "iS`stack"
                                             "pushReduce(iS)`stack"
                                             "D`seq(fv`ffct)`arity"
                                             "fv`fdepth"
                                             "fv`fpc")
                                            (("1"
                                              (split -1)
                                              (("1"
                                                (with-labels
                                                 (flatten -1)
                                                 ((nxtr nxtc nxtt)))
                                                (("1"
                                                  (replace nxtr)
                                                  (("1"
                                                    (replace nxtc)
                                                    (("1"
                                                      (replace nxtt)
                                                      (("1"
                                                        (split obj)
                                                        (("1"
                                                          (rewrite
                                                           context_composition)
                                                          (("1"
                                                            (replace
                                                             rdf
                                                             :dir
                                                             RL)
                                                            (("1"
                                                              (rewrite
                                                               context_composition)
                                                              (("1"
                                                                (rewrite
                                                                 context_composition)
                                                                (("1"
                                                                  (expand
                                                                   fill
                                                                   obj
                                                                   3)
                                                                  (("1"
                                                                    (expand
                                                                     fill
                                                                     obj
                                                                     3)
                                                                    (("1"
                                                                      (apply-eta
                                                                       "u`1"
                                                                       "(letexpr?)")
                                                                      (("1"
                                                                        (expand
                                                                         u)
                                                                        (("1"
                                                                          (replace
                                                                           -1)
                                                                          (("1"
                                                                            (propax)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         obj)
                                                                        (("2"
                                                                          (expand
                                                                           u)
                                                                          (("2"
                                                                            (expand
                                                                             fct_reconstruct_state
                                                                             1)
                                                                            (("2"
                                                                              (case
                                                                               "fv`fpc < translate_length(D`seq(fv`ffct)`body)")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (use
                                                                                   reconstruct_state_decl_begin_letexpr)
                                                                                  (("1"
                                                                                    (assert)
                                                                                    (("1"
                                                                                      (expand
                                                                                       pushRedex?)
                                                                                      (("1"
                                                                                        (expand
                                                                                         state_extract_stat)
                                                                                        (("1"
                                                                                          (lift-if
                                                                                           push)
                                                                                          (("1"
                                                                                            (split
                                                                                             push)
                                                                                            (("1"
                                                                                              (grind)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (flatten)
                                                                                              (("2"
                                                                                                (replace
                                                                                                 defm
                                                                                                 push)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   translate_definitions
                                                                                                   push)
                                                                                                  (("2"
                                                                                                    (use
                                                                                                     translate_extract_decl_begin_def)
                                                                                                    (("1"
                                                                                                      (expand
                                                                                                       fv)
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         -1
                                                                                                         :dir
                                                                                                         RL)
                                                                                                        (("1"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil)
                                                                                                     ("2"
                                                                                                      (assert)
                                                                                                      (("2"
                                                                                                        (expand
                                                                                                         fv)
                                                                                                        (("2"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (hide
                                                                                 2)
                                                                                (("2"
                                                                                  (case
                                                                                   "fv`fpc < slength(iS`defs`seq(fv`ffct)`body)")
                                                                                  (("1"
                                                                                    (replace
                                                                                     defm)
                                                                                    (("1"
                                                                                      (expand
                                                                                       translate_definitions)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (expand
                                                                                     fv)
                                                                                    (("2"
                                                                                      (hide-all-but
                                                                                       (1
                                                                                        push))
                                                                                      (("2"
                                                                                        (grind)
                                                                                        (("2"
                                                                                          (typepred
                                                                                           "iS`callstack`seq(iS`callstack`length - 1)`fpc")
                                                                                          (("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (with-labels
                                                           (skeep
                                                            :preds?
                                                            t)
                                                           ((ih obj)))
                                                          (("2"
                                                            (rewrite
                                                             compose_popDepth)
                                                            (("2"
                                                              (expand
                                                               popDepth
                                                               obj
                                                               2)
                                                              (("2"
                                                                (apply-eta
                                                                 "u`1"
                                                                 "(letexpr?)")
                                                                (("1"
                                                                  (inst
                                                                   rds
                                                                   i)
                                                                  (("1"
                                                                    (case-replace
                                                                     "fct_reconstruct_state
                                            (D`seq(fv`ffct)`body,
                                             iS`stack,
                                             D`seq(fv`ffct)`arity,
                                             fv`fdepth,
                                             fv`fpc) = u")
                                                                    (("1"
                                                                      (case
                                                                       "i < popDepth(u`1) + popDepth(u`2)")
                                                                      (("1"
                                                                        (expand
                                                                         compose_translate_vars
                                                                         rds)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (expand
                                                                             popDepth
                                                                             -1
                                                                             1)
                                                                            (("1"
                                                                              (expand
                                                                               compose_translate_vars
                                                                               obj)
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (expand
                                                                                   pushReduce)
                                                                                  (("1"
                                                                                    (expand
                                                                                     shift)
                                                                                    (("1"
                                                                                      (expand
                                                                                       endi)
                                                                                      (("1"
                                                                                        (expand
                                                                                         add)
                                                                                        (("1"
                                                                                          (propax)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         compose_translate_vars
                                                                         rds)
                                                                        (("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (expand
                                                                             popDepth
                                                                             1
                                                                             1)
                                                                            (("2"
                                                                              (expand
                                                                               compose_translate_vars
                                                                               obj)
                                                                              (("2"
                                                                                (assert)
                                                                                (("2"
                                                                                  (expand
                                                                                   popDepth
                                                                                   obj
                                                                                   3)
                                                                                  (("2"
                                                                                    (expand
                                                                                     popDepth
                                                                                     obj
                                                                                     3)
                                                                                    (("2"
                                                                                      (expand
                                                                                       pushReduce)
                                                                                      (("2"
                                                                                        (expand
                                                                                         endi)
                                                                                        (("2"
                                                                                          (expand
                                                                                           add)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            (("2"
                                                                                              (lift-if)
                                                                                              (("2"
                                                                                                (split)
                                                                                                (("1"
                                                                                                  (flatten)
                                                                                                  (("1"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (flatten)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       popDepth
                                                                                                       rds
                                                                                                       1)
                                                                                                      (("2"
                                                                                                        (assert)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       u)
                                                                      (("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (hide
                                                                   obj)
                                                                  (("2"
                                                                    (expand
                                                                     u)
                                                                    (("2"
                                                                      (expand
                                                                       fct_reconstruct_state
                                                                       +)
                                                                      (("2"
                                                                        (lift-if
                                                                         +)
                                                                        (("2"
                                                                          (case
                                                                           "fv`fpc < translate_length(D`seq(fv`ffct)`body)")
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (rewrite
                                                                               reconstruct_state_decl_begin_letexpr)
                                                                              (("1"
                                                                                (expand
                                                                                 pushRedex?)
                                                                                (("1"
                                                                                  (expand
                                                                                   state_extract_stat)
                                                                                  (("1"
                                                                                    (lift-if
                                                                                     push)
                                                                                    (("1"
                                                                                      (split
                                                                                       push)
                                                                                      (("1"
                                                                                        (grind)
                                                                                        nil
                                                                                        nil)
                                                                                       ("2"
                                                                                        (replace
                                                                                         defm
                                                                                         push)
                                                                                        (("2"
                                                                                          (expand
                                                                                           translate_definitions
                                                                                           push)
                                                                                          (("2"
                                                                                            (use
                                                                                             translate_extract_decl_begin_def)
                                                                                            (("1"
                                                                                              (flatten)
                                                                                              (("1"
                                                                                                (assert)
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   fv)
                                                                                                  (("1"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil)
                                                                                             ("2"
                                                                                              (flatten)
                                                                                              (("2"
                                                                                                (assert)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   fv)
                                                                                                  (("2"
                                                                                                    (assert)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (typepred
                                                                               "fv`fpc")
                                                                              (("2"
                                                                                (expand
                                                                                 pushRedex?)
                                                                                (("2"
                                                                                  (expand
                                                                                   state_extract_stat)
                                                                                  (("2"
                                                                                    (expand
                                                                                     fv)
                                                                                    (("2"
                                                                                      (replace
                                                                                       defm
                                                                                       -1)
                                                                                      (("2"
                                                                                        (expand
                                                                                         translate_definitions
                                                                                         -1)
                                                                                        (("2"
                                                                                          (assert)
                                                                                          (("2"
                                                                                            (lift-if
                                                                                             push)
                                                                                            (("2"
                                                                                              (split
                                                                                               push)
                                                                                              (("1"
                                                                                                (grind)
                                                                                                nil
                                                                                                nil)
                                                                                               ("2"
                                                                                                (flatten)
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (replace
                                                                                                     defm
                                                                                                     push)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       translate_definitions
                                                                                                       push)
                                                                                                      (("2"
                                                                                                        (assert)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide obj)
                                                (("2"
                                                  (expand pushRedex?)
                                                  (("2"
                                                    (expand
                                                     state_extract_stat)
                                                    (("2"
                                                      (lift-if push)
                                                      (("2"
                                                        (split push)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (replace
                                                             defm
                                                             push)
                                                            (("2"
                                                              (expand
                                                               translate_definitions
                                                               push)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (typepred
                                                                   "endi(iS`callstack, 0)`fpc")
                                                                  (("2"
                                                                    (replace
                                                                     defm
                                                                     -1)
                                                                    (("2"
                                                                      (expand
                                                                       translate_definitions
                                                                       -1)
                                                                      (("2"
                                                                        (assert)
                                                                        (("2"
                                                                          (use
                                                                           translate_extract_decl_begin_def)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (expand
                                                                               fv)
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide obj)
                                              (("2"
                                                (typepred "fv`fdepth")
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (rewrite -1)
                                                    (("1"
                                                      (replace defm)
                                                      (("1"
                                                        (expand
                                                         translate_definitions)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (replace defm)
                                                      (("2"
                                                        (expand
                                                         translate_definitions)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand
                                                             pushRedex?)
                                                            (("2"
                                                              (expand
                                                               state_extract_stat)
                                                              (("2"
                                                                (replace
                                                                 defm)
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (lift-if
                                                                     push)
                                                                    (("2"
                                                                      (split
                                                                       push)
                                                                      (("1"
                                                                        (expand
                                                                         fv)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         fv)
                                                                        (("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide obj)
                                              (("3"
                                                (split)
                                                (("1"
                                                  (typepred
                                                   "fv`fdepth")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (typepred "iS`stack")
                                                  (("2"
                                                    (rewrite
                                                     fdepth_sum_pop)
                                                    (("2"
                                                      (expand fv)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("4"
                                              (hide obj)
                                              (("4" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide obj)
                                          (("2"
                                            (expand pushReduce)
                                            (("2"
                                              (expand endi)
                                              (("2"
                                                (expand get_frame_body)
                                                (("2"
                                                  (expand fv)
                                                  (("2"
                                                    (replace defm)
                                                    (("2"
                                                      (expand
                                                       translate_definitions)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (rewrite
                                                           translate_next_pc_def)
                                                          (("1"
                                                            (expand
                                                             endi)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide 2)
                                                            (("2"
                                                              (expand
                                                               pushRedex?)
                                                              (("2"
                                                                (expand
                                                                 state_extract_stat)
                                                                (("2"
                                                                  (lift-if
                                                                   push)
                                                                  (("2"
                                                                    (replace
                                                                     defm)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (typepred
                                                                         "endi(iS`callstack, 0)`fpc")
                                                                        (("2"
                                                                          (split
                                                                           push)
                                                                          (("1"
                                                                            (propax)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (replace
                                                                             defm)
                                                                            (("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (hide obj)
                                          (("3"
                                            (typepred "fv`fpc")
                                            (("3"
                                              (expand*
                                               pushRedex?
                                               state_extract_stat)
                                              (("3"
                                                (lift-if push)
                                                (("3"
                                                  (assert)
                                                  (("3"
                                                    (split push)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (replace defm)
                                                      (("2"
                                                        (expand
                                                         translate_definitions)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (expand fv)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("4"
                                          (hide obj)
                                          (("4"
                                            (typepred "fv`ffct")
                                            (("4"
                                              (expand
                                               translate_definitions)
                                              (("4" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide obj)
                                        (("2"
                                          (expand* pushReduce endi)
                                          (("2"
                                            (expand* fv get_frame_body)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide obj)
                                      (("2"
                                        (expand*
                                         pushReduce
                                         fv
                                         endi
                                         get_frame_body)
                                        (("2"
                                          (expand endi)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (hide obj)
                                      (("3" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide obj)
                                    (("2"
                                      (expand tv1)
                                      (("2"
                                        (use extract_call_tv_eq)
                                        (("2"
                                          (split)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (expand pushReduce)
                                            (("2"
                                              (expand pop)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide obj)
                                  (("2"
                                    (expand K)
                                    (("2"
                                      (use extract_call_context_eq)
                                      (("2"
                                        (split -1)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (expand* pushReduce pop)
                                          nil
                                          nil)
                                         ("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide obj)
                                  (("3" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "fv`fpc")
                              (("2"
                                (typepred "fv`fdepth")
                                (("2"
                                  (replace defm)
                                  (("2"
                                    (expand translate_definitions)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (flatten)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (split)
                              (("1"
                                (typepred "fv`fdepth")
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (typepred "iS`stack")
                                (("2"
                                  (rewrite fdepth_sum_pop)
                                  (("2"
                                    (expand fv)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pushReduce const-decl "istate" ireduction nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fct_reconstruct_state const-decl
     "[IExpression, IContext, [nat -> nat]]" itranslation nil)
    (translate_stack_size_at def-decl "nat" itranslation nil)
    (translate_length def-decl "posnat" itranslation nil)
    (pushRedex? const-decl "bool" ireduction nil)
    (extract_call_tv_eq formula-decl nil itranslation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_next_pc def-decl "upto(translate_length(A))"
     itranslation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state_extract_stat const-decl
     "{s1, j | j < slength(s1) AND executable_stat?(s1, j)}" ireduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (translate_extract_decl_begin_def formula-decl nil itranslation
     nil)
    (translate_length_def formula-decl nil itranslation nil)
    (FALSE const-decl "bool" booleans nil)
    (ivar adt-constructor-decl "[[nat, bool] -> (ivar?)]" ireduction
     nil)
    (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil)
    (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil)
    (iexpr type-decl nil ireduction nil)
    (reconstruct_state_decl_begin_letexpr formula-decl nil itranslation
     nil)
    (IExpression_letexpr_eta formula-decl nil IExpression_adt nil)
    (fill def-decl "IExpression" IL nil)
    (context_composition formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (compose def-decl "IContext" IL nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (compose_popDepth formula-decl nil itranslation nil)
    (next_pc_pos rec-application-judgement "posnat" ireduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (compose_translate_vars const-decl "nat" itranslation nil)
    (shift const-decl "nat" itranslation nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (translate_stack_size_at_def formula-decl nil itranslation nil)
    (fdepth_sum_pop formula-decl nil ireduction nil)
    (pop const-decl "finseq[T]" ireduction nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (get_frame_body const-decl "[stack_frame(iS`defs), istat]"
     ireduction nil)
    (fct_reconstruct_state_next_pc_decl_begin formula-decl nil
     itranslation nil)
    (translate_next_pc_def formula-decl nil itranslation nil)
    (extract_call_context_eq formula-decl nil itranslation nil)
    (endi const-decl "T" ireduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (istate type-eq-decl nil ireduction nil)
    (Store type-eq-decl nil ireduction nil)
    (fdepth_sum const-decl "nat" ireduction nil)
    (Stack type-eq-decl nil ireduction nil)
    (ivalue type-decl nil ireduction nil)
    (is_fun_call_at const-decl "bool" ireduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (stack_frame type-eq-decl nil ireduction nil)
    (stack_size_at def-decl "nat" ireduction nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (slength def-decl "posnat" ireduction nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Definition type-eq-decl nil ireduction nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "bool" ireduction nil)
    (istat type-decl nil ireduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (tdef type-eq-decl nil itranslation nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (redex_matches const-decl "bool" itranslation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (state_matches const-decl "bool" itranslation nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (skipReduce_match_TCC1 0
  (skipReduce_match_TCC1-1 nil 3707573865 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (skipRedex? const-decl "bool" ireduction nil)
    (state_matches const-decl "bool" itranslation nil)
    (redex_matches const-decl "bool" itranslation nil)
    (extract_call_tv const-decl "[nat -> nat]" itranslation nil)
    (endi const-decl "T" ireduction nil)
    (extract_call_context const-decl "IContext" itranslation nil)
    (value? const-decl "bool" IL nil)
    (count_matches const-decl "bool" itranslation nil)
    (store_matches const-decl "bool" itranslation nil)
    (translate_definitions const-decl "finseq[ireduction.Definition]"
     itranslation nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (unmark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (skipReduce_match subtype "0"
    "naturalnumbers.below(itranslation.iS`callstack`length)")))
 (skipReduce_match_TCC2 0
  (skipReduce_match_TCC2-1 nil 3707573865
   ("" (skeep* :preds? t)
    (("" (rewrite typed_iareduce_def_types) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil itranslation nil)
    (Definition type-eq-decl nil itranslation nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typed_iareduce_def_types formula-decl nil typed_rreduction nil))
   nil
   (skipReduce_match subtype
    "ireduction.endi(itranslation.iS`callstack, 0)`ffct"
    "below[D`length]")))
 (skipReduce_match_TCC3 0
  (skipReduce_match_TCC5-1 nil 3707573865
   ("" (skeep) (("" (assert) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (skipReduce_match subtype "itranslation.iS"
    "{iS | booleans.AND(reals.>(ireduction.iS`callstack`length, 0), ireduction.pushRedex?(ireduction.iS))}")))
 (skipReduce_match 0
  (skipReduce_match-4 nil 3707595158
   (""
    (with-labels (skeep* :preds? t) ((dwt terr ierr stm cll skip obj)))
    (("" (with-labels (name "t" "typed_to_topstate(trS)") ((tdef)))
      (("" (with-labels (case "value?(t`state`redex)") ((tv) (tv)))
        (("1" (postpone) nil nil)
         ("2" (with-labels (name nS "make_redex_typed(t)") ((ndef)))
          (("1"
            (with-labels (name fv "endi(iS`callstack, 0)") ((fvdef)))
            (("1"
              (with-labels
               (name u
                     "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                                                    D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc)")
               ((udef)))
              (("1"
                (with-labels (case "nS`state`redex = u`1") ((redeq)))
                (("1" (with-labels (case "pureLetRedex?(u`1)") ((plr)))
                  (("1" (expand typed_iareduce)
                    (("1" (replace tdef)
                      (("1" (replace ndef)
                        (("1" (replace redeq)
                          (("1" (assert)
                            (("1" (case "NOT variable?(u`1)")
                              (("1"
                                (assert)
                                (("1"
                                  (expand state_matches stm)
                                  (("1"
                                    (with-labels
                                     (flatten stm)
                                     ((defm domm stom cntm rdm)))
                                    (("1"
                                      (expand state_matches obj)
                                      (("1"
                                        (split obj)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil)
                                         ("3"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("3"
                                            (expand* nS t)
                                            (("3"
                                              (expand*
                                               make_redex_typed
                                               typed_to_topstate
                                               make_redex
                                               to_topstate)
                                              nil
                                              nil))
                                            nil))
                                          nil)
                                         ("4"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("4"
                                            (expand*
                                             nS
                                             t
                                             typed_to_topstate
                                             to_topstate
                                             make_redex_typed
                                             make_redex)
                                            nil
                                            nil))
                                          nil)
                                         ("5"
                                          (expand skipReduce)
                                          (("5" (propax) nil nil))
                                          nil)
                                         ("6"
                                          (with-labels
                                           (flatten obj)
                                           ((useless obj)))
                                          (("6"
                                            (hide useless)
                                            (("6"
                                              (name-replace
                                               newS
                                               "typed_iareduce(D)(trS)")
                                              (("6"
                                                (expand typed_iareduce)
                                                (("6"
                                                  (replace* tdef ndef)
                                                  (("6"
                                                    (replace ndef)
                                                    (("6"
                                                      (replace -1)
                                                      (("6"
                                                        (with-labels
                                                         (case
                                                          "redex_matches(D, nS, iS)")
                                                         ((rdm2)))
                                                        (("1"
                                                          (expand
                                                           redex_matches
                                                           rdm2)
                                                          (("1"
                                                            (with-labels
                                                             (flatten
                                                              rdm2)
                                                             ((rdmf
                                                               rdms
                                                               rdmd)))
                                                            (("1"
                                                              (replace
                                                               fvdef)
                                                              (("1"
                                                                (name-replace
                                                                 K
                                                                 "extract_call_context(D, nS`def_types, iS)")
                                                                (("1"
                                                                  (name-replace
                                                                   tv1
                                                                   "extract_call_tv(D, nS`def_types, iS)")
                                                                  (("1"
                                                                    (with-labels
                                                                     (case
                                                                      "compose(K, u`2) = nS`state`context")
                                                                     ((ctxeq)))
                                                                    (("1"
                                                                      (expand
                                                                       redex_matches
                                                                       obj)
                                                                      (("1"
                                                                        (with-labels
                                                                         (name
                                                                          fv2
                                                                          "endi(skipReduce(iS)`callstack, 0)")
                                                                         ((fv2def)))
                                                                        (("1"
                                                                          (replace
                                                                           fv2def)
                                                                          (("1"
                                                                            (with-labels
                                                                             (name
                                                                              u2
                                                                              "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                                                                                                 skipReduce(iS)`stack,
                                                                                                                                 D`seq(fv2`ffct)`arity, fv2`fdepth,
                                                                                                                                 fv2`fpc)")
                                                                             ((u2def)))
                                                                            (("1"
                                                                              (replace
                                                                               u2def)
                                                                              (("1"
                                                                                (case-replace
                                                                                 "extract_call_context(D, newS`def_types, skipReduce(iS)) = K")
                                                                                (("1"
                                                                                  (case-replace
                                                                                   "extract_call_tv
                                                                                                                               (D, newS`def_types, skipReduce(iS)) = tv1")
                                                                                  (("1"
                                                                                    (lemma
                                                                                     fct_reconstruct_state_next_pc_skip)
                                                                                    (("1"
                                                                                      (inst?
                                                                                       -1
                                                                                       :where
                                                                                       udef)
                                                                                      (("1"
                                                                                        (inst
                                                                                         -1
                                                                                         "skipReduce(iS)`stack")
                                                                                        (("1"
                                                                                          (split
                                                                                           -1)
                                                                                          (("1"
                                                                                            (with-labels
                                                                                             (flatten
                                                                                              -1)
                                                                                             ((ue1
                                                                                               ue2
                                                                                               ue3)))
                                                                                            (("1"
                                                                                              (case-replace
                                                                                               "fv2`ffct = fv`ffct")
                                                                                              (("1"
                                                                                                (case-replace
                                                                                                 "fv2`fdepth = fv`fdepth")
                                                                                                (("1"
                                                                                                  (case-replace
                                                                                                   "fv2`fpc = translate_next_pc(D`seq(fv`ffct)`body,
                                                                                                                                                                            fv`fpc)")
                                                                                                  (("1"
                                                                                                    (replace
                                                                                                     u2def)
                                                                                                    (("1"
                                                                                                      (split
                                                                                                       obj)
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         ue1)
                                                                                                        (("1"
                                                                                                          (replace
                                                                                                           ue2)
                                                                                                          (("1"
                                                                                                            (replace
                                                                                                             -15
                                                                                                             +
                                                                                                             :dir
                                                                                                             RL)
                                                                                                            (("1"
                                                                                                              (assert)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 letReduce)
                                                                                                                (("1"
                                                                                                                  (assert)
                                                                                                                  (("1"
                                                                                                                    (replace
                                                                                                                     udef)
                                                                                                                    (("1"
                                                                                                                      (replace
                                                                                                                       ctxeq
                                                                                                                       obj
                                                                                                                       :dir
                                                                                                                       RL)
                                                                                                                      (("1"
                                                                                                                        (rewrite
                                                                                                                         context_composition)
                                                                                                                        (("1"
                                                                                                                          (rewrite
                                                                                                                           context_composition)
                                                                                                                          (("1"
                                                                                                                            (rewrite
                                                                                                                             context_composition)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               fill
                                                                                                                               obj
                                                                                                                               3)
                                                                                                                              (("1"
                                                                                                                                (expand
                                                                                                                                 fill
                                                                                                                                 obj
                                                                                                                                 3)
                                                                                                                                (("1"
                                                                                                                                  (assert)
                                                                                                                                  nil
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (replace
                                                                                                         udef)
                                                                                                        (("2"
                                                                                                          (with-labels
                                                                                                           (skeep
                                                                                                            :preds?
                                                                                                            t)
                                                                                                           ((ih
                                                                                                             obj)))
                                                                                                          (("2"
                                                                                                            (replace
                                                                                                             -16
                                                                                                             :dir
                                                                                                             RL)
                                                                                                            (("2"
                                                                                                              (assert)
                                                                                                              (("2"
                                                                                                                (expand
                                                                                                                 letReduce
                                                                                                                 +)
                                                                                                                (("2"
                                                                                                                  (case-replace
                                                                                                                   "i=0")
                                                                                                                  (("1"
                                                                                                                    (expand
                                                                                                                     skipReduce)
                                                                                                                    (("1"
                                                                                                                      (expand
                                                                                                                       compose_translate_vars
                                                                                                                       obj)
                                                                                                                      (("1"
                                                                                                                        (replace
                                                                                                                         ue2
                                                                                                                         obj)
                                                                                                                        (("1"
                                                                                                                          (rewrite
                                                                                                                           compose_popDepth
                                                                                                                           obj)
                                                                                                                          (("1"
                                                                                                                            (expand
                                                                                                                             popDepth
                                                                                                                             obj
                                                                                                                             2)
                                                                                                                            (("1"
                                                                                                                              (assert)
                                                                                                                              (("1"
                                                                                                                                (assert)
                                                                                                                                (("1"
                                                                                                                                  (replace
                                                                                                                                   ue3
                                                                                                                                   obj)
                                                                                                                                  (("1"
                                                                                                                                    (assert)
                                                                                                                                    (("1"
                                                                                                                                      (expand
                                                                                                                                       push
                                                                                                                                       obj)
                                                                                                                                      (("1"
                                                                                                                                        (expand
                                                                                                                                         add
                                                                                                                                         obj)
                                                                                                                                        (("1"
                                                                                                                                          (expand
                                                                                                                                           endi
                                                                                                                                           obj)
                                                                                                                                          (("1"
                                                                                                                                            (lemma
                                                                                                                                             reconstruct_state_skip_letrhs)
                                                                                                                                            (("1"
                                                                                                                                              (case
                                                                                                                                               "fv`fpc < translate_length(D`seq(fv`ffct)`body)")
                                                                                                                                              (("1"
                                                                                                                                                (expand
                                                                                                                                                 fct_reconstruct_state
                                                                                                                                                 udef)
                                                                                                                                                (("1"
                                                                                                                                                  (assert)
                                                                                                                                                  (("1"
                                                                                                                                                    (inst?
                                                                                                                                                     :where
                                                                                                                                                     udef)
                                                                                                                                                    (("1"
                                                                                                                                                      (split
                                                                                                                                                       -2)
                                                                                                                                                      (("1"
                                                                                                                                                        (assert)
                                                                                                                                                        (("1"
                                                                                                                                                          (expand
                                                                                                                                                           endi)
                                                                                                                                                          (("1"
                                                                                                                                                            (assert)
                                                                                                                                                            (("1"
                                                                                                                                                              (replace
                                                                                                                                                               redeq)
                                                                                                                                                              (("1"
                                                                                                                                                                (replace
                                                                                                                                                                 udef
                                                                                                                                                                 obj
                                                                                                                                                                 :dir
                                                                                                                                                                 RL)
                                                                                                                                                                (("1"
                                                                                                                                                                  (assert)
                                                                                                                                                                  (("1"
                                                                                                                                                                    (replace
                                                                                                                                                                     -1
                                                                                                                                                                     obj)
                                                                                                                                                                    (("1"
                                                                                                                                                                      (postpone)
                                                                                                                                                                      nil
                                                                                                                                                                      nil))
                                                                                                                                                                    nil))
                                                                                                                                                                  nil))
                                                                                                                                                                nil))
                                                                                                                                                              nil))
                                                                                                                                                            nil))
                                                                                                                                                          nil))
                                                                                                                                                        nil)
                                                                                                                                                       ("2"
                                                                                                                                                        (postpone)
                                                                                                                                                        nil
                                                                                                                                                        nil))
                                                                                                                                                      nil))
                                                                                                                                                    nil))
                                                                                                                                                  nil))
                                                                                                                                                nil)
                                                                                                                                               ("2"
                                                                                                                                                (expand
                                                                                                                                                 skipRedex?)
                                                                                                                                                (("2"
                                                                                                                                                  (flatten)
                                                                                                                                                  (("2"
                                                                                                                                                    (replace
                                                                                                                                                     defm
                                                                                                                                                     skip)
                                                                                                                                                    (("2"
                                                                                                                                                      (expand
                                                                                                                                                       translate_definitions
                                                                                                                                                       skip)
                                                                                                                                                      (("2"
                                                                                                                                                        (assert)
                                                                                                                                                        nil
                                                                                                                                                        nil))
                                                                                                                                                      nil))
                                                                                                                                                    nil))
                                                                                                                                                  nil))
                                                                                                                                                nil))
                                                                                                                                              nil))
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil)
                                                                                                                   ("2"
                                                                                                                    (inst
                                                                                                                     rdms
                                                                                                                     "i-1")
                                                                                                                    (("1"
                                                                                                                      (expand
                                                                                                                       skipReduce)
                                                                                                                      (("1"
                                                                                                                        (case-replace
                                                                                                                         "endi(push(letrhs(nS`state`redex), nS`state`stack), i) = endi(nS`state`stack, i-1)")
                                                                                                                        (("1"
                                                                                                                          (case-replace
                                                                                                                           "popDepth(u2`1) + popDepth(u2`2) = popDepth(u`1) + popDepth(u`2) + 1")
                                                                                                                          (("1"
                                                                                                                            (expand
                                                                                                                             compose_translate_vars
                                                                                                                             obj)
                                                                                                                            (("1"
                                                                                                                              (lift-if
                                                                                                                               obj)
                                                                                                                              (("1"
                                                                                                                                (split
                                                                                                                                 obj)
                                                                                                                                (("1"
                                                                                                                                  (flatten)
                                                                                                                                  (("1"
                                                                                                                                    (replace
                                                                                                                                     ue3
                                                                                                                                     obj)
                                                                                                                                    (("1"
                                                                                                                                      (assert)
                                                                                                                                      (("1"
                                                                                                                                        (assert)
                                                                                                                                        (("1"
                                                                                                                                          (expand
                                                                                                                                           compose_translate_vars
                                                                                                                                           rdms)
                                                                                                                                          (("1"
                                                                                                                                            (propax)
                                                                                                                                            nil
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil)
                                                                                                                                 ("2"
                                                                                                                                  (flatten)
                                                                                                                                  (("2"
                                                                                                                                    (expand
                                                                                                                                     compose_translate_vars
                                                                                                                                     rdms)
                                                                                                                                    (("2"
                                                                                                                                      (assert)
                                                                                                                                      nil
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil)
                                                                                                                           ("2"
                                                                                                                            (replace
                                                                                                                             ue1)
                                                                                                                            (("2"
                                                                                                                              (replace
                                                                                                                               ue2)
                                                                                                                              (("2"
                                                                                                                                (rewrite
                                                                                                                                 compose_popDepth
                                                                                                                                 +)
                                                                                                                                (("2"
                                                                                                                                  (expand*
                                                                                                                                   pureLetRedex?
                                                                                                                                   letRedex?)
                                                                                                                                  (("2"
                                                                                                                                    (flatten)
                                                                                                                                    (("2"
                                                                                                                                      (assert)
                                                                                                                                      (("2"
                                                                                                                                        (expand
                                                                                                                                         popDepth
                                                                                                                                         1
                                                                                                                                         2)
                                                                                                                                        (("2"
                                                                                                                                          (expand
                                                                                                                                           popDepth
                                                                                                                                           1
                                                                                                                                           2)
                                                                                                                                          (("2"
                                                                                                                                            (expand
                                                                                                                                             popDepth
                                                                                                                                             1
                                                                                                                                             2)
                                                                                                                                            (("2"
                                                                                                                                              (rewrite
                                                                                                                                               purePopDepth
                                                                                                                                               1)
                                                                                                                                              (("2"
                                                                                                                                                (hide-all-but
                                                                                                                                                 (1
                                                                                                                                                  plr))
                                                                                                                                                (("2"
                                                                                                                                                  (grind)
                                                                                                                                                  nil
                                                                                                                                                  nil))
                                                                                                                                                nil))
                                                                                                                                              nil))
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil)
                                                                                                                         ("2"
                                                                                                                          (expand*
                                                                                                                           push
                                                                                                                           add
                                                                                                                           endi)
                                                                                                                          (("2"
                                                                                                                            (assert)
                                                                                                                            (("2"
                                                                                                                              (lift-if
                                                                                                                               1)
                                                                                                                              (("2"
                                                                                                                                (assert)
                                                                                                                                nil
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil)
                                                                                                                         ("3"
                                                                                                                          (assert)
                                                                                                                          nil
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil)
                                                                                                                     ("2"
                                                                                                                      (assert)
                                                                                                                      (("2"
                                                                                                                        (expand
                                                                                                                         letReduce
                                                                                                                         ih)
                                                                                                                        (("2"
                                                                                                                          (expand
                                                                                                                           popDepth
                                                                                                                           ih
                                                                                                                           1)
                                                                                                                          (("2"
                                                                                                                            (rewrite
                                                                                                                             purePopDepth
                                                                                                                             ih)
                                                                                                                            (("1"
                                                                                                                              (assert)
                                                                                                                              nil
                                                                                                                              nil)
                                                                                                                             ("2"
                                                                                                                              (expand
                                                                                                                               pureLetRedex?)
                                                                                                                              (("2"
                                                                                                                                (propax)
                                                                                                                                nil
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("3"
                                                                                                        (case
                                                                                                         "fv`fpc < translate_length(D`seq(fv`ffct)`body)")
                                                                                                        (("1"
                                                                                                          (expand
                                                                                                           fct_is_result_defined
                                                                                                           obj)
                                                                                                          (("1"
                                                                                                            (assert)
                                                                                                            (("1"
                                                                                                              (split
                                                                                                               obj)
                                                                                                              (("1"
                                                                                                                (postpone)
                                                                                                                nil
                                                                                                                nil)
                                                                                                               ("2"
                                                                                                                (flatten)
                                                                                                                (("2"
                                                                                                                  (use
                                                                                                                   translate_is_result_defined_skip_next_pc)
                                                                                                                  (("1"
                                                                                                                    (split
                                                                                                                     -1)
                                                                                                                    (("1"
                                                                                                                      (assert)
                                                                                                                      nil
                                                                                                                      nil)
                                                                                                                     ("2"
                                                                                                                      (postpone)
                                                                                                                      nil
                                                                                                                      nil))
                                                                                                                    nil)
                                                                                                                   ("2"
                                                                                                                    (hide
                                                                                                                     obj)
                                                                                                                    (("2"
                                                                                                                      (typepred
                                                                                                                       "fv`fdepth")
                                                                                                                      (("2"
                                                                                                                        (replace
                                                                                                                         defm
                                                                                                                         -1)
                                                                                                                        (("2"
                                                                                                                          (expand
                                                                                                                           translate_definitions
                                                                                                                           -1)
                                                                                                                          (("2"
                                                                                                                            (assert)
                                                                                                                            (("2"
                                                                                                                              (split
                                                                                                                               -1)
                                                                                                                              (("1"
                                                                                                                                (assert)
                                                                                                                                (("1"
                                                                                                                                  (expand
                                                                                                                                   skipReduce
                                                                                                                                   +)
                                                                                                                                  (("1"
                                                                                                                                    (typepred
                                                                                                                                     "iS`stack")
                                                                                                                                    (("1"
                                                                                                                                      (rewrite
                                                                                                                                       fdepth_sum_pop)
                                                                                                                                      (("1"
                                                                                                                                        (expand
                                                                                                                                         fv)
                                                                                                                                        (("1"
                                                                                                                                          (assert)
                                                                                                                                          (("1"
                                                                                                                                            (grind)
                                                                                                                                            nil
                                                                                                                                            nil))
                                                                                                                                          nil))
                                                                                                                                        nil))
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil)
                                                                                                                               ("2"
                                                                                                                                (assert)
                                                                                                                                nil
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil)
                                                                                                         ("2"
                                                                                                          (expand
                                                                                                           skipRedex?)
                                                                                                          (("2"
                                                                                                            (flatten)
                                                                                                            (("2"
                                                                                                              (replace
                                                                                                               defm
                                                                                                               skip)
                                                                                                              (("2"
                                                                                                                (expand
                                                                                                                 translate_definitions
                                                                                                                 skip)
                                                                                                                (("2"
                                                                                                                  (assert)
                                                                                                                  nil
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil)
                                                                                                   ("2"
                                                                                                    (hide
                                                                                                     obj)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       fv2)
                                                                                                      (("2"
                                                                                                        (expand
                                                                                                         fv)
                                                                                                        (("2"
                                                                                                          (expand
                                                                                                           skipReduce)
                                                                                                          (("2"
                                                                                                            (expand
                                                                                                             endi)
                                                                                                            (("2"
                                                                                                              (replace
                                                                                                               defm
                                                                                                               1)
                                                                                                              (("2"
                                                                                                                (expand
                                                                                                                 translate_definitions
                                                                                                                 1)
                                                                                                                (("2"
                                                                                                                  (assert)
                                                                                                                  (("2"
                                                                                                                    (rewrite
                                                                                                                     translate_next_pc_def)
                                                                                                                    (("1"
                                                                                                                      (assert)
                                                                                                                      nil
                                                                                                                      nil)
                                                                                                                     ("2"
                                                                                                                      (hide
                                                                                                                       2)
                                                                                                                      (("2"
                                                                                                                        (expand
                                                                                                                         skipRedex?)
                                                                                                                        (("2"
                                                                                                                          (flatten)
                                                                                                                          (("2"
                                                                                                                            (replace
                                                                                                                             defm
                                                                                                                             skip)
                                                                                                                            (("2"
                                                                                                                              (assert)
                                                                                                                              (("2"
                                                                                                                                (expand
                                                                                                                                 endi)
                                                                                                                                (("2"
                                                                                                                                  (assert)
                                                                                                                                  (("2"
                                                                                                                                    (expand
                                                                                                                                     translate_definitions)
                                                                                                                                    (("2"
                                                                                                                                      (assert)
                                                                                                                                      nil
                                                                                                                                      nil))
                                                                                                                                    nil))
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (hide
                                                                                                   obj)
                                                                                                  (("2"
                                                                                                    (expand
                                                                                                     fv2)
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       fv)
                                                                                                      (("2"
                                                                                                        (expand
                                                                                                         endi)
                                                                                                        (("2"
                                                                                                          (expand
                                                                                                           skipReduce)
                                                                                                          (("2"
                                                                                                            (assert)
                                                                                                            nil
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil)
                                                                                               ("2"
                                                                                                (hide
                                                                                                 obj)
                                                                                                (("2"
                                                                                                  (expand*
                                                                                                   fv2
                                                                                                   fv
                                                                                                   endi
                                                                                                   skipReduce)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil)
                                                                                           ("2"
                                                                                            (hide
                                                                                             obj)
                                                                                            (("2"
                                                                                              (postpone)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (hide
                                                                                           obj)
                                                                                          (("2"
                                                                                            (expand
                                                                                             skipReduce)
                                                                                            (("2"
                                                                                              (propax)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (hide
                                                                                         obj)
                                                                                        (("2"
                                                                                          (expand
                                                                                           skipRedex?)
                                                                                          (("2"
                                                                                            (flatten)
                                                                                            (("2"
                                                                                              (typepred
                                                                                               "fv`fdepth")
                                                                                              (("2"
                                                                                                (expand
                                                                                                 fv)
                                                                                                (("2"
                                                                                                  (assert)
                                                                                                  (("2"
                                                                                                    (replace
                                                                                                     defm
                                                                                                     (-1
                                                                                                      skip))
                                                                                                    (("2"
                                                                                                      (expand
                                                                                                       translate_definitions
                                                                                                       (-1
                                                                                                        skip))
                                                                                                      (("2"
                                                                                                        (assert)
                                                                                                        (("2"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (hide
                                                                                     obj)
                                                                                    (("2"
                                                                                      (expand
                                                                                       tv1)
                                                                                      (("2"
                                                                                        (lemma
                                                                                         extract_call_tv_eq)
                                                                                        (("2"
                                                                                          (case-replace
                                                                                           "newS`def_types = nS`def_types")
                                                                                          (("1"
                                                                                            (inst?
                                                                                             :where
                                                                                             1)
                                                                                            (("1"
                                                                                              (split
                                                                                               -2)
                                                                                              (("1"
                                                                                                (propax)
                                                                                                nil
                                                                                                nil)
                                                                                               ("2"
                                                                                                (expand
                                                                                                 skipReduce)
                                                                                                (("2"
                                                                                                  (expand
                                                                                                   pop)
                                                                                                  (("2"
                                                                                                    (propax)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil)
                                                                                               ("3"
                                                                                                (expand*
                                                                                                 skipReduce
                                                                                                 endi)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil)
                                                                                           ("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("2"
                                                                                    (expand
                                                                                     K)
                                                                                    (("2"
                                                                                      (case-replace
                                                                                       "newS`def_types = nS`def_types")
                                                                                      (("1"
                                                                                        (use
                                                                                         extract_call_context_eq)
                                                                                        (("1"
                                                                                          (split
                                                                                           -1)
                                                                                          (("1"
                                                                                            (propax)
                                                                                            nil
                                                                                            nil)
                                                                                           ("2"
                                                                                            (expand*
                                                                                             skipReduce
                                                                                             pop)
                                                                                            nil
                                                                                            nil)
                                                                                           ("3"
                                                                                            (expand*
                                                                                             skipReduce
                                                                                             endi)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("3"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("3"
                                                                                    (assert)
                                                                                    (("3"
                                                                                      (expand*
                                                                                       skipReduce
                                                                                       nS
                                                                                       t
                                                                                       make_redex_typed
                                                                                       typed_to_topstate)
                                                                                      (("3"
                                                                                        (replace
                                                                                         -7
                                                                                         :dir
                                                                                         RL)
                                                                                        (("3"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("4"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("4"
                                                                                    (assert)
                                                                                    (("4"
                                                                                      (expand*
                                                                                       nS
                                                                                       t
                                                                                       make_redex_typed
                                                                                       typed_to_topstate)
                                                                                      (("4"
                                                                                        (replace
                                                                                         -7
                                                                                         :dir
                                                                                         RL)
                                                                                        (("4"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (hide
                                                                               obj)
                                                                              (("2"
                                                                                (typepred
                                                                                 "fv2`fpc")
                                                                                (("2"
                                                                                  (typepred
                                                                                   "fv2`fdepth")
                                                                                  (("2"
                                                                                    (expand
                                                                                     skipReduce)
                                                                                    (("2"
                                                                                      (replace
                                                                                       defm)
                                                                                      (("2"
                                                                                        (expand
                                                                                         translate_definitions)
                                                                                        (("2"
                                                                                          (assert)
                                                                                          (("2"
                                                                                            (assert)
                                                                                            (("2"
                                                                                              (flatten)
                                                                                              (("2"
                                                                                                (assert)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("3"
                                                                              (hide
                                                                               obj)
                                                                              (("3"
                                                                                (split)
                                                                                (("1"
                                                                                  (typepred
                                                                                   "fv2`fdepth")
                                                                                  (("1"
                                                                                    (hide-all-but
                                                                                     (u2def
                                                                                      -1))
                                                                                    (("1"
                                                                                      (grind)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (expand
                                                                                   skipReduce)
                                                                                  (("2"
                                                                                    (case-replace
                                                                                     "fv2`fdepth = fv`fdepth")
                                                                                    (("1"
                                                                                      (postpone)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (expand*
                                                                                       fv2
                                                                                       fv
                                                                                       skipReduce
                                                                                       endi)
                                                                                      (("2"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("4"
                                                                              (hide
                                                                               obj)
                                                                              (("4"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (hide
                                                                           obj)
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (use
                                                                       fill_eq_ctx)
                                                                      (("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil
                                                                    nil)
                                                                   ("3"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (postpone)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil
                                                          nil)
                                                         ("4"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil)
               ("2" (postpone) nil nil) ("3" (postpone) nil nil)
               ("4" (typepred "fv`ffct")
                (("4" (expand state_matches)
                  (("4" (flatten)
                    (("4" (hide obj)
                      (("4" (expand translate_definitions)
                        (("4" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (skipReduce_match-3 nil 3707595060
   (""
    (with-labels (skeep* :preds? t) ((dwt terr ierr stm cll skip obj)))
    (("" (with-labels (name "t" "typed_to_topstate(trS)") ((tdef)))
      (("" (with-labels (case "value?(t`state`redex)") ((tv) (tv)))
        (("1" (postpone) nil)
         ("2" (with-labels (name nS "make_redex_typed(t)") ((ndef)))
          (("1"
            (with-labels (name fv "endi(iS`callstack, 0)") ((fvdef)))
            (("1"
              (with-labels
               (name u
                     "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                                      D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc)")
               ((udef)))
              (("1"
                (with-labels (case "nS`state`redex = u`1") ((redeq)))
                (("1" (with-labels (case "pureLetRedex?(u`1)") ((plr)))
                  (("1" (expand typed_iareduce)
                    (("1" (replace tdef)
                      (("1" (replace ndef)
                        (("1" (replace redeq)
                          (("1" (assert)
                            (("1" (case "NOT variable?(u`1)")
                              (("1"
                                (assert)
                                (("1"
                                  (expand state_matches stm)
                                  (("1"
                                    (with-labels
                                     (flatten stm)
                                     ((defm domm stom cntm rdm)))
                                    (("1"
                                      (expand state_matches obj)
                                      (("1"
                                        (split obj)
                                        (("1" (grind) nil)
                                         ("2" (grind) nil)
                                         ("3"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("3"
                                            (expand* nS t)
                                            (("3"
                                              (expand*
                                               make_redex_typed
                                               typed_to_topstate
                                               make_redex
                                               to_topstate)
                                              nil)))))
                                         ("4"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("4"
                                            (expand*
                                             nS
                                             t
                                             typed_to_topstate
                                             to_topstate
                                             make_redex_typed
                                             make_redex)
                                            nil)))
                                         ("5"
                                          (expand skipReduce)
                                          (("5" (propax) nil)))
                                         ("6"
                                          (with-labels
                                           (flatten obj)
                                           ((useless obj)))
                                          (("6"
                                            (hide useless)
                                            (("6"
                                              (name-replace
                                               newS
                                               "typed_iareduce(D)(trS)")
                                              (("6"
                                                (expand typed_iareduce)
                                                (("6"
                                                  (replace* tdef ndef)
                                                  (("6"
                                                    (replace ndef)
                                                    (("6"
                                                      (replace -1)
                                                      (("6"
                                                        (with-labels
                                                         (case
                                                          "redex_matches(D, nS, iS)")
                                                         ((rdm2)))
                                                        (("1"
                                                          (expand
                                                           redex_matches
                                                           rdm2)
                                                          (("1"
                                                            (with-labels
                                                             (flatten
                                                              rdm2)
                                                             ((rdmf
                                                               rdms
                                                               rdmd)))
                                                            (("1"
                                                              (replace
                                                               fvdef)
                                                              (("1"
                                                                (name-replace
                                                                 K
                                                                 "extract_call_context(D, nS`def_types, iS)")
                                                                (("1"
                                                                  (name-replace
                                                                   tv1
                                                                   "extract_call_tv(D, nS`def_types, iS)")
                                                                  (("1"
                                                                    (with-labels
                                                                     (case
                                                                      "compose(K, u`2) = nS`state`context")
                                                                     ((ctxeq)))
                                                                    (("1"
                                                                      (expand
                                                                       redex_matches
                                                                       obj)
                                                                      (("1"
                                                                        (with-labels
                                                                         (name
                                                                          fv2
                                                                          "endi(skipReduce(iS)`callstack, 0)")
                                                                         ((fv2def)))
                                                                        (("1"
                                                                          (replace
                                                                           fv2def)
                                                                          (("1"
                                                                            (with-labels
                                                                             (name
                                                                              u2
                                                                              "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                                                                 skipReduce(iS)`stack,
                                                                                                 D`seq(fv2`ffct)`arity, fv2`fdepth,
                                                                                                 fv2`fpc)")
                                                                             ((u2def)))
                                                                            (("1"
                                                                              (replace
                                                                               u2def)
                                                                              (("1"
                                                                                (case-replace
                                                                                 "extract_call_context(D, newS`def_types, skipReduce(iS)) = K")
                                                                                (("1"
                                                                                  (case-replace
                                                                                   "extract_call_tv
                                                                                                 (D, newS`def_types, skipReduce(iS)) = tv1")
                                                                                  (("1"
                                                                                    (lemma
                                                                                     fct_reconstruct_state_next_pc_skip)
                                                                                    (("1"
                                                                                      (inst?
                                                                                       -1
                                                                                       :where
                                                                                       udef)
                                                                                      (("1"
                                                                                        (inst
                                                                                         -1
                                                                                         "skipReduce(iS)`stack")
                                                                                        (("1"
                                                                                          (split
                                                                                           -1)
                                                                                          (("1"
                                                                                            (with-labels
                                                                                             (flatten
                                                                                              -1)
                                                                                             ((ue1
                                                                                               ue2
                                                                                               ue3)))
                                                                                            (("1"
                                                                                              (case-replace
                                                                                               "fv2`ffct = fv`ffct")
                                                                                              (("1"
                                                                                                (case-replace
                                                                                                 "fv2`fdepth = fv`fdepth")
                                                                                                (("1"
                                                                                                  (case-replace
                                                                                                   "fv2`fpc = translate_next_pc(D`seq(fv`ffct)`body,
                                                                                                                                  fv`fpc)")
                                                                                                  (("1"
                                                                                                    (replace
                                                                                                     u2def)
                                                                                                    (("1"
                                                                                                      (split
                                                                                                       obj)
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         ue1)
                                                                                                        (("1"
                                                                                                          (replace
                                                                                                           ue2)
                                                                                                          (("1"
                                                                                                            (replace
                                                                                                             -14
                                                                                                             +
                                                                                                             :dir
                                                                                                             RL)
                                                                                                            (("1"
                                                                                                              (assert)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 letReduce)
                                                                                                                (("1"
                                                                                                                  (assert)
                                                                                                                  (("1"
                                                                                                                    (replace
                                                                                                                     udef)
                                                                                                                    (("1"
                                                                                                                      (replace
                                                                                                                       ctxeq
                                                                                                                       obj
                                                                                                                       :dir
                                                                                                                       RL)
                                                                                                                      (("1"
                                                                                                                        (rewrite
                                                                                                                         context_composition)
                                                                                                                        (("1"
                                                                                                                          (rewrite
                                                                                                                           context_composition)
                                                                                                                          (("1"
                                                                                                                            (rewrite
                                                                                                                             context_composition)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               fill
                                                                                                                               obj
                                                                                                                               3)
                                                                                                                              (("1"
                                                                                                                                (expand
                                                                                                                                 fill
                                                                                                                                 obj
                                                                                                                                 3)
                                                                                                                                (("1"
                                                                                                                                  (assert)
                                                                                                                                  nil)))))))))))))))))))))))))))
                                                                                                       ("2"
                                                                                                        (replace
                                                                                                         udef)
                                                                                                        (("2"
                                                                                                          (postpone)
                                                                                                          nil)))))))
                                                                                                   ("2"
                                                                                                    (postpone)
                                                                                                    nil)))
                                                                                                 ("2"
                                                                                                  (postpone)
                                                                                                  nil)))
                                                                                               ("2"
                                                                                                (postpone)
                                                                                                nil)))))
                                                                                           ("2"
                                                                                            (postpone)
                                                                                            nil)))
                                                                                         ("2"
                                                                                          (postpone)
                                                                                          nil)))
                                                                                       ("2"
                                                                                        (postpone)
                                                                                        nil)))))
                                                                                   ("2"
                                                                                    (postpone)
                                                                                    nil)))
                                                                                 ("2"
                                                                                  (postpone)
                                                                                  nil)
                                                                                 ("3"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("3"
                                                                                    (replace
                                                                                     -6
                                                                                     :dir
                                                                                     RL)
                                                                                    (("3"
                                                                                      (assert)
                                                                                      (("3"
                                                                                        (expand*
                                                                                         skipReduce
                                                                                         nS
                                                                                         t
                                                                                         make_redex_typed
                                                                                         typed_to_topstate)
                                                                                        nil)))))))
                                                                                 ("4"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("4"
                                                                                    (replace
                                                                                     -6
                                                                                     :dir
                                                                                     RL)
                                                                                    (("4"
                                                                                      (assert)
                                                                                      (("4"
                                                                                        (expand*
                                                                                         nS
                                                                                         t
                                                                                         make_redex_typed
                                                                                         typed_to_topstate)
                                                                                        nil)))))))))))
                                                                             ("2"
                                                                              (hide
                                                                               obj)
                                                                              (("2"
                                                                                (postpone)
                                                                                nil)))
                                                                             ("3"
                                                                              (hide
                                                                               obj)
                                                                              (("3"
                                                                                (postpone)
                                                                                nil)))
                                                                             ("4"
                                                                              (hide
                                                                               obj)
                                                                              (("4"
                                                                                (grind)
                                                                                nil)))))))
                                                                         ("2"
                                                                          (hide
                                                                           obj)
                                                                          (("2"
                                                                            (grind)
                                                                            nil)))))))
                                                                     ("2"
                                                                      (use
                                                                       fill_eq_ctx)
                                                                      (("2"
                                                                        (assert)
                                                                        nil)))))
                                                                   ("2"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil)
                                                                   ("3"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil)))))))))))
                                                         ("2"
                                                          (postpone)
                                                          nil)
                                                         ("3"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil)
                                                         ("4"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil)))))))))))))))))))))))))))
                               ("2" (grind) nil)))))))))))))
                   ("2" (postpone) nil)))
                 ("2" (postpone) nil)))
               ("2" (postpone) nil) ("3" (postpone) nil)
               ("4" (postpone) nil)))
             ("2" (grind) nil)))
           ("2" (grind) nil))))))))
    nil)
   nil nil)
  (skipReduce_match-2 nil 3707594901
   (""
    (with-labels (skeep* :preds? t) ((dwt terr ierr stm cll skip obj)))
    (("" (with-labels (name "t" "typed_to_topstate(trS)") ((tdef)))
      (("" (with-labels (case "value?(t`state`redex)") ((tv) (tv)))
        (("1" (postpone) nil)
         ("2" (with-labels (name nS "make_redex_typed(t)") ((ndef)))
          (("1"
            (with-labels (name fv "endi(iS`callstack, 0)") ((fvdef)))
            (("1"
              (with-labels
               (name u
                     "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                        D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc)")
               ((udef)))
              (("1"
                (with-labels (case "nS`state`redex = u`1") ((redeq)))
                (("1" (with-labels (case "pureLetRedex?(u`1)") ((plr)))
                  (("1" (expand typed_iareduce)
                    (("1" (replace tdef)
                      (("1" (replace ndef)
                        (("1" (replace redeq)
                          (("1" (assert)
                            (("1" (case "NOT variable?(u`1)")
                              (("1"
                                (assert)
                                (("1"
                                  (expand state_matches stm)
                                  (("1"
                                    (with-labels
                                     (flatten stm)
                                     ((defm domm stom cntm rdm)))
                                    (("1"
                                      (expand state_matches obj)
                                      (("1"
                                        (split obj)
                                        (("1" (grind) nil)
                                         ("2" (grind) nil)
                                         ("3"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("3"
                                            (expand* nS t)
                                            (("3"
                                              (expand*
                                               make_redex_typed
                                               typed_to_topstate
                                               make_redex
                                               to_topstate)
                                              nil)))))
                                         ("4"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("4"
                                            (expand*
                                             nS
                                             t
                                             typed_to_topstate
                                             to_topstate
                                             make_redex_typed
                                             make_redex)
                                            nil)))
                                         ("5"
                                          (expand skipReduce)
                                          (("5" (propax) nil)))
                                         ("6"
                                          (with-labels
                                           (flatten obj)
                                           ((useless obj)))
                                          (("6"
                                            (hide useless)
                                            (("6"
                                              (name-replace
                                               newS
                                               "typed_iareduce(D)(trS)")
                                              (("6"
                                                (expand typed_iareduce)
                                                (("6"
                                                  (replace* tdef ndef)
                                                  (("6"
                                                    (replace ndef)
                                                    (("6"
                                                      (replace -1)
                                                      (("6"
                                                        (with-labels
                                                         (case
                                                          "redex_matches(D, nS, iS)")
                                                         ((rdm2)))
                                                        (("1"
                                                          (expand
                                                           redex_matches
                                                           rdm2)
                                                          (("1"
                                                            (with-labels
                                                             (flatten
                                                              rdm2)
                                                             ((rdmf
                                                               rdms)))
                                                            (("1"
                                                              (replace
                                                               fvdef)
                                                              (("1"
                                                                (name-replace
                                                                 K
                                                                 "extract_call_context(D, nS`def_types, iS)")
                                                                (("1"
                                                                  (name-replace
                                                                   tv1
                                                                   "extract_call_tv(D, nS`def_types, iS)")
                                                                  (("1"
                                                                    (with-labels
                                                                     (case
                                                                      "compose(K, u`2) = nS`state`context")
                                                                     ((ctxeq)))
                                                                    (("1"
                                                                      (expand
                                                                       redex_matches
                                                                       obj)
                                                                      (("1"
                                                                        (with-labels
                                                                         (name
                                                                          fv2
                                                                          "endi(skipReduce(iS)`callstack, 0)")
                                                                         ((fv2def)))
                                                                        (("1"
                                                                          (replace
                                                                           fv2def)
                                                                          (("1"
                                                                            (with-labels
                                                                             (name
                                                                              u2
                                                                              "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                                                 skipReduce(iS)`stack,
                                                                 D`seq(fv2`ffct)`arity, fv2`fdepth,
                                                                 fv2`fpc)")
                                                                             ((u2def)))
                                                                            (("1"
                                                                              (replace
                                                                               u2def)
                                                                              (("1"
                                                                                (case-replace
                                                                                 "extract_call_context(D, newS`def_types, skipReduce(iS)) = K")
                                                                                (("1"
                                                                                  (case-replace
                                                                                   "extract_call_tv
                                                                   (D, newS`def_types, skipReduce(iS)) = tv1")
                                                                                  (("1"
                                                                                    (lemma
                                                                                     fct_reconstruct_state_next_pc_skip)
                                                                                    (("1"
                                                                                      (inst?
                                                                                       -1
                                                                                       :where
                                                                                       udef)
                                                                                      (("1"
                                                                                        (inst
                                                                                         -1
                                                                                         "skipReduce(iS)`stack")
                                                                                        (("1"
                                                                                          (split
                                                                                           -1)
                                                                                          (("1"
                                                                                            (with-labels
                                                                                             (flatten
                                                                                              -1)
                                                                                             ((ue1
                                                                                               ue2
                                                                                               ue3)))
                                                                                            (("1"
                                                                                              (case-replace
                                                                                               "fv2`ffct = fv`ffct")
                                                                                              (("1"
                                                                                                (case-replace
                                                                                                 "fv2`fdepth = fv`fdepth")
                                                                                                (("1"
                                                                                                  (case-replace
                                                                                                   "fv2`fpc = translate_next_pc(D`seq(fv`ffct)`body,
                                                                                        fv`fpc)")
                                                                                                  (("1"
                                                                                                    (replace
                                                                                                     u2def)
                                                                                                    (("1"
                                                                                                      (split
                                                                                                       obj)
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         ue1)
                                                                                                        (("1"
                                                                                                          (replace
                                                                                                           ue2)
                                                                                                          (("1"
                                                                                                            (replace
                                                                                                             -14
                                                                                                             +
                                                                                                             :dir
                                                                                                             RL)
                                                                                                            (("1"
                                                                                                              (assert)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 letReduce)
                                                                                                                (("1"
                                                                                                                  (assert)
                                                                                                                  (("1"
                                                                                                                    (replace
                                                                                                                     udef)
                                                                                                                    (("1"
                                                                                                                      (replace
                                                                                                                       ctxeq
                                                                                                                       obj
                                                                                                                       :dir
                                                                                                                       RL)
                                                                                                                      (("1"
                                                                                                                        (rewrite
                                                                                                                         context_composition)
                                                                                                                        (("1"
                                                                                                                          (rewrite
                                                                                                                           context_composition)
                                                                                                                          (("1"
                                                                                                                            (rewrite
                                                                                                                             context_composition)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               fill
                                                                                                                               obj
                                                                                                                               3)
                                                                                                                              (("1"
                                                                                                                                (expand
                                                                                                                                 fill
                                                                                                                                 obj
                                                                                                                                 3)
                                                                                                                                (("1"
                                                                                                                                  (assert)
                                                                                                                                  nil)))))))))))))))))))))))))))
                                                                                                       ("2"
                                                                                                        (replace
                                                                                                         udef)
                                                                                                        (("2"
                                                                                                          (postpone)
                                                                                                          nil)))))))
                                                                                                   ("2"
                                                                                                    (postpone)
                                                                                                    nil)))
                                                                                                 ("2"
                                                                                                  (postpone)
                                                                                                  nil)))
                                                                                               ("2"
                                                                                                (postpone)
                                                                                                nil)))))
                                                                                           ("2"
                                                                                            (postpone)
                                                                                            nil)))
                                                                                         ("2"
                                                                                          (postpone)
                                                                                          nil)))
                                                                                       ("2"
                                                                                        (postpone)
                                                                                        nil)))))
                                                                                   ("2"
                                                                                    (postpone)
                                                                                    nil)))
                                                                                 ("2"
                                                                                  (postpone)
                                                                                  nil)
                                                                                 ("3"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("3"
                                                                                    (replace
                                                                                     -6
                                                                                     :dir
                                                                                     RL)
                                                                                    (("3"
                                                                                      (assert)
                                                                                      (("3"
                                                                                        (expand*
                                                                                         skipReduce
                                                                                         nS
                                                                                         t
                                                                                         make_redex_typed
                                                                                         typed_to_topstate)
                                                                                        nil)))))))
                                                                                 ("4"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("4"
                                                                                    (replace
                                                                                     -6
                                                                                     :dir
                                                                                     RL)
                                                                                    (("4"
                                                                                      (assert)
                                                                                      (("4"
                                                                                        (expand*
                                                                                         nS
                                                                                         t
                                                                                         make_redex_typed
                                                                                         typed_to_topstate)
                                                                                        nil)))))))))))
                                                                             ("2"
                                                                              (hide
                                                                               obj)
                                                                              (("2"
                                                                                (postpone)
                                                                                nil)))
                                                                             ("3"
                                                                              (hide
                                                                               obj)
                                                                              (("3"
                                                                                (postpone)
                                                                                nil)))
                                                                             ("4"
                                                                              (hide
                                                                               obj)
                                                                              (("4"
                                                                                (grind)
                                                                                nil)))))))
                                                                         ("2"
                                                                          (hide
                                                                           obj)
                                                                          (("2"
                                                                            (grind)
                                                                            nil)))))))
                                                                     ("2"
                                                                      (use
                                                                       fill_eq_ctx)
                                                                      (("2"
                                                                        (assert)
                                                                        nil)))))
                                                                   ("2"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil)
                                                                   ("3"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil)))))))))))
                                                         ("2"
                                                          (postpone)
                                                          nil)
                                                         ("3"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil)
                                                         ("4"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil)))))))))))))))))))))))))))
                               ("2" (grind) nil)))))))))))))
                   ("2" (postpone) nil)))
                 ("2" (postpone) nil)))
               ("2" (postpone) nil) ("3" (postpone) nil)
               ("4" (postpone) nil)))
             ("2" (grind) nil)))
           ("2" (grind) nil))))))))
    nil)
   nil nil)
  (skipReduce_match-1 nil 3707573865
   (""
    (with-labels (skeep* :preds? t) ((dwt terr ierr stm cll skip obj)))
    (("" (with-labels (name "t" "typed_to_topstate(trS)") ((tdef)))
      (("" (with-labels (case "value?(t`state`redex)") ((tv) (tv)))
        (("1" (postpone) nil nil)
         ("2" (with-labels (name nS "make_redex_typed(t)") ((ndef)))
          (("1"
            (with-labels (name fv "endi(iS`callstack, 0)") ((fvdef)))
            (("1"
              (with-labels
               (name u
                     "fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
          D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc)")
               ((udef)))
              (("1"
                (with-labels (case "nS`state`redex = u`1") ((redeq)))
                (("1" (with-labels (case "pureLetRedex?(u`1)") ((plr)))
                  (("1" (expand typed_reduce)
                    (("1" (replace tdef)
                      (("1" (replace ndef)
                        (("1" (replace redeq)
                          (("1" (assert)
                            (("1" (case "NOT variable?(u`1)")
                              (("1"
                                (assert)
                                (("1"
                                  (expand state_matches stm)
                                  (("1"
                                    (with-labels
                                     (flatten stm)
                                     ((defm domm stom cntm rdm)))
                                    (("1"
                                      (expand state_matches obj)
                                      (("1"
                                        (split obj)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil)
                                         ("3"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("3"
                                            (expand* nS t)
                                            (("3"
                                              (expand*
                                               make_redex_typed
                                               typed_to_topstate
                                               make_redex
                                               to_topstate)
                                              nil
                                              nil))
                                            nil))
                                          nil)
                                         ("4"
                                          (expand*
                                           letReduce
                                           skipReduce)
                                          (("4"
                                            (expand*
                                             nS
                                             t
                                             typed_to_topstate
                                             to_topstate
                                             make_redex_typed
                                             make_redex)
                                            nil
                                            nil))
                                          nil)
                                         ("5"
                                          (expand skipReduce)
                                          (("5" (propax) nil nil))
                                          nil)
                                         ("6"
                                          (with-labels
                                           (flatten obj)
                                           ((useless obj)))
                                          (("6"
                                            (hide useless)
                                            (("6"
                                              (name-replace
                                               newS
                                               "typed_reduce(D)(trS)")
                                              (("6"
                                                (expand typed_reduce)
                                                (("6"
                                                  (replace* tdef ndef)
                                                  (("6"
                                                    (replace ndef)
                                                    (("6"
                                                      (replace -1)
                                                      (("6"
                                                        (with-labels
                                                         (case
                                                          "redex_matches(D, nS, iS)")
                                                         ((rdm2)))
                                                        (("1"
                                                          (expand
                                                           redex_matches
                                                           rdm2)
                                                          (("1"
                                                            (with-labels
                                                             (flatten
                                                              rdm2)
                                                             ((rdmf
                                                               rdms)))
                                                            (("1"
                                                              (replace
                                                               fvdef)
                                                              (("1"
                                                                (name-replace
                                                                 K
                                                                 "extract_call_context(D, nS`def_types, iS)")
                                                                (("1"
                                                                  (name-replace
                                                                   tv1
                                                                   "extract_call_tv(D, nS`def_types, iS)")
                                                                  (("1"
                                                                    (with-labels
                                                                     (case
                                                                      "compose(K, u`2) = nS`state`context")
                                                                     ((ctxeq)))
                                                                    (("1"
                                                                      (expand
                                                                       redex_matches
                                                                       obj)
                                                                      (("1"
                                                                        (with-labels
                                                                         (name
                                                                          fv2
                                                                          "endi(skipReduce(iS)`callstack, 0)")
                                                                         ((fv2def)))
                                                                        (("1"
                                                                          (replace
                                                                           fv2def)
                                                                          (("1"
                                                                            (with-labels
                                                                             (name
                                                                              u2
                                                                              "fct_reconstruct_state(D`seq(fv2`ffct)`body,
                                 skipReduce(iS)`stack,
                                 D`seq(fv2`ffct)`arity, fv2`fdepth,
                                 fv2`fpc)")
                                                                             ((u2def)))
                                                                            (("1"
                                                                              (replace
                                                                               u2def)
                                                                              (("1"
                                                                                (case-replace
                                                                                 "extract_call_context(D, newS`def_types, skipReduce(iS)) = K")
                                                                                (("1"
                                                                                  (case-replace
                                                                                   "extract_call_tv
                                     (D, newS`def_types, skipReduce(iS)) = tv1")
                                                                                  (("1"
                                                                                    (lemma
                                                                                     fct_reconstruct_state_next_pc_skip)
                                                                                    (("1"
                                                                                      (inst?
                                                                                       -1
                                                                                       :where
                                                                                       udef)
                                                                                      (("1"
                                                                                        (inst
                                                                                         -1
                                                                                         "skipReduce(iS)`stack")
                                                                                        (("1"
                                                                                          (split
                                                                                           -1)
                                                                                          (("1"
                                                                                            (with-labels
                                                                                             (flatten
                                                                                              -1)
                                                                                             ((ue1
                                                                                               ue2
                                                                                               ue3)))
                                                                                            (("1"
                                                                                              (case-replace
                                                                                               "fv2`ffct = fv`ffct")
                                                                                              (("1"
                                                                                                (case-replace
                                                                                                 "fv2`fdepth = fv`fdepth")
                                                                                                (("1"
                                                                                                  (case-replace
                                                                                                   "fv2`fpc = translate_next_pc(D`seq(fv`ffct)`body,
                                              fv`fpc)")
                                                                                                  (("1"
                                                                                                    (replace
                                                                                                     u2def)
                                                                                                    (("1"
                                                                                                      (split
                                                                                                       obj)
                                                                                                      (("1"
                                                                                                        (replace
                                                                                                         ue1)
                                                                                                        (("1"
                                                                                                          (replace
                                                                                                           ue2)
                                                                                                          (("1"
                                                                                                            (replace
                                                                                                             -14
                                                                                                             +
                                                                                                             :dir
                                                                                                             RL)
                                                                                                            (("1"
                                                                                                              (assert)
                                                                                                              (("1"
                                                                                                                (expand
                                                                                                                 letReduce)
                                                                                                                (("1"
                                                                                                                  (assert)
                                                                                                                  (("1"
                                                                                                                    (replace
                                                                                                                     udef)
                                                                                                                    (("1"
                                                                                                                      (replace
                                                                                                                       ctxeq
                                                                                                                       obj
                                                                                                                       :dir
                                                                                                                       RL)
                                                                                                                      (("1"
                                                                                                                        (rewrite
                                                                                                                         context_composition)
                                                                                                                        (("1"
                                                                                                                          (rewrite
                                                                                                                           context_composition)
                                                                                                                          (("1"
                                                                                                                            (rewrite
                                                                                                                             context_composition)
                                                                                                                            (("1"
                                                                                                                              (expand
                                                                                                                               fill
                                                                                                                               obj
                                                                                                                               3)
                                                                                                                              (("1"
                                                                                                                                (expand
                                                                                                                                 fill
                                                                                                                                 obj
                                                                                                                                 3)
                                                                                                                                (("1"
                                                                                                                                  (assert)
                                                                                                                                  nil
                                                                                                                                  nil))
                                                                                                                                nil))
                                                                                                                              nil))
                                                                                                                            nil))
                                                                                                                          nil))
                                                                                                                        nil))
                                                                                                                      nil))
                                                                                                                    nil))
                                                                                                                  nil))
                                                                                                                nil))
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil)
                                                                                                       ("2"
                                                                                                        (replace
                                                                                                         udef)
                                                                                                        (("2"
                                                                                                          (postpone)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil)
                                                                                                   ("2"
                                                                                                    (postpone)
                                                                                                    nil
                                                                                                    nil))
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (postpone)
                                                                                                  nil
                                                                                                  nil))
                                                                                                nil)
                                                                                               ("2"
                                                                                                (postpone)
                                                                                                nil
                                                                                                nil))
                                                                                              nil))
                                                                                            nil)
                                                                                           ("2"
                                                                                            (postpone)
                                                                                            nil
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (postpone)
                                                                                          nil
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (postpone)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (postpone)
                                                                                    nil
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (postpone)
                                                                                  nil
                                                                                  nil)
                                                                                 ("3"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("3"
                                                                                    (replace
                                                                                     -6
                                                                                     :dir
                                                                                     RL)
                                                                                    (("3"
                                                                                      (assert)
                                                                                      (("3"
                                                                                        (expand*
                                                                                         skipReduce
                                                                                         nS
                                                                                         t
                                                                                         make_redex_typed
                                                                                         typed_to_topstate)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("4"
                                                                                  (hide
                                                                                   obj)
                                                                                  (("4"
                                                                                    (replace
                                                                                     -6
                                                                                     :dir
                                                                                     RL)
                                                                                    (("4"
                                                                                      (assert)
                                                                                      (("4"
                                                                                        (expand*
                                                                                         nS
                                                                                         t
                                                                                         make_redex_typed
                                                                                         typed_to_topstate)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (hide
                                                                               obj)
                                                                              (("2"
                                                                                (postpone)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("3"
                                                                              (hide
                                                                               obj)
                                                                              (("3"
                                                                                (postpone)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("4"
                                                                              (hide
                                                                               obj)
                                                                              (("4"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (hide
                                                                           obj)
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (use
                                                                       fill_eq_ctx)
                                                                      (("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil
                                                                    nil)
                                                                   ("3"
                                                                    (expand*
                                                                     nS
                                                                     t
                                                                     make_redex_typed
                                                                     typed_to_topstate)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (postpone)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil
                                                          nil)
                                                         ("4"
                                                          (expand*
                                                           nS
                                                           t
                                                           make_redex_typed
                                                           typed_to_topstate)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil)
               ("2" (postpone) nil nil) ("3" (postpone) nil nil)
               ("4" (postpone) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))

