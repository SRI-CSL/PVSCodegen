(typed_rreduction
 (typed_rstate_TCC1 0
  (typed_rstate_TCC1-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_rstate subtype "typed_rreduction.i"
    "below[state`stack`length]")))
 (typed_rstate_TCC2 0
  (typed_rstate_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (inst -3 "i-popDepth(state`redex)")
            (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}"
     typed_rreduction nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_rstate subtype "typed_rreduction.stack_types"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_rreduction.state`redex), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_rreduction.state`redex)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (typed_rstate_TCC3 0
  (typed_rstate_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_rstate subtype "IL.popDepth(typed_rreduction.state`redex)"
    "naturalnumbers.upto(typed_rreduction.stack_types`length)")))
 (typed_rstate_TCC4 0
  (typed_rstate_TCC4-1 nil 3705932019
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (inst -4 "i-popDepth(state`context)")
            (("1" (rewrite cvars_vars_ctx)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}"
     typed_rreduction nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_rstate subtype
    "typed_reduction.popn(typed_rreduction.stack_types, IL.popDepth(typed_rreduction.state`redex))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_rreduction.state`context), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_rreduction.state`context)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply_TCC1 0
  (is_well_typed_letApply_TCC1-1 nil 3703270930
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil
   (is_well_typed_letApply subtype "typed_rreduction.i"
    "below[length[(variable?)](args)]")))
 (is_well_typed_letApply_TCC2 0
  (is_well_typed_letApply_TCC2-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (typepred "nth(args, i1)") (("" (grind) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed_letApply subtype
    "list_props[(IExpression_adt.variable?)].nth(typed_rreduction.args, typed_rreduction.i)"
    "(IL.contextPure?)")))
 (is_well_typed_letApply_TCC3 0
  (is_well_typed_letApply_TCC3-2 nil 3706551373
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil
   (is_well_typed_letApply subtype "typed_rreduction.i"
    "below[length[nat](args_type)]"))
  (is_well_typed_letApply_TCC3-1 nil 3703270930
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil
   (is_well_typed_letApply subtype "typed_rreduction.i"
    "below[length[nat](args_type)]")))
 (is_well_typed_letApply_TCC4 0
  (is_well_typed_letApply_TCC4-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (inst -8 "i_1")
          (("2" (split -8)
            (("1" (propax) nil nil)
             ("2" (expand in_varlist)
              (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popDepth def-decl "nat" IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (singleton const-decl "(singleton?)" sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil))
   nil
   (is_well_typed_letApply subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(list_props[(IExpression_adt.variable?)].nth(typed_rreduction.args, typed_rreduction.i)), typed_reduction.stypes`length), FORALL (i_1: naturalnumbers.nat): booleans.IMPLIES(preprocess.cvars(list_props[(IExpression_adt.variable?)].nth(typed_rreduction.args, typed_rreduction.i))(i_1), reals.<(i_1, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply_TCC5 0
  (is_well_typed_letApply_TCC5-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil
   (is_well_typed_letApply subtype "typed_rreduction.A"
    "(IL.contextPure?)")))
 (is_well_typed_letApply_TCC6 0
  (is_well_typed_letApply_TCC6-1 nil 3705932019
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (is_well_typed_letApply subtype
    "finite_sequences[naturalnumbers.nat].o(typed_rreduction.stypes, list2finseq[naturalnumbers.nat].list2finseq(typed_rreduction.args_type))"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_rreduction.A), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_rreduction.A)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply_TCC7 0
  (is_well_typed_letApply_TCC7-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (use "pure_contextPure")
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (use "rreduction.pure_letApply") nil nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (letApply def-decl "IExpression" rreduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (A skolem-const-decl "IExpression" typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil))
   nil
   (is_well_typed_letApply subtype
    "rreduction.letApply(typed_rreduction.arity, typed_rreduction.args, typed_rreduction.A)"
    "(IL.contextPure?)")))
 (is_well_typed_letApply_TCC8 0
  (is_well_typed_letApply_TCC8-1 nil 3706555818
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purepopdepth)
        (("1" (grind) nil nil)
         ("2" (use "rreduction.pure_letApply") nil nil))
        nil)
       ("2" (skeep)
        (("2" (rewrite cvars_pure)
          (("1" (rewrite vars_letapply)
            (("1" (inst -8 "i + arity")
              (("1" (inst -9 i)
                (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use "rreduction.pure_letApply") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letApply def-decl "IExpression" rreduction nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (cvars_pure formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_letApply formula-decl nil rreduction nil))
   nil
   (is_well_typed_letApply subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(rreduction.letApply(typed_rreduction.arity, typed_rreduction.args, typed_rreduction.A)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(rreduction.letApply(typed_rreduction.arity, typed_rreduction.args, typed_rreduction.A))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_letApply 0
  (is_well_typed_letApply-1 nil 3703270931
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (expand letApply)
        (("1" (expand letApply_type)
          (("1"
            (case-replace
             "stypes o list2finseq[nat](args_type) = stypes")
            (("1" (lemma is_well_typed_dom)
              (("1" (inst?)
                (("1" (inst -1 dom_types)
                  (("1" (split -1)
                    (("1" (grind) nil nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil)
                     ("3" (skeep)
                      (("3" (use pure_refs) (("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (decompose-equality)
                (("1" (grind) nil nil)
                 ("2" (decompose-equality) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand letApply +)
        (("2" (expand letApply_type +)
          (("2" (lift-if +)
            (("2" (expand is_well_typed +)
              (("2" (expand is_well_typed + 2)
                (("2" (split)
                  (("1" (inst -10 0) (("1" (grind) nil nil)) nil)
                   ("2" (expand expr_type) (("2" (propax) nil nil))
                    nil)
                   ("3" (inst? -6)
                    (("3" (split -6)
                      (("1" (propax) nil nil) ("2" (propax) nil nil)
                       ("3" (delete 2)
                        (("3" (expand add +)
                          (("3" (expand popn +)
                            (("3"
                              (case-replace "popDepth(car(args)) = 0")
                              (("1" (assert) nil nil)
                               ("2" (grind) nil nil)
                               ("3" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete 2)
                        (("4" (skeep*)
                          (("4" (case "in_varlist(args)(i-1)")
                            (("1" (expand add)
                              (("1"
                                (expand popn)
                                (("1"
                                  (case-replace
                                   "popDepth(car(args)) = 0")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_map)
                                (("2"
                                  (expand o)
                                  (("2"
                                    (case-replace
                                     "(lambda (v: (variable?)): index(v) = i - 1) = (LAMBDA (x_1: (variable?)): 1 + index(x_1) = i)")
                                    (("1"
                                      (expand some +)
                                      (("1"
                                        (lift-if)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (apply-extensionality)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("5" (delete 2)
                        (("5" (skeep :preds? t)
                          (("5" (rewrite map_nth_rw)
                            (("1"
                              (case-replace
                               "nth(cdr(args), i) = nth(args, i + 1)")
                              (("1"
                                (case-replace
                                 "nth(cdr(args_type), i) = nth(args_type, i+1)")
                                (("1"
                                  (case-replace
                                   "popDepth(car(args)) = 0")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1"
                                        (inst -13 "1+i")
                                        (("1"
                                          (expand is_well_typed -13)
                                          (("1"
                                            (expand add +)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand nth 1 2)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (expand nth 1 2)
                                (("2" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (expand length -3)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("6" (case-replace "popDepth(car(args)) = 0")
                        (("1" (assert)
                          (("1"
                            (case-replace
                             "stypes o list2finseq[nat](args_type) = add(car(args_type), stypes) o
                               list2finseq[nat](cdr(args_type))")
                            (("1" (delete 2)
                              (("1"
                                (delete 2)
                                (("1"
                                  (decompose-equality)
                                  (("1"
                                    (grind)
                                    (("1"
                                      (grind)
                                      (("1"
                                        (expand length -4)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand length -4)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (decompose-equality)
                                    (("2"
                                      (expand o)
                                      (("2"
                                        (expand add)
                                        (("2"
                                          (lift-if)
                                          (("2"
                                            (lift-if)
                                            (("2"
                                              (lift-if)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand list2finseq)
                                                  (("2"
                                                    (expand nth 1 2)
                                                    (("2"
                                                      (ground)
                                                      (("2"
                                                        (case-replace
                                                         "x!1 = stypes`length")
                                                        (("1"
                                                          (expand nth)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep :preds? t)
        (("3" (split)
          (("1" (rewrite popdepth_letApply)
            (("1" (rewrite purePopDepth)
              (("1" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (rewrite vars_letApply)
                (("1" (inst -8 "arity + i")
                  (("1" (inst -9 i)
                    (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (use "rreduction.pure_letApply") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (skeep* :preds? t)
        (("4" (use pure_contextPure)
          (("4" (use "rreduction.pure_letApply")
            (("4" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("5" (delete 2)
      (("5" (skeep* :preds? t)
        (("5" (split)
          (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (delete 2)
      (("6" (skeep* :preds? t)
        (("6" (use pure_contextPure) (("6" (grind) nil nil)) nil))
        nil))
      nil)
     ("7" (delete 2)
      (("7" (skeep* :preds? t)
        (("7" (split)
          (("1" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (inst -8 i_1)
                (("1" (split -8)
                  (("1" (propax) nil nil)
                   ("2" (expand in_varlist)
                    (("2" (rewrite some_nth)
                      (("2" (inst 1 i1) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (delete 2)
      (("8" (skeep* :preds? t) (("8" (grind) nil nil)) nil)) nil))
    nil)
   ((some_nth formula-decl nil finseq_theorems nil) nil
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    nil (purePopDepth formula-decl nil IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (cvars_pure formula-decl nil preprocess nil)
    (vars_letApply formula-decl nil rreduction nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "T3" function_props nil) nil
    (int_plus_int_is_int application-judgement "int" integers nil)
    (some_map formula-decl nil finseq_theorems nil)
    (TRUE const-decl "bool" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil) nil
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (pure_refs formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (letApply_type def-decl "typeinfo" typed_reduction nil)
    (pred type-eq-decl nil defined_types nil)
    (letApply def-decl "IExpression" rreduction nil)
    (O const-decl "finseq" finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (<= const-decl "bool" reals nil) nil
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (contextPure? def-decl "bool" IL nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_to_topstate_TCC1 0
  (typed_to_topstate_TCC1-1 nil 3702747756
   ("" (skeep)
    (("" (lemma to_topstate_dangling)
      (("" (inst?)
        (("" (assert)
          (("" (expand to_topstate)
            (("" (lemma arm_fill)
              (("" (inst?)
                (("" (typepred "tS`state") (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate_dangling judgement-tcc nil rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (arm_fill formula-decl nil preprocess nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_to_topstate subtype
    "rreduction.to_topstate(typed_rreduction.tS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_to_topstate_TCC2 0
  (typed_to_topstate_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`dom_types")
      (("" (expand to_topstate) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil))
   nil
   (typed_to_topstate subtype "typed_rreduction.tS`dom_types"
    "{dom_types | FORALL (r: (rreduction.to_topstate(typed_rreduction.tS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.to_topstate(typed_rreduction.tS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.to_topstate(typed_rreduction.tS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_to_topstate_TCC3 0
  (typed_to_topstate_TCC3-2 "" 3720242971
   ("" (skeep* :preds? t)
    (("" (expand to_topstate)
      (("" (typepred "tS`stack_types")
        (("" (split) (("1" (propax) nil nil) ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil))
   shostak
   (typed_to_topstate subtype "typed_rreduction.tS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.to_topstate(typed_rreduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.to_topstate(typed_rreduction.tS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.tS`dom_types))}"))
  (typed_to_topstate_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand to_topstate)
      (("" (typepred "tS`stack_types")
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "rtopstate" rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil))
   nil
   (typed_to_topstate subtype "typed_rreduction.tS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.to_topstate(typed_rreduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.to_topstate(typed_rreduction.tS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.tS`dom_types))}")))
 (typed_to_topstate_TCC4 0
  (typed_to_topstate_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand to_topstate)
      (("" (rewrite fill_well_typed)
        (("1" (skeep)
          (("1" (typepred "tS`state`redex")
            (("1" (typepred "tS`stack_types")
              (("1" (inst -4 "i-popDepth(tS`state`redex)")
                (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (typepred "tS`state`redex")
            (("2" (typepred "tS`stack_types")
              (("2" (inst -5 "i-popDepth(tS`state`context)")
                (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "rtopstate" rreduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (cvars_vars formula-decl nil preprocess nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (tS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (fill_well_typed formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_to_topstate subtype
    "typed_reduction.typeinfo_fill(typed_rreduction.tS`context_type, typed_rreduction.tS`redex_type)"
    "{tA | typed_reduction.is_well_typed(rreduction.to_topstate(typed_rreduction.tS`state)`redex, typed_rreduction.tA, typed_rreduction.tS`stack_types, typed_rreduction.tS`dom_types, typed_rreduction.tS`def_types)}")))
 (typed_to_topstate_TCC5 0
  (typed_to_topstate_TCC5-1 nil 3702747756 ("" (grind) nil nil)
   ((to_topstate const-decl "rtopstate" rreduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_to_topstate subtype "typed_reduction.holet"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.to_topstate(typed_rreduction.tS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.tS`stack_types, IL.popDepth(rreduction.to_topstate(typed_rreduction.tS`state)`redex)), typed_rreduction.tS`dom_types, typed_rreduction.tS`def_types, typed_reduction.expr_type(typed_reduction.typeinfo_fill(typed_rreduction.tS`context_type, typed_rreduction.tS`redex_type)))}")))
 (make_redex_typed_TCC1 0
  (make_redex_typed_TCC1-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_rreduction.tS`state"
    "{t: rreduction.rtopstate | }")))
 (make_redex_typed_TCC2 0
  (make_redex_typed_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (typepred "buildRedex(tS`state`redex)")
        (("" (typepred "tS`state")
          (("" (replace -4 -2 :dir RL)
            (("" (rewrite arm_fill)
              (("" (flatten)
                (("" (assert)
                  (("" (use make_redex_ndr)
                    (("" (lemma make_redex_ndr)
                      (("" (inst?)
                        (("" (expand make_redex)
                          (("" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (arm_fill formula-decl nil preprocess nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (make_redex_ndr application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype
    "rreduction.make_redex(typed_rreduction.tS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (make_redex_typed_TCC3 0
  (make_redex_typed_TCC3-2 "" 3720242993
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (typepred "tS`dom_types")
        (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (pureRedex? const-decl "bool" IL nil)
    (j skolem-const-decl "below(make_redex(tS`state)`store(r)`length)"
     typed_rreduction nil)
    (r skolem-const-decl "(make_redex(tS`state)`domain)"
     typed_rreduction nil)
    (tS skolem-const-decl
     "{tS | tS`state`context = hole AND NOT value?(tS`state`redex)}"
     typed_rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (make_redex_typed subtype "typed_rreduction.tS`dom_types"
    "{dom_types | FORALL (r: (rreduction.make_redex(typed_rreduction.tS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.make_redex(typed_rreduction.tS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.make_redex(typed_rreduction.tS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (make_redex_typed_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (typepred "tS`dom_types") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (pureRedex? const-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil))
   nil
   (make_redex_typed subtype "typed_rreduction.tS`dom_types"
    "{dom_types | FORALL (r: (rreduction.make_redex(typed_rreduction.tS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.make_redex(typed_rreduction.tS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.make_redex(typed_rreduction.tS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (make_redex_typed_TCC4 0
  (make_redex_typed_TCC4-2 "" 3720243008
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (expand make_redex)
        (("" (split) (("1" (propax) nil nil) ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (make_redex_typed subtype "typed_rreduction.tS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.make_redex(typed_rreduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.make_redex(typed_rreduction.tS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.tS`dom_types))}"))
  (make_redex_typed_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (expand make_redex)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil))
   nil
   (make_redex_typed subtype "typed_rreduction.tS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.make_redex(typed_rreduction.tS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.make_redex(typed_rreduction.tS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.tS`dom_types))}")))
 (make_redex_typed_TCC5 0
  (make_redex_typed_TCC5-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`redex_type")
      (("" (expand make_redex)
        (("" (use buildRedexType_correct)
          (("" (simplify :let-reduce? t)
            (("" (split -1)
              (("1" (grind) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (typepred "tS`stack_types")
                  (("2" (grind) nil nil)) nil))
                nil)
               ("3" (typepred "tS`stack_types")
                (("3" (typepred "tS`state`redex")
                  (("3" (skeep)
                    (("3" (inst -2 "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (tS skolem-const-decl
     "{tS | tS`state`context = hole AND NOT value?(tS`state`redex)}"
     typed_rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_rreduction.tA"
    "{tA | typed_reduction.is_well_typed(rreduction.make_redex(typed_rreduction.tS`state)`redex, typed_rreduction.tA, typed_rreduction.tS`stack_types, typed_rreduction.tS`dom_types, typed_rreduction.tS`def_types)}")))
 (make_redex_typed_TCC6 0
  (make_redex_typed_TCC6-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (grind) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex") (("3" (grind) nil nil))
                nil)
               ("4" (typepred "tS`state`redex")
                (("4" (skeep)
                  (("4" (inst -2 "i-popDepth(tS`state`redex)")
                    (("1" (rewrite cvars_vars) (("1" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("5" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (tS skolem-const-decl
     "{tS | tS`state`context = hole AND NOT value?(tS`state`redex)}"
     typed_rreduction nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (make_redex_typed subtype "typed_rreduction.tK"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.make_redex(typed_rreduction.tS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.tS`stack_types, IL.popDepth(rreduction.make_redex(typed_rreduction.tS`state)`redex)), typed_rreduction.tS`dom_types, typed_rreduction.tS`def_types, typed_reduction.expr_type(typed_rreduction.tA))}")))
 (set_new_type_TCC1 0
  (set_new_type_TCC1-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`state`store(r)`seq(j)")
      (("" (typepred "tS`dom_types") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (set_new_type subtype
    "typed_rreduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.tS`state`domain)) := typed_rreduction.i]"
    "{dom_types | FORALL (r: (typed_rreduction.tS`state`domain)): FORALL (j: naturalnumbers.below(typed_rreduction.tS`state`store(r)`length)): typed_reduction.value_of_type(typed_rreduction.tS`state`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (set_new_type_TCC2 0
  (set_new_type_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep)
          (("2" (typepred "tS`state`stack")
            (("2" (typepred "tS`state`stack`seq(i_1)")
              (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (set_new_type subtype "typed_rreduction.tS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = typed_rreduction.tS`state`stack`length, FORALL (i_1: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(typed_rreduction.tS`state`stack`seq(i_1), typed_rreduction.stypes`seq(i_1), typed_rreduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.tS`state`domain)) := typed_rreduction.i]))}")))
 (set_new_type_TCC3 0
  (set_new_type_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (lemma is_well_typed_dom)
      (("" (inst?)
        (("" (inst -1 "tS`dom_types")
          (("" (split -1)
            (("1" (typepred "tS`redex_type") (("1" (assert) nil nil))
              nil)
             ("2" (typepred "tS`state`redex") (("2" (propax) nil nil))
              nil)
             ("3" (skeep*)
              (("3" (typepred "tS`state`redex") (("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_well_typed_dom formula-decl nil typed_reduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (set_new_type subtype "typed_rreduction.tS`redex_type"
    "{tA | typed_reduction.is_well_typed(typed_rreduction.tS`state`redex, typed_rreduction.tA, typed_rreduction.tS`stack_types, typed_rreduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.tS`state`domain)) := typed_rreduction.i], typed_rreduction.tS`def_types)}")))
 (set_new_type_TCC4 0
  (set_new_type_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`context_type")
      (("" (lemma is_well_typed_ctx_dom)
        (("" (inst?) (("" (inst? :where 1) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (is_well_typed_ctx_dom formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (set_new_type subtype "typed_rreduction.tS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(typed_rreduction.tS`state`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.tS`stack_types, IL.popDepth(typed_rreduction.tS`state`redex)), typed_rreduction.tS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.tS`state`domain)) := typed_rreduction.i], typed_rreduction.tS`def_types, typed_reduction.expr_type(typed_rreduction.tS`redex_type))}")))
 (stack_still_typed_TCC1 0
  (stack_still_typed_TCC1-1 nil 3702752010 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (stack_still_typed subtype "typed_rreduction.i" "below[S`length]")))
 (stack_still_typed_TCC2 0
  (stack_still_typed_TCC2-1 nil 3702752010 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (stack_still_typed subtype "typed_rreduction.i"
    "below[S1`length]")))
 (stack_still_typed_TCC3 0
  (stack_still_typed_TCC3-1 nil 3702752010 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (stack_still_typed subtype "typed_rreduction.i"
    "below[S1`length]")))
 (stack_still_typed 0
  (stack_still_typed-1 nil 3702752011
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (inst?)
          (("2" (inst?)
            (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (is_well_typed_release_set_TCC1 0
  (is_well_typed_release_set_TCC1-1 nil 3703336707
   ("" (skeep* :preds? t)
    (("" (rewrite contextPure_release_set) nil nil)) nil)
   ((contextPure_release_set formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   nil
   (is_well_typed_release_set subtype
    "preprocess.release_set(typed_rreduction.A, typed_rreduction.X)"
    "(IL.contextPure?)")))
 (is_well_typed_release_set_TCC2 0
  (is_well_typed_release_set_TCC2-1 nil 3703336707
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite popDepth_release_set) nil nil)
       ("2" (skeep)
        (("2" (rewrite cvars_release_set)
          (("2" (expand* union member)
            (("2" (split)
              (("1" (grind) nil nil)
               ("2" (expand bumpn)
                (("2" (flatten)
                  (("2" (inst -7 "i-popDepth(A)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popDepth_release_set formula-decl nil preprocess nil)
    (cvars_release_set formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (popDepth def-decl "nat" IL nil)
    (A skolem-const-decl "(contextPure?)" typed_rreduction nil)
    (X skolem-const-decl "finite_set[nat]" typed_rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   nil
   (is_well_typed_release_set subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(preprocess.release_set(typed_rreduction.A, typed_rreduction.X)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(preprocess.release_set(typed_rreduction.A, typed_rreduction.X))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_release_set 0
  (is_well_typed_release_set-1 nil 3703336707
   ("" (induct X :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand nonempty?)
        (("2" (expand release_set +)
          (("2" (assert)
            (("2" (inst? -5)
              (("1" (split -5)
                (("1" (replace -1)
                  (("1" (expand is_well_typed + 1)
                    (("1" (propax) nil nil)) nil))
                  nil)
                 ("2" (expand popDepth +)
                  (("2" (skeep :preds? t)
                    (("2" (inst -6 x) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand popDepth +)
                (("2" (expand cvars 1)
                  (("2" (skeep)
                    (("2" (expand add)
                      (("2" (expand member)
                        (("2" (split -1)
                          (("1" (inst -6 "choose(X_1)")
                            (("1" (grind) nil nil)) nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep* :preds? t)
        (("3" (split)
          (("1" (rewrite popDepth_release_set) nil nil)
           ("2" (rewrite cvars_release_set)
            (("2" (expand* union member)
              (("2" (skeep)
                (("2" (split)
                  (("1" (grind) nil nil)
                   ("2" (expand bumpn)
                    (("2" (flatten)
                      (("2" (inst -7 "i-popDepth(A)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (skeep* :preds? t)
        (("4" (rewrite contextPure_release_set) nil nil)) nil))
      nil))
    nil)
   ((contextPure_release_set formula-decl nil preprocess nil)
    (popDepth_release_set formula-decl nil preprocess nil)
    (union const-decl "set" sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_release_set formula-decl nil preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (choose const-decl "(p)" sets nil) nil
    (TRUE const-decl "bool" booleans nil) nil nil
    (remove const-decl "set" sets nil) nil
    (add const-decl "(nonempty?)" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (release_set def-decl "IExpression" preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (is_well_typed_mark_TCC1 0
  (is_well_typed_mark_TCC1-1 nil 3702755599
   ("" (skeep* :preds? t) (("" (rewrite contextPure_mark) nil nil))
    nil)
   ((contextPure_mark formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   nil
   (is_well_typed_mark subtype
    "preprocess.mark(typed_rreduction.X)(typed_rreduction.A)"
    "(IL.contextPure?)")))
 (is_well_typed_mark_TCC2 0
  (is_well_typed_mark_TCC2-1 nil 3702755599
   ("" (skeep* :preds? t)
    (("" (rewrite popDepth_mark)
      (("" (rewrite cvars_mark)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((popDepth_mark formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars_mark formula-decl nil preprocess nil))
   nil
   (is_well_typed_mark subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(preprocess.mark(typed_rreduction.X)(typed_rreduction.A)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(preprocess.mark(typed_rreduction.X)(typed_rreduction.A))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_mark 0
  (is_well_typed_mark-1 nil 3702755599
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand mark +)
        (("4" (expand is_well_typed +)
          (("4"
            (case "application1_var < def_types`length AND
        tA = leaft(def_types`seq(application1_var)`return_type) AND
         length(application2_var) =
          def_types`seq(application1_var)`args_type`length")
            (("1" (flatten)
              (("1" (assert)
                (("1" (typepred "markvars(X)(application2_var)")
                  (("1" (rewrite -1)
                    (("1" (rewrite -1)
                      (("1" (assert)
                        (("1"
                          (case-replace
                           "forall (i: below(length(application2_var))):
         is_well_typed(nth(application2_var, i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)
       =
         is_well_typed(nth(markvars(X)(application2_var), i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)")
                          (("1" (iff)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (skeep :preds? t)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (skeep* :preds? t)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (inst?)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete 2)
                            (("2" (skeep :preds? t)
                              (("2"
                                (case
                                 "variable?(nth(application2_var, i))")
                                (("1"
                                  (case
                                   "variable?(nth(markvars(X)(application2_var), i))")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1"
                                        (rewrite markvars_index +)
                                        nil
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (delete 2)
                            (("3" (skeep :preds? t)
                              (("3"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep :preds? t)
                                  (("2"
                                    (case
                                     "cvars(application(application1_var, application2_var))(i_1)")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (expand cvars)
                                      (("2"
                                        (expand vars)
                                        (("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 i)
                                              (("2"
                                                (case
                                                 "variable?(nth[(variable?)](markvars(X)(application2_var), i))")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand singleton)
                                                    (("1"
                                                      (rewrite
                                                       markvars_index)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4" (delete 2)
                            (("4" (skeep) (("4" (grind) nil nil)) nil))
                            nil)
                           ("5" (delete 2)
                            (("5" (skeep)
                              (("5"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (inst -6 i_1)
                                    (("2"
                                      (split -6)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (expand cvars)
                                        (("2"
                                          (expand vars)
                                          (("2"
                                            (expand in_varlist)
                                            (("2"
                                              (rewrite some_nth)
                                              (("2"
                                                (inst 1 i)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("6" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "markvars(X)(application2_var)")
              (("2" (replace -2) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand mark +)
        (("5" (expand is_well_typed +)
          (("5" (case "lett?(tA)")
            (("1" (assert)
              (("1" (inst? -5)
                (("1" (split -5)
                  (("1" (assert)
                    (("1" (replace -1)
                      (("1" (rewrite popDepth_mark)
                        (("1"
                          (case "is_well_typed(mark(union(drop(vars(letexpr2_var)), X))
                          (letexpr1_var),
                      lrhs(tA), stypes, dom_types, def_types)
         AND
         expr_type(lrhs(tA)) = lettype(tA)")
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (lift-if)
                                (("1"
                                  (expand is_well_typed + 4)
                                  (("1"
                                    (inst
                                     -8
                                     "lbody(tA)"
                                     "add(lettype(tA), popn(stypes, popDepth(letexpr1_var)))"
                                     dom_types
                                     def_types
                                     "bump(X)")
                                    (("1"
                                      (split -8)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (use pure_contextPure)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (grind) nil nil)
                     ("2" (skeep)
                      (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand mark +)
        (("6" (expand is_well_typed +)
          (("6" (case "iftt?(tA)")
            (("1" (assert)
              (("1"
                (case "expr_type(tthen(tA)) = expr_type(telse(tA))")
                (("1" (assert)
                  (("1" (expand mark -7)
                    (("1" (inst? -7)
                      (("1" (split -7)
                        (("1" (replace -1 :dir RL)
                          (("1"
                            (case "is_well_typed(ift1_var, leaft(0), stypes, dom_types, def_types)")
                            (("1" (assert)
                              (("1"
                                (rewrite is_well_typed_release_set)
                                (("1"
                                  (rewrite is_well_typed_release_set)
                                  (("1"
                                    (inst? -9)
                                    (("1"
                                      (inst? -10)
                                      (("1"
                                        (split -9)
                                        (("1"
                                          (split -10)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (use pure_contextPure)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use pure_contextPure)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (delete 2)
                                        (("2"
                                          (rewrite cvars_pure)
                                          (("1"
                                            (split)
                                            (("1"
                                              (rewrite purePopDepth)
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (inst?)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (rewrite purePopDepth)
                                      (("1"
                                        (rewrite cvars_pure)
                                        (("1"
                                          (split)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (inst?)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (skeep :preds? t)
                                    (("2"
                                      (rewrite popDepth_mark)
                                      (("2"
                                        (rewrite purePopDepth)
                                        (("1"
                                          (inst?)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (rewrite popDepth_mark)
                                    (("3"
                                      (split)
                                      (("1"
                                        (rewrite purePopDepth)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (rewrite cvars_mark)
                                        (("2"
                                          (rewrite cvars_pure)
                                          (("1"
                                            (skeep)
                                            (("1"
                                              (inst?)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (rewrite contextPure_mark)
                                    (("4"
                                      (use pure_contextPure)
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skeep :preds? t)
                                  (("2"
                                    (rewrite popDepth_mark)
                                    (("2"
                                      (rewrite purePopDepth)
                                      (("1"
                                        (inst?)
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (rewrite popDepth_mark)
                                  (("3"
                                    (rewrite purePopDepth)
                                    (("1"
                                      (rewrite cvars_mark)
                                      (("1"
                                        (rewrite cvars_pure)
                                        (("1"
                                          (split)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (inst?)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (rewrite contextPure_mark)
                                  (("4"
                                    (use pure_contextPure)
                                    (("4" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (split)
                          (("1" (grind) nil nil)
                           ("2" (skeep)
                            (("2" (inst -5 i) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand mark +)
        (("7" (expand is_well_typed +) (("7" (grind) nil nil)) nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand mark +)
        (("11" (expand is_well_typed +)
          (("11" (case "popt?(tA)")
            (("1" (assert)
              (("1" (inst?) (("1" (inst?) (("1" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand mark +)
        (("13" (expand is_well_typed +)
          (("13" (inst? -6)
            (("13" (split)
              (("1" (propax) nil nil)
               ("2" (use pure_contextPure) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (rewrite popDepth_mark)
          (("14" (split)
            (("1" (propax) nil nil)
             ("2" (skeep)
              (("2" (rewrite cvars_mark) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (delete 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite contextPure_mark) nil nil)) nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (emptyset const-decl "set" sets nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    nil
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil (cvars_pure formula-decl nil preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (purePopDepth formula-decl nil IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (empty? const-decl "bool" sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (cvars_mark formula-decl nil preprocess nil)
    (contextPure_mark formula-decl nil preprocess nil)
    (is_well_typed_release_set formula-decl nil typed_rreduction nil)
    (difference const-decl "set" sets nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (popDepth_mark formula-decl nil preprocess nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (union const-decl "set" sets nil)
    (drop const-decl "finite_set[nat]" IL nil) nil nil
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    nil
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (markvars_index formula-decl nil preprocess nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (in_varlist const-decl "finite_set[nat]" IL nil) nil nil nil nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (markv const-decl "(variable?)" preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (singleton const-decl "(singleton?)" sets nil) nil
    (injective? const-decl "bool" functions nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil))
   shostak))
 (is_well_typed_unmark_TCC1 0
  (is_well_typed_unmark_TCC1-1 nil 3702755599
   ("" (skeep*) (("" (rewrite unmark_contextPure) nil nil)) nil)
   ((unmark_contextPure recursive-judgement-axiom nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil))
   nil
   (is_well_typed_unmark subtype
    "preprocess.unmark(typed_rreduction.A)" "(IL.contextPure?)")))
 (is_well_typed_unmark_TCC2 0
  (is_well_typed_unmark_TCC2-1 nil 3702755599
   ("" (skeep* :preds? t)
    (("" (rewrite unmark_popDepth)
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep)
          (("2" (lemma unmark_cvars)
            (("2" (inst -1 A i) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((unmark_popDepth formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (unmark_cvars formula-decl nil preprocess nil))
   nil
   (is_well_typed_unmark subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(preprocess.unmark(typed_rreduction.A)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(preprocess.unmark(typed_rreduction.A))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (is_well_typed_unmark 0
  (is_well_typed_unmark-1 nil 3702758947
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand unmark +)
        (("4" (expand is_well_typed +)
          (("4" (typepred "unmarkvars(application2_var)")
            (("4" (replace -2)
              (("4"
                (case "application1_var < def_types`length AND
         tA = leaft(def_types`seq(application1_var)`return_type) AND
          length(application2_var) =
           def_types`seq(application1_var)`args_type`length")
                (("1" (flatten)
                  (("1" (assert)
                    (("1"
                      (case "forall (i: below(length(application2_var))):
         is_well_typed(nth(application2_var, i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)
       =
         is_well_typed(nth(unmarkvars(application2_var), i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)")
                      (("1" (hide-all-but (1 -1))
                        (("1" (iff)
                          (("1" (split)
                            (("1" (flatten)
                              (("1"
                                (skeep)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (inst?)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (skeep)
                                (("2"
                                  (inst?)
                                  (("2"
                                    (inst?)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (skeep)
                          (("2" (rewrite unmarkvars_nth)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("3" (delete 2)
                        (("3" (skeep* :preds? t)
                          (("3" (rewrite unmarkvars_nth)
                            (("3" (rewrite unmark_unmarkvar :dir RL)
                              (("3"
                                (rewrite unmark_popDepth)
                                (("3"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (lemma unmark_cvars)
                                      (("2"
                                        (inst
                                         -1
                                         "nth(application2_var, i)"
                                         i_1)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst -10 i_1)
                                            (("2"
                                              (expand cvars -10)
                                              (("2"
                                                (expand vars)
                                                (("2"
                                                  (expand in_varlist)
                                                  (("2"
                                                    (rewrite some_nth)
                                                    (("2"
                                                      (inst?)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete 2) (("4" (grind) nil nil)) nil)
                       ("5" (delete 2)
                        (("5" (skeep)
                          (("5" (split)
                            (("1" (grind) nil nil)
                             ("2" (skeep)
                              (("2"
                                (inst -8 "i_1")
                                (("2"
                                  (split -8)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (expand cvars +)
                                    (("2"
                                      (expand vars)
                                      (("2"
                                        (expand in_varlist)
                                        (("2"
                                          (rewrite some_nth)
                                          (("2"
                                            (inst?)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("6" (delete 2) (("6" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand unmark +)
        (("5" (expand is_well_typed +)
          (("5" (case "lett?(tA)")
            (("1" (assert)
              (("1" (rewrite unmark_popDepth)
                (("1" (inst? -4)
                  (("1" (inst? -5)
                    (("1" (split -5)
                      (("1" (grind) nil nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (delete 2)
                      (("2" (split)
                        (("1" (rewrite purePopDepth)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (skeep)
                          (("2" (rewrite cvars_pure)
                            (("1"
                              (inst -4 "i-1+popDepth(letexpr1_var)")
                              (("1"
                                (split -4)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (grind) nil nil)
                       ("2" (skeep) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand unmark +)
        (("6" (expand is_well_typed +)
          (("6" (case "iftt?(tA)")
            (("1" (assert)
              (("1" (rewrite unmark_unmarkvar)
                (("1" (inst? -5)
                  (("1" (inst? -6)
                    (("1" (inst? -7)
                      (("1" (split -6)
                        (("1" (split -7)
                          (("1" (grind) nil nil)
                           ("2" (use pure_contextPure)
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("2" (use pure_contextPure)
                          (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (rewrite purePopDepth)
                          (("1" (split)
                            (("1" (grind) nil nil)
                             ("2" (skeep)
                              (("2"
                                (rewrite cvars_pure)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete 2)
                      (("2" (rewrite purePopDepth)
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (rewrite cvars_pure)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand unmark +)
        (("7" (expand is_well_typed +)
          (("7" (rewrite unmark_unmarkvar)
            (("7" (rewrite unmark_unmarkvar)
              (("7" (rewrite unmark_unmarkvar) (("7" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand unmark +)
        (("8" (rewrite unmark_unmarkvar)
          (("8" (rewrite unmark_unmarkvar) (("8" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (rewrite unmark_popDepth)
          (("14" (split)
            (("1" (propax) nil nil)
             ("2" (skeep)
              (("2" (lemma unmark_cvars)
                (("2" (inst -1 A i) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (delete 2)
      (("15" (skeep*) (("15" (use unmark_contextPure) nil nil)) nil))
      nil))
    nil)
   (nil
    (unmark_contextPure recursive-judgement-axiom nil preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (emptyset const-decl "set" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    nil nil nil
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    nil
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    nil nil
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_pure formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (pure_contextPure formula-decl nil IL nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil) nil
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (in_varlist const-decl "finite_set[nat]" IL nil) nil
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (unmarkvars_nth formula-decl nil preprocess nil)
    (unmark_unmarkvar formula-decl nil preprocess nil)
    (unmark_cvars formula-decl nil preprocess nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (unmark_popDepth formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (length def-decl "nat" list_props nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    nil (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil))
   shostak))
 (decref_new_values_TCC1 0
  (decref_new_values_TCC1-1 nil 3702831701
   ("" (skeep* :preds? t)
    (("" (typepred "decref(rS, r, i)")
      (("" (inst?) (("" (bash) nil nil)) nil)) nil))
    nil)
   ((decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref_new_values subtype "typed_rreduction.j"
    "below[decref(rS, r, i)`store(s)`length]")))
 (decref_new_values_TCC2 0
  (decref_new_values_TCC2-1 nil 3702831701 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (decref_new_values subtype "typed_rreduction.s"
    "(rreduction.decref(typed_rreduction.rS, typed_rreduction.r, typed_rreduction.i)`domain)")))
 (decref_new_values 0
  (decref_new_values-2 "" 3724087724
   ("" (skeep* :preds? t)
    (("" (lemma decref_induction)
      ((""
        (inst -1 "LAMBDA (rS2: rstate): rS2`domain = rS`domain AND
rS2`store(s)`length = rS`store(s)`length AND (rS2`store(s)`seq(j) =
rS`store(s)`seq(j) OR (ref?(rS`store(s)`seq(j)) AND rS2`store(s)`seq(j)
= nil))")
        (("1" (assert)
          (("1" (split -1)
            (("1" (inst -1 rS r i) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil) ("3" (grind) nil nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (grind) nil nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    nil nil (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil) nil
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (decref_induction formula-decl nil reduction_props nil))
   shostak)
  (decref_new_values-1 nil 3702831702
   ("" (skeep* :preds? t)
    (("" (lemma decref_induction)
      ((""
        (inst -1
         "LAMBDA (rS2: rstate): rS2`domain(s) AND j < rS2`store(s)`length IMPLIES rS2`store(s)`seq(j) = rS`store(s)`seq(j) OR (ref?(rS`store(s)`seq(j)) AND rS2`store(s)`seq(j) = nil)")
        (("" (split -1)
          (("1" (inst?)
            (("1" (split -1)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (typepred "decref(rS, r, i)")
                (("3" (replace -2) (("3" (propax) nil nil)) nil)) nil)
               ("4" (typepred "decref(rS, r, i)")
                (("4" (inst?)
                  (("4" (flatten)
                    (("4" (replace -3) (("4" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (rS2 r2 i2))
            (("2" (flatten)
              (("2" (simplify)
                (("2" (split -1)
                  (("1" (case-replace "r2 = s")
                    (("1" (case-replace "i2 = j")
                      (("1" (simplify) (("1" (grind) nil nil)) nil)
                       ("2" (simplify)
                        (("2" (lift-if) (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (lift-if) (("2" (assert) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (case-replace "r2 = s")
                      (("1" (case-replace "i2 = j")
                        (("1" (assert) nil nil)
                         ("2" (simplify)
                          (("2" (lift-if) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (simplify)
                        (("2" (lift-if) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("3" (propax) nil nil)
                   ("4" (lift-if -)
                    (("4" (simplify) (("4" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((decref_induction formula-decl nil reduction_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateReduce_new_stack_TCC1 0
  (updateReduce_new_stack_TCC1-1 nil 3702833125
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_stack subtype "typed_rreduction.rS"
    "{grS | booleans.AND(IL.updateRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (updateReduce_new_stack_TCC2 0
  (updateReduce_new_stack_TCC2-1 nil 3702833125
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce_new_stack subtype "typed_rreduction.i"
    "below[updateReduce(D)(rS)`stack`length]")))
 (updateReduce_new_stack 0
  (updateReduce_new_stack-3 "" 3706540538
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "updateReduce(D)(rS)`stack`length = rS`stack`length")
      (("1" (hide -1)
        (("1" (skeep :preds? t)
          (("1"
            (case "updateReduce(D)(rS)`stack`seq(i) = rS`stack`seq(i) OR (ref?(rS`stack`seq(i)) AND updateReduce(D)(rS)`stack`seq(i) = nil)")
            (("1" (prop) nil nil)
             ("2" (delete 3 4)
              (("2" (expand updateReduce :assert? none)
                (("2" (expand decref1_chk)
                  (("2" (simplify :let-reduce? t)
                    (("2" (lift-if)
                      (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand updateReduce :assert? none)
          (("2" (expand decref1_chk)
            (("2" (simplify :let-reduce? t)
              (("2" (lift-if)
                (("2" (expand maybe_clear_stack_at)
                  (("2" (assert)
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    nil (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil) nil
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (updateReduce_new_stack-2 "" 3702917238
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "updateReduce(D)(rS)`stack`length = rS`stack`length")
      (("1" (hide -1)
        (("1" (skeep :preds? t)
          (("1"
            (case "updateReduce(D)(rS)`stack`seq(i) = rS`stack`seq(i) OR (ref?(rS`stack`seq(i)) AND updateReduce(D)(rS)`stack`seq(i) = nil)")
            (("1" (prop) nil nil)
             ("2" (delete 3 4)
              (("2" (expand updateReduce :assert? none)
                (("2" (expand decref)
                  (("2" (simplify :let-reduce? t)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand updateReduce :assert? none)
          (("2" (expand decref)
            (("2" (simplify :let-reduce? t)
              (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil))
   shostak)
  (updateReduce_new_stack-1 nil 3702833126
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "updateReduce(D)(rS)`stack`length = rS`stack`length")
      (("1" (hide -1)
        (("1" (skeep :preds? t)
          (("1"
            (case "updateReduce(D)(rS)`stack`seq(i) = rS`stack`seq(i) OR (ref?(rS`stack`seq(i)) AND updateReduce(D)(rS)`stack`seq(i) = nil)")
            (("1" (prop) nil nil)
             ("2" (delete 3 4)
              (("2" (expand updateReduce :assert? none)
                (("2" (expand decref)
                  (("2" (simplify :let-reduce? t)
                    (("2" (lift-if)
                      (("2" (split +)
                        (("1" (flatten)
                          (("1" (split +)
                            (("1" (flatten)
                              (("1"
                                (split +)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (lift-if +)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split +)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (split +)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (split +)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (lift-if +)
                                                          (("1"
                                                            (split +)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (split
                                                                 +)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (lift-if
                                                                         +)
                                                                        (("2"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (split +)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (lift-if
                                                                 +)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (lift-if
                                                               +)
                                                              (("2"
                                                                (split
                                                                 +)
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (split
                                                                         +)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split +)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (lift-if +)
                                                  (("1"
                                                    (split +)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (split +)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (split +)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (lift-if
                                                                       +)
                                                                      (("1"
                                                                        (split
                                                                         +)
                                                                        (("1"
                                                                          (propax)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (split
                                                                             +)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (split
                                                                                 +)
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split +)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (lift-if
                                                                           +)
                                                                          (("1"
                                                                            (split
                                                                             +)
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (split
                                                                                 +)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (split +)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (split +)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (lift-if
                                                                 +)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (split
                                                                               +)
                                                                              (("1"
                                                                                (flatten)
                                                                                (("1"
                                                                                  (lift-if
                                                                                   +)
                                                                                  (("1"
                                                                                    (split
                                                                                     +)
                                                                                    (("1"
                                                                                      (propax)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (split
                                                                                         +)
                                                                                        (("1"
                                                                                          (flatten)
                                                                                          (("1"
                                                                                            (split
                                                                                             +)
                                                                                            (("1"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (propax)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (lift-if
                                                                                 +)
                                                                                (("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (split
                                                                                     +)
                                                                                    (("1"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              (("2"
                                                                (lift-if
                                                                 +)
                                                                (("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (split
                                                                         +)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (flatten)
                                                            (("2"
                                                              (split +)
                                                              (("1"
                                                                (lift-if
                                                                 +)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (flatten)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                (("2"
                                                                  (lift-if
                                                                   +)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lift-if +)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (split +)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (split +)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (lift-if +)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand updateReduce)
          (("2" (simplify)
            (("2" (assert)
              (("2" (expand decref)
                (("2" (lift-if +)
                  (("2" (assert)
                    (("2" (split +)
                      (("1" (flatten)
                        (("1" (split +)
                          (("1" (flatten)
                            (("1" (split +)
                              (("1"
                                (flatten)
                                (("1"
                                  (lift-if +)
                                  (("1"
                                    (split +)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split +)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (split +)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (rewrite
                                                 decref1_preserves_stack)
                                                (("1"
                                                  (simplify)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (rewrite
                                               decref1_preserves_stack)
                                              (("2"
                                                (simplify)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (lift-if +)
                                  (("2"
                                    (split +)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split +)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (split +)
                                            (("1"
                                              (rewrite
                                               decref1_preserves_stack)
                                              (("1"
                                                (simplify)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (rewrite
                                               decref1_preserves_stack)
                                              (("2"
                                                (simplify)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (lift-if +)
                              (("2"
                                (split +)
                                (("1"
                                  (split +)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (split +)
                                          (("1" (flatten) nil nil)
                                           ("2"
                                            (rewrite
                                             decref1_preserves_stack)
                                            (("2"
                                              (simplify)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (split +)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (split +)
                                              (("1" (flatten) nil nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (rewrite
                                                   decref1_preserves_stack)
                                                  (("2"
                                                    (simplify)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite
                                             decref1_preserves_stack)
                                            (("2"
                                              (simplify)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil))
   shostak))
 (decref1_preserves_domain 0
  (decref1_preserves_domain-1 nil 3703255356
   ("" (skeep* :preds? t)
    (("" (typepred "decref1(rS, r, i)") (("" (propax) nil nil)) nil))
    nil)
   ((decref1 def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref1_preserves_store_length_TCC1 0
  (decref1_preserves_store_length_TCC1-1 nil 3702993949
   ("" (subtype-tcc) nil nil)
   ((decref1_preserves_domain formula-decl nil typed_rreduction nil))
   nil
   (decref1_preserves_store_length subtype "typed_rreduction.s"
    "(rreduction.decref1(typed_rreduction.rS, typed_rreduction.r, typed_rreduction.i)`domain)")))
 (decref1_preserves_store_length 0
  (decref1_preserves_store_length-1 nil 3703255372
   ("" (skeep* :preds? t)
    (("" (lemma decref1_induction)
      ((""
        (inst -1
         "LAMBDA (rS2: rstate): rS2`domain(s) AND rS2`store(s)`length = rS`store(s)`length")
        (("" (split)
          (("1" (inst?) (("1" (prop) nil nil)) nil)
           ("2" (skeep* :preds? t)
            (("2" (simplify) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((decref1_induction formula-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (value_maybe_freed_type 0
  (value_maybe_freed_type-1 nil 3703261830 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil))
   shostak))
 (decref1_preserves_store_TCC1 0
  (decref1_preserves_store_TCC1-1 nil 3702993949
   ("" (subtype-tcc) nil nil)
   ((value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil))
   nil
   (decref1_preserves_store subtype "typed_rreduction.j"
    "below[decref1(rS, r, i)`store(s)`length]")))
 (decref1_preserves_store 0
  (decref1_preserves_store-1 nil 3703010923
   ("" (skeep* :preds? t)
    (("" (use decref1_induction)
      ((""
        (inst -1
         "LAMBDA (rS2: rstate): rS2`domain(s) AND j < rS2`store(s)`length AND value_maybe_freed(u, rS2`store(s)`seq(j))")
        (("" (split -1)
          (("1" (inst?) (("1" (prop) nil nil)) nil)
           ("2" (skeep :preds? t)
            (("2" (simplify) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((decref1_induction formula-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref1_preserves_store2_TCC1 0
  (decref1_preserves_store2_TCC1-1 nil 3703253343
   ("" (subtype-tcc) nil nil)
   ((value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil))
   nil
   (decref1_preserves_store2 subtype "typed_rreduction.j"
    "below[decref1(rS, r, i)`store(s)`length]")))
 (decref1_preserves_store2 0
  (decref1_preserves_store2-1 nil 3703255673
   ("" (skeep* :preds? t)
    (("" (expand value_maybe_freed2)
      (("" (split) (("1" (assert) nil nil) ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (decref1_preserves_store formula-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (releaseReduce_new_store_TCC1 0
  (releaseReduce_new_store_TCC1-1 nil 3703269542
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (releaseReduce_new_store subtype "typed_rreduction.rS"
    "{grS | booleans.AND(IL.pureReleaseRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (releaseReduce_new_store_TCC2 0
  (releaseReduce_new_store_TCC2-1 nil 3703269542
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (releaseReduce_new_store subtype "typed_rreduction.j"
    "below[rS`store(r)`length]")))
 (releaseReduce_new_store 0
  (releaseReduce_new_store-1 nil 3703269543
   ("" (skeep* :preds? t)
    (("" (case "rS`domain(r)")
      (("1" (assert)
        (("1"
          (case "releaseReduce(D)(rS)`store(r)`length = rS`store(r)`length")
          (("1" (assert)
            (("1" (skeep :preds? t)
              (("1" (replace -2)
                (("1" (hide -2 -4)
                  (("1" (expand releaseReduce)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (expand decref)
                            (("1" (assert)
                              (("1"
                                (name-replace u "rS`store(r)`seq(j)")
                                (("1"
                                  (assert)
                                  (("1"
                                    (case
                                     "value_maybe_freed(u, rS`store(r)`seq(j))")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (expand u)
                                      (("2"
                                        (expand value_maybe_freed)
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (delete 3)
            (("2" (hide -2)
              (("2" (expand releaseReduce)
                (("2" (expand decref)
                  (("2" (lift-if)
                    (("2" (split)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand releaseReduce)
          (("2" (expand decref)
            (("2" (split)
              (("1" (flatten) (("1" (assert) nil nil)) nil)
               ("2" (flatten) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil (decref1_preserves_store formula-decl nil typed_rreduction nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil)
    (releaseReduce_ndr application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (decref1_preserves_domain formula-decl nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateReduce_new_store_TCC1 0
  (updateReduce_new_store_TCC1-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_store subtype "typed_rreduction.rS`redex"
    "(IExpression_adt.update?)")))
 (updateReduce_new_store_TCC2 0
  (updateReduce_new_store_TCC8-1 nil 3705932019
   ("" (skeep* :preds? t)
    (("" (use updateRedex_target_index)
      (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((updateRedex_target_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_store subtype
    "IExpression_adt.target(typed_rreduction.rS`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_rreduction.rS`stack`length)}")))
 (updateReduce_new_store_TCC3 0
  (updateReduce_new_store_TCC3-1 nil 3702993203
   ("" (skeep* :preds? t)
    (("" (typepred "rS`stack")
      (("" (expand every)
        (("" (expand get)
          (("" (inst?)
            (("1" (expand domainValue?) (("1" (prop) nil nil)) nil)
             ("2" (use updateRedex_target_index)
              (("2" (prop) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rS skolem-const-decl "{rS: rstate |
   NOT rS`error AND noDanglingRefs?(rS) AND updateRedex?(rS`redex)}"
     typed_rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_store subtype
    "IExpression_adt.refindex(IL.get(typed_rreduction.rS`stack)(IExpression_adt.target(typed_rreduction.rS`redex)))"
    "(typed_rreduction.rS`domain)")))
 (updateReduce_new_store_TCC4 0
  (updateReduce_new_store_TCC4-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce_new_store subtype "typed_rreduction.j"
    "below[rS`store(refindex(get(rS`stack)(target(rS`redex))))`length]")))
 (updateReduce_new_store_TCC5 0
  (updateReduce_new_store_TCC5-1 nil 3706540664
   ("" (skeep* :preds? t)
    (("" (use updateRedex_rhs_index) (("" (grind) nil nil)) nil)) nil)
   ((updateRedex_rhs_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_store subtype
    "IExpression_adt.rhs(typed_rreduction.rS`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_rreduction.rS`stack`length)}")))
 (updateReduce_new_store_TCC6 0
  (updateReduce_new_store_TCC6-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce_new_store subtype "typed_rreduction.j"
    "below[rS`store(r)`length]")))
 (updateReduce_new_store_TCC7 0
  (updateReduce_new_store_TCC7-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce_new_store subtype "typed_rreduction.rS`redex"
    "(IExpression_adt.update?)")))
 (updateReduce_new_store_TCC8 0
  (updateReduce_new_store_TCC8-1 nil 3705932019
   ("" (skeep* :preds? t)
    (("" (use updateRedex_target_index)
      (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((updateRedex_target_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_store subtype
    "IExpression_adt.target(typed_rreduction.rS`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_rreduction.rS`stack`length)}")))
 (updateReduce_new_store_TCC9 0
  (updateReduce_new_store_TCC9-1 nil 3706555818
   ("" (skeep* :preds? t)
    (("" (use updateRedex_rhs_index) (("" (grind) nil nil)) nil)) nil)
   ((updateRedex_rhs_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_new_store subtype
    "IExpression_adt.rhs(typed_rreduction.rS`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_rreduction.rS`stack`length)}")))
 (updateReduce_new_store 0
  (updateReduce_new_store-6 "" 3706545186
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (split -)
                (("1" (flatten)
                  (("1" (split -)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (expand updateReduce)
                          (("1" (grind) nil nil)) nil)
                         ("2" (skeep :preds? t)
                          (("2" (expand updateReduce +)
                            (("2" (replace -2)
                              (("2"
                                (hide-all-but +)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten) (("2" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand update_store)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand decref1_chk)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand update_store)
                                              (("1"
                                                (assert)
                                                (("1" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF ref?(get(rS`stack)(target(rS`redex))) AND r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2)
                              (("1" (propax) nil nil)) nil)
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand vmf2)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand
                                               maybe_clear_stack_at)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand update_store)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (name-replace
                                                       "nstore"
                                                       "rS`store
                                                                                      WITH [(refindex
                                                                                             (get
                                                                                              (rS`stack)
                                                                                              (target(rS`redex))))
                                                                                            `seq
                                                                                            (value
                                                                                             (get
                                                                                              (rS`stack)
                                                                                              (lhs(rS`redex))))
                                                                                            := get
                                                                                               (rS`stack)
                                                                                               (rhs(rS`redex))]")
                                                      (("1"
                                                        (case
                                                         "j < nstore(r)`length")
                                                        (("1"
                                                          (case
                                                           "value_maybe_freed2(rS`store(r)`seq(j),
                                                        IF r = refindex(get(rS`stack)(target(rS`redex)))
                                                          THEN get(rS`stack)(rhs(rS`redex))
                                                        ELSE rS`store(r)`seq(j)
                                                        ENDIF, nstore(r)`seq(j))")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (name-replace
                                                               "v"
                                                               "IF r = refindex(get(rS`stack)(target(rS`redex)))
                                                       THEN get(rS`stack)(rhs(rS`redex))
                                                     ELSE rS`store(r)`seq(j)
                                                     ENDIF")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (expand
                                                                   decref1_chk)
                                                                  (("1"
                                                                    (lift-if)
                                                                    (("1"
                                                                      (split)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (split
                                                                             3)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (split
                                                                         3)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (split
                                                                               1)
                                                                              (("1"
                                                                                (flatten)
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (flatten)
                                                                                (("2"
                                                                                  (assert)
                                                                                  (("2"
                                                                                    (lift-if
                                                                                     2)
                                                                                    (("2"
                                                                                      (split
                                                                                       2)
                                                                                      (("1"
                                                                                        (flatten)
                                                                                        (("1"
                                                                                          (split)
                                                                                          (("1"
                                                                                            (flatten)
                                                                                            (("1"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil))
                                                                                            nil)
                                                                                           ("2"
                                                                                            (assert)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil)
                                                                                       ("2"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (expand
                                                                           nstore)
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (delete 2)
                                                            (("2"
                                                              (expand
                                                               nstore)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (typepred
                                                             "rS`stack")
                                                            (("2"
                                                              (expand
                                                               get)
                                                              (("2"
                                                                (expand
                                                                 every)
                                                                (("2"
                                                                  (inst
                                                                   -1
                                                                   "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                                  (("2"
                                                                    (expand
                                                                     decref1_chk)
                                                                    (("2"
                                                                      (lift-if
                                                                       3)
                                                                      (("2"
                                                                        (split
                                                                         3)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (lift-if
                                                                             1)
                                                                            (("1"
                                                                              (split
                                                                               1)
                                                                              (("1"
                                                                                (flatten)
                                                                                (("1"
                                                                                  (split
                                                                                   1)
                                                                                  (("1"
                                                                                    (flatten)
                                                                                    (("1"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil)
                                                                                   ("2"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (assert)
                                                                                (("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (assert)
                                                                            (("2"
                                                                              (lift-if
                                                                               2)
                                                                              (("2"
                                                                                (split
                                                                                 2)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  (("1"
                                                                                    (split
                                                                                     1)
                                                                                    (("1"
                                                                                      (flatten)
                                                                                      (("1"
                                                                                        (assert)
                                                                                        nil
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil)
                                                                                 ("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (typepred
                                                           "rS`stack")
                                                          (("2"
                                                            (expand
                                                             get)
                                                            (("2"
                                                              (expand
                                                               every)
                                                              (("2"
                                                                (inst
                                                                 -1
                                                                 "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep) nil nil) ("3" (skeep) nil nil)
                           ("4" (skeep) nil nil))
                          nil)
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("3" (expand updateRedex?)
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (get const-decl "(value?)" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decref1_preserves_domain formula-decl nil typed_rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (decref1_preserves_store2 formula-decl nil typed_rreduction nil)
    nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (updateRedex_target_index formula-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    nil (below type-eq-decl nil naturalnumbers nil)
    (member const-decl "bool" sets nil) nil
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (updateReduce_new_store-5 "" 3703257865
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF ref?(get(rS`stack)(target(rS`redex))) AND r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2)
                              (("1" (propax) nil nil)) nil)
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                                                WITH [(refindex
                                                                       (get
                                                                        (rS`stack)
                                                                        (target(rS`redex))))
                                                                      `seq
                                                                      (value
                                                                       (get
                                                                        (rS`stack)
                                                                        (lhs(rS`redex))))
                                                                      := get
                                                                         (rS`stack)
                                                                         (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j),
                         IF r = refindex(get(rS`stack)(target(rS`redex)))
                           THEN get(rS`stack)(rhs(rS`redex))
                         ELSE rS`store(r)`seq(j)
                         ENDIF, nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (name-replace
                                                             "v"
                                                             "IF r = refindex(get(rS`stack)(target(rS`redex)))
                           THEN get(rS`stack)(rhs(rS`redex))
                         ELSE rS`store(r)`seq(j)
                         ENDIF")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep) nil nil) ("3" (skeep) nil nil)
                           ("4" (skeep) nil nil))
                          nil)
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("3" (expand updateRedex?)
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (get const-decl "(value?)" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (member const-decl "bool" sets nil))
   nil)
  (updateReduce_new_store-4 "" 3703257560
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil)))))
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil)))))))))))))
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil)))
                           ("2" (propax) nil)))))))))
                   ("2" (propax) nil)))))))))))))
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil)))))
                           ("2" (propax) nil)))))))))))
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF ref?(get(rS`stack))(target(rS`redex)) AND r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2) (("1" (propax) nil)))
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil)))))
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                                                WITH [(refindex
                                                                       (get
                                                                        (rS`stack)
                                                                        (target(rS`redex))))
                                                                      `seq
                                                                      (value
                                                                       (get
                                                                        (rS`stack)
                                                                        (lhs(rS`redex))))
                                                                      := get
                                                                         (rS`stack)
                                                                         (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil)))))
                                                         ("3"
                                                          (propax)
                                                          nil)))
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil)))))))
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil)))))))))))))))))))
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2"
                                                (grind)
                                                nil)))))))))))))
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil)))))))))))))))
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1" (assert) (("1" (grind) nil)))
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil)))))))))))
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil)
                           ("2" (propax) nil)))))))))))))))
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil))))))))))))))))
    nil)
   nil nil)
  (updateReduce_new_store-3 "" 3703257039
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil)))))
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil)))))))))))))
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil)))
                           ("2" (propax) nil)))))))))
                   ("2" (propax) nil)))))))))))))
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil)))))
                           ("2" (propax) nil)))))))))))
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2) (("1" (propax) nil)))
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil)))))
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                                                WITH [(refindex
                                                                       (get
                                                                        (rS`stack)
                                                                        (target(rS`redex))))
                                                                      `seq
                                                                      (value
                                                                       (get
                                                                        (rS`stack)
                                                                        (lhs(rS`redex))))
                                                                      := get
                                                                         (rS`stack)
                                                                         (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil)))))
                                                         ("3"
                                                          (propax)
                                                          nil)))
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil)))))))
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil)))))))))))))))))))
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2"
                                                (grind)
                                                nil)))))))))))))
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil)))))))))))))))
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1" (assert) (("1" (grind) nil)))
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil)))))))))))
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil)
                           ("2" (propax) nil)))))))))))))))
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil))))))))))))))))
    nil)
   nil nil)
  (updateReduce_new_store-2 "" 3703005669
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2)
                              (("1" (propax) nil nil)) nil)
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                            WITH [(refindex
                                                   (get
                                                    (rS`stack)
                                                    (target(rS`redex))))
                                                  `seq
                                                  (value
                                                   (get
                                                    (rS`stack)
                                                    (lhs(rS`redex))))
                                                  := get
                                                     (rS`stack)
                                                     (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (member const-decl "bool" sets nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak)
  (updateReduce_new_store-1 nil 3702993204
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce)
                              (("2"
                                (expand decref)
                                (("2"
                                  (split)
                                  (("1"
                                    (replace -2)
                                    (("1"
                                      (lift-if +)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -2)
                                    (("2"
                                      (lift-if)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten) (("1" (postpone) nil nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (flatten)
                        (("1" (expand add)
                          (("1" (expand member)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (expand decref)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (updateReduce_redex_TCC1 0
  (updateReduce_redex_TCC1-1 nil 3702925500 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (updateReduce_redex subtype "typed_rreduction.rS`redex"
    "(IExpression_adt.update?)")))
 (updateReduce_redex_TCC2 0
  (updateReduce_redex_TCC2-1 nil 3702925500
   ("" (skeep* :preds? t)
    (("" (use updateRedex_target_index) (("" (prop) nil nil)) nil))
    nil)
   ((updateRedex_target_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (updateReduce_redex subtype
    "IExpression_adt.target(typed_rreduction.rS`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_rreduction.rS`stack`length)}")))
 (updateReduce_redex 0
  (updateReduce_redex-2 "" 3706552349
   ("" (skeep* :preds? t)
    ((""
      (case "updateReduce(D)(rS)`redex = ref(least_out(rS`domain)) OR updateReduce(D)(rS)`redex = get(rS`stack)(target(rS`redex)) OR updateReduce(D)(rS)`redex = rS`redex")
      (("1" (split)
        (("1" (propax) nil nil) ("2" (propax) nil nil)
         ("3" (propax) nil nil))
        nil)
       ("2" (delete 3 4 5)
        (("2" (expand updateReduce)
          (("2" (expand decref1_chk)
            (("2" (lift-if)
              (("2" (assert)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (propax) nil nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (< const-decl "bool" reals nil) nil
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (updateReduce_redex-1 nil 3702925501
   ("" (skeep* :preds? t)
    ((""
      (case "updateReduce(D)(rS)`redex = ref(least_out(rS`domain)) OR updateReduce(D)(rS)`redex = get(rS`stack)(target(rS`redex)) OR updateReduce(D)(rS)`redex = rS`redex")
      (("1" (split)
        (("1" (propax) nil nil) ("2" (propax) nil nil)
         ("3" (propax) nil nil))
        nil)
       ("2" (delete 3 4 5)
        (("2" (expand updateReduce)
          (("2" (expand decref) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil))
   shostak))
 (updateReduce_context 0
  (updateReduce_context-1 nil 3702929446
   ("" (skeep* :preds? t)
    (("" (expand updateReduce)
      (("" (expand decref1_chk)
        (("" (lift-if)
          (("" (split)
            (("1" (flatten)
              (("1" (split)
                (("1" (propax) nil nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (assert) nil nil) ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_reduce_TCC1 0
  (typed_reduce_TCC1-1 nil 3702747756
   ("" (subtype-tcc) (("" (postpone) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.t"
    "{tS | booleans.AND(typed_rreduction.tS`state`context = IL.hole, )}")))
 (typed_reduce_TCC2 0
  (typed_reduce_TCC2-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IExpression_adt.variable?(rreduction.grS`redex)}")))
 (typed_reduce_TCC3 0
  (typed_reduce_TCC3-1 nil 3705930673
   ("" (skeep* :preds? t)
    (("" (use variableReduce_ndr)
      (("1" (use variableReduce_arm)
        (("1" (split)
          (("1" (grind) nil nil) ("2" (propax) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil))
          nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (assert)
              (("2" (skeep)
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (split)
        (("1"
          (expand* make_redex_typed make_redex typed_to_topstate
           to_topstate)
          (("1" (assert)
            (("1" (replace*) (("1" (assert) nil nil)) nil)) nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((variableReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (variableReduce_arm formula-decl nil reduction_props nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC4 0
  (typed_reduce_TCC4-1 nil 3705930673
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC5 0
  (typed_reduce_TCC5-1 nil 3705930673
   ("" (skeep* :preds? t)
    (("" (lemma stack_still_typed)
      ((""
        (inst -1 "nS`dom_types" "nS`stack_types" "nS`state`stack"
         "variableReduce(D)(nS`state)`stack")
        (("1" (split)
          (("1" (propax) nil nil) ("2" (assert) nil nil)
           ("3" (expand variableReduce) (("3" (assert) nil nil)) nil)
           ("4" (typepred "nS`stack_types") (("4" (propax) nil nil))
            nil)
           ("5" (expand variableReduce)
            (("5" (assert)
              (("5" (skeep)
                (("5" (lift-if) (("5" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (split)
          (("1" (replace* (-3 -5))
            (("1" (expand* make_redex_typed make_redex to_topstate)
              (("1" (expand typed_to_topstate)
                (("1" (expand to_topstate) (("1" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((stack_still_typed formula-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC6 0
  (typed_reduce_TCC6-1 nil 3705930673
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      (("" (assert)
        (("" (rewrite value_well_typed)
          (("" (typepred "nS`redex_type")
            (("" (expand is_well_typed)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "nS`stack_types")
                    (("" (expand get)
                      (("" (inst?)
                        (("1" (grind) nil nil)
                         ("2" (typepred "nS`state`redex")
                          (("2" (inst -2 "index(nS`state`redex)")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC7 0
  (typed_reduce_TCC7-1 nil 3705930673
   ("" (skeep* :preds? t)
    (("" (expand variableReduce)
      (("" (assert)
        ((""
          (case-replace "popDepth(get
                                      (nS`state`stack)(nS`state`redex)) = 0")
          (("1" (assert)
            (("1" (typepred "nS`context_type")
              (("1" (case-replace "popDepth(nS`state`redex) = 0")
                (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (typepred "get(nS`state`stack)(nS`state`redex)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.variableReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_reduce_TCC8 0
  (typed_reduce_TCC8-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IL.pureLetRedex?(rreduction.grS`redex)}")))
 (typed_reduce_TCC9 0
  (typed_reduce_TCC9-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use letReduce_ndr)
      (("1" (use letReduce_arm)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1" (expand* typed_to_topstate to_topstate)
              (("1" (expand* make_redex_typed make_redex) nil nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((letReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (letRedex? const-decl "bool" IL nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (letReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC10 0
  (typed_reduce_TCC10-2 "" 3720243117
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (typed_reduce_TCC10-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC11 0
  (typed_reduce_TCC11-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "letexpr?(nS`state`redex)")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.lett?)")))
 (typed_reduce_TCC12 0
  (typed_reduce_TCC12-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (split)
        (("1" (expand add)
          (("1" (expand push)
            (("1" (expand add) (("1" (grind) nil nil)) nil)) nil))
          nil)
         ("2" (skeep :preds? t)
          (("2" (case-replace "i = nS`stack_types`length")
            (("1" (typepred "nS`stack_types")
              (("1" (expand push)
                (("1" (expand add)
                  (("1" (lift-if)
                    (("1" (assert)
                      (("1" (typepred "nS`redex_type")
                        (("1" (case "letexpr?(nS`state`redex)")
                          (("1" (assert)
                            (("1" (expand is_well_typed)
                              (("1"
                                (flatten)
                                (("1"
                                  (rewrite value_well_typed -3)
                                  (("1"
                                    (flatten)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "nS`stack_types")
              (("2" (assert)
                (("2" (expand push)
                  (("2" (expand add) (("2" (inst?) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (seq type-eq-decl nil more_finseq nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_rreduction.nS`redex_type), typed_rreduction.nS`stack_types)"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC13 0
  (typed_reduce_TCC13-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand is_well_typed +)
        (("" (typepred "nS`redex_type")
          (("" (assert)
            (("" (case "letexpr?(nS`state`redex)")
              (("1" (assert)
                (("1" (expand is_well_typed -)
                  (("1"
                    (case-replace
                     "popDepth(letrhs(nS`state`redex)) = 0")
                    (("1" (assert) nil nil)
                     ("2" (expand pureLetRedex?)
                      (("2" (expand letRedex?)
                        (("2" (flatten)
                          (("2" (hide-all-but (1 -8))
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typeinfo_adt.popt(typeinfo_adt.lbody(typed_rreduction.nS`redex_type))"
    "{tA | typed_reduction.is_well_typed(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_rreduction.nS`redex_type), typed_rreduction.nS`stack_types), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC14 0
  (typed_reduce_TCC14-2 nil 3705934280
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand popDepth +)
        (("" (expand popDepth + 1)
          (("" (assert)
            ((""
              (case-replace
               "popn(add[nat](lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types")
              (("1"
                (case-replace
                 "expr_type(popt(lbody(nS`redex_type))) = expr_type(nS`redex_type)")
                (("1" (typepred "nS`context_type")
                  (("1" (case-replace "popDepth(nS`state`redex) = 0")
                    (("1" (assert)
                      (("1"
                        (case-replace "CASES body(nS`state`redex)
                                OF pop(B): 1 + popDepth(B),
                                   letexpr(B, C): popDepth(B),
                                   release(x, B): popDepth(B)
                                ELSE 0
                                ENDCASES = popDepth(body(nS`state`redex))")
                        (("1" (rewrite purePopDepth)
                          (("1" (assert) nil nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (expand popDepth 1 4)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (case "letexpr?(nS`state`redex)")
                      (("1" (assert)
                        (("1" (expand popDepth)
                          (("1" (case "value?(letrhs(nS`state`redex))")
                            (("1" (assert)
                              (("1"
                                (hide-all-but (1 -1))
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (case "lett?(nS`redex_type)")
                    (("1" (assert)
                      (("1" (expand expr_type) (("1" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (case "letexpr?(nS`state`redex)")
                      (("1" (typepred "nS`redex_type")
                        (("1" (assert)
                          (("1" (expand is_well_typed)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (decompose-equality)
                (("1" (grind) nil nil)
                 ("2" (decompose-equality) (("2" (grind) nil nil))
                  nil))
                nil)
               ("3" (expand add) (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (popt adt-constructor-decl "[typeinfo -> (popt?)]" typeinfo_adt
     nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popDepth def-decl "nat" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_rreduction.nS`redex_type), typed_rreduction.nS`stack_types), IL.popDepth(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typeinfo_adt.popt(typeinfo_adt.lbody(typed_rreduction.nS`redex_type))))}"))
  (typed_reduce_TCC14-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand popDepth +)
        (("" (expand popDepth + 1)
          (("" (rewrite purePopDepth)
            (("1" (assert)
              (("1"
                (case-replace
                 "popn(add[nat](lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types")
                (("1"
                  (case-replace
                   "expr_type(popt(lbody(nS`redex_type))) = expr_type(nS`redex_type)")
                  (("1" (typepred "nS`context_type")
                    (("1" (case-replace "popDepth(nS`state`redex) = 0")
                      (("1" (assert) nil nil)
                       ("2" (case "letexpr?(nS`state`redex)")
                        (("1" (assert)
                          (("1" (expand popDepth)
                            (("1"
                              (case "atom?(letrhs(nS`state`redex))")
                              (("1"
                                (assert)
                                (("1"
                                  (hide-all-but (1 -1))
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (case "lett?(nS`redex_type)")
                      (("1" (assert)
                        (("1" (expand expr_type)
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (case "letexpr?(nS`state`redex)")
                        (("1" (typepred "nS`redex_type")
                          (("1" (assert)
                            (("1" (expand is_well_typed)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (decompose-equality)
                  (("1" (grind) nil nil)
                   ("2" (decompose-equality) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popt adt-constructor-decl "[typeinfo -> (popt?)]" typeinfo_adt
     nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(more_finseq[naturalnumbers.nat].add(typeinfo_adt.lettype(typed_rreduction.nS`redex_type), typed_rreduction.nS`stack_types), IL.popDepth(rreduction.letReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typeinfo_adt.popt(typeinfo_adt.lbody(typed_rreduction.nS`redex_type))))}")))
 (typed_reduce_TCC15 0
  (typed_reduce_TCC15-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IL.applyRedex?(rreduction.grS`redex)}")))
 (typed_reduce_TCC16 0
  (typed_reduce_TCC16-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use applyReduce_ndr)
      (("1" (use applyReduce_arm)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1" (expand make_redex_typed)
              (("1" (expand make_redex)
                (("1" (expand typed_to_topstate)
                  (("1" (expand to_topstate) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((applyReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (applyReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC17 0
  (typed_reduce_TCC17-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC18 0
  (typed_reduce_TCC18-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types")
          (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC19 0
  (typed_reduce_TCC19-1 nil 3702747756
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (value? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state`redex"
    "(IExpression_adt.application?)")))
 (typed_reduce_TCC20 0
  (typed_reduce_TCC20-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "application?(nS`state`redex)")
        (("1" (assert)
          (("1" (expand is_well_typed)
            (("1" (expand defs_well_typed) (("1" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "IExpression_adt.fun(typed_rreduction.nS`state`redex)"
    "below[tS`def_types`length]")))
 (typed_reduce_TCC21 0
  (typed_reduce_TCC21-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (hide-all-but 5)
      ((""
        (name-replace L
         "tS`def_types`seq(fun(nS`state`redex))`args_type")
        (("" (rewrite finseq2list_length) nil nil)) nil))
      nil))
    nil)
   ((finseq2list_length formula-decl nil list2finseq_extra nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "list2finseq[naturalnumbers.nat].finseq2list(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type)"
    "{args_type_1: list_adt[naturalnumbers.nat].list | list_props[naturalnumbers.nat].length(args_type_1) = length(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type)}")))
 (typed_reduce_TCC22 0
  (typed_reduce_TCC22-2 "" 3720281964
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      ((""
        (case "fun(nS`state`redex) < D`length AND length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
        (("1" (assert)
          (("1" (flatten)
            (("1" (assert)
              (("1"
                (case-replace "length
                                        (tS`def_types`seq
                                         (fun(nS`state`redex))`args_type) = D`seq(fun(nS`state`redex))`arity")
                (("1" (case "application?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (typepred "nS`redex_type")
                      (("1" (expand is_well_typed -)
                        (("1" (flatten)
                          (("1" (use is_well_typed_letApply)
                            (("1" (split -1)
                              (("1" (assert) nil nil)
                               ("2" (rewrite pure_mark) nil nil)
                               ("3"
                                (rewrite cvars_mark)
                                (("3"
                                  (skeep)
                                  (("3"
                                    (typepred
                                     "D`seq(fun(nS`state`redex))`body")
                                    (("3"
                                      (inst -2 i)
                                      (("3"
                                        (rewrite cvars_pure)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (skeep)
                                (("4"
                                  (typepred "nS`state`redex")
                                  (("4"
                                    (inst -2 i)
                                    (("4"
                                      (typepred "nS`stack_types")
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("5"
                                (skeep :preds? t)
                                (("5"
                                  (inst?)
                                  (("5"
                                    (rewrite finseq2list_nth)
                                    (("5"
                                      (replace*)
                                      (("5"
                                        (expand*
                                         typed_to_topstate
                                         to_topstate)
                                        (("5"
                                          (expand make_redex_typed)
                                          (("5" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("6"
                                (use is_well_typed_mark)
                                (("1"
                                  (split -1)
                                  (("1"
                                    (replace -1 :dir RL)
                                    (("1"
                                      (expand defs_well_typed)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst
                                           -11
                                           "fun(nS`state`redex)")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (use
                                               is_well_typed_extend_stack)
                                              (("1"
                                                (rewrite -1)
                                                (("1"
                                                  (rewrite
                                                   list2finseq_finseq2list)
                                                  (("1"
                                                    (replace*)
                                                    (("1"
                                                      (expand*
                                                       typed_to_topstate
                                                       to_topstate
                                                       make_redex_typed)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   pure_contextPure)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (delete 2 6)
                                                (("2"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("2"
                                                    (rewrite
                                                     cvars_pure)
                                                    (("2"
                                                      (rewrite
                                                       list2finseq_finseq2list)
                                                      (("2"
                                                        (split)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (skeep)
                                                          (("2"
                                                            (typepred
                                                             "D`seq(fun(nS`state`redex))`body")
                                                            (("2"
                                                              (inst?)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use pure_contextPure)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (delete 2 6)
                                  (("2"
                                    (rewrite purePopDepth)
                                    (("2"
                                      (rewrite cvars_pure)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split)
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (typepred
                                               "D`seq(fun(nS`state`redex))`body")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (expand
                                                     defs_well_typed)
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (inst
                                                         -14
                                                         "fun(nS`state`redex)")
                                                        (("2"
                                                          (rewrite
                                                           list2finseq_finseq2list)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "finseq2list_length")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete 5)
                    (("2" (case "application?(nS`state`redex)")
                      (("1" (propax) nil nil)
                       ("2" (assert)
                        (("2" (typepred "nS`redex_type")
                          (("2" (expand is_well_typed)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 5)
          (("2" (case "application?(nS`state`redex)")
            (("1" (assert)
              (("1" (typepred "nS`redex_type")
                (("1" (expand is_well_typed)
                  (("1" (flatten)
                    (("1" (expand defs_well_typed)
                      (("1" (flatten)
                        (("1" (case "fun(nS`state`redex) < D`length")
                          (("1" (assert)
                            (("1" (inst? -8)
                              (("1"
                                (flatten)
                                (("1"
                                  (replace*)
                                  (("1"
                                    (expand*
                                     make_redex_typed
                                     typed_to_topstate)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace*) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "rstate" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (finseq2list_length formula-decl nil list2finseq_extra nil)
    (pure_mark formula-decl nil preprocess nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (cvars_mark formula-decl nil preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (finseq2list_nth formula-decl nil list2finseq_extra nil)
    (is_well_typed_extend_stack formula-decl nil typed_reduction nil)
    (pure_contextPure formula-decl nil IL nil)
    (list2finseq_finseq2list formula-decl nil list2finseq_extra nil)
    (purePopDepth formula-decl nil IL nil)
    (O const-decl "finseq" finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (is_well_typed_mark formula-decl nil typed_rreduction nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (is_well_typed_letApply formula-decl nil typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (IExpression type-decl nil IExpression_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype
    "typed_reduction.letApply_type(length(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), list2finseq[naturalnumbers.nat].finseq2list(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)"
    "{tA | typed_reduction.is_well_typed(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}"))
  (typed_reduce_TCC22-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      ((""
        (case "fun(nS`state`redex) < D`length AND length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
        (("1" (assert)
          (("1" (flatten)
            (("1" (assert)
              (("1"
                (case-replace "length
                                    (tS`def_types`seq
                                     (fun(nS`state`redex))`args_type) = D`seq(fun(nS`state`redex))`arity")
                (("1" (case "application?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (typepred "nS`redex_type")
                      (("1" (expand is_well_typed -)
                        (("1" (flatten)
                          (("1" (use is_well_typed_letApply)
                            (("1" (split -1)
                              (("1" (propax) nil nil)
                               ("2" (rewrite pure_mark) nil nil)
                               ("3"
                                (rewrite cvars_mark)
                                (("3"
                                  (skeep)
                                  (("3"
                                    (typepred
                                     "D`seq(fun(nS`state`redex))`body")
                                    (("3"
                                      (inst -2 i)
                                      (("3"
                                        (rewrite cvars_pure)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (skeep)
                                (("4"
                                  (typepred "nS`state`redex")
                                  (("4"
                                    (inst -2 i)
                                    (("4"
                                      (typepred "nS`stack_types")
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("5"
                                (skeep :preds? t)
                                (("5"
                                  (inst?)
                                  (("5"
                                    (rewrite finseq2list_nth)
                                    (("5"
                                      (replace*)
                                      (("5"
                                        (expand*
                                         typed_to_topstate
                                         to_topstate)
                                        (("5"
                                          (expand make_redex_typed)
                                          (("5" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("6"
                                (use is_well_typed_mark)
                                (("1"
                                  (split -1)
                                  (("1"
                                    (replace -1 :dir RL)
                                    (("1"
                                      (expand defs_well_typed)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst
                                           -11
                                           "fun(nS`state`redex)")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (use
                                               is_well_typed_extend_stack)
                                              (("1"
                                                (rewrite -1)
                                                (("1"
                                                  (rewrite
                                                   list2finseq_finseq2list)
                                                  (("1"
                                                    (replace*)
                                                    (("1"
                                                      (expand*
                                                       typed_to_topstate
                                                       to_topstate
                                                       make_redex_typed)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   pure_contextPure)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (delete 2 6)
                                                (("2"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("2"
                                                    (rewrite
                                                     cvars_pure)
                                                    (("2"
                                                      (rewrite
                                                       list2finseq_finseq2list)
                                                      (("2"
                                                        (split)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (skeep)
                                                          (("2"
                                                            (typepred
                                                             "D`seq(fun(nS`state`redex))`body")
                                                            (("2"
                                                              (inst?)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use pure_contextPure)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (delete 2 6)
                                  (("2"
                                    (rewrite purePopDepth)
                                    (("2"
                                      (rewrite cvars_pure)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split)
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (typepred
                                               "D`seq(fun(nS`state`redex))`body")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (expand
                                                     defs_well_typed)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (inst
                                                         -14
                                                         "fun(nS`state`redex)")
                                                        (("1"
                                                          (rewrite
                                                           list2finseq_finseq2list)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 5)
                  (("2" (case "application?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (typepred "nS`redex_type")
                        (("1" (expand is_well_typed)
                          (("1" (flatten) (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 5)
          (("2" (case "application?(nS`state`redex)")
            (("1" (assert)
              (("1" (typepred "nS`redex_type")
                (("1" (expand is_well_typed)
                  (("1" (flatten)
                    (("1" (expand defs_well_typed)
                      (("1" (flatten)
                        (("1" (case "fun(nS`state`redex) < D`length")
                          (("1" (assert)
                            (("1" (inst? -8)
                              (("1"
                                (flatten)
                                (("1"
                                  (replace*)
                                  (("1"
                                    (expand*
                                     make_redex_typed
                                     typed_to_topstate)
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace*)
                            (("2"
                              (expand* make_redex_typed
                               typed_to_topstate)
                              nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "rstate" rreduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (finseq2list_length formula-decl nil list2finseq_extra nil)
    (pure_mark formula-decl nil preprocess nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (cvars_mark formula-decl nil preprocess nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (finseq2list_nth formula-decl nil list2finseq_extra nil)
    (is_well_typed_extend_stack formula-decl nil typed_reduction nil)
    (pure_contextPure formula-decl nil IL nil)
    (list2finseq_finseq2list formula-decl nil list2finseq_extra nil)
    (purePopDepth formula-decl nil IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil))
   nil
   (typed_reduce subtype
    "typed_reduction.letApply_type(length(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), list2finseq[naturalnumbers.nat].finseq2list(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)"
    "{tA | typed_reduction.is_well_typed(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC23 0
  (typed_reduce_TCC23-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (rewrite letApply_expr_type)
      ((""
        (case-replace
         "popDepth(applyReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1" (expand applyReduce +)
          (("1" (assert)
            (("1"
              (case-replace "expr_type(tS`def_types`seq
                                      (fun(nS`state`redex))`body_type) = expr_type(nS`redex_type)")
              (("1" (typepred "nS`context_type")
                (("1" (propax) nil nil)) nil)
               ("2" (case "application?(nS`state`redex)")
                (("1" (assert)
                  (("1" (typepred "nS`redex_type")
                    (("1" (expand is_well_typed)
                      (("1" (flatten)
                        (("1" (replace -2)
                          (("1" (simplify)
                            (("1" (expand expr_type 1 2)
                              (("1"
                                (expand defs_well_typed)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst -8 "fun(nS`state`redex)")
                                    (("1"
                                      (replace*)
                                      (("1"
                                        (expand*
                                         typed_to_topstate
                                         make_redex_typed)
                                        (("1"
                                          (flatten)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (replace*)
                                      (("2"
                                        (expand*
                                         make_redex_typed
                                         make_redex
                                         typed_to_topstate
                                         to_topstate)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand applyRedex?) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 5)
          (("2" (expand applyReduce)
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (rewrite purePopDepth)
                        (("1" (rewrite purePopDepth)
                          (("1" (grind) nil nil)) nil)
                         ("2" (rewrite pure_letApply)
                          (("2" (rewrite pure_mark) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letApply_expr_type formula-decl nil typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (length def-decl "nat" list_props nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (purePopDepth formula-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letApply def-decl "IExpression" rreduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.applyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_reduction.letApply_type(length(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), list2finseq[naturalnumbers.nat].finseq2list(typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)))}")))
 (typed_reduce_TCC24 0
  (typed_reduce_TCC24-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))
 (typed_reduce_TCC25 0
  (typed_reduce_TCC25-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use ifReduce_ndr)
      (("1" (use ifReduce_arm)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (replace -5)
          (("2" (replace -3)
            (("2"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iftRedex? const-decl "bool" IL nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (ifReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC26 0
  (typed_reduce_TCC26-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (expand release_marked)
        (("" (assert)
          (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC27 0
  (typed_reduce_TCC27-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (expand ifReduce)
        (("1" (expand release_marked)
          (("1" (typepred "nS`stack_types") (("1" (assert) nil nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand ifReduce)
          (("2" (expand release_marked)
            (("2" (assert)
              (("2" (typepred "nS`stack_types") (("2" (inst?) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release_marked const-decl "rstate" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC28 0
  (typed_reduce_TCC28-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state`redex"
    "(IExpression_adt.ift?)")))
 (typed_reduce_TCC29 0
  (typed_reduce_TCC29-1 nil 3706555818
   ("" (skeep* :preds? t)
    ((""
      (with-labels (typepred "nS`state`redex")
       ((href hvar hcvar hsl hcp)))
      (("" (inst hvar "index(condition(nS`state`redex))")
        (("" (split hvar)
          (("1" (grind) nil nil)
           ("2" (apply-eta "nS`state`redex" "(ift?)")
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (IExpression_ift_eta formula-decl nil IExpression_adt nil)
    (condition adt-accessor-decl "[(ift?) -> (variable?)]"
               IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "IExpression_adt.condition(typed_rreduction.nS`state`redex)"
    "{x | reals.<(IExpression_adt.index(IL.x), typed_rreduction.nS`state`stack`length)}")))
 (typed_reduce_TCC30 0
  (typed_reduce_TCC30-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "ift?(nS`state`redex)")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.iftt?)")))
 (typed_reduce_TCC31 0
  (typed_reduce_TCC31-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "ift?(nS`state`redex)")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.iftt?)")))
 (typed_reduce_TCC32 0
  (typed_reduce_TCC32-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (lift-if)
        (("" (expand release_marked)
          (("" (lift-if)
            (("" (lift-if)
              (("" (expand is_well_typed + (1 3))
                (("" (typepred "nS`redex_type")
                  (("" (case "ift?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (expand is_well_typed -)
                        (("1" (flatten) (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "rstate" rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "IF IL.get(typed_rreduction.nS`state`stack)(IExpression_adt.condition(typed_rreduction.nS`state`redex)) = IExpression_adt.constant(0) THEN typeinfo_adt.telse(typed_rreduction.nS`redex_type) ELSE typeinfo_adt.tthen(typed_rreduction.nS`redex_type) ENDIF"
    "{tA | typed_reduction.is_well_typed(rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC33 0
  (typed_reduce_TCC33-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "popDepth(ifReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
      (("1" (expand ifReduce +)
        (("1" (expand release_marked)
          (("1" (assert)
            (("1" (typepred "nS`context_type")
              (("1" (typepred "nS`redex_type")
                (("1" (case "ift?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (expand is_well_typed)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (expand expr_type -7)
                            (("1" (lift-if) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite purePopDepth)
        (("1" (rewrite purePopDepth)
          (("1" (case "ift?(nS`state`redex)")
            (("1" (assert)
              (("1" (expand pure?) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (expand ifReduce)
          (("2" (delete 7)
            (("2" (delete 2)
              (("2" (expand release_marked)
                (("2" (expand pure? + (1 3)) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.ifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, IF IL.get(typed_rreduction.nS`state`stack)(IExpression_adt.condition(typed_rreduction.nS`state`redex)) = IExpression_adt.constant(0) THEN typed_reduction.expr_type(typeinfo_adt.telse(typed_rreduction.nS`redex_type)) ELSE typed_reduction.expr_type(typeinfo_adt.tthen(typed_rreduction.nS`redex_type)) ENDIF)}")))
 (typed_reduce_TCC34 0
  (typed_reduce_TCC34-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | booleans.AND(IL.updateRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (typed_reduce_TCC35 0
  (typed_reduce_TCC35-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "updateReduce(D)(nS`state)")
      (("1" (use updateReduce_arm)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (replace -5)
          (("2" (replace -3)
            (("2"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (updateReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC36 0
  (typed_reduce_TCC36-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1" (typepred "nS`redex_type")
          (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.leaft?)")))
 (typed_reduce_TCC37 0
  (typed_reduce_TCC37-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1" (typepred "nS`redex_type")
          (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)"
    "nat")))
 (typed_reduce_TCC38 0
  (typed_reduce_TCC38-2 "" 3720283052
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace "nS`dom_types
                 WITH [(least_out(nS`state`domain))
                         |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (split)
              (("1" (skeep)
                (("1" (typepred "nS2`dom_types(x1)")
                  (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep* :preds? t)
                (("2" (use updateReduce_new_store)
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (replace -1)
                        (("1" (inst?)
                          (("1" (expand value_maybe_freed2)
                            (("1" (split)
                              (("1"
                                (lemma value_maybe_freed_type)
                                (("1"
                                  (inst? :where -2)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (typepred "nS2`dom_types")
                                        (("2"
                                          (inst
                                           -1
                                           "refindex(get(nS`state`stack)
                                                       (target(nS`state`redex)))"
                                           "j")
                                          (("1"
                                            (case-replace
                                             "nS2`dom_types
                                            (refindex(get(nS`state`stack)
                                                         (target(nS`state`redex)))) = nS2`dom_types(least_out(nS`state`domain))")
                                            (("1"
                                              (expand*
                                               ns2
                                               set_new_type)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2"
                                              (expand*
                                               nS2
                                               set_new_type)
                                              (("2"
                                                (delete 2 3)
                                                (("2"
                                                  (lift-if +)
                                                  (("2"
                                                    (simplify)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (split +)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (typepred
                                                             "nS`redex_type")
                                                            (("2"
                                                              (expand
                                                               is_well_typed)
                                                              (("2"
                                                                (flatten)
                                                                (("2"
                                                                  (case
                                                                   "variable?(target(nS`state`redex))")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (expand
                                                                       is_well_typed
                                                                       -4)
                                                                      (("1"
                                                                        (typepred
                                                                         "nS`stack_types")
                                                                        (("1"
                                                                          (expand
                                                                           get)
                                                                          (("1"
                                                                            (inst
                                                                             -2
                                                                             "nS`state`stack`length - 1 -
                                                     index(target(nS`state`redex))")
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (expand
                                                                                 value_of_type
                                                                                 -2)
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (use
                                                                               updateRedex_target_index)
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand* nS2 set_new_type)
                                            (("2"
                                              (replace -4)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (typepred "nS`state`stack")
                                            (("3"
                                              (expand get)
                                              (("3"
                                                (expand every)
                                                (("3"
                                                  (inst? -1)
                                                  (("1"
                                                    (bash)
                                                    (("1"
                                                      (expand*
                                                       nS2
                                                       set_new_type)
                                                      (("1"
                                                        (bash)
                                                        (("1"
                                                          (expand
                                                           domainValue?)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (bash)
                                                    (("2"
                                                      (use
                                                       updateRedex_target_index)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma value_maybe_freed_type)
                                (("2"
                                  (inst? :where -2)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (typepred "nS`redex_type")
                                        (("2"
                                          (expand is_well_typed)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (case
                                               "variable?(rhs(nS`state`redex))")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   is_well_typed
                                                   -6)
                                                  (("1"
                                                    (expand get)
                                                    (("1"
                                                      (typepred
                                                       "nS2`stack_types")
                                                      (("1"
                                                        (expand*
                                                         nS2
                                                         set_new_type)
                                                        (("1"
                                                          (inst?)
                                                          (("1"
                                                            (replace*)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (use
                                                             updateRedex_rhs_index)
                                                            (("2"
                                                              (bash)
                                                              (("2"
                                                                (expand
                                                                 nS2)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (inst?)
                        (("2"
                          (case "value_of_type(nS`state`store(r)`seq(j), nS2`dom_types(r), nS2`dom_types)")
                          (("1" (lift-if)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand value_maybe_freed2)
                                  (("1"
                                    (split)
                                    (("1"
                                      (lemma value_maybe_freed_type)
                                      (("1"
                                        (inst? :where -2)
                                        (("1"
                                          (inst?)
                                          (("1" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma value_maybe_freed_type)
                                      (("2"
                                        (inst? :where -2)
                                        (("2"
                                          (inst?)
                                          (("2"
                                            (split -1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (typepred
                                               "nS`redex_type")
                                              (("2"
                                                (expand is_well_typed)
                                                (("2"
                                                  (case
                                                   "variable?(rhs(nS`state`redex))")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -6)
                                                        (("1"
                                                          (typepred
                                                           "nS2`stack_types")
                                                          (("1"
                                                            (expand
                                                             get)
                                                            (("1"
                                                              (expand*
                                                               nS2
                                                               set_new_type)
                                                              (("1"
                                                                (inst?)
                                                                (("1"
                                                                  (case-replace
                                                                   "nS`dom_types(r) = leaftype(nS`redex_type) - 1")
                                                                  (("1"
                                                                    (replace*)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (case
                                                                     "variable?(target(nS`state`redex))")
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (expand
                                                                         is_well_typed
                                                                         -7)
                                                                        (("1"
                                                                          (typepred
                                                                           "nS`stack_types")
                                                                          (("1"
                                                                            (inst
                                                                             -2
                                                                             "nS`state`stack`length - 1 -
                                                        index(target(nS`state`redex))")
                                                                            (("1"
                                                                              (expand
                                                                               value_of_type
                                                                               -2)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (use
                                                                               updateRedex_target_index)
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (use
                                                                   updateRedex_rhs_index)
                                                                  (("2"
                                                                    (expand
                                                                     nS2)
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (expand value_maybe_freed2)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lemma value_maybe_freed_type)
                                      (("2"
                                        (inst? :where -2)
                                        (("2"
                                          (inst?)
                                          (("2" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2"
                                  (inst?)
                                  (("1" (replace*) nil nil)
                                   ("2"
                                    (expand* nS2 set_new_type)
                                    (("2" (assert) nil nil))
                                    nil)
                                   ("3"
                                    (assert)
                                    (("3"
                                      (expand* nS2 set_new_type)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (replace*)
                    (("2"
                      (expand* make_redex_typed typed_to_topstate
                       make_redex to_topstate)
                      nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 7) (("2" (expand* nS2 set_new_type) nil nil))
              nil))
            nil)
           ("2" (delete 7)
            (("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed) (("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (delete 7)
            (("3" (typepred "nS`redex_type")
              (("3" (expand is_well_typed) (("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 7) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (updateReduce_new_store formula-decl nil typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (j skolem-const-decl
     "below(updateReduce(D)(nS`state)`store(r)`length)"
     typed_rreduction nil)
    (r skolem-const-decl "(updateReduce(D)(nS`state)`domain)"
     typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value_maybe_freed_type formula-decl nil typed_rreduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (updateRedex_rhs_index formula-decl nil rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype
    "typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (typed_reduce_TCC38-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace "nS`dom_types
           WITH [(least_out(nS`state`domain))
                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (split)
              (("1" (skeep)
                (("1" (typepred "nS2`dom_types(x1)")
                  (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep* :preds? t)
                (("2" (use updateReduce_new_store)
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (replace -1)
                        (("1" (inst?)
                          (("1" (expand value_maybe_freed2)
                            (("1" (split)
                              (("1"
                                (lemma value_maybe_freed_type)
                                (("1"
                                  (inst? :where -2)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (typepred "nS2`dom_types")
                                        (("2"
                                          (inst
                                           -1
                                           "refindex(get(nS`state`stack)
                                     (target(nS`state`redex)))"
                                           "j")
                                          (("1"
                                            (case-replace
                                             "nS2`dom_types
                        (refindex(get(nS`state`stack)
                                     (target(nS`state`redex)))) = nS2`dom_types(least_out(nS`state`domain))")
                                            (("1"
                                              (expand*
                                               ns2
                                               set_new_type)
                                              (("1"
                                                (expand*
                                                 nS2
                                                 set_new_type)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (expand*
                                               nS2
                                               set_new_type)
                                              (("2"
                                                (delete 2 3)
                                                (("2"
                                                  (lift-if +)
                                                  (("2"
                                                    (simplify)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (split +)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (typepred
                                                             "nS`redex_type")
                                                            (("2"
                                                              (expand
                                                               is_well_typed)
                                                              (("2"
                                                                (flatten)
                                                                (("2"
                                                                  (case
                                                                   "variable?(target(nS`state`redex))")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (expand
                                                                       is_well_typed
                                                                       -4)
                                                                      (("1"
                                                                        (typepred
                                                                         "nS`stack_types")
                                                                        (("1"
                                                                          (expand
                                                                           get)
                                                                          (("1"
                                                                            (inst
                                                                             -2
                                                                             "nS`state`stack`length - 1 -
                           index(target(nS`state`redex))")
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (expand
                                                                                 value_of_type
                                                                                 -2)
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (use
                                                                               updateRedex_target_index)
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand* nS2 set_new_type)
                                            (("2"
                                              (replace -4)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (typepred "nS`state`stack")
                                            (("3"
                                              (expand get)
                                              (("3"
                                                (expand every)
                                                (("3"
                                                  (inst? -1)
                                                  (("1"
                                                    (bash)
                                                    (("1"
                                                      (expand*
                                                       nS2
                                                       set_new_type)
                                                      (("1"
                                                        (bash)
                                                        (("1"
                                                          (expand
                                                           domainValue?)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (bash)
                                                    (("2"
                                                      (use
                                                       updateRedex_target_index)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma value_maybe_freed_type)
                                (("2"
                                  (inst? :where -2)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (typepred "nS`redex_type")
                                        (("2"
                                          (expand is_well_typed)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (case
                                               "variable?(rhs(nS`state`redex))")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   is_well_typed
                                                   -6)
                                                  (("1"
                                                    (expand get)
                                                    (("1"
                                                      (typepred
                                                       "nS2`stack_types")
                                                      (("1"
                                                        (expand*
                                                         nS2
                                                         set_new_type)
                                                        (("1"
                                                          (inst?)
                                                          (("1"
                                                            (replace*)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (use
                                                             updateRedex_rhs_index)
                                                            (("2"
                                                              (bash)
                                                              (("2"
                                                                (expand
                                                                 nS2)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (inst?)
                        (("2"
                          (case "value_of_type(nS`state`store(r)`seq(j), nS2`dom_types(r), nS2`dom_types)")
                          (("1" (lift-if)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand value_maybe_freed2)
                                  (("1"
                                    (split)
                                    (("1"
                                      (lemma value_maybe_freed_type)
                                      (("1"
                                        (inst? :where -2)
                                        (("1"
                                          (inst?)
                                          (("1" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma value_maybe_freed_type)
                                      (("2"
                                        (inst? :where -2)
                                        (("2"
                                          (inst?)
                                          (("2"
                                            (split -1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (typepred
                                               "nS`redex_type")
                                              (("2"
                                                (expand is_well_typed)
                                                (("2"
                                                  (case
                                                   "variable?(rhs(nS`state`redex))")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -6)
                                                        (("1"
                                                          (typepred
                                                           "nS2`stack_types")
                                                          (("1"
                                                            (expand
                                                             get)
                                                            (("1"
                                                              (expand*
                                                               nS2
                                                               set_new_type)
                                                              (("1"
                                                                (inst?)
                                                                (("1"
                                                                  (case-replace
                                                                   "nS`dom_types(r) = leaftype(nS`redex_type) - 1")
                                                                  (("1"
                                                                    (replace*)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (case
                                                                     "variable?(target(nS`state`redex))")
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (expand
                                                                         is_well_typed
                                                                         -7)
                                                                        (("1"
                                                                          (typepred
                                                                           "nS`stack_types")
                                                                          (("1"
                                                                            (inst
                                                                             -2
                                                                             "nS`state`stack`length - 1 -
                          index(target(nS`state`redex))")
                                                                            (("1"
                                                                              (expand
                                                                               value_of_type
                                                                               -2)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (use
                                                                               updateRedex_target_index)
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (use
                                                                   updateRedex_rhs_index)
                                                                  (("2"
                                                                    (expand
                                                                     nS2)
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (expand value_maybe_freed2)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lemma value_maybe_freed_type)
                                      (("2"
                                        (inst? :where -2)
                                        (("2"
                                          (inst?)
                                          (("2" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2"
                                  (inst?)
                                  (("1"
                                    (expand nS2)
                                    (("1"
                                      (expand set_new_type)
                                      (("1" (replace*) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand* nS2 set_new_type)
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (replace*)
                    (("2"
                      (expand* make_redex_typed typed_to_topstate
                       make_redex to_topstate)
                      nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 7) (("2" (expand* nS2 set_new_type) nil nil))
              nil))
            nil)
           ("2" (delete 7)
            (("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed) (("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (delete 7)
            (("3" (typepred "nS`redex_type")
              (("3" (expand is_well_typed) (("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 7) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateRedex? const-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (updateRedex_rhs_index formula-decl nil rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil))
   nil
   (typed_reduce subtype
    "typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC39 0
  (typed_reduce_TCC39-2 "" 3720294823
   ("" (skeep* :preds? t)
    ((""
      (name-replace "nS2"
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
        (("1" (expand set_new_type -1)
          (("1" (rewrite -1)
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (use updateReduce_new_stack)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (expand nS2)
                      (("1" (expand set_new_type)
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`stack_types")
                      (("2" (skeep)
                        (("2" (inst?)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace
                                   "nS`stack_types = nS2`stack_types")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (expand nS2)
                                    (("2"
                                      (expand set_new_type)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (case-replace
                                   "nS`stack_types = nS2`stack_types")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand value_of_type)
                                      (("1"
                                        (flatten)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand nS2)
                                    (("2"
                                      (expand set_new_type)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred i)
                              (("2"
                                (expand nS2)
                                (("2"
                                  (expand set_new_type)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred i)
                            (("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (replace -5)
                        (("1" (replace -5)
                          (("1"
                            (expand* make_redex_typed typed_to_topstate
                             make_redex to_topstate)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand nS2)
                    (("2" (expand set_new_type)
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (typepred "nS`redex_type")
          (("2" (case "update?(nS`state`redex)")
            (("1" (assert) nil nil) ("2" (grind) nil nil)) nil))
          nil)
         ("3" (typepred "nS`redex_type")
          (("3" (case "update?(nS`state`redex)")
            (("1" (assert)
              (("1" (expand is_well_typed) (("1" (propax) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type")
        (("2" (case "update?(nS`state`redex)")
          (("1" (assert)
            (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("3" (typepred "nS`redex_type")
        (("3" (case "update?(nS`state`redex)")
          (("1" (assert)
            (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (i skolem-const-decl "below(nS`stack_types`length)"
       typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (updateReduce_new_stack formula-decl nil typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC39-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (name-replace "nS2"
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
        (("1" (expand set_new_type -1)
          (("1" (rewrite -1)
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (use updateReduce_new_stack)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (expand nS2)
                      (("1" (expand set_new_type)
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`stack_types")
                      (("2" (skeep)
                        (("2" (inst?)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace
                                   "nS`stack_types = nS2`stack_types")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (expand nS2)
                                    (("2"
                                      (expand set_new_type)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (case-replace
                                   "nS`stack_types = nS2`stack_types")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand value_of_type)
                                      (("1" (flatten) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand nS2)
                                    (("2"
                                      (expand set_new_type)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred i)
                              (("2"
                                (expand nS2)
                                (("2"
                                  (expand set_new_type)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred i)
                            (("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (replace -5)
                        (("1" (replace -5)
                          (("1"
                            (expand* make_redex_typed typed_to_topstate
                             make_redex to_topstate)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (propax) nil nil)) nil)
         ("3" (typepred "nS`redex_type")
          (("3" (case "update?(nS`state`redex)")
            (("1" (assert)
              (("1" (expand is_well_typed) (("1" (propax) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type")
        (("2" (case "update?(nS`state`redex)")
          (("1" (assert)
            (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("3" (typepred "nS`redex_type")
        (("3" (case "update?(nS`state`redex)")
          (("1" (assert)
            (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]))}")))
 (typed_reduce_TCC40 0
  (typed_reduce_TCC40-2 "" 3720295009
   ("" (skeep* :preds? t)
    (("" (use updateReduce_redex)
      (("1" (case "update?(nS`state`redex)")
        (("1" (assert)
          (("1"
            (case "leaft?(nS`redex_type) AND leaftype(nS`redex_type) > 0")
            (("1"
              (name-replace "nS2"
               "set_new_type(nS, leaftype(nS`redex_type) - 1)")
              (("1"
                (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
                (("1" (expand set_new_type)
                  (("1" (replace -1)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (typepred "nS`redex_type")
                          (("1" (expand is_well_typed -1)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -1)
                                    (("2"
                                      (typepred "nS2`stack_types")
                                      (("2"
                                        (inst
                                         -2
                                         "nS2`stack_types`length - 1 - index(target(nS2`state`redex))")
                                        (("1"
                                          (case
                                           "variable?(target(nS`state`redex))")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand is_well_typed -5)
                                              (("1"
                                                (rewrite
                                                 value_well_typed
                                                 +)
                                                (("1"
                                                  (expand nS2)
                                                  (("1"
                                                    (expand
                                                     set_new_type)
                                                    (("1"
                                                      (expand get)
                                                      (("1"
                                                        (replace*)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (typepred "nS2`state`redex")
                                          (("2"
                                            (inst
                                             -2
                                             "index(target(nS2`state`redex))")
                                            (("2"
                                              (split -2)
                                              (("1"
                                                (expand nS2)
                                                (("1"
                                                  (expand set_new_type)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand nS2)
                                                (("2"
                                                  (expand set_new_type)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1)
                                    (("3"
                                      (typepred "nS2`redex_type")
                                      (("3"
                                        (expand nS2)
                                        (("3"
                                          (expand set_new_type)
                                          (("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand nS2) (("2" (assert) nil nil)) nil)
                 ("3" (flatten) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil)
             ("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed -) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand updateRedex?) (("2" (propax) nil nil)) nil))
        nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((updateReduce_redex formula-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (> const-decl "bool" reals nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types)}"))
  (typed_reduce_TCC40-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use updateReduce_redex)
      (("1" (case "update?(nS`state`redex)")
        (("1" (assert)
          (("1"
            (case "leaft?(nS`redex_type) AND leaftype(nS`redex_type) > 0")
            (("1"
              (name-replace "nS2"
               "set_new_type(nS, leaftype(nS`redex_type) - 1)")
              (("1"
                (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
                (("1" (expand set_new_type)
                  (("1" (replace -1)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (typepred "nS`redex_type")
                          (("1" (expand is_well_typed -1)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -1)
                                    (("2"
                                      (typepred "nS2`stack_types")
                                      (("2"
                                        (inst
                                         -2
                                         "nS2`stack_types`length - 1 - index(target(nS2`state`redex))")
                                        (("1"
                                          (case
                                           "variable?(target(nS`state`redex))")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand is_well_typed -5)
                                              (("1"
                                                (rewrite
                                                 value_well_typed
                                                 +)
                                                (("1"
                                                  (expand nS2)
                                                  (("1"
                                                    (expand
                                                     set_new_type)
                                                    (("1"
                                                      (expand get)
                                                      (("1"
                                                        (replace*)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (typepred "nS2`state`redex")
                                          (("2"
                                            (inst
                                             -2
                                             "index(target(nS2`state`redex))")
                                            (("2"
                                              (split -2)
                                              (("1"
                                                (expand nS2)
                                                (("1"
                                                  (expand set_new_type)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand nS2)
                                                (("2"
                                                  (expand set_new_type)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1)
                                    (("3"
                                      (typepred "nS2`redex_type")
                                      (("3"
                                        (expand nS2)
                                        (("3"
                                          (expand set_new_type)
                                          (("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand nS2) (("2" (propax) nil nil)) nil)
                 ("3" (flatten) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil)
             ("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed -) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand updateRedex?) (("2" (propax) nil nil)) nil))
        nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC41 0
  (typed_reduce_TCC41-2 "" 3720295246
   ("" (skeep* :preds? t)
    (("" (rewrite updateReduce_context)
      (("1"
        (case-replace
         "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1"
          (case "leaft?(nS`redex_type) AND leaftype(nS`redex_type) - 1 >= 0")
          (("1"
            (name "nS2"
                  "set_new_type(nS, leaftype(nS`redex_type) - 1)")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten) nil nil))
            nil)
           ("2" (case "update?(nS`state`redex)")
            (("1" (assert)
              (("1" (typepred "nS`redex_type")
                (("1" (expand is_well_typed)
                  (("1" (prop) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (delete 7)
          (("2" (case-replace "popDepth(nS`state`redex) = 0")
            (("1" (use updateReduce_redex)
              (("1" (split)
                (("1" (replace*)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (rewrite -1)
                  (("2"
                    (typepred
                     "get(nS`state`stack)(target(nS`state`redex))")
                    (("2"
                      (name-replace u
                       "get(nS`state`stack)(target(nS`state`redex))")
                      (("2" (hide-all-but (1 -1))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replace*) nil nil))
                nil)
               ("2" (split)
                (("1" (replace*)
                  (("1"
                    (expand* make_redex_typed typed_to_topstate
                     make_redex to_topstate)
                    nil nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (case "update?(nS`state`redex)")
                (("1" (assert)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 6)
        (("2" (replace*)
          (("2"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((updateReduce_context formula-decl nil typed_rreduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (updateReduce_redex formula-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}"))
  (typed_reduce_TCC41-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (rewrite updateReduce_context)
      (("1"
        (case-replace
         "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1"
          (case "leaft?(nS`redex_type) AND leaftype(nS`redex_type) - 1 >= 0")
          (("1"
            (name "nS2"
                  "set_new_type(nS, leaftype(nS`redex_type) - 1)")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten) nil nil))
            nil)
           ("2" (case "update?(nS`state`redex)")
            (("1" (assert)
              (("1" (typepred "nS`redex_type")
                (("1" (expand is_well_typed)
                  (("1" (prop) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (delete 7)
          (("2" (case-replace "popDepth(nS`state`redex) = 0")
            (("1" (use updateReduce_redex)
              (("1" (split)
                (("1" (replace*)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (rewrite -1)
                  (("2"
                    (typepred
                     "get(nS`state`stack)(target(nS`state`redex))")
                    (("2"
                      (name-replace u
                       "get(nS`state`stack)(target(nS`state`redex))")
                      (("2" (hide-all-but (1 -1))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replace*) nil nil))
                nil)
               ("2" (split)
                (("1" (replace*)
                  (("1"
                    (expand* make_redex_typed typed_to_topstate
                     make_redex to_topstate)
                    nil nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (case "update?(nS`state`redex)")
                (("1" (assert)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 6)
        (("2" (replace*)
          (("2"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (unmark def-decl "IExpression" preprocess nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (get const-decl "(value?)" IL nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.updateReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_reduce_TCC42 0
  (typed_reduce_TCC42-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))
 (typed_reduce_TCC43 0
  (typed_reduce_TCC43-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use lookupReduce_ndr)
      (("1" (use lookupReduce_arm)
        (("1" (split -1)
          (("1" (grind) nil nil) ("2" (propax) nil nil)
           ("3" (typepred "nS`state") (("3" (propax) nil nil)) nil)
           ("4" (typepred "nS`state") (("4" (propax) nil nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (replace*)
          (("2"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (lookupReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC44 0
  (typed_reduce_TCC44-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (expand release_marked)
        (("" (expand setRedex)
          (("" (assert)
            (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "rstate" rreduction nil)
    (setRedex const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (release_marked const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC45 0
  (typed_reduce_TCC45-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (lemma stack_still_typed)
      (("" (inst?)
        (("1" (inst -1 "nS`state`stack")
          (("1" (split -1)
            (("1" (propax) nil nil)
             ("2" (typepred "nS`stack_types") (("2" (propax) nil nil))
              nil)
             ("3" (delete 8)
              (("3" (expand lookupReduce)
                (("3" (expand release_marked)
                  (("3" (expand setRedex) (("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "nS`stack_types") (("4" (propax) nil nil))
              nil)
             ("5" (delete 8)
              (("5" (skeep* :preds? t)
                (("5" (expand lookupReduce)
                  (("5" (expand release_marked)
                    (("5" (expand setRedex) (("5" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (split)
          (("1" (replace*)
            (("1"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil)
           ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((stack_still_typed formula-decl nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (setRedex const-decl "rstate" rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC46 0
  (typed_reduce_TCC46-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand lookupRedex?)
      (("" (expand lookupReduce)
        (("" (expand setRedex)
          (("" (expand release_marked)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand is_well_typed + 1)
                    (("1" (rewrite value_well_typed)
                      (("1" (typepred "nS`redex_type")
                        (("1" (expand is_well_typed)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace
                                   "leaftype(nS`redex_type) = nS`dom_types(refindex(get(nS`state`stack)
                                     (arrayvalue(nS`state`redex))))")
                                  (("1"
                                    (typepred "nS`dom_types")
                                    (("1" (inst?) nil nil))
                                    nil)
                                   ("2"
                                    (delete 2)
                                    (("2"
                                      (expand is_well_typed -)
                                      (("2"
                                        (typepred "nS`stack_types")
                                        (("2"
                                          (inst
                                           -2
                                           "nS`stack_types`length - 1 - index(arrayvalue(nS`state`redex))")
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (use
                                             lookupRedex_arrayvalue_index)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (replace*)
                                              (("2"
                                                (expand*
                                                 make_redex_typed
                                                 typed_to_topstate
                                                 make_redex
                                                 to_topstate)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "nS`redex_type")
                  (("2" (flatten) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex_arrayvalue_index formula-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC47 0
  (typed_reduce_TCC47-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "lookupReduce(D)(nS`state)`context = nS`state`context")
      (("1"
        (case-replace
         "popDepth(lookupReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1" (typepred "nS`context_type") (("1" (propax) nil nil))
          nil)
         ("2" (case-replace "popDepth(nS`state`redex) = 0")
          (("1" (delete 8)
            (("1" (expand lookupReduce)
              (("1" (expand* release_marked setRedex)
                (("1" (assert)
                  (("1" (expand popDepth + 1)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1"
                            (typepred "nS`state`store
                   (refindex(get(nS`state`stack)
                                (arrayvalue(nS`state`redex))))`seq
                   (value(get(nS`state`stack)(position(nS`state`redex))))")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (delete 2 9)
            (("2" (delete -1)
              (("2" (case "lookup?(nS`state`redex)")
                (("1" (assert)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 8)
        (("2" (expand lookupReduce)
          (("2" (expand* release_marked setRedex)
            (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release_marked const-decl "rstate" rreduction nil)
    (setRedex const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.lookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_reduce_TCC48 0
  (typed_reduce_TCC48-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IL.newintRedex?(rreduction.grS`redex)}")))
 (typed_reduce_TCC49 0
  (typed_reduce_TCC49-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use newintReduce_ndr)
      (("1" (use newintReduce_arm)
        (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (split)
        (("1" (replace*)
          (("1"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((newintReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (newintReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC50 0
  (typed_reduce_TCC50-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.leaft?)")))
 (typed_reduce_TCC51 0
  (typed_reduce_TCC51-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)"
    "nat")))
 (typed_reduce_TCC52 0
  (typed_reduce_TCC52-2 "" 3720295430
   ("" (skeep* :preds? t)
    ((""
      (name-replace "nS2"
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
        (("1" (expand set_new_type -1)
          (("1" (rewrite -1)
            (("1" (split)
              (("1" (skeep)
                (("1" (typepred "nS2`dom_types(x1)")
                  (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep* :preds? t)
                (("2" (expand newintReduce)
                  (("2" (case-replace "r = least_out(nS`state`domain)")
                    (("1" (simplify)
                      (("1" (expand nS2)
                        (("1" (expand set_new_type)
                          (("1" (expand value_of_type)
                            (("1" (typepred "nS`redex_type")
                              (("1"
                                (expand newintRedex?)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand is_well_typed)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lift-if)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst?)
                            (("1" (inst -1 j)
                              (("1"
                                (expand* nS2 set_new_type)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (expand* nS2 set_new_type)
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (expand* nS2 set_new_type)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (assert) nil nil)) nil)
         ("3" (delete 9)
          (("3" (expand newintRedex?)
            (("3" (assert)
              (("3" (typepred "nS`redex_type")
                (("3" (expand is_well_typed) (("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 9)
        (("2" (expand newintRedex?)
          (("2" (assert)
            (("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (delete 9)
        (("3" (expand newintRedex?)
          (("3" (assert)
            (("3" (typepred "nS`redex_type")
              (("3" (expand is_well_typed) (("3" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (member const-decl "bool" sets nil)
    (j skolem-const-decl
     "below(newintReduce(D)(nS`state)`store(r)`length)"
     typed_rreduction nil)
    (r skolem-const-decl "(newintReduce(D)(nS`state)`domain)"
     typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype
    "typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (typed_reduce_TCC52-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (name-replace "nS2"
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
        (("1" (expand set_new_type -1)
          (("1" (rewrite -1)
            (("1" (split)
              (("1" (skeep)
                (("1" (typepred "nS2`dom_types(x1)")
                  (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep* :preds? t)
                (("2" (expand newintReduce)
                  (("2" (case-replace "r = least_out(nS`state`domain)")
                    (("1" (simplify)
                      (("1" (expand nS2)
                        (("1" (expand set_new_type)
                          (("1" (expand value_of_type)
                            (("1" (typepred "nS`redex_type")
                              (("1"
                                (expand newintRedex?)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand is_well_typed)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lift-if)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst?)
                            (("1" (inst -1 j)
                              (("1" (expand* nS2 set_new_type) nil nil)
                               ("2"
                                (expand* nS2 set_new_type)
                                nil
                                nil))
                              nil)
                             ("2" (expand* nS2 set_new_type)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (propax) nil nil)) nil)
         ("3" (delete 9)
          (("3" (expand newintRedex?)
            (("3" (assert)
              (("3" (typepred "nS`redex_type")
                (("3" (expand is_well_typed) (("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 9)
        (("2" (expand newintRedex?)
          (("2" (assert)
            (("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (delete 9)
        (("3" (expand newintRedex?)
          (("3" (assert)
            (("3" (typepred "nS`redex_type")
              (("3" (expand is_well_typed) (("3" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (member const-decl "bool" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (unmark def-decl "IExpression" preprocess nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil))
   nil
   (typed_reduce subtype
    "typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC53 0
  (typed_reduce_TCC53-2 "" 3720295621
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (assert)
              ((""
                (name-replace "nS2"
                 "set_new_type(nS, leaftype(nS`redex_type) - 1)")
                (("1"
                  (case-replace
                   "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
                  (("1" (expand set_new_type -1)
                    (("1" (rewrite -1)
                      (("1" (typepred "nS2`stack_types")
                        (("1" (expand newintReduce)
                          (("1" (expand* nS2 set_new_type)
                            (("1" (skeep)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand* nS2 set_new_type)
                                    (("2"
                                      (typepred i)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand nS2) (("2" (assert) nil nil)) nil)
                   ("3" (replace*) (("3" (assert) nil nil)) nil))
                  nil)
                 ("2" (replace*) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (i skolem-const-decl "below(nS`stack_types`length)"
       typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]))}"))
  (typed_reduce_TCC53-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (assert)
              ((""
                (name-replace "nS2"
                 "set_new_type(nS, leaftype(nS`redex_type) - 1)")
                (("1"
                  (case-replace
                   "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
                  (("1" (expand set_new_type -1)
                    (("1" (rewrite -1)
                      (("1" (typepred "nS2`stack_types")
                        (("1" (expand newintReduce)
                          (("1" (expand* nS2 set_new_type)
                            (("1" (skeep)
                              (("1"
                                (inst?)
                                (("1"
                                  (expand* nS2 set_new_type)
                                  (("1"
                                    (typepred i)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand nS2) (("2" (propax) nil nil)) nil)
                   ("3" (replace*) (("3" (assert) nil nil)) nil))
                  nil)
                 ("2" (replace*) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]))}")))
 (typed_reduce_TCC54 0
  (typed_reduce_TCC54-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      (("" (expand is_well_typed)
        (("" (expand newintRedex?)
          (("" (assert)
            (("" (typepred "nS`redex_type")
              (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "rstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC55 0
  (typed_reduce_TCC55-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (expand newintRedex?)
        (("" (assert)
          (("" (expand is_well_typed)
            (("" (assert)
              ((""
                (name-replace "rS2"
                 "set_new_type(nS, leaftype(nS`redex_type) - 1)")
                (("1" (expand newintReduce)
                  (("1" (typepred "rS2`context_type")
                    (("1"
                      (case-replace
                       "popDepth(ref(least_out(nS`state`domain))) = popDepth(rS2`state`redex)")
                      (("1" (expand* rS2 set_new_type) nil nil)
                       ("2" (expand* rS2 set_new_type)
                        (("2" (assert)
                          (("2" (expand popDepth)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (newintReduce const-decl "rstate" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newintRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.newintReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_reduce_TCC56 0
  (typed_reduce_TCC56-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))
 (typed_reduce_TCC57 0
  (typed_reduce_TCC57-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use newrefReduce_ndr)
      (("1" (use newrefReduce_arm)
        (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (typepred "D`seq(x1)`body")
            (("2" (split)
              (("1" (skeep)
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (split)
        (("1" (replace*)
          (("1"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((newrefReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (newrefReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC58 0
  (typed_reduce_TCC58-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.leaft?)")))
 (typed_reduce_TCC59 0
  (typed_reduce_TCC59-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "(number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)"
    "nat")))
 (typed_reduce_TCC60 0
  (typed_reduce_TCC60-2 "" 3720295721
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (split)
                    (("1" (skeep)
                      (("1" (typepred "nS2`dom_types(x1)")
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep* :preds? t)
                      (("2" (expand newrefReduce)
                        (("2"
                          (case-replace
                           "r = least_out(nS`state`domain)")
                          (("1" (simplify)
                            (("1" (expand value_of_type)
                              (("1" (propax) nil nil)) nil))
                            nil)
                           ("2" (lift-if)
                            (("2" (assert)
                              (("2"
                                (typepred "nS2`dom_types")
                                (("2"
                                  (inst -1 r j)
                                  (("1"
                                    (expand* nS2 set_new_type)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (expand* nS2 set_new_type)
                                    (("2" (assert) nil nil))
                                    nil)
                                   ("3"
                                    (expand* nS2 set_new_type)
                                    (("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (r skolem-const-decl "(newrefReduce(D)(nS`state)`domain)"
     typed_rreduction nil)
    (j skolem-const-decl
     "below(newrefReduce(D)(nS`state)`store(r)`length)"
     typed_rreduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype
    "typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (typed_reduce_TCC60-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (split)
                    (("1" (skeep)
                      (("1" (typepred "nS2`dom_types(x1)")
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep* :preds? t)
                      (("2" (expand newrefReduce)
                        (("2"
                          (case-replace
                           "r = least_out(nS`state`domain)")
                          (("1" (simplify)
                            (("1" (expand value_of_type)
                              (("1" (propax) nil nil)) nil))
                            nil)
                           ("2" (lift-if)
                            (("2" (assert)
                              (("2"
                                (typepred "nS2`dom_types")
                                (("2"
                                  (inst -1 r j)
                                  (("1"
                                    (expand* nS2 set_new_type)
                                    nil
                                    nil)
                                   ("2"
                                    (expand* nS2 set_new_type)
                                    nil
                                    nil)
                                   ("3"
                                    (expand* nS2 set_new_type)
                                    (("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (newrefReduce const-decl "rstate" rreduction nil))
   nil
   (typed_reduce subtype
    "typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]"
    "{dom_types | FORALL (r: (rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC61 0
  (typed_reduce_TCC61-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (typepred "nS2`stack_types")
                    (("" (expand newrefReduce)
                      (("" (expand* nS2 set_new_type)
                        (("" (skeep :preds? t)
                          (("" (inst?)
                            (("1" (assert) nil nil)
                             ("2" (expand* nS2 set_new_type) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (i skolem-const-decl "below(nS`stack_types`length)"
       typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)]))}")))
 (typed_reduce_TCC62 0
  (typed_reduce_TCC62-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      (("" (expand is_well_typed)
        (("" (expand newrefRedex?)
          (("" (assert)
            (("" (typepred "nS`redex_type")
              (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC63 0
  (typed_reduce_TCC63-2 "" 3720295887
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (typepred "nS2`context_type")
                    ((""
                      (case-replace
                       "popDepth(newrefReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
                      (("1" (expand newrefReduce)
                        (("1" (expand* nS2 set_new_type)
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (expand newrefReduce)
                        (("2" (expand popDepth)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (nS2 skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}"))
  (typed_reduce_TCC63-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (typepred "nS2`context_type")
                    ((""
                      (case-replace
                       "popDepth(newrefReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
                      (("1" (expand newrefReduce)
                        (("1" (expand* nS2 set_new_type) nil nil)) nil)
                       ("2" (expand newrefReduce)
                        (("2" (expand popDepth)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.newrefReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types WITH [(finite_set_theorems.least_out(typed_rreduction.nS`state`domain)) |-> (number_fields.-)(typeinfo_adt.leaftype(typed_rreduction.nS`redex_type), 1)], typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_reduce_TCC64 0
  (typed_reduce_TCC64-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | booleans.AND(IL.popRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (typed_reduce_TCC65 0
  (typed_reduce_TCC65-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (use popReduce_ndr)
        (("1" (use popReduce_arm)
          (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (typepred "D`seq(x1)`body")
              (("2" (split)
                (("1" (skeep)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (replace*)
          (("2"
            (expand* typed_to_topstate make_redex_typed to_topstate
             make_redex)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (popReduce_arm formula-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce_ndr judgement-tcc nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC66 0
  (typed_reduce_TCC66-2 "" 3720295926
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((popReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (typed_reduce_TCC66-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((popReduce const-decl "rstate" rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (popRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC67 0
  (typed_reduce_TCC67-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`stack_types")
      (("" (typepred "nS`state`redex")
        (("" (case "popDepth(nS`state`redex) > 0")
          (("1" (grind) nil nil)
           ("2" (expand popRedex?)
            (("2" (flatten)
              (("2" (assert)
                (("2" (expand popDepth) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "nonempty_fs[nat]")))
 (typed_reduce_TCC68 0
  (typed_reduce_TCC68-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (expand popReduce)
        (("1" (assert)
          (("1" (expand pop)
            (("1" (expand tail)
              (("1" (typepred "nS`stack_types")
                (("1" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep :preds? t)
        (("2" (expand popReduce)
          (("2" (expand pop)
            (("2" (lift-if)
              (("2" (expand tail)
                (("2" (assert)
                  (("2" (typepred "nS`stack_types")
                    (("2" (inst?)
                      (("2" (ground) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((tail const-decl "finseq[T]" finseq_theorems nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (> const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "finseq_theorems[naturalnumbers.nat].tail(typed_rreduction.nS`stack_types)"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC69 0
  (typed_reduce_TCC69-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "pop?(nS`state`redex)")
        (("1" (assert)
          (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "(typeinfo_adt.popt?)")))
 (typed_reduce_TCC70 0
  (typed_reduce_TCC70-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand popRedex?)
            (("" (flatten)
              (("" (assert)
                (("" (expand is_well_typed -)
                  (("" (flatten)
                    (("" (rewrite value_well_typed)
                      (("" (rewrite value_well_typed) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (popRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "typeinfo_adt.ptbody(typed_rreduction.nS`redex_type)"
    "{tA | typed_reduction.is_well_typed(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, finseq_theorems[naturalnumbers.nat].tail(typed_rreduction.nS`stack_types), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC71 0
  (typed_reduce_TCC71-2 "" 3720306957
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(popReduce(D)(nS`state)`redex) = 0")
      (("1" (expand popReduce +)
        (("1" (expand popRedex?)
          (("1" (flatten)
            (("1" (assert)
              (("1" (typepred "nS`context_type")
                (("1"
                  (case-replace
                   "expr_type(nS`redex_type) = expr_type(ptbody(nS`redex_type))")
                  (("1"
                    (case-replace
                     "popn(nS`stack_types, popDepth(nS`state`redex)) = tail[nat](nS`stack_types)")
                    (("1" (case-replace "popDepth(nS`state`redex) = 1")
                      (("1" (hide-all-but 1)
                        (("1" (apply-extensionality :hide? t)
                          (("1" (grind) nil nil)
                           ("2" (apply-extensionality :hide? t)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (case "popt?(nS`redex_type)")
                    (("1" (assert)
                      (("1" (expand expr_type + 1)
                        (("1" (propax) nil nil)) nil))
                      nil)
                     ("2" (assert)
                      (("2" (typepred "nS`redex_type")
                        (("2" (expand is_well_typed -)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand popReduce)
        (("2" (hide-all-but (1 -))
          (("2" (expand popRedex?)
            (("2" (flatten)
              (("2" (hide-all-but (1 -3 -4)) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop const-decl "Stack" IL nil) (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(finseq_theorems[naturalnumbers.nat].tail(typed_rreduction.nS`stack_types), IL.popDepth(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typeinfo_adt.ptbody(typed_rreduction.nS`redex_type)))}"))
  (typed_reduce_TCC71-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(popReduce(D)(nS`state)`redex) = 0")
      (("1" (expand popReduce +)
        (("1" (expand popRedex?)
          (("1" (flatten)
            (("1" (assert)
              (("1" (typepred "nS`context_type")
                (("1"
                  (case-replace
                   "expr_type(nS`redex_type) = expr_type(ptbody(nS`redex_type))")
                  (("1"
                    (case-replace
                     "popn(nS`stack_types, popDepth(nS`state`redex)) = tail[nat](nS`stack_types)")
                    (("1" (case-replace "popDepth(nS`state`redex) = 1")
                      (("1" (hide-all-but 1)
                        (("1" (grind-with-ext) nil nil)) nil)
                       ("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (case "popt?(nS`redex_type)")
                    (("1" (assert)
                      (("1" (expand expr_type + 1)
                        (("1" (propax) nil nil)) nil))
                      nil)
                     ("2" (assert)
                      (("2" (typepred "nS`redex_type")
                        (("2" (expand is_well_typed -)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand popReduce)
        (("2" (hide-all-but (1 -))
          (("2" (expand popRedex?)
            (("2" (flatten)
              (("2" (hide-all-but (1 -3 -4)) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (pop const-decl "Stack" IL nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(finseq_theorems[naturalnumbers.nat].tail(typed_rreduction.nS`stack_types), IL.popDepth(rreduction.popReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typeinfo_adt.ptbody(typed_rreduction.nS`redex_type)))}")))
 (typed_reduce_TCC72 0
  (typed_reduce_TCC72-2 "" 3720321687
   ("" (skeep* :preds? t)
    ((""
      (case "NOT nS`state`error AND pureReleaseRedex?(nS`state`redex)")
      (("1" (flatten)
        (("1" (use releasereduce_ndr)
          (("1" (use releasereduce_arm)
            (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)
             ("2" (skeep)
              (("2" (typepred "D`seq(x1)`body")
                (("2" (split)
                  (("1" (skeep)
                    (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("2" (hide 13)
        (("2" (prop)
          (("1" (grind) nil nil)
           ("2" (expand make_redex_typed)
            (("2" (typepred "make_redex(t`state)")
              (("2" (replace -4)
                (("2" (assert)
                  (("2" (expand pureRedex?) (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pureReleaseRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (releaseReduce_ndr judgement-tcc nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (releaseReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | booleans.AND(IL.pureReleaseRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}"))
  (typed_reduce_TCC72-1 nil 3706555818 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_reduce subtype "typed_rreduction.nS`state"
    "{grS | booleans.AND(IL.pureReleaseRedex?(rreduction.grS`redex), rreduction.noDanglingRefs?(rreduction.grS))}")))
 (typed_reduce_TCC73 0
  (typed_reduce_TCC73-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case "NOT nS`state`error AND pureReleaseRedex?(nS`state`redex)")
      (("1" (flatten)
        (("1" (use releaseReduce_ndr)
          (("1" (use releaseReduce_arm)
            (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)
             ("2" (skeep)
              (("2" (typepred "D`seq(x1)`body")
                (("2" (split)
                  (("1" (skeep)
                    (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("2" (use typed_reduce_TCC72)
        (("2" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (propax) nil nil) ("4" (propax) nil nil)
               ("5" (propax) nil nil) ("6" (propax) nil nil)
               ("7" (propax) nil nil) ("8" (propax) nil nil)
               ("9" (propax) nil nil) ("10" (propax) nil nil)
               ("11" (propax) nil nil))
              nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pureReleaseRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (releaseReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (releaseReduce_arm formula-decl nil reduction_props nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (typed_reduce_TCC72 subtype-tcc nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype
    "rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_reduce_TCC74 0
  (typed_reduce_TCC74-2 nil 3705939845
   ("" (skeep* :preds? t)
    ((""
      (case "NOT nS`state`error AND pureReleaseRedex?(nS`state`redex)")
      (("1" (flatten)
        (("1" (use releaseReduce_new_store)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (lemma value_maybe_freed_type)
                (("1" (inst? :where -4)
                  (("1" (inst?)
                    (("1" (split -1)
                      (("1" (propax) nil nil)
                       ("2" (typepred "nS`dom_types")
                        (("2" (inst?) nil nil)) nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("2" (use typed_reduce_TCC72)
        (("2" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (propax) nil nil) ("4" (propax) nil nil)
               ("5" (propax) nil nil) ("6" (propax) nil nil)
               ("7" (propax) nil nil) ("8" (propax) nil nil)
               ("9" (propax) nil nil) ("10" (propax) nil nil)
               ("11" (propax) nil nil))
              nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pureReleaseRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (releaseReduce_new_store formula-decl nil typed_rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (value_maybe_freed_type formula-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (typed_reduce_TCC72 subtype-tcc nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}"))
  (typed_reduce_TCC74-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case "NOT nS`state`error AND pureReleaseRedex?(nS`state`redex)")
      (("1" (flatten)
        (("1" (use releaseReduce_new_store)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (lemma value_maybe_freed_type)
                (("1" (inst? :where -4)
                  (("1" (inst?)
                    (("1" (split -1)
                      (("1" (propax) nil nil)
                       ("2" (typepred "nS`dom_types")
                        (("2" (inst?) nil nil)) nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("2" (use typed_reduce_TCC66)
        (("2" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (propax) nil nil) ("4" (propax) nil nil)
               ("5" (propax) nil nil) ("6" (propax) nil nil)
               ("7" (propax) nil nil) ("8" (propax) nil nil)
               ("9" (propax) nil nil) ("10" (propax) nil nil))
              nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_reduce_TCC75 0
  (typed_reduce_TCC75-2 nil 3705939866
   ("" (skeep* :preds? t)
    (("" (lemma stack_still_typed)
      (("" (inst?)
        (("1" (inst -1 "nS`state`stack")
          (("1" (split -1)
            (("1" (propax) nil nil)
             ("2" (typepred "nS`stack_types") (("2" (propax) nil nil))
              nil)
             ("3" (delete 12)
              (("3" (expand releaseReduce)
                (("3" (expand decref)
                  (("3" (lift-if)
                    (("3" (split)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "nS`stack_types") (("4" (propax) nil nil))
              nil)
             ("5" (skeep* :preds? t)
              (("5" (delete 13)
                (("5" (expand releaseReduce)
                  (("5" (expand decref)
                    (("5" (lift-if)
                      (("5" (split)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1"
                              (case-replace
                               "i = nS`state`stack`length - 1 - index(rvar(nS`state`redex)) - popDepth(nS`state`redex)")
                              (("1"
                                (simplify)
                                (("1" (propax) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (use typed_reduce_TCC72)
          (("2" (split -1)
            (("1" (inst?) (("1" (prop) nil nil)) nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((stack_still_typed formula-decl nil typed_rreduction nil)
    (typed_reduce_TCC72 subtype-tcc nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}"))
  (typed_reduce_TCC75-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (lemma stack_still_typed)
      (("" (inst?)
        (("1" (inst -1 "nS`state`stack")
          (("1" (split -1)
            (("1" (propax) nil nil)
             ("2" (typepred "nS`stack_types") (("2" (propax) nil nil))
              nil)
             ("3" (delete 12)
              (("3" (expand releaseReduce)
                (("3" (expand decref)
                  (("3" (lift-if)
                    (("3" (split)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "nS`stack_types") (("4" (propax) nil nil))
              nil)
             ("5" (skeep* :preds? t)
              (("5" (delete 13)
                (("5" (expand releaseReduce)
                  (("5" (expand decref)
                    (("5" (lift-if)
                      (("5" (split)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1"
                              (case-replace
                               "i = nS`state`stack`length - 1 - index(rvar(nS`state`redex)) - popDepth(nS`state`redex)")
                              (("1"
                                (simplify)
                                (("1" (propax) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (use typed_reduce_TCC66)
          (("2" (split -1)
            (("1" (inst?) (("1" (prop) nil nil)) nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (unmark def-decl "IExpression" preprocess nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_reduce_TCC76 0
  (typed_reduce_TCC76-3 nil 3705940023
   ("" (skeep* :preds? t)
    (("" (expand releaseReduce)
      (("" (expand decref)
        (("" (assert)
          (("" (lift-if)
            ((""
              (case "is_well_typed(rexpr(nS`state`redex), nS`redex_type,
                                nS`stack_types, nS`dom_types, nS`def_types)")
              (("1" (split)
                (("1" (flatten) (("1" (assert) nil nil)) nil)
                 ("2" (flatten) nil nil))
                nil)
               ("2" (delete 13)
                (("2" (use typed_reduce_TCC72)
                  (("2" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`redex_type")
                                (("1"
                                  (expand is_well_typed -)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil) ("3" (propax) nil nil)
                         ("4" (propax) nil nil) ("5" (propax) nil nil)
                         ("6" (propax) nil nil) ("7" (propax) nil nil)
                         ("8" (propax) nil nil) ("9" (propax) nil nil)
                         ("10" (propax) nil nil)
                         ("11" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (delete 13)
                (("3" (use typed_reduce_TCC72)
                  (("3" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`state`redex")
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (typepred "nS`stack_types")
                                      (("2"
                                        (inst
                                         -5
                                         "i-popDepth(nS`state`redex)")
                                        (("1"
                                          (rewrite cvars_vars)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil) ("3" (propax) nil nil)
                         ("4" (propax) nil nil) ("5" (propax) nil nil)
                         ("6" (propax) nil nil) ("7" (propax) nil nil)
                         ("8" (propax) nil nil) ("9" (propax) nil nil)
                         ("10" (propax) nil nil)
                         ("11" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("4" (delete 13)
                (("4" (use typed_reduce_TCC72)
                  (("4" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil) ("4" (propax) nil nil)
                         ("5" (propax) nil nil) ("6" (propax) nil nil)
                         ("7" (propax) nil nil) ("8" (propax) nil nil)
                         ("9" (propax) nil nil) ("10" (propax) nil nil)
                         ("11" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("5" (delete 13)
                (("5" (use typed_reduce_TCC72)
                  (("5" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil) ("4" (propax) nil nil)
                         ("5" (propax) nil nil) ("6" (propax) nil nil)
                         ("7" (propax) nil nil) ("8" (propax) nil nil)
                         ("9" (propax) nil nil) ("10" (propax) nil nil)
                         ("11" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (typed_reduce_TCC72 subtype-tcc nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (i skolem-const-decl "nat" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}"))
  (typed_reduce_TCC76-2 nil 3705939907
   ("" (skeep* :preds? t)
    (("" (expand releaseReduce)
      (("" (expand decref)
        (("" (assert)
          (("" (lift-if)
            ((""
              (case "is_well_typed(rexpr(nS`state`redex), nS`redex_type,
                                nS`stack_types, nS`dom_types, nS`def_types)")
              (("1" (split)
                (("1" (flatten) (("1" (assert) nil)))
                 ("2" (flatten) nil)))
               ("2" (delete 12)
                (("2" (use typed_reduce_TCC72)
                  (("2" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`redex_type")
                                (("1"
                                  (expand is_well_typed -)
                                  (("1" (propax) nil)))))))
                             ("2" (grind) nil)))))
                         ("2" (propax) nil) ("3" (propax) nil)
                         ("4" (propax) nil) ("5" (propax) nil)
                         ("6" (propax) nil) ("7" (propax) nil)
                         ("8" (propax) nil) ("9" (propax) nil)
                         ("10" (propax) nil)))))
                     ("2" (propax) nil) ("3" (propax) nil)))))))
               ("3" (delete 12)
                (("3" (use typed_reduce_TCC72)
                  (("3" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`state`redex")
                                (("1"
                                  (split)
                                  (("1" (grind) nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (typepred "nS`stack_types")
                                      (("2"
                                        (inst
                                         -5
                                         "i-popDepth(nS`state`redex)")
                                        (("1"
                                          (rewrite cvars_vars)
                                          (("1" (grind) nil)))
                                         ("2" (grind) nil)))))))))))))
                             ("2" (grind) nil)))))
                         ("2" (propax) nil) ("3" (propax) nil)
                         ("4" (propax) nil) ("5" (propax) nil)
                         ("6" (propax) nil) ("7" (propax) nil)
                         ("8" (propax) nil) ("9" (propax) nil)
                         ("10" (propax) nil)))))
                     ("2" (propax) nil) ("3" (propax) nil)))))))
               ("4" (delete 12)
                (("4" (use typed_reduce_TCC72)
                  (("4" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil) ("2" (propax) nil)
                         ("3" (propax) nil) ("4" (propax) nil)
                         ("5" (propax) nil) ("6" (propax) nil)
                         ("7" (propax) nil) ("8" (propax) nil)
                         ("9" (propax) nil) ("10" (propax) nil)))))
                     ("2" (propax) nil) ("3" (propax) nil)))))))
               ("5" (delete 12)
                (("5" (use typed_reduce_TCC72)
                  (("5" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil) ("2" (propax) nil)
                         ("3" (propax) nil) ("4" (propax) nil)
                         ("5" (propax) nil) ("6" (propax) nil)
                         ("7" (propax) nil) ("8" (propax) nil)
                         ("9" (propax) nil) ("10" (propax) nil)))))
                     ("2" (propax) nil)
                     ("3" (propax) nil))))))))))))))))))
    nil)
   nil nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}"))
  (typed_reduce_TCC76-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand releaseReduce)
      (("" (expand decref)
        (("" (assert)
          (("" (lift-if)
            ((""
              (case "is_well_typed(rexpr(nS`state`redex), nS`redex_type,
                         nS`stack_types, nS`dom_types, nS`def_types)")
              (("1" (split)
                (("1" (flatten) (("1" (assert) nil nil)) nil)
                 ("2" (flatten) nil nil))
                nil)
               ("2" (delete 12)
                (("2" (use typed_reduce_TCC66)
                  (("2" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`redex_type")
                                (("1"
                                  (expand is_well_typed -)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil) ("3" (propax) nil nil)
                         ("4" (propax) nil nil) ("5" (propax) nil nil)
                         ("6" (propax) nil nil) ("7" (propax) nil nil)
                         ("8" (propax) nil nil) ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (delete 12)
                (("3" (use typed_reduce_TCC66)
                  (("3" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`state`redex")
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (typepred "nS`stack_types")
                                      (("2"
                                        (inst
                                         -5
                                         "i-popDepth(nS`state`redex)")
                                        (("1"
                                          (rewrite cvars_vars)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil) ("3" (propax) nil nil)
                         ("4" (propax) nil nil) ("5" (propax) nil nil)
                         ("6" (propax) nil nil) ("7" (propax) nil nil)
                         ("8" (propax) nil nil) ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("4" (delete 12)
                (("4" (use typed_reduce_TCC66)
                  (("4" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil) ("4" (propax) nil nil)
                         ("5" (propax) nil nil) ("6" (propax) nil nil)
                         ("7" (propax) nil nil) ("8" (propax) nil nil)
                         ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("5" (delete 12)
                (("5" (use typed_reduce_TCC66)
                  (("5" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil) ("4" (propax) nil nil)
                         ("5" (propax) nil nil) ("6" (propax) nil nil)
                         ("7" (propax) nil nil) ("8" (propax) nil nil)
                         ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((releaseReduce const-decl "rstate" rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (cvars_vars formula-decl nil preprocess nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_reduce_TCC77 0
  (typed_reduce_TCC77-2 nil 3705940070
   ("" (skeep* :preds? t)
    (("" (use typed_reduce_TCC72)
      (("" (split -1)
        (("1" (inst?)
          (("1" (split -1)
            (("1" (flatten)
              (("1"
                (case-replace
                 "releaseReduce(D)(nS`state)`context = nS`state`context")
                (("1"
                  (case-replace
                   "popDepth(releaseReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
                  (("1" (typepred "nS`context_type")
                    (("1" (propax) nil nil)) nil)
                   ("2" (expand releaseReduce 1)
                    (("2" (delete 14)
                      (("2" (delete -1)
                        (("2" (lift-if)
                          (("2" (split)
                            (("1" (flatten)
                              (("1"
                                (expand decref)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case "release?(nS`state`redex)")
                                    (("1"
                                      (assert)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (case "release?(nS`state`redex)")
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 14)
                  (("2" (expand releaseReduce)
                    (("2" (expand decref)
                      (("2" (assert)
                        (("2" (lift-if)
                          (("2" (split)
                            (("1" (flatten) (("1" (assert) nil nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil)
             ("4" (propax) nil nil) ("5" (propax) nil nil)
             ("6" (propax) nil nil) ("7" (propax) nil nil)
             ("8" (propax) nil nil) ("9" (propax) nil nil)
             ("10" (propax) nil nil) ("11" (propax) nil nil))
            nil))
          nil)
         ("2" (propax) nil nil) ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((typed_reduce_TCC72 subtype-tcc nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}"))
  (typed_reduce_TCC77-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use typed_reduce_TCC66)
      (("" (split -1)
        (("1" (inst?)
          (("1" (split -1)
            (("1" (flatten)
              (("1"
                (case-replace
                 "releaseReduce(D)(nS`state)`context = nS`state`context")
                (("1"
                  (case-replace
                   "popDepth(releaseReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
                  (("1" (typepred "nS`context_type")
                    (("1" (propax) nil nil)) nil)
                   ("2" (expand releaseReduce 1)
                    (("2" (delete 13)
                      (("2" (delete -1)
                        (("2" (lift-if)
                          (("2" (split)
                            (("1" (flatten)
                              (("1"
                                (expand decref)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case "release?(nS`state`redex)")
                                    (("1"
                                      (assert)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (case "release?(nS`state`redex)")
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 13)
                  (("2" (expand releaseReduce)
                    (("2" (expand decref)
                      (("2" (assert)
                        (("2" (lift-if)
                          (("2" (split)
                            (("1" (flatten) (("1" (assert) nil nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil)
             ("4" (propax) nil nil) ("5" (propax) nil nil)
             ("6" (propax) nil nil) ("7" (propax) nil nil)
             ("8" (propax) nil nil) ("9" (propax) nil nil)
             ("10" (propax) nil nil))
            nil))
          nil)
         ("2" (propax) nil nil) ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (pure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil))
   nil
   (typed_reduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(rreduction.releaseReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_reduce_defs 0
  (typed_reduce_defs-1 nil 3703344804
   ("" (skeep :preds? t)
    (("" (expand typed_reduce)
      (("" (expand* make_redex_typed typed_to_topstate) nil nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_reduce const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil))
   shostak))
 (typed_reduce_state_TCC1 0
  (typed_reduce_state_TCC1-1 nil 3703344804 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_reduce_state subtype "typed_rreduction.tS`state"
    "{grS | rreduction.noDanglingRefs?(rreduction.grS)}")))
 (typed_reduce_state 0
  (typed_reduce_state-2 "" 3720321890
   ("" (skeep* :preds? t)
    (("" (expand typed_reduce)
      (("" (typepred "typed_to_topstate(tS)`state")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_reduce const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (letReduce const-decl "rstate" rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (release_marked const-decl "rstate" rreduction nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (reduce const-decl "rstate" rreduction nil)
    (reduce_ndr application-judgement "(noDanglingRefs?)" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil) nil
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil))
   shostak)
  (typed_reduce_state-1 nil 3703344859
   ("" (skeep* :preds? t)
    (("" (expand typed_reduce)
      (("" (expand reduce)
        (("" (expand* make_redex_typed typed_to_topstate) nil nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "rtopstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (get const-decl "(value?)" IL nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (push const-decl "Stack" IL nil)
    (letReduce const-decl "rstate" rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (release_marked const-decl "rstate" rreduction nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}"
     rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (update_store const-decl "{((newstr: Store(dom)),
  (newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil)
    (decref1_chk const-decl "{rS1 |
   rS1`domain = rS`domain AND
    (FORALL (s: (rS`domain)):
       rS1`store(s)`length = rS`store(s)`length AND
        rS1`count(s) <= rS`count(s) AND
         (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}" rreduction
     nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (reduce const-decl "rstate" rreduction nil)
    (reduce_ndr application-judgement "(noDanglingRefs?)" rreduction
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil))
   shostak))
 (reduce_stack_length_TCC1 0
  (reduce_stack_length_TCC1-1 nil 3703867850 ("" (subtype-tcc) nil nil)
   nil nil
   (reduce_stack_length subtype "typed_rreduction.grS"
    "{grS | rreduction.noDanglingRefs?(rreduction.grS)}")))
 (reduce_stack_length 0
  (reduce_stack_length-4 "" 3720323146
   ("" (skeep* :preds? t)
    (("" (expand reduce :assert? none)
      (("" (name-replace "t" "to_topstate(grS)")
        (("" (case "value?(t`redex)")
          (("1" (assert)
            (("1" (expand* t to_topstate)
              (("1" (rewrite popdepth_fill) (("1" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (simplify :let-reduce? t)
            (("2" (name-replace "nS" "make_redex(t)")
              (("2"
                (case-replace
                 "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = nS`stack`length - popDepth(nS`redex) - popDepth(nS`context)")
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (expand variableReduce)
                          (("1" (assert)
                            (("1" (expand popDepth 1 1)
                              (("1"
                                (typepred "get(nS`stack)(nS`redex)")
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (expand letReduce)
                              (("1"
                                (expand* push add)
                                (("1"
                                  (expand popDepth + (2 3 4))
                                  (("1"
                                    (expand popDepth + 2)
                                    (("1"
                                      (case "letexpr?(nS`redex)")
                                      (("1"
                                        (case-replace
                                         "popDepth(body(nS`redex)) = 0")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (use purePopDepth)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand applyReduce)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (rewrite popdepth_letApply)
                                          (("1"
                                            (rewrite popDepth_mark)
                                            (("1"
                                              (case-replace
                                               "popDepth(nS`redex) = 0")
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (typepred
                                                       "D`seq(fun(nS`redex))`body")
                                                      (("1"
                                                        (rewrite
                                                         purePopDepth)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand ifReduce)
                                      (("1"
                                        (expand release_marked)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand popDepth + (2 4))
                                            (("1"
                                              (case-replace
                                               "popDepth(nS`redex) = 0")
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (rewrite
                                                       purePopDepth)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (rewrite
                                                       purePopDepth)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (case-replace
                                           "updateReduce(D)(nS)`stack`length = nS`stack`length")
                                          (("1"
                                            (rewrite
                                             updateReduce_context)
                                            (("1"
                                              (use updateReduce_redex)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case-replace
                                                   "popDepth(nS`redex) = 0")
                                                  (("1"
                                                    (split)
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (expand
                                                         popDepth)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (replace -1)
                                                      (("2"
                                                        (typepred
                                                         "get(nS`stack)(target(nS`redex))")
                                                        (("2"
                                                          (hide-all-but
                                                           (1 -1))
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but
                                                     (1 -3))
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (split)
                                                (("1"
                                                  (expand*
                                                   nS
                                                   t
                                                   make_redex
                                                   to_topstate)
                                                  nil
                                                  nil)
                                                 ("2"
                                                  (expand nS)
                                                  (("2"
                                                    (hide (-1 -2 2))
                                                    (("2"
                                                      (lemma
                                                       make_redex_ndr)
                                                      (("2"
                                                        (inst -1 t)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (expand*
                                                 nS
                                                 t
                                                 make_redex
                                                 to_topstate)
                                                nil
                                                nil)
                                               ("2"
                                                (expand nS)
                                                (("2"
                                                  (lemma
                                                   make_redex_ndr)
                                                  (("2"
                                                    (inst -1 t)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use
                                             updateReduce_new_stack)
                                            (("1" (flatten) nil nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (expand*
                                                 nS
                                                 t
                                                 make_redex
                                                 to_topstate)
                                                nil
                                                nil)
                                               ("2"
                                                (lemma make_redex_ndr)
                                                (("2"
                                                  (inst -1 t)
                                                  (("2"
                                                    (expand nS)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand lookupReduce)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand*
                                                       release_marked
                                                       setRedex)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand
                                                           popDepth
                                                           +
                                                           2)
                                                          (("1"
                                                            (typepred
                                                             "nS`store(refindex(get(nS`stack)(arrayvalue(nS`redex))))`seq
                                                           (value(get(nS`stack)(position(nS`redex))))")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand newintReduce)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       newrefReduce)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (split)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           popReduce)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               pop)
                                                              (("1"
                                                                (case-replace
                                                                 "popDepth(nS`redex) = 1")
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (expand
                                                           releaseReduce)
                                                          (("2"
                                                            (expand
                                                             decref)
                                                            (("2"
                                                              (lift-if)
                                                              (("2"
                                                                (split)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (case
                                                                       "releaseRedex?(nS`redex)")
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         nS)
                                                                        (("2"
                                                                          (expand
                                                                           make_redex)
                                                                          (("2"
                                                                            (typepred
                                                                             "buildRedex(t`redex)")
                                                                            (("2"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (case
                                                                       "releaseRedex?(nS`redex)")
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (expand*
                                                                         nS
                                                                         make_redex)
                                                                        (("2"
                                                                          (typepred
                                                                           "buildRedex(t`redex)")
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 3)
                  (("2"
                    (case-replace
                     "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = t`stack`length - popDepth(t`redex) - popDepth(t`context)")
                    (("1" (expand nS)
                      (("1" (expand make_redex)
                        (("1" (typepred "buildRedex(t`redex)")
                          (("1" (replace -1 :dir RL)
                            (("1" (rewrite popdepth_fill)
                              (("1"
                                (replace -1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* t to_topstate)
                      (("2" (rewrite popdepth_fill)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce const-decl "rstate" rreduction nil) nil
    (bumpn const-decl "finite_set[nat]" IL nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (popdepth_fill formula-decl nil IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letReduce const-decl "rstate" rreduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (push const-decl "Stack" IL nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (length def-decl "nat" list_props nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (applyRedex? const-decl "bool" IL nil)
    (popDepth_mark formula-decl nil preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (release_marked const-decl "rstate" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (updateReduce_redex formula-decl nil typed_rreduction nil) nil
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (updateReduce_context formula-decl nil typed_rreduction nil)
    (updateReduce_new_stack formula-decl nil typed_rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (pop const-decl "Stack" IL nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil) nil
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) nil nil nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (reduce_stack_length-3 nil 3705950281
   ("" (skeep* :preds? t)
    (("" (expand reduce :assert? none)
      (("" (name-replace "t" "to_topstate(grS)")
        (("" (case "value?(t`redex)")
          (("1" (assert)
            (("1" (expand* t to_topstate)
              (("1" (rewrite popdepth_fill) (("1" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (simplify :let-reduce? t)
            (("2" (name-replace "nS" "make_redex(t)")
              (("2"
                (case-replace
                 "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = nS`stack`length - popDepth(nS`redex) - popDepth(nS`context)")
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (expand variableReduce)
                          (("1" (assert)
                            (("1" (expand popDepth 1 1)
                              (("1"
                                (typepred "get(nS`stack)(nS`redex)")
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (expand letReduce)
                              (("1"
                                (expand* push add)
                                (("1"
                                  (expand popDepth + (2 3 4))
                                  (("1"
                                    (expand popDepth + 2)
                                    (("1"
                                      (case "letexpr?(nS`redex)")
                                      (("1"
                                        (case-replace
                                         "popDepth(body(nS`redex)) = 0")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (use purePopDepth)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand applyReduce)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (rewrite popdepth_letApply)
                                          (("1"
                                            (rewrite popDepth_mark)
                                            (("1"
                                              (case-replace
                                               "popDepth(nS`redex) = 0")
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (typepred
                                                       "D`seq(fun(nS`redex))`body")
                                                      (("1"
                                                        (rewrite
                                                         purePopDepth)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand ifReduce)
                                      (("1"
                                        (expand release_marked)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand popDepth + (2 4))
                                            (("1"
                                              (case-replace
                                               "popDepth(nS`redex) = 0")
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (rewrite
                                                       purePopDepth)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (rewrite
                                                       purePopDepth)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (case-replace
                                           "updateReduce(D)(nS)`stack`length = nS`stack`length")
                                          (("1"
                                            (rewrite
                                             updateReduce_context)
                                            (("1"
                                              (use updateReduce_redex)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case-replace
                                                   "popDepth(nS`redex) = 0")
                                                  (("1"
                                                    (split)
                                                    (("1"
                                                      (replace -1)
                                                      (("1"
                                                        (expand
                                                         popDepth)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (replace -1)
                                                      (("2"
                                                        (typepred
                                                         "get(nS`stack)(target(nS`redex))")
                                                        (("2"
                                                          (hide-all-but
                                                           (1 -1))
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but
                                                     (1 -3))
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (split)
                                                (("1"
                                                  (expand*
                                                   nS
                                                   t
                                                   make_redex
                                                   to_topstate)
                                                  nil
                                                  nil)
                                                 ("2"
                                                  (expand nS)
                                                  (("2"
                                                    (hide (-1 -2 2))
                                                    (("2"
                                                      (lemma
                                                       make_redex_ndr)
                                                      (("2"
                                                        (inst -1 t)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (expand*
                                                 nS
                                                 t
                                                 make_redex
                                                 to_topstate)
                                                nil
                                                nil)
                                               ("2"
                                                (expand nS)
                                                (("2"
                                                  (lemma
                                                   make_redex_ndr)
                                                  (("2"
                                                    (inst -1 t)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use
                                             updateReduce_new_stack)
                                            (("1" (flatten) nil nil)
                                             ("2"
                                              (split)
                                              (("1"
                                                (expand*
                                                 nS
                                                 t
                                                 make_redex
                                                 to_topstate)
                                                nil
                                                nil)
                                               ("2"
                                                (lemma make_redex_ndr)
                                                (("2"
                                                  (inst -1 t)
                                                  (("2"
                                                    (expand nS)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand lookupReduce)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand*
                                                       release_marked
                                                       setRedex)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand
                                                           popDepth
                                                           +
                                                           2)
                                                          (("1"
                                                            (typepred
                                                             "nS`store(refindex(get(nS`stack)(arrayvalue(nS`redex))))`seq
                                       (value(get(nS`stack)(position(nS`redex))))")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand newintReduce)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       newrefReduce)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (split)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           popReduce)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               pop)
                                                              (("1"
                                                                (case-replace
                                                                 "popDepth(nS`redex) = 1")
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (expand
                                                           releaseReduce)
                                                          (("2"
                                                            (expand
                                                             decref)
                                                            (("2"
                                                              (lift-if)
                                                              (("2"
                                                                (split)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (case
                                                                       "releaseRedex?(nS`redex)")
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (expand
                                                                         nS)
                                                                        (("2"
                                                                          (expand
                                                                           make_redex)
                                                                          (("2"
                                                                            (typepred
                                                                             "buildRedex(t`redex)")
                                                                            (("2"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (case
                                                                       "releaseRedex?(nS`redex)")
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (expand*
                                                                         nS
                                                                         make_redex)
                                                                        (("2"
                                                                          (typepred
                                                                           "buildRedex(t`redex)")
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 3)
                  (("2"
                    (case-replace
                     "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = t`stack`length - popDepth(t`redex) - popDepth(t`context)")
                    (("1" (expand nS)
                      (("1" (expand make_redex)
                        (("1" (typepred "buildRedex(t`redex)")
                          (("1" (replace -1 :dir RL)
                            (("1" (rewrite popdepth_fill)
                              (("1"
                                (replace -1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* t to_topstate)
                      (("2" (rewrite popdepth_fill)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reduce const-decl "rstate" rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (popdepth_fill formula-decl nil IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (variableReduce const-decl "rstate" rreduction nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letReduce const-decl "rstate" rreduction nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (push const-decl "Stack" IL nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (popDepth_mark formula-decl nil preprocess nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (release_marked const-decl "rstate" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (pop const-decl "Stack" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil))
   nil)
  (reduce_stack_length-2 nil 3705950021
   ("" (skeep* :preds? t)
    (("" (expand reduce :assert? none)
      (("" (name-replace "t" "to_topstate(grS)")
        (("" (case "value?(t`redex)")
          (("1" (assert)
            (("1" (expand* t to_topstate)
              (("1" (rewrite popdepth_fill) (("1" (grind) nil)))))))
           ("2" (simplify :let-reduce? t)
            (("2" (name-replace "nS" "make_redex(t)")
              (("2"
                (case-replace
                 "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = nS`stack`length - popDepth(nS`redex) - popDepth(nS`context)")
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (split)
                      (("1" (postpone) nil)
                       ("2" (split)
                        (("1" (flatten)
                          (("1" (expand letReduce)
                            (("1" (expand* push add)
                              (("1"
                                (expand popDepth + (2 3 4))
                                (("1"
                                  (expand popDepth + 2)
                                  (("1"
                                    (case "letexpr?(nS`redex)")
                                    (("1"
                                      (case-replace
                                       "popDepth(body(nS`redex)) = 0")
                                      (("1" (grind) nil)
                                       ("2"
                                        (use purePopDepth)
                                        (("2" (grind) nil)))))
                                     ("2" (grind) nil)))))))))))))
                         ("2" (flatten)
                          (("2" (split)
                            (("1" (flatten)
                              (("1"
                                (expand applyReduce)
                                (("1"
                                  (assert)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (ground)
                                      (("1"
                                        (rewrite popdepth_letApply)
                                        (("1"
                                          (rewrite popDepth_mark)
                                          (("1"
                                            (case-replace
                                             "popDepth(nS`redex) = 0")
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (typepred
                                                     "D`seq(fun(nS`redex))`body")
                                                    (("1"
                                                      (rewrite
                                                       purePopDepth)
                                                      nil)))))
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (grind)
                                                    nil)))))))
                                             ("2"
                                              (grind)
                                              nil)))))))))))))))))
                             ("2" (flatten)
                              (("2"
                                (split)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (expand ifReduce)
                                    (("1"
                                      (expand release_marked)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand popDepth + (2 4))
                                          (("1"
                                            (case-replace
                                             "popDepth(nS`redex) = 0")
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (rewrite
                                                     purePopDepth)
                                                    (("1"
                                                      (grind)
                                                      nil)))))
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (rewrite
                                                     purePopDepth)
                                                    (("2"
                                                      (grind)
                                                      nil)))))))))
                                             ("2"
                                              (grind)
                                              nil)))))))))))))
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (case-replace
                                         "updateReduce(D)(nS)`stack`length = nS`stack`length")
                                        (("1"
                                          (rewrite
                                           updateReduce_context)
                                          (("1"
                                            (use updateReduce_redex)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (case-replace
                                                 "popDepth(nS`redex) = 0")
                                                (("1"
                                                  (split)
                                                  (("1"
                                                    (replace -1)
                                                    (("1"
                                                      (expand popDepth)
                                                      (("1"
                                                        (propax)
                                                        nil)))))
                                                   ("2"
                                                    (replace -1)
                                                    (("2"
                                                      (typepred
                                                       "get(nS`stack)(target(nS`redex))")
                                                      (("2"
                                                        (hide-all-but
                                                         (1 -1))
                                                        (("2"
                                                          (grind)
                                                          nil)))))))))
                                                 ("2"
                                                  (hide-all-but (1 -3))
                                                  (("2"
                                                    (grind)
                                                    nil)))))))
                                             ("2"
                                              (split)
                                              (("1"
                                                (expand*
                                                 nS
                                                 t
                                                 make_redex
                                                 to_topstate)
                                                nil)
                                               ("2"
                                                (expand nS)
                                                (("2"
                                                  (hide (-1 -2 2))
                                                  (("2"
                                                    (lemma
                                                     make_redex_ndr)
                                                    (("2"
                                                      (inst -1 t)
                                                      nil)))))))
                                               ("3" (propax) nil)))))
                                           ("2"
                                            (split)
                                            (("1"
                                              (expand*
                                               nS
                                               t
                                               make_redex
                                               to_topstate)
                                              nil)
                                             ("2"
                                              (expand nS)
                                              (("2"
                                                (lemma make_redex_ndr)
                                                (("2"
                                                  (inst -1 t)
                                                  nil)))))))))
                                         ("2"
                                          (use updateReduce_new_stack)
                                          (("1" (flatten) nil)
                                           ("2"
                                            (split)
                                            (("1"
                                              (expand*
                                               nS
                                               t
                                               make_redex
                                               to_topstate)
                                              nil)
                                             ("2"
                                              (lemma make_redex_ndr)
                                              (("2"
                                                (inst -1 t)
                                                (("2"
                                                  (expand nS)
                                                  (("2"
                                                    (propax)
                                                    nil)))))))
                                             ("3" (propax) nil)))))))))
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (expand lookupReduce)
                                            (("1"
                                              (lift-if)
                                              (("1"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand*
                                                     release_marked
                                                     setRedex)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         popDepth
                                                         +
                                                         2)
                                                        (("1"
                                                          (typepred
                                                           "nS`store(refindex(get(nS`stack)(arrayvalue(nS`redex))))`seq
                                       (value(get(nS`stack)(position(nS`redex))))")
                                                          (("1"
                                                            (grind)
                                                            nil)))))))))))
                                                 ("2"
                                                  (propax)
                                                  nil)))))))))
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand newintReduce)
                                                (("1" (grind) nil)))))
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     newrefReduce)
                                                    (("1"
                                                      (grind)
                                                      nil)))))
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (split)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         popReduce)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             pop)
                                                            (("1"
                                                              (case-replace
                                                               "popDepth(nS`redex) = 1")
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (split)
                                                                  (("1"
                                                                    (grind)
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (typepred
                                                                       "get(nS`stack)(pbody(nS`redex))")
                                                                      (("2"
                                                                        (grind)
                                                                        nil)))))))))
                                                               ("2"
                                                                (grind)
                                                                nil)))))))))))
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (expand
                                                         releaseReduce)
                                                        (("2"
                                                          (expand
                                                           decref)
                                                          (("2"
                                                            (lift-if)
                                                            (("2"
                                                              (split)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (case
                                                                     "releaseRedex?(nS`redex)")
                                                                    (("1"
                                                                      (grind)
                                                                      nil)
                                                                     ("2"
                                                                      (expand
                                                                       nS)
                                                                      (("2"
                                                                        (expand
                                                                         make_redex)
                                                                        (("2"
                                                                          (typepred
                                                                           "buildRedex(t`redex)")
                                                                          (("2"
                                                                            (grind)
                                                                            nil)))))))))))))
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (case
                                                                     "releaseRedex?(nS`redex)")
                                                                    (("1"
                                                                      (grind)
                                                                      nil)
                                                                     ("2"
                                                                      (expand*
                                                                       nS
                                                                       make_redex)
                                                                      (("2"
                                                                        (typepred
                                                                         "buildRedex(t`redex)")
                                                                        (("2"
                                                                          (grind)
                                                                          nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))
                 ("2" (delete 3)
                  (("2"
                    (case-replace
                     "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = t`stack`length - popDepth(t`redex) - popDepth(t`context)")
                    (("1" (expand nS)
                      (("1" (expand make_redex)
                        (("1" (typepred "buildRedex(t`redex)")
                          (("1" (replace -1 :dir RL)
                            (("1" (rewrite popdepth_fill)
                              (("1"
                                (replace -1)
                                (("1" (grind) nil)))))))))))))
                     ("2" (expand* t to_topstate)
                      (("2" (rewrite popdepth_fill)
                        (("2" (grind) nil))))))))))))))))))))))
    nil)
   nil nil)
  (reduce_stack_length-1 nil 3703867860
   ("" (skeep* :preds? t)
    (("" (expand reduce :assert? none)
      (("" (name-replace "t" "to_topstate(grS)")
        (("" (case "atom?(t`redex)")
          (("1" (assert)
            (("1" (expand* t to_topstate)
              (("1" (rewrite popdepth_fill) (("1" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (simplify :let-reduce? t)
            (("2" (name-replace "nS" "make_redex(t)")
              (("2"
                (case-replace
                 "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = nS`stack`length - popDepth(nS`redex) - popDepth(nS`context)")
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (expand letReduce)
                          (("1" (expand* push add)
                            (("1" (expand popDepth + (2 3 4))
                              (("1"
                                (expand popDepth + 2)
                                (("1"
                                  (case "letexpr?(nS`redex)")
                                  (("1"
                                    (case-replace
                                     "popDepth(body(nS`redex)) = 0")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use purePopDepth)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (expand applyReduce)
                              (("1"
                                (assert)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (ground)
                                    (("1"
                                      (rewrite popdepth_letApply)
                                      (("1"
                                        (rewrite popDepth_mark)
                                        (("1"
                                          (case-replace
                                           "popDepth(nS`redex) = 0")
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (typepred
                                                   "D`seq(fun(nS`redex))`body")
                                                  (("1"
                                                    (rewrite
                                                     purePopDepth)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand ifReduce)
                                  (("1"
                                    (expand release_marked)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand popDepth + (2 4))
                                        (("1"
                                          (case-replace
                                           "popDepth(nS`redex) = 0")
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (case-replace
                                       "updateReduce(D)(nS)`stack`length = nS`stack`length")
                                      (("1"
                                        (rewrite updateReduce_context)
                                        (("1"
                                          (use updateReduce_redex)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (case-replace
                                               "popDepth(nS`redex) = 0")
                                              (("1"
                                                (split)
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (expand popDepth)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (replace -1)
                                                  (("2"
                                                    (typepred
                                                     "get(nS`stack)(target(nS`redex))")
                                                    (("2"
                                                      (hide-all-but
                                                       (1 -1))
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but (1 -3))
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (split)
                                            (("1"
                                              (expand*
                                               nS
                                               t
                                               make_redex
                                               to_topstate)
                                              nil
                                              nil)
                                             ("2"
                                              (expand nS)
                                              (("2"
                                                (hide (-1 -2 2))
                                                (("2"
                                                  (lemma
                                                   make_redex_ndr)
                                                  (("2"
                                                    (inst -1 t)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (split)
                                          (("1"
                                            (expand*
                                             nS
                                             t
                                             make_redex
                                             to_topstate)
                                            nil
                                            nil)
                                           ("2"
                                            (expand nS)
                                            (("2"
                                              (lemma make_redex_ndr)
                                              (("2"
                                                (inst -1 t)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use updateReduce_new_stack)
                                        (("1" (flatten) nil nil)
                                         ("2"
                                          (split)
                                          (("1"
                                            (expand*
                                             nS
                                             t
                                             make_redex
                                             to_topstate)
                                            nil
                                            nil)
                                           ("2"
                                            (lemma make_redex_ndr)
                                            (("2"
                                              (inst -1 t)
                                              (("2"
                                                (expand nS)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand lookupReduce)
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand*
                                                   release_marked
                                                   setRedex)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       popDepth
                                                       +
                                                       2)
                                                      (("1"
                                                        (typepred
                                                         "nS`store(refindex(get(nS`stack)(arrayvalue(nS`redex))))`seq
                     (value(get(nS`stack)(position(nS`redex))))")
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand newintReduce)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand newrefReduce)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       popReduce)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand pop)
                                                          (("1"
                                                            (case-replace
                                                             "popDepth(nS`redex) = 1")
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (split)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (typepred
                                                                     "get(nS`stack)(pbody(nS`redex))")
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (expand
                                                       releaseReduce)
                                                      (("2"
                                                        (expand decref)
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (split)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (case
                                                                   "releaseRedex?(nS`redex)")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (expand
                                                                     nS)
                                                                    (("2"
                                                                      (expand
                                                                       make_redex)
                                                                      (("2"
                                                                        (typepred
                                                                         "buildRedex(t`redex)")
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (case
                                                                   "releaseRedex?(nS`redex)")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (expand*
                                                                     nS
                                                                     make_redex)
                                                                    (("2"
                                                                      (typepred
                                                                       "buildRedex(t`redex)")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 3)
                  (("2"
                    (case-replace
                     "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = t`stack`length - popDepth(t`redex) - popDepth(t`context)")
                    (("1" (expand nS)
                      (("1" (expand make_redex)
                        (("1" (typepred "buildRedex(t`redex)")
                          (("1" (replace -1 :dir RL)
                            (("1" (rewrite popdepth_fill)
                              (("1"
                                (replace -1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* t to_topstate)
                      (("2" (rewrite popdepth_fill)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (FORALL (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{(K, B) | fill(K, B) = A}" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (popDepth_mark formula-decl nil preprocess nil)
    (applyRedex? const-decl "bool" IL nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (push const-decl "Stack" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (purePopDepth formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letReduce const-decl "rstate" rreduction nil)
    (pureRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (popdepth_fill formula-decl nil IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (atom? const-decl "bool" IL nil)
    (reduce const-decl "rstate" rreduction nil))
   shostak))
 (npopts_TCC1 0
  (npopts_TCC1-1 nil 3706621099 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (npopts subtype "(number_fields.-)(typed_rreduction.n, 1)" "nat")))
 (npopts_TCC2 0
  (npopts_TCC2-1 nil 3706621099 ("" (termination-tcc) nil nil) nil nil
   (npopts termination
    "typed_rreduction.npopts((number_fields.-)(typed_rreduction.n, 1), typed_rreduction.tA)"
    "nil")))
 (npopts_expr_type 0
  (npopts_expr_type-1 nil 3706621792
   ("" (induct-and-simplify k) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (npopts def-decl "typeinfo" typed_rreduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (npops_is_well_typed_TCC1 0
  (npops_is_well_typed_TCC1-1 nil 3706621792
   ("" (skeep* :preds? t) (("" (rewrite npops_contextPure) nil nil))
    nil)
   ((npops_contextPure formula-decl nil iareduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (npops_is_well_typed subtype
    "iareduction.npops(typed_rreduction.k, typed_rreduction.A)"
    "(IL.contextPure?)")))
 (npops_is_well_typed_TCC2 0
  (npops_is_well_typed_TCC2-1 nil 3706621792
   ("" (skeep* :preds? t)
    (("" (rewrite npops_popDepth)
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep)
          (("2" (rewrite npops_cvars) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((npops_popDepth formula-decl nil iareduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (npops_cvars formula-decl nil iareduction nil))
   nil
   (npops_is_well_typed subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(iareduction.npops(typed_rreduction.k, typed_rreduction.A)), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(iareduction.npops(typed_rreduction.k, typed_rreduction.A))(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (npops_is_well_typed_TCC3 0
  (npops_is_well_typed_TCC3-1 nil 3706621792 ("" (subtype-tcc) nil nil)
   ((< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (npops_is_well_typed subtype "typed_rreduction.stypes"
    "{stypes | booleans.AND(reals.<=(IL.popDepth(typed_rreduction.A), typed_reduction.stypes`length), FORALL i: booleans.IMPLIES(preprocess.cvars(typed_rreduction.A)(typed_reduction.i), reals.<(typed_reduction.i, typed_reduction.stypes`length)))}")))
 (npops_is_well_typed 0
  (npops_is_well_typed-1 nil 3706621864
   ("" (induct k)
    (("1" (skeep* :preds? t) (("1" (expand* npops npopts) nil nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand npops +)
        (("2" (expand npopts +)
          (("2" (expand is_well_typed + 1) (("2" (inst? -5) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skeep* :preds? t) nil nil)) nil)
     ("4" (hide 2)
      (("4" (skeep* :preds? t)
        (("4" (split)
          (("1" (rewrite npops_popDepth) nil nil)
           ("2" (skeep)
            (("2" (rewrite npops_cvars)
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (hide 2)
      (("5" (skeep* :preds? t)
        (("5" (rewrite npops_contextPure) nil nil)) nil))
      nil))
    nil)
   ((npops_contextPure formula-decl nil iareduction nil)
    (npops_popDepth formula-decl nil iareduction nil)
    (npops_cvars formula-decl nil iareduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (npopts def-decl "typeinfo" typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil) nil
    (< const-decl "bool" reals nil)
    (npops def-decl "IExpression" iareduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (iapply_nstack_types_TCC1 0
  (iapply_nstack_types_TCC1-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil))
   nil
   (iapply_nstack_types subtype "typed_rreduction.stypes"
    "{stypes2 | typed_rreduction.stypes2`length = (number_fields.+)(typed_rreduction.arity, typed_rreduction.stypes`length)}")))
 (iapply_nstack_types_TCC2 0
  (iapply_nstack_types_TCC3-1 nil 3706555818 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (some adt-def-decl "boolean" list_adt nil))
   nil
   (iapply_nstack_types subtype "typed_rreduction.args"
    "(list_adt[(IExpression_adt.variable?)].cons?)")))
 (iapply_nstack_types_TCC3 0
  (iapply_nstack_types_TCC3-1 nil 3706555818
   ("" (skeep* :preds? t)
    (("" (inst -4 "index(car(args))")
      (("1" (split -4)
        (("1" (grind) nil nil)
         ("2" (expand in_varlist)
          (("2" (rewrite some_nth)
            (("1" (inst 1 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < stypes`length}"
          typed_rreduction nil)
    (stypes skolem-const-decl "finseq[nat]" typed_rreduction nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (arity skolem-const-decl "nat" typed_rreduction nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (some adt-def-decl "boolean" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_types subtype
    "(number_fields.-)((number_fields.-)(typed_rreduction.stypes`length, 1), IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(typed_rreduction.args)))"
    "below[stypes`length]")))
 (iapply_nstack_types_TCC4 0
  (iapply_nstack_types_TCC4-1 nil 3706555818
   ("" (skeep* :preds? t)
    (("" (inst -4 "index(car(args))")
      (("1" (split)
        (("1" (grind) nil nil)
         ("2" (expand in_varlist)
          (("2" (rewrite some_nth)
            (("1" (inst 1 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   nil nil
   (iapply_nstack_types subtype "typed_rreduction.y"
    "(IExpression_adt.variable?)")))
 (iapply_nstack_types_TCC5 0
  (iapply_nstack_types_TCC5-1 nil 3706555818 ("" (subtype-tcc) nil nil)
   nil nil
   (iapply_nstack_types subtype
    "typed_rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(typed_rreduction.y), 1)]"
    "(IExpression_adt.variable?)")))
 (iapply_nstack_types_TCC6 0
  (iapply_nstack_types_TCC6-1 nil 3706555818
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite "map_length")
        (("1" (expand "length" -3)
          (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (expand "add")
          (("2" (rewrite "bump_varlist")
            (("2" (grind)
              (("2" (expand "some" +)
                (("2" (lift-if)
                  (("2" (prop) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (map_length formula-decl nil more_map_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (some adt-def-decl "boolean" list_adt nil)
    (bump_varlist formula-decl nil rreduction nil))
   nil
   (iapply_nstack_types subtype
    "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: typed_rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(typed_rreduction.y), 1)])(list_adt[(IExpression_adt.variable?)].cdr(typed_rreduction.args))"
    "{args_1: list_adt[(IExpression_adt.variable?)].list | booleans.AND(list_props[(IExpression_adt.variable?)].length(args_1) = (number_fields.-)(typed_rreduction.arity, 1), FORALL i: booleans.IMPLIES(IL.in_varlist(args_1)(typed_rreduction.i), reals.<(typed_rreduction.i, more_finseq[naturalnumbers.nat].add(typed_rreduction.stypes`seq((number_fields.-)((number_fields.-)(typed_rreduction.stypes`length, 1), IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(typed_rreduction.args)))), typed_rreduction.stypes)`length)))}")))
 (iapply_nstack_types_TCC7 0
  (iapply_nstack_types_TCC7-1 nil 3706623873 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (iapply_nstack_types subtype
    "typed_rreduction.iapply_nstack_types((number_fields.-)(typed_rreduction.arity, 1), more_finseq[naturalnumbers.nat].add(typed_rreduction.stypes`seq((number_fields.-)((number_fields.-)(typed_rreduction.stypes`length, 1), IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(typed_rreduction.args)))), typed_rreduction.stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: typed_rreduction.y WITH [`index := (number_fields.+)(IExpression_adt.index(typed_rreduction.y), 1)])(list_adt[(IExpression_adt.variable?)].cdr(typed_rreduction.args)))"
    "{stypes2 | typed_rreduction.stypes2`length = (number_fields.+)(typed_rreduction.arity, typed_rreduction.stypes`length)}")))
 (npops_arm 0
  (npops_arm-1 nil 3706623982 ("" (induct-and-simplify k) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (npops def-decl "IExpression" iareduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (iapplyReduce_arm 0
  (iapplyReduce_arm-1 nil 3706623873
   ("" (skeep* :preds? t)
    (("" (expand iapplyReduce)
      (("" (assert)
        (("" (split)
          (("1" (flatten)
            (("1" (rewrite npops_arm)
              (("1" (typepred "D`seq(fun(grS`redex))`body")
                (("1" (rewrite -3 :dir RL)
                  (("1" (use arm_mark_unmark) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((iapplyReduce const-decl "rstate" iareduction nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (npops_arm formula-decl nil typed_rreduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (mark def-decl "IExpression" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil
    (< const-decl "bool" reals nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil nil (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil) nil
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (arm_mark_unmark formula-decl nil reduction_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_iareduce_TCC1 0
  (typed_iareduce_TCC1-1 nil 3706538966
   ("" (skeep* :preds? t)
    (("" (use iapplyReduce_ndr)
      (("1" (use iapplyReduce_arm)
        (("1" (split)
          (("1" (prop) nil nil) ("2" (propax) nil nil)
           ("3" (typepred "nS`state") (("3" (propax) nil nil)) nil)
           ("4" (typepred "nS`state") (("4" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (split)
        (("1" (replace* -3 -5)
          (("1"
            (expand* typed_to_topstate make_redex_typed to_topstate
             make_redex)
            nil nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((iapplyReduce_ndr judgement-tcc nil iareduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (iapplyReduce_arm formula-decl nil typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_iareduce subtype
    "iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_iareduce_TCC2 0
  (typed_iareduce_TCC2-1 nil 3706538966
   ("" (skeep* :preds? t)
    (("" (expand iapplyReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((iapplyReduce const-decl "rstate" iareduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil iareduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_iareduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_iareduce_TCC3 0
  (typed_iareduce_TCC3-1 nil 3706538966
   ("" (skeep* :preds? t)
    ((""
      (case "fun(nS`state`redex) < D`length AND length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
      (("1" (flatten)
        (("1" (expand iapplyReduce)
          (("1" (assert)
            (("1"
              (typepred
               "iapply_nstack(D`seq(fun(nS`state`redex))`arity, nS`state`domain,
                     nS`state`stack, args(nS`state`redex), nS`state`store,
                     nS`state`redex, nS`state`count)")
              (("1" (assert)
                (("1" (split)
                  (("1" (expand o)
                    (("1" (replace -1)
                      (("1" (assert)
                        (("1" (expand applyRedex?)
                          (("1" (typepred "nS`redex_type")
                            (("1" (assert)
                              (("1"
                                (expand is_well_typed)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep :preds? t)
                    (("2" (use iapply_nstack_indices)
                      (("2" (split)
                        (("1"
                          (inst -1
                           "nS`state`stack`length + D`seq(fun(nS`state`redex))`arity - 1 -
              i")
                          (("1" (assert)
                            (("1" (rewrite -1)
                              (("1"
                                (expand o)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (typepred "nS`redex_type")
                                          (("1"
                                            (expand applyRedex?)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand is_well_typed)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (expand
                                                       is_well_typed)
                                                      (("1"
                                                        (typepred
                                                         "nS`stack_types")
                                                        (("1"
                                                          (inst?)
                                                          (("1"
                                                            (case-replace
                                                             "tS`def_types = nS`def_types")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (replace*
                                                               -15
                                                               -13)
                                                              (("2"
                                                                (expand*
                                                                 make_redex_typed
                                                                 typed_to_topstate)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (typepred
                                                             "nS`state`redex")
                                                            (("2"
                                                              (inst
                                                               -2
                                                               "index(nth(args(nS`state`redex),i-nS`state`stack`length))")
                                                              (("2"
                                                                (split)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (expand
                                                                   vars)
                                                                  (("2"
                                                                    (expand
                                                                     in_varlist)
                                                                    (("2"
                                                                      (rewrite
                                                                       some_nth)
                                                                      (("2"
                                                                        (inst?)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (typepred
                                               "nS`stack_types")
                                              (("1"
                                                (inst?)
                                                (("1"
                                                  (hide-all-but
                                                   (1 -2 -3))
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (typepred
                                               "nS`stack_types")
                                              (("2" (inst?) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand o)
                            (("2" (typepred "nS`stack_types")
                              (("2"
                                (expand applyRedex?)
                                (("2"
                                  (assert)
                                  (("2"
                                    (typepred "nS`redex_type")
                                    (("2"
                                      (expand is_well_typed)
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (case-replace
                                             "nS`def_types = tS`def_types")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (replace* -14 -12)
                                              (("2"
                                                (expand*
                                                 make_redex_typed
                                                 typed_to_topstate)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "nS`state`redex")
                          (("2" (expand applyRedex?)
                            (("2" (assert)
                              (("2"
                                (expand mark)
                                (("2"
                                  (decompose-equality -6)
                                  (("2"
                                    (skeep* :preds? t)
                                    (("2"
                                      (replace -3 -10 :dir RL)
                                      (("2"
                                        (rewrite markvars_mark_def)
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (inst -10 j)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (typepred "nS`state`redex")
                  (("2" (inst -2 i)
                    (("2" (split)
                      (("1" (grind) nil nil)
                       ("2" (expand applyRedex?)
                        (("2" (assert) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand applyRedex?)
        (("2" (assert)
          (("2" (typepred "nS`redex_type")
            (("2" (expand is_well_typed)
              (("2" (flatten)
                (("2" (assert)
                  (("2" (case-replace "nS`def_types = tS`def_types")
                    (("1" (expand defs_well_typed)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (inst -7 "fun(nS`state`redex)")
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (replace* -8 -6)
                      (("2"
                        (expand* make_redex_typed typed_to_topstate)
                        nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand applyRedex?) (("3" (flatten) nil nil)) nil)
       ("4" (expand applyRedex?) (("4" (propax) nil nil)) nil))
      nil))
    nil)
   ((args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (iapplyReduce const-decl "rstate" iareduction nil)
    (iapply_nstack def-decl
     "{((S1: Stack | every(domainValue?(dom))(S1)),
  (ncnt: [i: (dom) -> {j | j = refcount(dom, str, S1, A)(i)}])) |
   S1`length = S`length + arity}" iareduction nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (applyRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (O const-decl "finseq" finite_sequences nil)
    (iapply_nstack_indices formula-decl nil iareduction nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (markvars_mark_def formula-decl nil preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_rreduction nil)
    (i skolem-const-decl "below((nS`stack_types o
        tS`def_types`seq(fun(nS`state`redex))`args_type)`length)"
       typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nth def-decl "T" list_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_iareduce subtype
    "finite_sequences[naturalnumbers.nat].o(typed_rreduction.nS`stack_types, typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type)"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_iareduce_TCC4 0
  (typed_iareduce_TCC4-2 "" 3720328166
   ("" (skeep* :preds? t)
    (("" (expand iapplyReduce)
      (("" (typepred "nS`redex_type")
        (("" (expand applyRedex?)
          (("" (assert)
            (("" (expand is_well_typed -)
              (("" (flatten)
                (("" (assert)
                  (("" (expand defs_well_typed)
                    (("" (flatten)
                      (("" (assert)
                        ((""
                          (case-replace "nS`def_types = tS`def_types")
                          (("1" (assert)
                            (("1" (inst? -7)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (replace -7)
                                    (("1"
                                      (replace -4)
                                      (("1"
                                        (rewrite npops_is_well_typed)
                                        (("1"
                                          (rewrite
                                           is_well_typed_mark
                                           :dir
                                           RL)
                                          (("1"
                                            (use
                                             is_well_typed_extend_stack)
                                            (("1"
                                              (split)
                                              (("1"
                                                (rewrite -1)
                                                (("1"
                                                  (lemma
                                                   is_well_typed_dom)
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (inst
                                                       -1
                                                       "nS`dom_types")
                                                      (("1"
                                                        (split)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (rewrite
                                                           pure_contextPure)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (skeep)
                                                          (("3"
                                                            (use
                                                             pure_refs)
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite
                                                 pure_contextPure)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (split 1)
                                                (("1"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skeep)
                                                  (("2"
                                                    (rewrite
                                                     cvars_pure)
                                                    (("2"
                                                      (typepred
                                                       "D`seq(fun(nS`state`redex))`body")
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite pure_contextPure)
                                            nil
                                            nil)
                                           ("3"
                                            (expand o 1)
                                            (("3"
                                              (rewrite purePopDepth)
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (split)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (skeep)
                                                    (("2"
                                                      (typepred
                                                       "D`seq(fun(nS`state`redex))`body")
                                                      (("2"
                                                        (rewrite
                                                         cvars_pure)
                                                        (("2"
                                                          (inst?)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (split 1)
                                          (("1"
                                            (rewrite purePopDepth)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (rewrite pure_mark)
                                              nil
                                              nil))
                                            nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (rewrite cvars_mark)
                                              (("2"
                                                (rewrite cvars_pure)
                                                (("2"
                                                  (typepred
                                                   "D`seq(fun(nS`state`redex))`body")
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (expand o 1)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (rewrite pure_contextPure)
                                          (("3"
                                            (rewrite pure_mark)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace* -9 -7)
                            (("2"
                              (expand* make_redex_typed
                               typed_to_topstate)
                              nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iapplyReduce const-decl "rstate" iareduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pure_mark formula-decl nil preprocess nil)
    (cvars_mark formula-decl nil preprocess nil)
    (is_well_typed_mark formula-decl nil typed_rreduction nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (pure_refs formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_rreduction nil)
    (is_well_typed_extend_stack formula-decl nil typed_reduction nil)
    (npops_is_well_typed formula-decl nil typed_rreduction nil)
    (O const-decl "finseq" finite_sequences nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_iareduce subtype
    "typed_rreduction.npopts(list_props[IExpression_adt.IExpression].length(IExpression_adt.args(typed_rreduction.nS`state`redex)), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)"
    "{tA | typed_reduction.is_well_typed(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, finite_sequences[naturalnumbers.nat].o(typed_rreduction.nS`stack_types, typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}"))
  (typed_iareduce_TCC4-1 nil 3706621099
   ("" (skeep* :preds? t)
    (("" (expand iapplyReduce)
      (("" (typepred "nS`redex_type")
        (("" (expand applyRedex?)
          (("" (assert)
            (("" (expand is_well_typed -)
              (("" (flatten)
                (("" (assert)
                  (("" (expand defs_well_typed)
                    (("" (flatten)
                      (("" (assert)
                        ((""
                          (case-replace "nS`def_types = tS`def_types")
                          (("1" (assert)
                            (("1" (inst? -7)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (replace -7)
                                    (("1"
                                      (replace -4)
                                      (("1"
                                        (rewrite npops_is_well_typed)
                                        (("1"
                                          (rewrite
                                           is_well_typed_mark
                                           :dir
                                           RL)
                                          (("1"
                                            (use
                                             is_well_typed_extend_stack)
                                            (("1"
                                              (split)
                                              (("1"
                                                (rewrite -1)
                                                (("1"
                                                  (lemma
                                                   is_well_typed_dom)
                                                  (("1"
                                                    (inst?)
                                                    (("1"
                                                      (inst
                                                       -1
                                                       "nS`dom_types")
                                                      (("1"
                                                        (split)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (rewrite
                                                           pure_contextPure)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (skeep)
                                                          (("3"
                                                            (use
                                                             pure_refs)
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite
                                                 pure_contextPure)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite pure_contextPure)
                                            nil
                                            nil)
                                           ("3"
                                            (expand o 1)
                                            (("3"
                                              (rewrite purePopDepth)
                                              (("3"
                                                (assert)
                                                (("3"
                                                  (split)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (skeep)
                                                    (("2"
                                                      (typepred
                                                       "D`seq(fun(nS`state`redex))`body")
                                                      (("2"
                                                        (rewrite
                                                         cvars_pure)
                                                        (("2"
                                                          (inst?)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (split 1)
                                          (("1"
                                            (rewrite purePopDepth)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (rewrite pure_mark)
                                              nil
                                              nil))
                                            nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (rewrite cvars_mark)
                                              (("2"
                                                (rewrite cvars_pure)
                                                (("2"
                                                  (typepred
                                                   "D`seq(fun(nS`state`redex))`body")
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (expand o 1)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (rewrite pure_contextPure)
                                          (("3"
                                            (rewrite pure_mark)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace* -9 -7)
                            (("2"
                              (expand* make_redex_typed
                               typed_to_topstate)
                              nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iapplyReduce const-decl "rstate" iareduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (pure_mark formula-decl nil preprocess nil)
    (cvars_mark formula-decl nil preprocess nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (pure_refs formula-decl nil IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (is_well_typed_extend_stack formula-decl nil typed_reduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil))
   nil
   (typed_iareduce subtype
    "typed_rreduction.npopts(list_props[IExpression_adt.IExpression].length(IExpression_adt.args(typed_rreduction.nS`state`redex)), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)"
    "{tA | typed_reduction.is_well_typed(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, finite_sequences[naturalnumbers.nat].o(typed_rreduction.nS`stack_types, typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_iareduce_TCC5 0
  (typed_iareduce_TCC5-2 "" 3720328475
   ("" (skeep* :preds? t)
    (("" (expand* iapplyReduce)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand applyRedex?)
            (("" (assert)
              (("" (expand is_well_typed)
                (("" (flatten)
                  (("" (expand defs_well_typed)
                    (("" (flatten)
                      (("" (case-replace "nS`def_types = tS`def_types")
                        (("1" (assert)
                          (("1" (inst? -7)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (rewrite npops_popDepth)
                                  (("1"
                                    (rewrite purePopDepth)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (rewrite popn_append :dir RL)
                                        (("1"
                                          (case-replace
                                           "popn(tS`def_types`seq
                                                    (fun(nS`state`redex))`args_type,
                                                D`seq(fun(nS`state`redex))`arity) = empty_seq[nat]")
                                          (("1"
                                            (case-replace
                                             "nS`stack_types o empty_seq[nat] = nS`stack_types")
                                            (("1"
                                              (typepred
                                               "nS`context_type")
                                              (("1"
                                                (case-replace
                                                 "popDepth(nS`state`redex) = 0")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (replace -5)
                                                    (("1"
                                                      (rewrite
                                                       npopts_expr_type)
                                                      (("1"
                                                        (replace
                                                         -12
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (replace -7)
                                                          (("1"
                                                            (expand
                                                             expr_type)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace -7)
                                            (("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (rewrite pure_mark) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replace* -7 -9)
                          (("2"
                            (expand* make_redex_typed
                             typed_to_topstate)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iapplyReduce const-decl "rstate" iareduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (npops_popDepth formula-decl nil iareduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (npopts_expr_type formula-decl nil typed_rreduction nil)
    (O const-decl "finseq" finite_sequences nil)
    (FALSE const-decl "bool" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon const-decl "T" epsilons nil)
    (TRUE const-decl "bool" booleans nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (tS skolem-const-decl
     "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}"
     typed_rreduction nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (popn_append formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak
   (typed_iareduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(finite_sequences[naturalnumbers.nat].o(typed_rreduction.nS`stack_types, typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), IL.popDepth(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.npopts(list_props[IExpression_adt.IExpression].length(IExpression_adt.args(typed_rreduction.nS`state`redex)), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)))}"))
  (typed_iareduce_TCC5-1 nil 3706621099
   ("" (skeep* :preds? t)
    (("" (expand* iapplyReduce)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand applyRedex?)
            (("" (assert)
              (("" (expand is_well_typed)
                (("" (flatten)
                  (("" (expand defs_well_typed)
                    (("" (flatten)
                      (("" (case-replace "nS`def_types = tS`def_types")
                        (("1" (assert)
                          (("1" (inst? -7)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (rewrite npops_popDepth)
                                  (("1"
                                    (rewrite purePopDepth)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (rewrite popn_append :dir RL)
                                        (("1"
                                          (case-replace
                                           "popn(tS`def_types`seq
                                              (fun(nS`state`redex))`args_type,
                                          D`seq(fun(nS`state`redex))`arity) = empty_seq[nat]")
                                          (("1"
                                            (case-replace
                                             "nS`stack_types o empty_seq[nat] = nS`stack_types")
                                            (("1"
                                              (typepred
                                               "nS`context_type")
                                              (("1"
                                                (case-replace
                                                 "popDepth(nS`state`redex) = 0")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (replace -5)
                                                    (("1"
                                                      (rewrite
                                                       npopts_expr_type)
                                                      (("1"
                                                        (replace
                                                         -12
                                                         :dir
                                                         RL)
                                                        (("1"
                                                          (replace -7)
                                                          (("1"
                                                            (expand
                                                             expr_type)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (replace -7)
                                            (("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (grind-with-ext)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (rewrite pure_mark) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (replace* -7 -9)
                          (("2"
                            (expand* make_redex_typed
                             typed_to_topstate)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iapplyReduce const-decl "rstate" iareduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (npops_popDepth formula-decl nil iareduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (popn_append formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (applyRedex? const-decl "bool" IL nil))
   nil
   (typed_iareduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(finite_sequences[naturalnumbers.nat].o(typed_rreduction.nS`stack_types, typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`args_type), IL.popDepth(iareduction.iapplyReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.npopts(list_props[IExpression_adt.IExpression].length(IExpression_adt.args(typed_rreduction.nS`state`redex)), typed_rreduction.tS`def_types`seq(IExpression_adt.fun(typed_rreduction.nS`state`redex))`body_type)))}")))
 (typed_iareduce_TCC6 0
  (typed_iareduce_TCC6-1 nil 3720239385 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_iareduce subtype "typed_rreduction.nS`state"
    "{grS | booleans.AND(IL.pureIftRedex?(iareduction.grS`redex), rreduction.noDanglingRefs?(iareduction.grS))}")))
 (typed_iareduce_TCC7 0
  (typed_iareduce_TCC7-1 nil 3720239385
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (assert)
        (("1" (typepred "iareduce(D)(tS`state)")
          (("1" (expand iareduce)
            (("1" (expand typed_to_topstate)
              (("1" (expand make_redex_typed)
                (("1" (replace -5) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand aifReduce)
        (("2" (split)
          (("1" (flatten)
            (("1" (use releaseReduce_arm)
              (("1" (split)
                (("1" (assert) nil nil)
                 ("2" (expand ifReduce)
                  (("2" (assert)
                    (("2" (hide 2)
                      (("2" (expand release_marked)
                        (("2" (expand pureReleaseRedex?)
                          (("2" (expand releaseRedex?)
                            (("2" (expand pureIftRedex?)
                              (("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (use pure_contextPure)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (use pure_contextPure)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (use ifReduce_ndr) nil nil)
                 ("4" (use ifReduce_arm)
                  (("1" (assert) nil nil)
                   ("2" (skeep)
                    (("2" (typepred "D`seq(x1)`body")
                      (("2" (split)
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (assert)
                              (("1"
                                (inst -3 i)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (use ifReduce_arm)
                  (("1" (split)
                    (("1" (assert) nil nil) ("2" (propax) nil nil)
                     ("3" (assert) nil nil) ("4" (assert) nil nil))
                    nil)
                   ("2" (skeep)
                    (("2" (typepred "D`seq(x1)`body")
                      (("2" (split)
                        (("1" (skeep)
                          (("1" (inst -3 i) (("1" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (typepred "D`seq(x1)`body")
                  (("2" (split)
                    (("1" (skeep)
                      (("1" (inst -3 i) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (use ifReduce_arm)
              (("1" (assert) nil nil)
               ("2" (skeep)
                (("2" (typepred "D`seq(x1)`body")
                  (("2" (split)
                    (("1" (skeep)
                      (("1" (inst -3 i) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand aifReduce)
        (("3" (split)
          (("1" (flatten)
            (("1" (use releaseReduce_arm)
              (("1" (split)
                (("1" (assert) nil nil)
                 ("2" (expand ifReduce)
                  (("2" (hide 2)
                    (("2" (expand release_marked)
                      (("2" (assert)
                        (("2" (expand pureReleaseRedex?)
                          (("2" (expand releaseRedex?)
                            (("2" (expand pureIftRedex?)
                              (("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (use pure_contextPure)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (use pure_contextPure)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert) (("3" (use ifReduce_ndr) nil nil)) nil)
                 ("4" (use ifReduce_arm)
                  (("1" (assert) nil nil)
                   ("2" (skeep)
                    (("2" (typepred "D`seq(x1)`body")
                      (("2" (split)
                        (("1" (skeep)
                          (("1" (inst -3 i) (("1" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("5" (use ifReduce_arm)
                  (("1" (assert) nil nil)
                   ("2" (skeep)
                    (("2" (typepred "D`seq(x1)`body")
                      (("2" (split)
                        (("1" (skeep)
                          (("1" (inst -3 i) (("1" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (typepred "D`seq(x1)`body")
                  (("2" (split)
                    (("1" (skeep)
                      (("1" (inst -3 i) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (use ifReduce_arm)
              (("1" (assert) nil nil)
               ("2" (skeep)
                (("2" (typepred "D`seq(x1)`body")
                  (("2" (split)
                    (("1" (skeep)
                      (("1" (inst -3 i) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (iareduce const-decl "rstate" iareduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil iareduction nil)
    (Definition type-eq-decl nil iareduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (iareduce_ndr application-judgement "(noDanglingRefs?)" iareduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (releaseReduce_arm formula-decl nil reduction_props nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (D skolem-const-decl "Defs" typed_rreduction nil)
    (ifReduce_arm formula-decl nil reduction_props nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nS skolem-const-decl "typed_rstate" typed_rreduction nil)
    (ifReduce_ndr judgement-tcc nil rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (pure_contextPure formula-decl nil IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (releaseRedex? const-decl "bool" IL nil)
    (release_marked const-decl "rstate" rreduction nil)
    (aifReduce const-decl "rstate" iareduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_iareduce subtype
    "iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_iareduce_TCC8 0
  (typed_iareduce_TCC8-1 nil 3720239385
   ("" (skeep* :preds? t)
    (("" (expand aifReduce)
      (("" (case "marked(condition(nS`state`redex))")
        (("1" (assert)
          (("1"
            (typepred "typed_reduce(D)(typed_reduce(D)(tS))`dom_types")
            (("1" (inst -1 r j)
              (("1" (assert)
                (("1" (expand typed_reduce -1 (2 4 6))
                  (("1" (replace -6 :dir RL)
                    (("1" (replace -8 :dir RL)
                      (("1" (name-replace nnS "typed_reduce(D)(tS)")
                        (("1" (expand typed_reduce -1)
                          (("1" (replace -7 :dir RL)
                            (("1" (replace -9 :dir RL)
                              (("1"
                                (replace -1)
                                (("1"
                                  (expand typed_reduce -2)
                                  (("1"
                                    (case
                                     "value?(typed_to_topstate(nnS)`state`redex)")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -2 -1 :dir RL)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand
                                             typed_to_topstate
                                             -1)
                                            (("1"
                                              (expand ifReduce -1)
                                              (("1"
                                                (expand
                                                 release_marked
                                                 -1)
                                                (("1"
                                                  (expand to_topstate)
                                                  (("1"
                                                    (rewrite
                                                     not_value_redex_fill)
                                                    (("1"
                                                      (rewrite
                                                       not_value_redex_fill)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (expand redex?)
                                                        (("2"
                                                          (expand
                                                           releaseRedex?)
                                                          (("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand redex?)
                                                      (("2"
                                                        (expand
                                                         releaseRedex?)
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2" (postpone) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (postpone) nil nil) ("3" (postpone) nil nil))
              nil)
             ("2" (postpone) nil nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (expand ifReduce)
            (("2" (expand release_marked)
              (("2" (assert)
                (("2" (lift-if)
                  (("2" (typepred "nS`dom_types")
                    (("2" (inst -1 r j) (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand* pureIftRedex? ifRedex?)
          (("3" (expand iftRedex?) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   nil nil
   (typed_iareduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_iareduce_TCC9 0
  (typed_iareduce_TCC9-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_iareduce_TCC10 0
  (typed_iareduce_TCC10-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype
    "IF IL.get(typed_rreduction.nS`state`stack)(IExpression_adt.condition(typed_rreduction.nS`state`redex)) = IExpression_adt.constant(0) THEN typeinfo_adt.telse(typed_rreduction.nS`redex_type) ELSE typeinfo_adt.tthen(typed_rreduction.nS`redex_type) ENDIF"
    "{tA | typed_reduction.is_well_typed(iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_iareduce_TCC11 0
  (typed_iareduce_TCC11-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(iareduction.aifReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, IF IL.get(typed_rreduction.nS`state`stack)(IExpression_adt.condition(typed_rreduction.nS`state`redex)) = IExpression_adt.constant(0) THEN typed_reduction.expr_type(typeinfo_adt.telse(typed_rreduction.nS`redex_type)) ELSE typed_reduction.expr_type(typeinfo_adt.tthen(typed_rreduction.nS`redex_type)) ENDIF)}")))
 (typed_iareduce_TCC12 0
  (typed_iareduce_TCC12-1 nil 3720239385 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{(K, B) |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (typed_iareduce subtype "typed_rreduction.nS`state"
    "{grS | booleans.AND(IL.lookupRedex?(iareduction.grS`redex), rreduction.noDanglingRefs?(iareduction.grS))}")))
 (typed_iareduce_TCC13 0
  (typed_iareduce_TCC13-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype
    "iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)"
    "{rS: rreduction.rstate | booleans.AND(rreduction.noDanglingRefs?(rS), booleans.AND(preprocess.allReleaseMarked?(rS`redex), preprocess.armc?(rS`context)))}")))
 (typed_iareduce_TCC14 0
  (typed_iareduce_TCC14-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype "typed_rreduction.nS`dom_types"
    "{dom_types | FORALL (r: (iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`domain)): FORALL (j: naturalnumbers.below(iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`length)): typed_reduction.value_of_type(iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`store(r)`seq(j), typed_rreduction.dom_types(r), typed_rreduction.dom_types)}")))
 (typed_iareduce_TCC15 0
  (typed_iareduce_TCC15-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype "typed_rreduction.nS`stack_types"
    "{stypes | booleans.AND(typed_rreduction.stypes`length = iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`length, FORALL (i: naturalnumbers.below(typed_rreduction.stypes`length)): typed_reduction.value_of_type(iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`stack`seq(i), typed_rreduction.stypes`seq(i), typed_rreduction.nS`dom_types))}")))
 (typed_iareduce_TCC16 0
  (typed_iareduce_TCC16-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype "typed_rreduction.nS`redex_type"
    "{tA | typed_reduction.is_well_typed(iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex, typed_rreduction.tA, typed_rreduction.nS`stack_types, typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types)}")))
 (typed_iareduce_TCC17 0
  (typed_iareduce_TCC17-1 nil 3720239385 ("" (subtype-tcc) nil nil) nil
   nil
   (typed_iareduce subtype "typed_rreduction.nS`context_type"
    "{tK | typed_reduction.is_well_typed_ctx(iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`context, typed_rreduction.tK, typed_reduction.popn(typed_rreduction.nS`stack_types, IL.popDepth(iareduction.alookupReduce(typed_rreduction.D)(typed_rreduction.nS`state)`redex)), typed_rreduction.nS`dom_types, typed_rreduction.nS`def_types, typed_reduction.expr_type(typed_rreduction.nS`redex_type))}")))
 (typed_iareduce_def_types 0
  (typed_iareduce_def_types-1 nil 3707594618
   ("" (skeep* :preds? t)
    (("" (expand typed_iareduce)
      (("" (lift-if)
        (("" (expand* typed_to_topstate make_redex_typed) nil nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_iareduce const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil))
   shostak)))

