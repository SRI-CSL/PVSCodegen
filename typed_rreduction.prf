(typed_rreduction
 (typed_rstate_TCC1 0
  (typed_rstate_TCC1-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_rstate_TCC2 0
  (typed_rstate_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex")
      (("" (split)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (inst -3 "i-popDepth(state`redex)")
            (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_rstate_TCC3 0
  (typed_rstate_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil)
   ((armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_rstate_TCC4 0
  (typed_rstate_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand popn)
      (("" (typepred "state`redex")
        (("" (split)
          (("1" (grind) nil nil)
           ("2" (skeep)
            (("2" (inst -4 "i-popDepth(state`context)")
              (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((popn const-decl "finseq[nat]" typed_reduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (is_well_typed_letApply_TCC1 0
  (is_well_typed_letApply_TCC1-1 nil 3703270930
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil))
 (is_well_typed_letApply_TCC2 0
  (is_well_typed_letApply_TCC2-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (typepred "nth(args, i1)") (("" (grind) nil nil)) nil)) nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_letApply_TCC3 0
  (is_well_typed_letApply_TCC3-1 nil 3703270930
   ("" (subtype-tcc) nil nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)) nil))
 (is_well_typed_letApply_TCC4 0
  (is_well_typed_letApply_TCC4-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (inst -8 "i_1")
          (("2" (split -8)
            (("1" (propax) nil nil)
             ("2" (expand in_varlist)
              (("2" (rewrite some_nth) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((in_varlist const-decl "finite_set[nat]" IL nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (some_nth formula-decl nil finseq_theorems nil))
   nil))
 (is_well_typed_letApply_TCC5 0
  (is_well_typed_letApply_TCC5-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (use pure_contextPure) (("" (grind) nil nil)) nil)) nil)
   ((pure_contextPure formula-decl nil IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   nil))
 (is_well_typed_letApply_TCC6 0
  (is_well_typed_letApply_TCC6-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
       ("2" (rewrite cvars_pure) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil))
 (is_well_typed_letApply_TCC7 0
  (is_well_typed_letApply_TCC7-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (use "pure_contextPure")
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (use "rreduction.pure_letApply") nil nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (letApply def-decl "IExpression" rreduction nil)
    (length def-decl "nat" list_props nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pure? def-decl "bool" IL nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil))
   nil))
 (is_well_typed_letApply_TCC8 0
  (is_well_typed_letApply_TCC8-1 nil 3703270930
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite purePopDepth)
        (("1" (grind) nil nil)
         ("2" (use "rreduction.pure_letApply") nil nil))
        nil)
       ("2" (rewrite cvars_pure)
        (("1" (skeep)
          (("1" (rewrite vars_letApply)
            (("1" (split)
              (("1" (grind) nil nil)
               ("2" (rewrite cvars_pure) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (use "rreduction.pure_letApply") nil nil))
        nil))
      nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (letApply def-decl "IExpression" rreduction nil)
    (length def-decl "nat" list_props nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (O const-decl "finseq" finite_sequences nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (vars_letApply formula-decl nil rreduction nil)
    (cvars_pure formula-decl nil preprocess nil))
   nil))
 (is_well_typed_letApply 0
  (is_well_typed_letApply-1 nil 3703270931
   ("" (induct arity)
    (("1" (skeep* :preds? t)
      (("1" (expand letApply)
        (("1" (expand letApply_type)
          (("1"
            (case-replace
             "stypes o list2finseq[nat](args_type) = stypes")
            (("1" (lemma is_well_typed_dom)
              (("1" (inst?)
                (("1" (inst -1 dom_types)
                  (("1" (split -1)
                    (("1" (grind) nil nil)
                     ("2" (use pure_contextPure)
                      (("2" (grind) nil nil)) nil)
                     ("3" (skeep)
                      (("3" (use pure_refs) (("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (decompose-equality)
                (("1" (grind) nil nil)
                 ("2" (decompose-equality) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep* :preds? t)
      (("2" (expand letApply +)
        (("2" (expand letApply_type +)
          (("2" (lift-if +)
            (("2" (expand is_well_typed +)
              (("2" (expand is_well_typed + 2)
                (("2" (split)
                  (("1" (inst -10 0) (("1" (grind) nil nil)) nil)
                   ("2" (expand expr_type) (("2" (propax) nil nil))
                    nil)
                   ("3" (inst? -6)
                    (("3" (split -6)
                      (("1" (propax) nil nil) ("2" (propax) nil nil)
                       ("3" (delete 2)
                        (("3" (expand add +)
                          (("3" (expand popn +)
                            (("3"
                              (case-replace "popDepth(car(args)) = 0")
                              (("1" (assert) nil nil)
                               ("2" (grind) nil nil)
                               ("3" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete 2)
                        (("4" (skeep*)
                          (("4" (case "in_varlist(args)(i-1)")
                            (("1" (expand add)
                              (("1"
                                (expand popn)
                                (("1"
                                  (case-replace
                                   "popDepth(car(args)) = 0")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand in_varlist)
                              (("2"
                                (rewrite some_map)
                                (("2"
                                  (expand o)
                                  (("2"
                                    (case-replace
                                     "(lambda (v: (variable?)): index(v) = i - 1) = (LAMBDA (x_1: (variable?)): 1 + index(x_1) = i)")
                                    (("1"
                                      (expand some +)
                                      (("1"
                                        (lift-if)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (apply-extensionality)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("5" (delete 2)
                        (("5" (skeep :preds? t)
                          (("5" (rewrite map_nth_rw)
                            (("1"
                              (case-replace
                               "nth(cdr(args), i) = nth(args, i + 1)")
                              (("1"
                                (case-replace
                                 "nth(cdr(args_type), i) = nth(args_type, i+1)")
                                (("1"
                                  (case-replace
                                   "popDepth(car(args)) = 0")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1"
                                        (inst -13 "1+i")
                                        (("1"
                                          (expand is_well_typed -13)
                                          (("1"
                                            (expand add +)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand nth 1 2)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (expand nth 1 2)
                                (("2" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (expand length -3)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("6" (case-replace "popDepth(car(args)) = 0")
                        (("1" (assert)
                          (("1"
                            (case-replace
                             "stypes o list2finseq[nat](args_type) = add(car(args_type), stypes) o
                               list2finseq[nat](cdr(args_type))")
                            (("1" (delete 2)
                              (("1"
                                (delete 2)
                                (("1"
                                  (decompose-equality)
                                  (("1"
                                    (grind)
                                    (("1"
                                      (grind)
                                      (("1"
                                        (expand length -4)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand length -4)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (decompose-equality)
                                    (("2"
                                      (expand o)
                                      (("2"
                                        (expand add)
                                        (("2"
                                          (lift-if)
                                          (("2"
                                            (lift-if)
                                            (("2"
                                              (lift-if)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand list2finseq)
                                                  (("2"
                                                    (expand nth 1 2)
                                                    (("2"
                                                      (ground)
                                                      (("2"
                                                        (case-replace
                                                         "x!1 = stypes`length")
                                                        (("1"
                                                          (expand nth)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep :preds? t)
        (("3" (split)
          (("1" (rewrite popdepth_letApply)
            (("1" (rewrite purePopDepth)
              (("1" (rewrite purePopDepth)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (rewrite vars_letApply)
                (("1" (inst -8 "arity + i")
                  (("1" (inst -9 i)
                    (("1" (rewrite cvars_pure) (("1" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (use "rreduction.pure_letApply") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (skeep* :preds? t)
        (("4" (use pure_contextPure)
          (("4" (use "rreduction.pure_letApply")
            (("4" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("5" (delete 2)
      (("5" (skeep* :preds? t)
        (("5" (split)
          (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (delete 2)
      (("6" (skeep* :preds? t)
        (("6" (use pure_contextPure) (("6" (grind) nil nil)) nil))
        nil))
      nil)
     ("7" (delete 2)
      (("7" (skeep* :preds? t)
        (("7" (split)
          (("1" (rewrite purePopDepth)
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
           ("2" (skeep)
            (("2" (rewrite cvars_pure)
              (("1" (inst -8 i_1)
                (("1" (split -8)
                  (("1" (propax) nil nil)
                   ("2" (expand in_varlist)
                    (("2" (rewrite some_nth)
                      (("2" (inst 1 i1) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (delete 2)
      (("8" (skeep* :preds? t) (("8" (grind) nil nil)) nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nth def-decl "T" list_props nil)
    (contextPure? def-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (<= const-decl "bool" reals nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (letApply def-decl "IExpression" rreduction nil)
    (pred type-eq-decl nil defined_types nil)
    (letApply_type def-decl "typeinfo" typed_reduction nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pure_contextPure formula-decl nil IL nil)
    (pure_refs formula-decl nil IL nil)
    (is_well_typed_dom formula-decl nil typed_reduction nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (TRUE const-decl "bool" booleans nil)
    (some_map formula-decl nil finseq_theorems nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (O const-decl "T3" function_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (vars_letApply formula-decl nil rreduction nil)
    (cvars_pure formula-decl nil preprocess nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (purePopDepth formula-decl nil IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (some_nth formula-decl nil finseq_theorems nil))
   shostak))
 (typed_to_topstate_TCC1 0
  (typed_to_topstate_TCC1-1 nil 3702747756
   ("" (skeep)
    (("" (lemma to_topstate_dangling)
      (("" (inst?)
        (("" (assert)
          (("" (expand to_topstate)
            (("" (lemma arm_fill)
              (("" (inst?)
                (("" (typepred "tS`state") (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate_dangling judgement-tcc nil rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (arm_fill formula-decl nil preprocess nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_to_topstate_TCC2 0
  (typed_to_topstate_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`dom_types")
      (("" (expand to_topstate) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil))
   nil))
 (typed_to_topstate_TCC3 0
  (typed_to_topstate_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand to_topstate)
      (("" (typepred "tS`stack_types")
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil))
   nil))
 (typed_to_topstate_TCC4 0
  (typed_to_topstate_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand to_topstate)
      (("" (rewrite fill_well_typed)
        (("1" (skeep)
          (("1" (typepred "tS`state`redex")
            (("1" (typepred "tS`stack_types")
              (("1" (inst -4 "i-popDepth(tS`state`redex)")
                (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (typepred "tS`state`redex")
            (("2" (typepred "tS`stack_types")
              (("2" (inst -5 "i-popDepth(tS`state`context)")
                (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate const-decl "rtopstate" rreduction nil)
    (cvars_vars_ctx formula-decl nil preprocess nil)
    (cvars_vars formula-decl nil preprocess nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (fill_well_typed formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_to_topstate_TCC5 0
  (typed_to_topstate_TCC5-1 nil 3702747756 ("" (grind) nil nil)
   ((to_topstate const-decl "rtopstate" rreduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC1 0
  (make_redex_typed_TCC1-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC2 0
  (make_redex_typed_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (typepred "buildRedex(tS`state`redex)")
        (("" (typepred "tS`state")
          (("" (replace -4 -2 :dir RL)
            (("" (rewrite arm_fill)
              (("" (flatten)
                (("" (assert)
                  (("" (use make_redex_ndr)
                    (("" (lemma make_redex_ndr)
                      (("" (inst?)
                        (("" (expand make_redex)
                          (("" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (arm_fill formula-decl nil preprocess nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (make_redex_ndr application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (atom? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC3 0
  (make_redex_typed_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (typepred "tS`dom_types") (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureRedex? const-decl "bool" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (atom? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC4 0
  (make_redex_typed_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (expand make_redex)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC5 0
  (make_redex_typed_TCC5-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`redex_type")
      (("" (expand make_redex)
        (("" (use buildRedexType_correct)
          (("" (simplify :let-reduce? t)
            (("" (split -1)
              (("1" (grind) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (typepred "tS`stack_types")
                  (("2" (grind) nil nil)) nil))
                nil)
               ("3" (typepred "tS`stack_types")
                (("3" (typepred "tS`state`redex")
                  (("3" (skeep)
                    (("3" (inst -2 "i-popDepth(tS`state`redex)")
                      (("1" (rewrite cvars_vars)
                        (("1" (grind) nil nil)) nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((atom? const-decl "bool" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (make_redex_typed_TCC6 0
  (make_redex_typed_TCC6-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex)
      (("" (lemma buildRedexType_correct)
        (("" (simplify :let-reduce? t)
          ((""
            (inst -1 "tS`state`redex" "tS`def_types" "tS`dom_types"
             "tS`stack_types" "tS`redex_type")
            (("" (split -1)
              (("1" (grind) nil nil)
               ("2" (typepred "tS`state`redex")
                (("2" (propax) nil nil)) nil)
               ("3" (typepred "tS`state`redex") (("3" (grind) nil nil))
                nil)
               ("4" (typepred "tS`state`redex")
                (("4" (skeep)
                  (("4" (inst -2 "i-popDepth(tS`state`redex)")
                    (("1" (rewrite cvars_vars) (("1" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("5" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (buildRedexType_correct formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (set_new_type_TCC1 0
  (set_new_type_TCC1-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`state`store(r)`seq(j)")
      (("" (typepred "tS`dom_types") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (set_new_type_TCC2 0
  (set_new_type_TCC2-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`stack_types")
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep)
          (("2" (typepred "tS`state`stack")
            (("2" (typepred "tS`state`stack`seq(i_1)")
              (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (set_new_type_TCC3 0
  (set_new_type_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (lemma is_well_typed_dom)
      (("" (inst?)
        (("" (inst -1 "tS`dom_types")
          (("" (split -1)
            (("1" (typepred "tS`redex_type") (("1" (assert) nil nil))
              nil)
             ("2" (typepred "tS`state`redex") (("2" (propax) nil nil))
              nil)
             ("3" (skeep*)
              (("3" (typepred "tS`state`redex") (("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_well_typed_dom formula-decl nil typed_reduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (set_new_type_TCC4 0
  (set_new_type_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "tS`context_type")
      (("" (lemma is_well_typed_ctx_dom)
        (("" (inst?) (("" (inst? :where 1) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (is_well_typed_ctx_dom formula-decl nil typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (stack_still_typed_TCC1 0
  (stack_still_typed_TCC1-1 nil 3702752010 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (stack_still_typed_TCC2 0
  (stack_still_typed_TCC2-1 nil 3702752010 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (stack_still_typed_TCC3 0
  (stack_still_typed_TCC3-1 nil 3702752010 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (stack_still_typed 0
  (stack_still_typed-1 nil 3702752011
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (inst?)
          (("2" (inst?)
            (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (is_well_typed_release_set_TCC1 0
  (is_well_typed_release_set_TCC1-1 nil 3703336707
   ("" (skeep* :preds? t)
    (("" (rewrite contextPure_release_set) nil nil)) nil)
   ((contextPure_release_set formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   nil))
 (is_well_typed_release_set_TCC2 0
  (is_well_typed_release_set_TCC2-1 nil 3703336707
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (rewrite popDepth_release_set) nil nil)
       ("2" (skeep)
        (("2" (rewrite cvars_release_set)
          (("2" (expand* union member)
            (("2" (split)
              (("1" (grind) nil nil)
               ("2" (expand bumpn)
                (("2" (flatten)
                  (("2" (inst -7 "i-popDepth(A)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (popDepth_release_set formula-decl nil preprocess nil)
    (cvars_release_set formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (is_well_typed_release_set 0
  (is_well_typed_release_set-1 nil 3703336707
   ("" (induct X :name finite_set_induction)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand nonempty?)
        (("2" (expand release_set +)
          (("2" (assert)
            (("2" (inst? -5)
              (("1" (split -5)
                (("1" (replace -1)
                  (("1" (expand is_well_typed + 1)
                    (("1" (propax) nil nil)) nil))
                  nil)
                 ("2" (expand popDepth +)
                  (("2" (skeep :preds? t)
                    (("2" (inst -6 x) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand popDepth +)
                (("2" (expand cvars 1)
                  (("2" (skeep)
                    (("2" (expand add)
                      (("2" (expand member)
                        (("2" (split -1)
                          (("1" (inst -6 "choose(X_1)")
                            (("1" (grind) nil nil)) nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (delete 2)
      (("3" (skeep* :preds? t)
        (("3" (split)
          (("1" (rewrite popDepth_release_set) nil nil)
           ("2" (rewrite cvars_release_set)
            (("2" (expand* union member)
              (("2" (skeep)
                (("2" (split)
                  (("1" (grind) nil nil)
                   ("2" (expand bumpn)
                    (("2" (flatten)
                      (("2" (inst -7 "i-popDepth(A)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (delete 2)
      (("4" (skeep* :preds? t)
        (("4" (rewrite contextPure_release_set) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (release_set def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (finite_set_induction formula-decl nil finite_set_theorems nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_remove application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (remove const-decl "set" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (choose const-decl "(p)" sets nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (cvars_release_set formula-decl nil preprocess nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (union const-decl "set" sets nil)
    (popDepth_release_set formula-decl nil preprocess nil)
    (contextPure_release_set formula-decl nil preprocess nil))
   shostak))
 (is_well_typed_mark_TCC1 0
  (is_well_typed_mark_TCC1-1 nil 3702755599
   ("" (skeep* :preds? t) (("" (rewrite contextPure_mark) nil nil))
    nil)
   ((contextPure_mark formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   nil))
 (is_well_typed_mark_TCC2 0
  (is_well_typed_mark_TCC2-1 nil 3702755599
   ("" (skeep* :preds? t)
    (("" (rewrite popDepth_mark)
      (("" (rewrite cvars_mark)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((popDepth_mark formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (cvars_mark formula-decl nil preprocess nil))
   nil))
 (is_well_typed_mark 0
  (is_well_typed_mark-1 nil 3702755599
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand mark +)
        (("4" (expand is_well_typed +)
          (("4"
            (case "application1_var < def_types`length AND
        tA = leaft(def_types`seq(application1_var)`return_type) AND
         length(application2_var) =
          def_types`seq(application1_var)`args_type`length")
            (("1" (flatten)
              (("1" (assert)
                (("1" (typepred "markvars(X)(application2_var)")
                  (("1" (rewrite -1)
                    (("1" (rewrite -1)
                      (("1" (assert)
                        (("1"
                          (case-replace
                           "forall (i: below(length(application2_var))):
         is_well_typed(nth(application2_var, i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)
       =
         is_well_typed(nth(markvars(X)(application2_var), i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)")
                          (("1" (iff)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (skeep :preds? t)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (skeep* :preds? t)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (inst?)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete 2)
                            (("2" (skeep :preds? t)
                              (("2"
                                (case
                                 "variable?(nth(application2_var, i))")
                                (("1"
                                  (case
                                   "variable?(nth(markvars(X)(application2_var), i))")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1"
                                        (rewrite markvars_index +)
                                        nil
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (delete 2)
                            (("3" (skeep :preds? t)
                              (("3"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep :preds? t)
                                  (("2"
                                    (case
                                     "cvars(application(application1_var, application2_var))(i_1)")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (expand cvars)
                                      (("2"
                                        (expand vars)
                                        (("2"
                                          (expand in_varlist)
                                          (("2"
                                            (rewrite some_nth)
                                            (("2"
                                              (inst 1 i)
                                              (("2"
                                                (case
                                                 "variable?(nth[(variable?)](markvars(X)(application2_var), i))")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand singleton)
                                                    (("1"
                                                      (rewrite
                                                       markvars_index)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4" (delete 2)
                            (("4" (skeep) (("4" (grind) nil nil)) nil))
                            nil)
                           ("5" (delete 2)
                            (("5" (skeep)
                              (("5"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (inst -6 i_1)
                                    (("2"
                                      (split -6)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (expand cvars)
                                        (("2"
                                          (expand vars)
                                          (("2"
                                            (expand in_varlist)
                                            (("2"
                                              (rewrite some_nth)
                                              (("2"
                                                (inst 1 i)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("6" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "markvars(X)(application2_var)")
              (("2" (replace -2) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand mark +)
        (("5" (expand is_well_typed +)
          (("5" (case "lett?(tA)")
            (("1" (assert)
              (("1" (inst? -5)
                (("1" (split -5)
                  (("1" (assert)
                    (("1" (replace -1)
                      (("1" (rewrite popDepth_mark)
                        (("1"
                          (case "is_well_typed(mark(union(drop(vars(letexpr2_var)), X))
                          (letexpr1_var),
                      lrhs(tA), stypes, dom_types, def_types)
         AND
         expr_type(lrhs(tA)) = lettype(tA)")
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (lift-if)
                                (("1"
                                  (expand is_well_typed + 4)
                                  (("1"
                                    (inst
                                     -8
                                     "lbody(tA)"
                                     "add(lettype(tA), popn(stypes, popDepth(letexpr1_var)))"
                                     dom_types
                                     def_types
                                     "bump(X)")
                                    (("1"
                                      (split -8)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (use pure_contextPure)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (split)
                    (("1" (grind) nil nil)
                     ("2" (skeep)
                      (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand mark +)
        (("6" (expand is_well_typed +)
          (("6" (case "iftt?(tA)")
            (("1" (assert)
              (("1"
                (case "expr_type(tthen(tA)) = expr_type(telse(tA))")
                (("1" (assert)
                  (("1" (expand mark -7)
                    (("1" (inst? -7)
                      (("1" (split -7)
                        (("1" (replace -1 :dir RL)
                          (("1"
                            (case "is_well_typed(ift1_var, leaft(0), stypes, dom_types, def_types)")
                            (("1" (assert)
                              (("1"
                                (rewrite is_well_typed_release_set)
                                (("1"
                                  (rewrite is_well_typed_release_set)
                                  (("1"
                                    (inst? -9)
                                    (("1"
                                      (inst? -10)
                                      (("1"
                                        (split -9)
                                        (("1"
                                          (split -10)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (use pure_contextPure)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use pure_contextPure)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (delete 2)
                                        (("2"
                                          (rewrite cvars_pure)
                                          (("1"
                                            (split)
                                            (("1"
                                              (rewrite purePopDepth)
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (inst?)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (rewrite purePopDepth)
                                      (("1"
                                        (rewrite cvars_pure)
                                        (("1"
                                          (split)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (inst?)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (skeep :preds? t)
                                    (("2"
                                      (rewrite popDepth_mark)
                                      (("2"
                                        (rewrite purePopDepth)
                                        (("1"
                                          (inst?)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (rewrite popDepth_mark)
                                    (("3"
                                      (split)
                                      (("1"
                                        (rewrite purePopDepth)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (rewrite cvars_mark)
                                        (("2"
                                          (rewrite cvars_pure)
                                          (("1"
                                            (skeep)
                                            (("1"
                                              (inst?)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (rewrite contextPure_mark)
                                    (("4"
                                      (use pure_contextPure)
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skeep :preds? t)
                                  (("2"
                                    (rewrite popDepth_mark)
                                    (("2"
                                      (rewrite purePopDepth)
                                      (("1"
                                        (inst?)
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (rewrite popDepth_mark)
                                  (("3"
                                    (rewrite purePopDepth)
                                    (("1"
                                      (rewrite cvars_mark)
                                      (("1"
                                        (rewrite cvars_pure)
                                        (("1"
                                          (split)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (inst?)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (rewrite contextPure_mark)
                                  (("4"
                                    (use pure_contextPure)
                                    (("4" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (split)
                          (("1" (grind) nil nil)
                           ("2" (skeep)
                            (("2" (inst -5 i) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand mark +)
        (("7" (expand is_well_typed +) (("7" (grind) nil nil)) nil))
        nil))
      nil)
     ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (skeep* :preds? t)
      (("11" (expand mark +)
        (("11" (expand is_well_typed +)
          (("11" (case "popt?(tA)")
            (("1" (assert)
              (("1" (inst?) (("1" (inst?) (("1" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep* :preds? t)
      (("13" (expand mark +)
        (("13" (expand is_well_typed +)
          (("13" (inst? -6)
            (("13" (split)
              (("1" (propax) nil nil)
               ("2" (use pure_contextPure) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (rewrite popDepth_mark)
          (("14" (split)
            (("1" (propax) nil nil)
             ("2" (skeep)
              (("2" (rewrite cvars_mark) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (delete 2)
      (("15" (skeep* :preds? t)
        (("15" (rewrite contextPure_mark) nil nil)) nil))
      nil))
    nil)
   ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (injective? const-decl "bool" functions nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (markv const-decl "(variable?)" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (markvars_index formula-decl nil preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (markvars def-decl "{J | length(J) = length(L)}" preprocess nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popDepth_mark formula-decl nil preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (pure_contextPure formula-decl nil IL nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (member const-decl "bool" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (difference const-decl "set" sets nil)
    (is_well_typed_release_set formula-decl nil typed_rreduction nil)
    (contextPure_mark formula-decl nil preprocess nil)
    (cvars_mark formula-decl nil preprocess nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (empty? const-decl "bool" sets nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (purePopDepth formula-decl nil IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (cvars_pure formula-decl nil preprocess nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (finite_difference application-judgement "finite_set[nat]"
     countability "sets_aux/")
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil))
   shostak))
 (is_well_typed_unmark_TCC1 0
  (is_well_typed_unmark_TCC1-1 nil 3702755599
   ("" (skeep*) (("" (rewrite unmark_contextPure) nil nil)) nil)
   ((unmark_contextPure recursive-judgement-axiom nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (is_well_typed_unmark_TCC2 0
  (is_well_typed_unmark_TCC2-1 nil 3702755599
   ("" (skeep* :preds? t)
    (("" (rewrite unmark_popDepth)
      (("" (split)
        (("1" (propax) nil nil)
         ("2" (skeep)
          (("2" (lemma unmark_cvars)
            (("2" (inst -1 A i) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((unmark_popDepth formula-decl nil preprocess nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (unmark_cvars formula-decl nil preprocess nil))
   nil))
 (is_well_typed_unmark 0
  (is_well_typed_unmark-1 nil 3702758947
   ("" (induct A)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep* :preds? t)
      (("4" (expand unmark +)
        (("4" (expand is_well_typed +)
          (("4" (typepred "unmarkvars(application2_var)")
            (("4" (replace -2)
              (("4"
                (case "application1_var < def_types`length AND
         tA = leaft(def_types`seq(application1_var)`return_type) AND
          length(application2_var) =
           def_types`seq(application1_var)`args_type`length")
                (("1" (flatten)
                  (("1" (assert)
                    (("1"
                      (case "forall (i: below(length(application2_var))):
         is_well_typed(nth(application2_var, i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)
       =
         is_well_typed(nth(unmarkvars(application2_var), i),
                       leaft(def_types`seq(application1_var)`args_type`seq
                                 (i)),
                       stypes, dom_types, def_types)")
                      (("1" (hide-all-but (1 -1))
                        (("1" (iff)
                          (("1" (split)
                            (("1" (flatten)
                              (("1"
                                (skeep)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (inst?)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (skeep)
                                (("2"
                                  (inst?)
                                  (("2"
                                    (inst?)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (skeep)
                          (("2" (rewrite unmarkvars_nth)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("3" (delete 2)
                        (("3" (skeep* :preds? t)
                          (("3" (rewrite unmarkvars_nth)
                            (("3" (rewrite unmark_unmarkvar :dir RL)
                              (("3"
                                (rewrite unmark_popDepth)
                                (("3"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (lemma unmark_cvars)
                                      (("2"
                                        (inst
                                         -1
                                         "nth(application2_var, i)"
                                         i_1)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (inst -10 i_1)
                                            (("2"
                                              (expand cvars -10)
                                              (("2"
                                                (expand vars)
                                                (("2"
                                                  (expand in_varlist)
                                                  (("2"
                                                    (rewrite some_nth)
                                                    (("2"
                                                      (inst?)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (delete 2) (("4" (grind) nil nil)) nil)
                       ("5" (delete 2)
                        (("5" (skeep)
                          (("5" (split)
                            (("1" (grind) nil nil)
                             ("2" (skeep)
                              (("2"
                                (inst -8 "i_1")
                                (("2"
                                  (split -8)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (expand cvars +)
                                    (("2"
                                      (expand vars)
                                      (("2"
                                        (expand in_varlist)
                                        (("2"
                                          (rewrite some_nth)
                                          (("2"
                                            (inst?)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("6" (delete 2) (("6" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep* :preds? t)
      (("5" (expand unmark +)
        (("5" (expand is_well_typed +)
          (("5" (case "lett?(tA)")
            (("1" (assert)
              (("1" (rewrite unmark_popDepth)
                (("1" (inst? -4)
                  (("1" (inst? -5)
                    (("1" (split -5)
                      (("1" (grind) nil nil)
                       ("2" (use pure_contextPure)
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (delete 2)
                      (("2" (split)
                        (("1" (rewrite purePopDepth)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (skeep)
                          (("2" (rewrite cvars_pure)
                            (("1"
                              (inst -4 "i-1+popDepth(letexpr1_var)")
                              (("1"
                                (split -4)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (grind) nil nil)
                       ("2" (skeep) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep* :preds? t)
      (("6" (expand unmark +)
        (("6" (expand is_well_typed +)
          (("6" (case "iftt?(tA)")
            (("1" (assert)
              (("1" (rewrite unmark_unmarkvar)
                (("1" (inst? -5)
                  (("1" (inst? -6)
                    (("1" (inst? -7)
                      (("1" (split -6)
                        (("1" (split -7)
                          (("1" (grind) nil nil)
                           ("2" (use pure_contextPure)
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("2" (use pure_contextPure)
                          (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (delete 2)
                        (("2" (rewrite purePopDepth)
                          (("1" (split)
                            (("1" (grind) nil nil)
                             ("2" (skeep)
                              (("2"
                                (rewrite cvars_pure)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete 2)
                      (("2" (rewrite purePopDepth)
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (rewrite cvars_pure)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete 2)
                    (("2" (split)
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skeep* :preds? t)
      (("7" (expand unmark +)
        (("7" (expand is_well_typed +)
          (("7" (rewrite unmark_unmarkvar)
            (("7" (rewrite unmark_unmarkvar)
              (("7" (rewrite unmark_unmarkvar) (("7" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep* :preds? t)
      (("8" (expand unmark +)
        (("8" (rewrite unmark_unmarkvar)
          (("8" (rewrite unmark_unmarkvar) (("8" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (grind) nil nil) ("10" (grind) nil nil)
     ("11" (grind) nil nil) ("12" (grind) nil nil)
     ("13" (grind) nil nil)
     ("14" (delete 2)
      (("14" (skeep* :preds? t)
        (("14" (rewrite unmark_popDepth)
          (("14" (split)
            (("1" (propax) nil nil)
             ("2" (skeep)
              (("2" (lemma unmark_cvars)
                (("2" (inst -1 A i) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (delete 2)
      (("15" (skeep*) (("15" (use unmark_contextPure) nil nil)) nil))
      nil))
    nil)
   ((unmark_contextPure recursive-judgement-axiom nil preprocess nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (emptyset const-decl "set" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (telse adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (add const-decl "(nonempty?)" sets nil)
    (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil)
    (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (cvars_pure formula-decl nil preprocess nil)
    (purePopDepth formula-decl nil IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (pure_contextPure formula-decl nil IL nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (seq type-eq-decl nil more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (unmarkvar const-decl "(variable?)" preprocess nil)
    (unmarkvars_nth formula-decl nil preprocess nil)
    (unmark_unmarkvar formula-decl nil preprocess nil)
    (unmark_cvars formula-decl nil preprocess nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (singleton const-decl "(singleton?)" sets nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (unmark_popDepth formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaft adt-constructor-decl "[nat -> (leaft?)]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (length def-decl "nat" list_props nil)
    (unmarkvars def-decl "list[(variable?)]" preprocess nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unmarkvars_length rec-application-judgement
     "{J | length(J) = length(L)}" preprocess nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil))
   shostak))
 (decref_new_values_TCC1 0
  (decref_new_values_TCC1-1 nil 3702831701
   ("" (skeep* :preds? t)
    (("" (typepred "decref(rS, r, i)")
      (("" (inst?) (("" (bash) nil nil)) nil)) nil))
    nil)
   ((decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_new_values_TCC2 0
  (decref_new_values_TCC2-1 nil 3702831701 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (decref_new_values 0
  (decref_new_values-1 nil 3702831702
   ("" (skeep* :preds? t)
    (("" (lemma decref_induction)
      ((""
        (inst -1
         "LAMBDA (rS2: rstate): rS2`domain(s) AND j < rS2`store(s)`length IMPLIES rS2`store(s)`seq(j) = rS`store(s)`seq(j) OR (ref?(rS`store(s)`seq(j)) AND rS2`store(s)`seq(j) = nil)")
        (("" (split -1)
          (("1" (inst?)
            (("1" (split -1)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (typepred "decref(rS, r, i)")
                (("3" (replace -2) (("3" (propax) nil nil)) nil)) nil)
               ("4" (typepred "decref(rS, r, i)")
                (("4" (inst?)
                  (("4" (flatten)
                    (("4" (replace -3) (("4" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (rS2 r2 i2))
            (("2" (flatten)
              (("2" (simplify)
                (("2" (split -1)
                  (("1" (case-replace "r2 = s")
                    (("1" (case-replace "i2 = j")
                      (("1" (simplify) (("1" (grind) nil nil)) nil)
                       ("2" (simplify)
                        (("2" (lift-if) (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (lift-if) (("2" (assert) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (case-replace "r2 = s")
                      (("1" (case-replace "i2 = j")
                        (("1" (assert) nil nil)
                         ("2" (simplify)
                          (("2" (lift-if) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (simplify)
                        (("2" (lift-if) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("3" (propax) nil nil)
                   ("4" (lift-if -)
                    (("4" (simplify) (("4" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((decref_induction formula-decl nil reduction_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (allcountStore const-decl "nat" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}"
     reduction_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateReduce_new_stack_TCC1 0
  (updateReduce_new_stack_TCC1-1 nil 3702833125
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_new_stack_TCC2 0
  (updateReduce_new_stack_TCC2-1 nil 3702833125
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_new_stack 0
  (updateReduce_new_stack-2 "" 3702917238
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "updateReduce(D)(rS)`stack`length = rS`stack`length")
      (("1" (hide -1)
        (("1" (skeep :preds? t)
          (("1"
            (case "updateReduce(D)(rS)`stack`seq(i) = rS`stack`seq(i) OR (ref?(rS`stack`seq(i)) AND updateReduce(D)(rS)`stack`seq(i) = nil)")
            (("1" (prop) nil nil)
             ("2" (delete 3 4)
              (("2" (expand updateReduce :assert? none)
                (("2" (expand decref)
                  (("2" (simplify :let-reduce? t)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand updateReduce :assert? none)
          (("2" (expand decref)
            (("2" (simplify :let-reduce? t)
              (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak)
  (updateReduce_new_stack-1 nil 3702833126
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "updateReduce(D)(rS)`stack`length = rS`stack`length")
      (("1" (hide -1)
        (("1" (skeep :preds? t)
          (("1"
            (case "updateReduce(D)(rS)`stack`seq(i) = rS`stack`seq(i) OR (ref?(rS`stack`seq(i)) AND updateReduce(D)(rS)`stack`seq(i) = nil)")
            (("1" (prop) nil nil)
             ("2" (delete 3 4)
              (("2" (expand updateReduce :assert? none)
                (("2" (expand decref)
                  (("2" (simplify :let-reduce? t)
                    (("2" (lift-if)
                      (("2" (split +)
                        (("1" (flatten)
                          (("1" (split +)
                            (("1" (flatten)
                              (("1"
                                (split +)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (lift-if +)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split +)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (split +)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (split +)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (lift-if +)
                                                          (("1"
                                                            (split +)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (split
                                                                 +)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (lift-if
                                                                         +)
                                                                        (("2"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (split +)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (lift-if
                                                                 +)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (lift-if
                                                               +)
                                                              (("2"
                                                                (split
                                                                 +)
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (split
                                                                         +)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split +)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (lift-if +)
                                                  (("1"
                                                    (split +)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (split +)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (split +)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (lift-if
                                                                       +)
                                                                      (("1"
                                                                        (split
                                                                         +)
                                                                        (("1"
                                                                          (propax)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (split
                                                                             +)
                                                                            (("1"
                                                                              (flatten)
                                                                              (("1"
                                                                                (split
                                                                                 +)
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (split +)
                                                              (("1"
                                                                (flatten)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (flatten)
                                                                (("2"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        (("1"
                                                                          (lift-if
                                                                           +)
                                                                          (("1"
                                                                            (split
                                                                             +)
                                                                            (("1"
                                                                              (propax)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (split
                                                                                 +)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  nil
                                                                                  nil)
                                                                                 ("2"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (split +)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (split +)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (lift-if
                                                                 +)
                                                                (("1"
                                                                  (split
                                                                   +)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (flatten)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (split
                                                                           +)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (split
                                                                               +)
                                                                              (("1"
                                                                                (flatten)
                                                                                (("1"
                                                                                  (lift-if
                                                                                   +)
                                                                                  (("1"
                                                                                    (split
                                                                                     +)
                                                                                    (("1"
                                                                                      (propax)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (flatten)
                                                                                      (("2"
                                                                                        (split
                                                                                         +)
                                                                                        (("1"
                                                                                          (flatten)
                                                                                          (("1"
                                                                                            (split
                                                                                             +)
                                                                                            (("1"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil)
                                                                                             ("2"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil)
                                                                                         ("2"
                                                                                          (propax)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (lift-if
                                                                                 +)
                                                                                (("2"
                                                                                  (flatten)
                                                                                  (("2"
                                                                                    (split
                                                                                     +)
                                                                                    (("1"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil)
                                                                                     ("2"
                                                                                      (assert)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              (("2"
                                                                (lift-if
                                                                 +)
                                                                (("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (split
                                                                         +)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (flatten)
                                                            (("2"
                                                              (split +)
                                                              (("1"
                                                                (lift-if
                                                                 +)
                                                                (("1"
                                                                  (flatten)
                                                                  (("1"
                                                                    (split
                                                                     +)
                                                                    (("1"
                                                                      (flatten)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                (("2"
                                                                  (lift-if
                                                                   +)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (split
                                                                       +)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (flatten)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (lift-if +)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (split +)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (split +)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (lift-if +)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand updateReduce)
          (("2" (simplify)
            (("2" (assert)
              (("2" (expand decref)
                (("2" (lift-if +)
                  (("2" (assert)
                    (("2" (split +)
                      (("1" (flatten)
                        (("1" (split +)
                          (("1" (flatten)
                            (("1" (split +)
                              (("1"
                                (flatten)
                                (("1"
                                  (lift-if +)
                                  (("1"
                                    (split +)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split +)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (split +)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (rewrite
                                                 decref1_preserves_stack)
                                                (("1"
                                                  (simplify)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (rewrite
                                               decref1_preserves_stack)
                                              (("2"
                                                (simplify)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (lift-if +)
                                  (("2"
                                    (split +)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (split +)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (split +)
                                            (("1"
                                              (rewrite
                                               decref1_preserves_stack)
                                              (("1"
                                                (simplify)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (rewrite
                                               decref1_preserves_stack)
                                              (("2"
                                                (simplify)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (lift-if +)
                              (("2"
                                (split +)
                                (("1"
                                  (split +)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (split +)
                                          (("1" (flatten) nil nil)
                                           ("2"
                                            (rewrite
                                             decref1_preserves_stack)
                                            (("2"
                                              (simplify)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (split +)
                                  (("1" (propax) nil nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (split +)
                                              (("1" (flatten) nil nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (rewrite
                                                   decref1_preserves_stack)
                                                  (("2"
                                                    (simplify)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite
                                             decref1_preserves_stack)
                                            (("2"
                                              (simplify)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref1_preserves_domain 0
  (decref1_preserves_domain-1 nil 3703255356
   ("" (skeep* :preds? t)
    (("" (typepred "decref1(rS, r, i)") (("" (propax) nil nil)) nil))
    nil)
   ((decref1 def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))}"
     rreduction nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (allcountStore const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref1_preserves_store_length_TCC1 0
  (decref1_preserves_store_length_TCC1-1 nil 3702993949
   ("" (subtype-tcc) nil nil)
   ((decref1_preserves_domain formula-decl nil typed_rreduction nil))
   nil))
 (decref1_preserves_store_length 0
  (decref1_preserves_store_length-1 nil 3703255372
   ("" (skeep* :preds? t)
    (("" (lemma decref1_induction)
      ((""
        (inst -1
         "LAMBDA (rS2: rstate): rS2`domain(s) AND rS2`store(s)`length = rS`store(s)`length")
        (("" (split)
          (("1" (inst?) (("1" (prop) nil nil)) nil)
           ("2" (skeep* :preds? t)
            (("2" (simplify) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((decref1_induction formula-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (value_maybe_freed_type 0
  (value_maybe_freed_type-1 nil 3703261830 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil))
   shostak))
 (decref1_preserves_store_TCC1 0
  (decref1_preserves_store_TCC1-1 nil 3702993949
   ("" (subtype-tcc) nil nil)
   ((value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil))
   nil))
 (decref1_preserves_store 0
  (decref1_preserves_store-1 nil 3703010923
   ("" (skeep* :preds? t)
    (("" (use decref1_induction)
      ((""
        (inst -1
         "LAMBDA (rS2: rstate): rS2`domain(s) AND j < rS2`store(s)`length AND value_maybe_freed(u, rS2`store(s)`seq(j))")
        (("" (split -1)
          (("1" (inst?) (("1" (prop) nil nil)) nil)
           ("2" (skeep :preds? t)
            (("2" (simplify) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((decref1_induction formula-decl nil rreduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (decref1_preserves_store2_TCC1 0
  (decref1_preserves_store2_TCC1-1 nil 3703253343
   ("" (subtype-tcc) nil nil)
   ((value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil))
   nil))
 (decref1_preserves_store2 0
  (decref1_preserves_store2-1 nil 3703255673
   ("" (skeep* :preds? t)
    (("" (expand value_maybe_freed2)
      (("" (split) (("1" (assert) nil nil) ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (decref1_preserves_store formula-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (releaseReduce_new_store_TCC1 0
  (releaseReduce_new_store_TCC1-1 nil 3703269542
   ("" (subtype-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (releaseReduce_new_store_TCC2 0
  (releaseReduce_new_store_TCC2-1 nil 3703269542
   ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil))
 (releaseReduce_new_store 0
  (releaseReduce_new_store-1 nil 3703269543
   ("" (skeep* :preds? t)
    (("" (case "rS`domain(r)")
      (("1" (assert)
        (("1"
          (case "releaseReduce(D)(rS)`store(r)`length = rS`store(r)`length")
          (("1" (assert)
            (("1" (skeep :preds? t)
              (("1" (replace -2)
                (("1" (hide -2 -4)
                  (("1" (expand releaseReduce)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (expand decref)
                            (("1" (assert)
                              (("1"
                                (name-replace u "rS`store(r)`seq(j)")
                                (("1"
                                  (assert)
                                  (("1"
                                    (case
                                     "value_maybe_freed(u, rS`store(r)`seq(j))")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (expand u)
                                      (("2"
                                        (expand value_maybe_freed)
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (delete 3)
            (("2" (hide -2)
              (("2" (expand releaseReduce)
                (("2" (expand decref)
                  (("2" (lift-if)
                    (("2" (split)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 3)
        (("2" (expand releaseReduce)
          (("2" (expand decref)
            (("2" (split)
              (("1" (flatten) (("1" (assert) nil nil)) nil)
               ("2" (flatten) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1_preserves_store formula-decl nil typed_rreduction nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil)
    (releaseReduce_ndr application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (decref1_preserves_domain formula-decl nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateReduce_new_store_TCC1 0
  (updateReduce_new_store_TCC1-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_new_store_TCC2 0
  (updateReduce_new_store_TCC2-1 nil 3702993203
   ("" (skeep* :preds? t)
    (("" (use updateRedex_target_index)
      (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((updateRedex_target_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_new_store_TCC3 0
  (updateReduce_new_store_TCC3-1 nil 3702993203
   ("" (skeep* :preds? t)
    (("" (typepred "rS`stack")
      (("" (expand every)
        (("" (expand get)
          (("" (inst?)
            (("1" (expand domainValue?) (("1" (prop) nil nil)) nil)
             ("2" (use updateRedex_target_index)
              (("2" (prop) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Stack type-eq-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (domainValue? const-decl "bool" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_new_store_TCC4 0
  (updateReduce_new_store_TCC4-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_new_store_TCC5 0
  (updateReduce_new_store_TCC5-1 nil 3702993203
   ("" (skeep* :preds? t)
    (("" (use updateRedex_rhs_index) (("" (prop) nil nil)) nil)) nil)
   ((updateRedex_rhs_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_new_store_TCC6 0
  (updateReduce_new_store_TCC6-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_new_store_TCC7 0
  (updateReduce_new_store_TCC7-1 nil 3702993203
   ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_new_store_TCC8 0
  (updateReduce_new_store_TCC8-1 nil 3702993203
   ("" (skeep* :preds? t)
    (("" (use updateRedex_rhs_index)
      (("" (use updateRedex_target_index) (("" (prop) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateRedex_rhs_index formula-decl nil rreduction nil))
   nil))
 (updateReduce_new_store_TCC9 0
  (updateReduce_new_store_TCC9-1 nil 3703256673
   ("" (skeep* :preds? t)
    (("" (use updateRedex_rhs_index) (("" (prop) nil nil)) nil)) nil)
   ((updateRedex_rhs_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_new_store 0
  (updateReduce_new_store-5 "" 3703257865
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF ref?(get(rS`stack)(target(rS`redex))) AND r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2)
                              (("1" (propax) nil nil)) nil)
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                                                WITH [(refindex
                                                                       (get
                                                                        (rS`stack)
                                                                        (target(rS`redex))))
                                                                      `seq
                                                                      (value
                                                                       (get
                                                                        (rS`stack)
                                                                        (lhs(rS`redex))))
                                                                      := get
                                                                         (rS`stack)
                                                                         (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j),
                         IF r = refindex(get(rS`stack)(target(rS`redex)))
                           THEN get(rS`stack)(rhs(rS`redex))
                         ELSE rS`store(r)`seq(j)
                         ENDIF, nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (name-replace
                                                             "v"
                                                             "IF r = refindex(get(rS`stack)(target(rS`redex)))
                           THEN get(rS`stack)(rhs(rS`redex))
                         ELSE rS`store(r)`seq(j)
                         ENDIF")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep) nil nil) ("3" (skeep) nil nil)
                           ("4" (skeep) nil nil))
                          nil)
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil)
                       ("3" (expand updateRedex?)
                        (("3" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (add const-decl "(nonempty?)" sets nil)
    (get const-decl "(value?)" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1_preserves_domain formula-decl nil typed_rreduction nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (decref1_preserves_store2 formula-decl nil typed_rreduction nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (member const-decl "bool" sets nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil)
  (updateReduce_new_store-4 "" 3703257560
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil)))))
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil)))))))))))))
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil)))
                           ("2" (propax) nil)))))))))
                   ("2" (propax) nil)))))))))))))
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil)))))
                           ("2" (propax) nil)))))))))))
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF ref?(get(rS`stack))(target(rS`redex)) AND r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2) (("1" (propax) nil)))
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil)))))
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                                                WITH [(refindex
                                                                       (get
                                                                        (rS`stack)
                                                                        (target(rS`redex))))
                                                                      `seq
                                                                      (value
                                                                       (get
                                                                        (rS`stack)
                                                                        (lhs(rS`redex))))
                                                                      := get
                                                                         (rS`stack)
                                                                         (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil)))))
                                                         ("3"
                                                          (propax)
                                                          nil)))
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil)))))))
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil)))))))))))))))))))
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2"
                                                (grind)
                                                nil)))))))))))))
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil)))))))))))))))
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1" (assert) (("1" (grind) nil)))
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil)))))))))))
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil)
                           ("2" (propax) nil)))))))))))))))
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil))))))))))))))))
    nil)
   nil nil)
  (updateReduce_new_store-3 "" 3703257039
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil)))))
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil)))))))))))))
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil)))
                           ("2" (propax) nil)))))))))
                   ("2" (propax) nil)))))))))))))
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil)))))
                           ("2" (propax) nil)))))))))))
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), IF r = refindex(get(rS`stack)(target(rS`redex))) THEN get(rS`stack)(rhs(rS`redex)) ELSE rS`store(r)`seq(j) ENDIF, u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2) (("1" (propax) nil)))
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil)))))
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                                                WITH [(refindex
                                                                       (get
                                                                        (rS`stack)
                                                                        (target(rS`redex))))
                                                                      `seq
                                                                      (value
                                                                       (get
                                                                        (rS`stack)
                                                                        (lhs(rS`redex))))
                                                                      := get
                                                                         (rS`stack)
                                                                         (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil)))))
                                                         ("3"
                                                          (propax)
                                                          nil)))
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil)))))))
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil)))))))))))))))))))
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2"
                                                (grind)
                                                nil)))))))))))))
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil)))))))))))))))
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1" (assert) (("1" (grind) nil)))
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil)))))))))))
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil)
                           ("2" (propax) nil)))))))))))))))
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil))))))))))))))))
    nil)
   nil nil)
  (updateReduce_new_store-2 "" 3703005669
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce +)
                              (("2"
                                (replace -2)
                                (("2"
                                  (hide-all-but +)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten)
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -2)
                  (("2" (skeep* :preds? t)
                    (("2"
                      (case "index(target(rS`redex)) < rS`stack`length")
                      (("1"
                        (case "index(rhs(rS`redex)) < rS`stack`length")
                        (("1"
                          (name-replace "vmf2"
                           "LAMBDA u: value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), u)")
                          (("1"
                            (case "vmf2(updateReduce(D)(rS)`store(r)`seq(j))")
                            (("1" (expand vmf2)
                              (("1" (propax) nil nil)) nil)
                             ("2" (delete 2)
                              (("2"
                                (expand updateReduce)
                                (("2"
                                  (split +)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (split +)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand vmf2)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split +)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand decref)
                                              (("1"
                                                (expand vmf2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (name-replace
                                                     "nstore"
                                                     "rS`store
                                            WITH [(refindex
                                                   (get
                                                    (rS`stack)
                                                    (target(rS`redex))))
                                                  `seq
                                                  (value
                                                   (get
                                                    (rS`stack)
                                                    (lhs(rS`redex))))
                                                  := get
                                                     (rS`stack)
                                                     (rhs(rS`redex))]")
                                                    (("1"
                                                      (case
                                                       "j < nstore(r)`length")
                                                      (("1"
                                                        (case
                                                         "value_maybe_freed2(rS`store(r)`seq(j), get(rS`stack)(rhs(rS`redex)), nstore(r)`seq(j))")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (delete 2)
                                                          (("2"
                                                            (expand
                                                             nstore)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (delete 2)
                                                        (("2"
                                                          (expand
                                                           nstore)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (delete 2)
                                                      (("2"
                                                        (typepred
                                                         "rS`stack")
                                                        (("2"
                                                          (expand get)
                                                          (("2"
                                                            (expand
                                                             every)
                                                            (("2"
                                                              (inst
                                                               -1
                                                               "rS`stack`length - 1 - index(rhs(rS`redex))")
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand vmf2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand vmf2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "rS`redex")
                          (("2" (inst -2 "index(rhs(rS`redex))")
                            (("2" (case "update?(rS`redex)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand updateRedex?)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use updateRedex_target_index)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (expand decref) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (decref1_preserves_store_length formula-decl nil typed_rreduction
     nil)
    (member const-decl "bool" sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (decref1_preserves_store2 formula-decl nil typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (decref1_preserves_domain formula-decl nil typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (value_maybe_freed const-decl "boolean" typed_rreduction nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (get const-decl "(value?)" IL nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak)
  (updateReduce_new_store-1 nil 3702993204
   ("" (skeep* :preds? t)
    (("" (case-replace "r = least_out(rS`domain)")
      (("1" (assert)
        (("1" (delete 3)
          (("1" (expand updateReduce -2)
            (("1" (assert)
              (("1" (expand decref)
                (("1" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand updateReduce)
                            (("1" (expand decref)
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (skeep :preds? t)
                            (("2" (expand updateReduce)
                              (("2"
                                (expand decref)
                                (("2"
                                  (split)
                                  (("1"
                                    (replace -2)
                                    (("1"
                                      (lift-if +)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -2)
                                    (("2"
                                      (lift-if)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (delete 3)
          (("2" (case "rS`domain(r)")
            (("1" (assert)
              (("1" (split)
                (("1" (delete -2)
                  (("1" (expand updateReduce)
                    (("1" (expand decref)
                      (("1" (lift-if)
                        (("1" (split)
                          (("1" (flatten) (("1" (postpone) nil nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (postpone) nil nil))
                nil))
              nil)
             ("2" (delete 4)
              (("2" (expand updateReduce)
                (("2" (split -)
                  (("1" (flatten)
                    (("1" (split -)
                      (("1" (flatten)
                        (("1" (expand add)
                          (("1" (expand member)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -)
                          (("1" (flatten)
                            (("1" (assert)
                              (("1"
                                (expand decref)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (updateReduce_redex_TCC1 0
  (updateReduce_redex_TCC1-1 nil 3702925500 ("" (subtype-tcc) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get const-decl "(value?)" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (updateReduce_redex_TCC2 0
  (updateReduce_redex_TCC2-1 nil 3702925500
   ("" (skeep* :preds? t)
    (("" (use updateRedex_target_index) (("" (prop) nil nil)) nil))
    nil)
   ((updateRedex_target_index formula-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (updateReduce_redex 0
  (updateReduce_redex-1 nil 3702925501
   ("" (skeep* :preds? t)
    ((""
      (case "updateReduce(D)(rS)`redex = ref(least_out(rS`domain)) OR updateReduce(D)(rS)`redex = get(rS`stack)(target(rS`redex)) OR updateReduce(D)(rS)`redex = rS`redex")
      (("1" (split)
        (("1" (propax) nil nil) ("2" (propax) nil nil)
         ("3" (propax) nil nil))
        nil)
       ("2" (delete 3 4 5)
        (("2" (expand updateReduce)
          (("2" (expand decref) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (updateReduce_context 0
  (updateReduce_context-1 nil 3702929446
   ("" (skeep* :preds? t)
    (("" (expand updateReduce)
      (("" (expand decref) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (get const-decl "(value?)" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (typed_reduce_TCC1 0
  (typed_reduce_TCC1-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC2 0
  (typed_reduce_TCC2-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC3 0
  (typed_reduce_TCC3-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use letReduce_ndr)
      (("1" (use letReduce_arm) (("1" (grind) nil nil)) nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1" (expand* typed_to_topstate to_topstate)
              (("1" (expand* make_redex_typed make_redex) nil nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((letReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (letReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC4 0
  (typed_reduce_TCC4-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC5 0
  (typed_reduce_TCC5-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "letexpr?(nS`state`redex)")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC6 0
  (typed_reduce_TCC6-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (split)
        (("1" (expand add)
          (("1" (expand push)
            (("1" (expand add) (("1" (grind) nil nil)) nil)) nil))
          nil)
         ("2" (skeep :preds? t)
          (("2" (case-replace "i = nS`stack_types`length")
            (("1" (typepred "nS`stack_types")
              (("1" (expand push)
                (("1" (expand add)
                  (("1" (lift-if)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (typepred "nS`redex_type")
                            (("1" (case "letexpr?(nS`state`redex)")
                              (("1"
                                (assert)
                                (("1"
                                  (expand is_well_typed)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand is_well_typed -3)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand expr_type)
                                            (("1"
                                              (expand get)
                                              (("1"
                                                (typepred
                                                 "nS`stack_types")
                                                (("1"
                                                  (inst
                                                   -2
                                                   "nS`state`stack`length - 1 -
                           index(letrhs(nS`state`redex))")
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (typepred
                                                     "nS`state`redex")
                                                    (("2"
                                                      (inst
                                                       -2
                                                       "index(letrhs(nS`state`redex))")
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (case "letexpr?(nS`state`redex)")
                            (("1"
                              (case "value?(letrhs(nS`state`redex))")
                              (("1"
                                (assert)
                                (("1"
                                  (typepred "nS`redex_type")
                                  (("1"
                                    (expand is_well_typed -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (rewrite value_well_typed -2)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "nS`stack_types`length")
              (("2" (assert)
                (("2" (lift-if)
                  (("2" (expand push)
                    (("2" (expand add)
                      (("2" (typepred "nS`stack_types")
                        (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get const-decl "(value?)" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (drop const-decl "finite_set[nat]" IL nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (bump const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (seq type-eq-decl nil more_finseq nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC7 0
  (typed_reduce_TCC7-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (lift-if)
        (("" (expand is_well_typed +)
          (("" (expand is_well_typed + 1)
            (("" (typepred "nS`redex_type")
              (("" (assert)
                (("" (case "letexpr?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (expand is_well_typed -)
                      (("1"
                        (case-replace
                         "popDepth(letrhs(nS`state`redex)) = 0")
                        (("1" (assert) nil nil)
                         ("2" (expand pureLetRedex?)
                          (("2" (expand letRedex?)
                            (("2" (flatten)
                              (("2"
                                (hide-all-but (1 -8))
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC8 0
  (typed_reduce_TCC8-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand letReduce)
      (("" (expand popDepth +)
        (("" (expand popDepth + 1)
          (("" (rewrite purePopDepth)
            (("1" (assert)
              (("1"
                (case-replace
                 "popn(add[nat](lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types")
                (("1"
                  (case-replace
                   "expr_type(popt(lbody(nS`redex_type))) = expr_type(nS`redex_type)")
                  (("1" (typepred "nS`context_type")
                    (("1" (case-replace "popDepth(nS`state`redex) = 0")
                      (("1" (assert) nil nil)
                       ("2" (case "letexpr?(nS`state`redex)")
                        (("1" (assert)
                          (("1" (expand popDepth)
                            (("1"
                              (case "atom?(letrhs(nS`state`redex))")
                              (("1"
                                (assert)
                                (("1"
                                  (hide-all-but (1 -1))
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (case "lett?(nS`redex_type)")
                      (("1" (assert)
                        (("1" (expand expr_type)
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (case "letexpr?(nS`state`redex)")
                        (("1" (typepred "nS`redex_type")
                          (("1" (assert)
                            (("1" (expand is_well_typed)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (decompose-equality)
                  (("1" (grind) nil nil)
                   ("2" (decompose-equality) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letReduce const-decl "rstate" rreduction nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (lbody adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil)
    (popt adt-constructor-decl "[typeinfo -> (popt?)]" typeinfo_adt
     nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]"
     IExpression_adt nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (seq type-eq-decl nil more_finseq nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (purePopDepth formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC9 0
  (typed_reduce_TCC9-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (replace -4)
      (("" (replace -2)
        (("" (expand typed_to_topstate)
          (("" (expand make_redex_typed)
            (("" (expand to_topstate)
              (("" (expand make_redex) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC10 0
  (typed_reduce_TCC10-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use applyReduce_ndr)
      (("1" (use applyReduce_arm) (("1" (grind) nil nil)) nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1" (expand make_redex_typed)
              (("1" (expand make_redex)
                (("1" (expand typed_to_topstate)
                  (("1" (expand to_topstate) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((applyReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (applyReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC11 0
  (typed_reduce_TCC11-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC12 0
  (typed_reduce_TCC12-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      (("" (assert)
        (("" (typepred "nS`stack_types")
          (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((applyReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC13 0
  (typed_reduce_TCC13-1 nil 3702747756
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC14 0
  (typed_reduce_TCC14-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "application?(nS`state`redex)")
        (("1" (assert)
          (("1" (expand is_well_typed)
            (("1" (expand defs_well_typed) (("1" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC15 0
  (typed_reduce_TCC15-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (hide-all-but 4)
      ((""
        (name-replace L
         "tS`def_types`seq(fun(nS`state`redex))`args_type")
        (("" (expand finseq2list)
          ((""
            (case "forall (n: upto(length(L))): length(finseq2list_rec(L, n)) = n")
            (("1" (grind) nil nil)
             ("2" (induct n)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq2list const-decl "list[T]" list2finseq nil)
    (pred type-eq-decl nil defined_types nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (finseq2list_rec def-decl "list[T]" list2finseq nil)
    (length def-decl "nat" list_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC16 0
  (typed_reduce_TCC16-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand applyReduce)
      ((""
        (case "fun(nS`state`redex) < D`length AND length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity")
        (("1" (assert)
          (("1" (flatten)
            (("1" (assert)
              (("1"
                (case-replace "length
                                    (tS`def_types`seq
                                     (fun(nS`state`redex))`args_type) = D`seq(fun(nS`state`redex))`arity")
                (("1" (case "application?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (typepred "nS`redex_type")
                      (("1" (expand is_well_typed -)
                        (("1" (flatten)
                          (("1" (use is_well_typed_letApply)
                            (("1" (split -1)
                              (("1" (propax) nil nil)
                               ("2" (rewrite pure_mark) nil nil)
                               ("3"
                                (rewrite cvars_mark)
                                (("3"
                                  (skeep)
                                  (("3"
                                    (typepred
                                     "D`seq(fun(nS`state`redex))`body")
                                    (("3"
                                      (inst -2 i)
                                      (("3"
                                        (rewrite cvars_pure)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (skeep)
                                (("4"
                                  (typepred "nS`state`redex")
                                  (("4"
                                    (inst -2 i)
                                    (("4"
                                      (typepred "nS`stack_types")
                                      (("4" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("5"
                                (skeep :preds? t)
                                (("5"
                                  (inst?)
                                  (("5"
                                    (rewrite finseq2list_nth)
                                    (("5"
                                      (replace*)
                                      (("5"
                                        (expand*
                                         typed_to_topstate
                                         to_topstate)
                                        (("5"
                                          (expand make_redex_typed)
                                          (("5" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("6"
                                (use is_well_typed_mark)
                                (("1"
                                  (split -1)
                                  (("1"
                                    (replace -1 :dir RL)
                                    (("1"
                                      (expand defs_well_typed)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst
                                           -11
                                           "fun(nS`state`redex)")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (use
                                               is_well_typed_extend_stack)
                                              (("1"
                                                (rewrite -1)
                                                (("1"
                                                  (rewrite
                                                   list2finseq_finseq2list)
                                                  (("1"
                                                    (replace*)
                                                    (("1"
                                                      (expand*
                                                       typed_to_topstate
                                                       to_topstate
                                                       make_redex_typed)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   pure_contextPure)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (delete 2 6)
                                                (("2"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("2"
                                                    (rewrite
                                                     cvars_pure)
                                                    (("2"
                                                      (rewrite
                                                       list2finseq_finseq2list)
                                                      (("2"
                                                        (split)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (skeep)
                                                          (("2"
                                                            (typepred
                                                             "D`seq(fun(nS`state`redex))`body")
                                                            (("2"
                                                              (inst?)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (use pure_contextPure)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (delete 2 6)
                                  (("2"
                                    (rewrite purePopDepth)
                                    (("2"
                                      (rewrite cvars_pure)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split)
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (typepred
                                               "D`seq(fun(nS`state`redex))`body")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (expand
                                                     defs_well_typed)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (inst
                                                         -14
                                                         "fun(nS`state`redex)")
                                                        (("1"
                                                          (rewrite
                                                           list2finseq_finseq2list)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (delete 5)
                  (("2" (case "application?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (typepred "nS`redex_type")
                        (("1" (expand is_well_typed)
                          (("1" (flatten) (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 5)
          (("2" (case "application?(nS`state`redex)")
            (("1" (assert)
              (("1" (typepred "nS`redex_type")
                (("1" (expand is_well_typed)
                  (("1" (flatten)
                    (("1" (expand defs_well_typed)
                      (("1" (flatten)
                        (("1" (case "fun(nS`state`redex) < D`length")
                          (("1" (assert)
                            (("1" (inst? -8)
                              (("1"
                                (flatten)
                                (("1"
                                  (replace*)
                                  (("1"
                                    (expand*
                                     make_redex_typed
                                     typed_to_topstate)
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (replace*)
                            (("2"
                              (expand* make_redex_typed
                               typed_to_topstate)
                              nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (IExpression type-decl nil IExpression_adt nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (atom? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (is_well_typed_letApply formula-decl nil typed_rreduction nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (is_well_typed_mark formula-decl nil typed_rreduction nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (O const-decl "finseq" finite_sequences nil)
    (purePopDepth formula-decl nil IL nil)
    (list2finseq_finseq2list formula-decl nil list2finseq_extra nil)
    (pure_contextPure formula-decl nil IL nil)
    (is_well_typed_extend_stack formula-decl nil typed_reduction nil)
    (finseq2list_nth formula-decl nil list2finseq_extra nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (in_varlist const-decl "finite_set[nat]" IL nil)
    (cvars_mark formula-decl nil preprocess nil)
    (cvars_pure formula-decl nil preprocess nil)
    (unmark_pure rec-application-judgement "(pure?)" preprocess nil)
    (pure_mark formula-decl nil preprocess nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (applyReduce const-decl "rstate" rreduction nil))
   nil))
 (typed_reduce_TCC17 0
  (typed_reduce_TCC17-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (rewrite letApply_expr_type)
      ((""
        (case-replace
         "popDepth(applyReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1" (expand applyReduce +)
          (("1" (assert)
            (("1"
              (case-replace "expr_type(tS`def_types`seq
                                      (fun(nS`state`redex))`body_type) = expr_type(nS`redex_type)")
              (("1" (typepred "nS`context_type")
                (("1" (propax) nil nil)) nil)
               ("2" (case "application?(nS`state`redex)")
                (("1" (assert)
                  (("1" (typepred "nS`redex_type")
                    (("1" (expand is_well_typed)
                      (("1" (flatten)
                        (("1" (replace -2)
                          (("1" (simplify)
                            (("1" (expand expr_type 1 2)
                              (("1"
                                (expand defs_well_typed)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst -8 "fun(nS`state`redex)")
                                    (("1"
                                      (replace*)
                                      (("1"
                                        (expand*
                                         typed_to_topstate
                                         make_redex_typed)
                                        (("1"
                                          (flatten)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (replace*)
                                      (("2"
                                        (expand*
                                         make_redex_typed
                                         make_redex
                                         typed_to_topstate
                                         to_topstate)
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand applyRedex?) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (delete 5)
          (("2" (expand applyReduce)
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (rewrite purePopDepth)
                        (("1" (rewrite purePopDepth)
                          (("1" (grind) nil nil)) nil)
                         ("2" (rewrite pure_letApply)
                          (("2" (rewrite pure_mark) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((letApply_expr_type formula-decl nil typed_reduction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (length def-decl "nat" list_props nil)
    (finseq2list const-decl "list[T]" list2finseq nil)
    (pure_letApply recursive-judgement-axiom nil rreduction nil)
    (pure_mark formula-decl nil preprocess nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (purePopDepth formula-decl nil IL nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (letApply def-decl "IExpression" rreduction nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (applyRedex? const-decl "bool" IL nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC18 0
  (typed_reduce_TCC18-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC19 0
  (typed_reduce_TCC19-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use ifReduce_ndr)
      (("1" (use ifReduce_arm) (("1" (grind) nil nil)) nil)
       ("2" (assert)
        (("2" (replace -5)
          (("2" (replace -3)
            (("2"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (ifReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC20 0
  (typed_reduce_TCC20-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (expand release_marked)
        (("" (assert)
          (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC21 0
  (typed_reduce_TCC21-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (expand ifReduce)
        (("1" (expand release_marked)
          (("1" (typepred "nS`stack_types") (("1" (assert) nil nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand ifReduce)
          (("2" (expand release_marked)
            (("2" (assert)
              (("2" (typepred "nS`stack_types") (("2" (inst?) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((release_marked const-decl "rstate" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC22 0
  (typed_reduce_TCC22-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC23 0
  (typed_reduce_TCC23-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use ifReduce_correct_indexing)
      (("1" (assert) nil nil)
       ("2" (replace -5)
        (("2" (replace -3)
          (("2"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce_correct_indexing formula-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC24 0
  (typed_reduce_TCC24-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "ift?(nS`state`redex)")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC25 0
  (typed_reduce_TCC25-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "ift?(nS`state`redex)")
        (("1" (assert) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC26 0
  (typed_reduce_TCC26-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand ifReduce)
      (("" (lift-if)
        (("" (expand release_marked)
          (("" (lift-if)
            (("" (lift-if)
              (("" (expand is_well_typed + (1 3))
                (("" (typepred "nS`redex_type")
                  (("" (case "ift?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (expand is_well_typed -)
                        (("1" (flatten) (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ifReduce const-decl "rstate" rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC27 0
  (typed_reduce_TCC27-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "popDepth(ifReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
      (("1" (expand ifReduce +)
        (("1" (expand release_marked)
          (("1" (assert)
            (("1" (typepred "nS`context_type")
              (("1" (typepred "nS`redex_type")
                (("1" (case "ift?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (expand is_well_typed)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (expand expr_type -7)
                            (("1" (lift-if) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite purePopDepth)
        (("1" (rewrite purePopDepth)
          (("1" (case "ift?(nS`state`redex)")
            (("1" (assert)
              (("1" (expand pure?) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (expand ifReduce)
          (("2" (delete 7)
            (("2" (delete 2)
              (("2" (expand release_marked)
                (("2" (expand pure? + (1 3)) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (iftRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (purePopDepth formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC28 0
  (typed_reduce_TCC28-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC29 0
  (typed_reduce_TCC29-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "updateReduce(D)(nS`state)")
      (("1" (use updateReduce_arm) (("1" (grind) nil nil)) nil)
       ("2" (assert)
        (("2" (replace -5)
          (("2" (replace -3)
            (("2"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (updateReduce_arm formula-decl nil reduction_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC30 0
  (typed_reduce_TCC30-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1" (typepred "nS`redex_type")
          (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC31 0
  (typed_reduce_TCC31-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1" (typepred "nS`redex_type")
          (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC32 0
  (typed_reduce_TCC32-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case "update?(nS`state`redex)")
      (("1" (assert)
        (("1"
          (name-replace nS2
           "set_new_type(nS, leaftype(nS`redex_type) - 1)")
          (("1"
            (case-replace "nS`dom_types
           WITH [(least_out(nS`state`domain))
                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types")
            (("1" (split)
              (("1" (skeep)
                (("1" (typepred "nS2`dom_types(x1)")
                  (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep* :preds? t)
                (("2" (use updateReduce_new_store)
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (replace -1)
                        (("1" (inst?)
                          (("1" (expand value_maybe_freed2)
                            (("1" (split)
                              (("1"
                                (lemma value_maybe_freed_type)
                                (("1"
                                  (inst? :where -2)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (typepred "nS2`dom_types")
                                        (("2"
                                          (inst
                                           -1
                                           "refindex(get(nS`state`stack)
                                     (target(nS`state`redex)))"
                                           "j")
                                          (("1"
                                            (case-replace
                                             "nS2`dom_types
                        (refindex(get(nS`state`stack)
                                     (target(nS`state`redex)))) = nS2`dom_types(least_out(nS`state`domain))")
                                            (("1"
                                              (expand*
                                               ns2
                                               set_new_type)
                                              (("1"
                                                (expand*
                                                 nS2
                                                 set_new_type)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (expand*
                                               nS2
                                               set_new_type)
                                              (("2"
                                                (delete 2 3)
                                                (("2"
                                                  (lift-if +)
                                                  (("2"
                                                    (simplify)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (split +)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (typepred
                                                             "nS`redex_type")
                                                            (("2"
                                                              (expand
                                                               is_well_typed)
                                                              (("2"
                                                                (flatten)
                                                                (("2"
                                                                  (case
                                                                   "variable?(target(nS`state`redex))")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (expand
                                                                       is_well_typed
                                                                       -4)
                                                                      (("1"
                                                                        (typepred
                                                                         "nS`stack_types")
                                                                        (("1"
                                                                          (expand
                                                                           get)
                                                                          (("1"
                                                                            (inst
                                                                             -2
                                                                             "nS`state`stack`length - 1 -
                           index(target(nS`state`redex))")
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (expand
                                                                                 value_of_type
                                                                                 -2)
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (use
                                                                               updateRedex_target_index)
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand* nS2 set_new_type)
                                            (("2"
                                              (replace -4)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (typepred "nS`state`stack")
                                            (("3"
                                              (expand get)
                                              (("3"
                                                (expand every)
                                                (("3"
                                                  (inst? -1)
                                                  (("1"
                                                    (bash)
                                                    (("1"
                                                      (expand*
                                                       nS2
                                                       set_new_type)
                                                      (("1"
                                                        (bash)
                                                        (("1"
                                                          (expand
                                                           domainValue?)
                                                          (("1"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (bash)
                                                    (("2"
                                                      (use
                                                       updateRedex_target_index)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (lemma value_maybe_freed_type)
                                (("2"
                                  (inst? :where -2)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (split -1)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (typepred "nS`redex_type")
                                        (("2"
                                          (expand is_well_typed)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (case
                                               "variable?(rhs(nS`state`redex))")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   is_well_typed
                                                   -6)
                                                  (("1"
                                                    (expand get)
                                                    (("1"
                                                      (typepred
                                                       "nS2`stack_types")
                                                      (("1"
                                                        (expand*
                                                         nS2
                                                         set_new_type)
                                                        (("1"
                                                          (inst?)
                                                          (("1"
                                                            (replace*)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (use
                                                             updateRedex_rhs_index)
                                                            (("2"
                                                              (bash)
                                                              (("2"
                                                                (expand
                                                                 nS2)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (inst?)
                        (("2"
                          (case "value_of_type(nS`state`store(r)`seq(j), nS2`dom_types(r), nS2`dom_types)")
                          (("1" (lift-if)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand value_maybe_freed2)
                                  (("1"
                                    (split)
                                    (("1"
                                      (lemma value_maybe_freed_type)
                                      (("1"
                                        (inst? :where -2)
                                        (("1"
                                          (inst?)
                                          (("1" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma value_maybe_freed_type)
                                      (("2"
                                        (inst? :where -2)
                                        (("2"
                                          (inst?)
                                          (("2"
                                            (split -1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (typepred
                                               "nS`redex_type")
                                              (("2"
                                                (expand is_well_typed)
                                                (("2"
                                                  (case
                                                   "variable?(rhs(nS`state`redex))")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         is_well_typed
                                                         -6)
                                                        (("1"
                                                          (typepred
                                                           "nS2`stack_types")
                                                          (("1"
                                                            (expand
                                                             get)
                                                            (("1"
                                                              (expand*
                                                               nS2
                                                               set_new_type)
                                                              (("1"
                                                                (inst?)
                                                                (("1"
                                                                  (case-replace
                                                                   "nS`dom_types(r) = leaftype(nS`redex_type) - 1")
                                                                  (("1"
                                                                    (replace*)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (case
                                                                     "variable?(target(nS`state`redex))")
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (expand
                                                                         is_well_typed
                                                                         -7)
                                                                        (("1"
                                                                          (typepred
                                                                           "nS`stack_types")
                                                                          (("1"
                                                                            (inst
                                                                             -2
                                                                             "nS`state`stack`length - 1 -
                          index(target(nS`state`redex))")
                                                                            (("1"
                                                                              (expand
                                                                               value_of_type
                                                                               -2)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (use
                                                                               updateRedex_target_index)
                                                                              (("2"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (use
                                                                   updateRedex_rhs_index)
                                                                  (("2"
                                                                    (expand
                                                                     nS2)
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (expand value_maybe_freed2)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lemma value_maybe_freed_type)
                                      (("2"
                                        (inst? :where -2)
                                        (("2"
                                          (inst?)
                                          (("2" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nS2`dom_types")
                            (("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2"
                                  (inst?)
                                  (("1"
                                    (expand nS2)
                                    (("1"
                                      (expand set_new_type)
                                      (("1" (replace*) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand* nS2 set_new_type)
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (replace*)
                    (("2"
                      (expand* make_redex_typed typed_to_topstate
                       make_redex to_topstate)
                      nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 7) (("2" (expand* nS2 set_new_type) nil nil))
              nil))
            nil)
           ("2" (delete 7)
            (("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed) (("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (delete 7)
            (("3" (typepred "nS`redex_type")
              (("3" (expand is_well_typed) (("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 7) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (value_maybe_freed2 const-decl "boolean" typed_rreduction nil)
    (updateRedex_rhs_index formula-decl nil rreduction nil)
    (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt
         nil)
    (value_maybe_freed_type formula-decl nil typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (updateRedex_target_index formula-decl nil rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (updateReduce_new_store formula-decl nil typed_rreduction nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil))
   nil))
 (typed_reduce_TCC33 0
  (typed_reduce_TCC33-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (name-replace "nS2"
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
        (("1" (expand set_new_type -1)
          (("1" (rewrite -1)
            (("1" (case-replace "nS`state = nS2`state")
              (("1" (use updateReduce_new_stack)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (expand nS2)
                      (("1" (expand set_new_type)
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (typepred "nS2`stack_types")
                      (("2" (skeep)
                        (("2" (inst?)
                          (("1" (inst?)
                            (("1" (split)
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace
                                   "nS`stack_types = nS2`stack_types")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (expand nS2)
                                    (("2"
                                      (expand set_new_type)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (case-replace
                                   "nS`stack_types = nS2`stack_types")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand value_of_type)
                                      (("1" (flatten) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand nS2)
                                    (("2"
                                      (expand set_new_type)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred i)
                              (("2"
                                (expand nS2)
                                (("2"
                                  (expand set_new_type)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred i)
                            (("2" (expand nS2)
                              (("2"
                                (expand set_new_type)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (split)
                  (("1" (expand nS2)
                    (("1" (expand set_new_type)
                      (("1" (replace -5)
                        (("1" (replace -5)
                          (("1"
                            (expand* make_redex_typed typed_to_topstate
                             make_redex to_topstate)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (expand nS2)
                (("2" (expand set_new_type) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (propax) nil nil)) nil)
         ("3" (typepred "nS`redex_type")
          (("3" (case "update?(nS`state`redex)")
            (("1" (assert)
              (("1" (expand is_well_typed) (("1" (propax) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (typepred "nS`redex_type")
        (("2" (case "update?(nS`state`redex)")
          (("1" (assert)
            (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("3" (typepred "nS`redex_type")
        (("3" (case "update?(nS`state`redex)")
          (("1" (assert)
            (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (updateRedex? const-decl "bool" IL nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (updateReduce_new_stack formula-decl nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC34 0
  (typed_reduce_TCC34-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use updateReduce_redex)
      (("1" (case "update?(nS`state`redex)")
        (("1" (assert)
          (("1"
            (case "leaft?(nS`redex_type) AND leaftype(nS`redex_type) > 0")
            (("1"
              (name-replace "nS2"
               "set_new_type(nS, leaftype(nS`redex_type) - 1)")
              (("1"
                (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
                (("1" (expand set_new_type)
                  (("1" (replace -1)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (typepred "nS`redex_type")
                          (("1" (expand is_well_typed -1)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1"
                                  (split)
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (expand is_well_typed +)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (replace -1)
                                    (("2"
                                      (typepred "nS2`stack_types")
                                      (("2"
                                        (inst
                                         -2
                                         "nS2`stack_types`length - 1 - index(target(nS2`state`redex))")
                                        (("1"
                                          (case
                                           "variable?(target(nS`state`redex))")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand is_well_typed -5)
                                              (("1"
                                                (rewrite
                                                 value_well_typed
                                                 +)
                                                (("1"
                                                  (expand nS2)
                                                  (("1"
                                                    (expand
                                                     set_new_type)
                                                    (("1"
                                                      (expand get)
                                                      (("1"
                                                        (replace*)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (typepred "nS2`state`redex")
                                          (("2"
                                            (inst
                                             -2
                                             "index(target(nS2`state`redex))")
                                            (("2"
                                              (split -2)
                                              (("1"
                                                (expand nS2)
                                                (("1"
                                                  (expand set_new_type)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand nS2)
                                                (("2"
                                                  (expand set_new_type)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -1)
                                    (("3"
                                      (typepred "nS2`redex_type")
                                      (("3"
                                        (expand nS2)
                                        (("3"
                                          (expand set_new_type)
                                          (("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand nS2) (("2" (propax) nil nil)) nil)
                 ("3" (flatten) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil)
             ("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed -) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand updateRedex?) (("2" (propax) nil nil)) nil))
        nil)
       ("2" (split)
        (("1" (replace -5)
          (("1" (replace -3)
            (("1"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((updateReduce_redex formula-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (markv const-decl "(variable?)" preprocess nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (get const-decl "(value?)" IL nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (> const-decl "bool" reals nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC35 0
  (typed_reduce_TCC35-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (rewrite updateReduce_context)
      (("1"
        (case-replace
         "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1"
          (case "leaft?(nS`redex_type) AND leaftype(nS`redex_type) - 1 >= 0")
          (("1"
            (name "nS2"
                  "set_new_type(nS, leaftype(nS`redex_type) - 1)")
            (("1" (typepred "nS2`context_type")
              (("1" (expand nS2)
                (("1" (expand set_new_type) (("1" (propax) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten) nil nil))
            nil)
           ("2" (case "update?(nS`state`redex)")
            (("1" (assert)
              (("1" (typepred "nS`redex_type")
                (("1" (expand is_well_typed)
                  (("1" (prop) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (delete 7)
          (("2" (case-replace "popDepth(nS`state`redex) = 0")
            (("1" (use updateReduce_redex)
              (("1" (split)
                (("1" (replace*)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (rewrite -1)
                  (("2"
                    (typepred
                     "get(nS`state`stack)(target(nS`state`redex))")
                    (("2"
                      (name-replace u
                       "get(nS`state`stack)(target(nS`state`redex))")
                      (("2" (hide-all-but (1 -1))
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("3" (replace*) nil nil))
                nil)
               ("2" (split)
                (("1" (replace*)
                  (("1"
                    (expand* make_redex_typed typed_to_topstate
                     make_redex to_topstate)
                    nil nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (case "update?(nS`state`redex)")
                (("1" (assert)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 6)
        (("2" (replace*)
          (("2"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((updateReduce_context formula-decl nil typed_rreduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (updateReduce_redex formula-decl nil typed_rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (count_copy def-decl "[(dom) -> nat]" rreduction nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (get const-decl "(value?)" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC36 0
  (typed_reduce_TCC36-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC37 0
  (typed_reduce_TCC37-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use lookupReduce_ndr)
      (("1" (use lookupReduce_arm)
        (("1" (split -1)
          (("1" (grind) nil nil) ("2" (propax) nil nil)
           ("3" (typepred "nS`state") (("3" (propax) nil nil)) nil)
           ("4" (typepred "nS`state") (("4" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (replace*)
          (("2"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (lookupReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC38 0
  (typed_reduce_TCC38-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand lookupReduce)
      (("" (expand release_marked)
        (("" (expand setRedex)
          (("" (assert)
            (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupReduce const-decl "rstate" rreduction nil)
    (setRedex const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (release_marked const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC39 0
  (typed_reduce_TCC39-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (lemma stack_still_typed)
      (("" (inst?)
        (("1" (inst -1 "nS`state`stack")
          (("1" (split -1)
            (("1" (propax) nil nil)
             ("2" (typepred "nS`stack_types") (("2" (propax) nil nil))
              nil)
             ("3" (delete 8)
              (("3" (expand lookupReduce)
                (("3" (expand release_marked)
                  (("3" (expand setRedex) (("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "nS`stack_types") (("4" (propax) nil nil))
              nil)
             ("5" (delete 8)
              (("5" (skeep* :preds? t)
                (("5" (expand lookupReduce)
                  (("5" (expand release_marked)
                    (("5" (expand setRedex) (("5" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (split)
          (("1" (replace*)
            (("1"
              (expand* make_redex_typed typed_to_topstate make_redex
               to_topstate)
              nil nil))
            nil)
           ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((stack_still_typed formula-decl nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (get const-decl "(value?)" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (setRedex const-decl "rstate" rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC40 0
  (typed_reduce_TCC40-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand lookupRedex?)
      (("" (expand lookupReduce)
        (("" (expand setRedex)
          (("" (expand release_marked)
            (("" (lift-if)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand is_well_typed + 1)
                    (("1" (rewrite value_well_typed)
                      (("1" (typepred "nS`redex_type")
                        (("1" (expand is_well_typed)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (case-replace
                                   "leaftype(nS`redex_type) = nS`dom_types(refindex(get(nS`state`stack)
                                     (arrayvalue(nS`state`redex))))")
                                  (("1"
                                    (typepred "nS`dom_types")
                                    (("1" (inst?) nil nil))
                                    nil)
                                   ("2"
                                    (delete 2)
                                    (("2"
                                      (expand is_well_typed -)
                                      (("2"
                                        (typepred "nS`stack_types")
                                        (("2"
                                          (inst
                                           -2
                                           "nS`stack_types`length - 1 - index(arrayvalue(nS`state`redex))")
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (use
                                             lookupRedex_arrayvalue_index)
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (replace*)
                                              (("2"
                                                (expand*
                                                 make_redex_typed
                                                 typed_to_topstate
                                                 make_redex
                                                 to_topstate)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "nS`redex_type")
                  (("2" (flatten) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex_arrayvalue_index formula-decl nil rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC41 0
  (typed_reduce_TCC41-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case-replace
       "lookupReduce(D)(nS`state)`context = nS`state`context")
      (("1"
        (case-replace
         "popDepth(lookupReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
        (("1" (typepred "nS`context_type") (("1" (propax) nil nil))
          nil)
         ("2" (case-replace "popDepth(nS`state`redex) = 0")
          (("1" (delete 8)
            (("1" (expand lookupReduce)
              (("1" (expand* release_marked setRedex)
                (("1" (assert)
                  (("1" (expand popDepth + 1)
                    (("1" (lift-if)
                      (("1" (split)
                        (("1" (flatten)
                          (("1"
                            (typepred "nS`state`store
                   (refindex(get(nS`state`stack)
                                (arrayvalue(nS`state`redex))))`seq
                   (value(get(nS`state`stack)(position(nS`state`redex))))")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (delete 2 9)
            (("2" (delete -1)
              (("2" (case "lookup?(nS`state`redex)")
                (("1" (assert)
                  (("1" (expand popDepth) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 8)
        (("2" (expand lookupReduce)
          (("2" (expand* release_marked setRedex)
            (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release_marked const-decl "rstate" rreduction nil)
    (setRedex const-decl "rstate" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC42 0
  (typed_reduce_TCC42-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC43 0
  (typed_reduce_TCC43-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use newintReduce_ndr)
      (("1" (use newintReduce_arm)
        (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)) nil)
       ("2" (split)
        (("1" (replace*)
          (("1"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((newintReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (newintReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC44 0
  (typed_reduce_TCC44-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC45 0
  (typed_reduce_TCC45-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC46 0
  (typed_reduce_TCC46-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (name-replace "nS2"
       "set_new_type(nS, leaftype(nS`redex_type) - 1)")
      (("1"
        (case "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
        (("1" (expand set_new_type -1)
          (("1" (rewrite -1)
            (("1" (split)
              (("1" (skeep)
                (("1" (typepred "nS2`dom_types(x1)")
                  (("1" (propax) nil nil)) nil))
                nil)
               ("2" (skeep* :preds? t)
                (("2" (expand newintReduce)
                  (("2" (case-replace "r = least_out(nS`state`domain)")
                    (("1" (simplify)
                      (("1" (expand nS2)
                        (("1" (expand set_new_type)
                          (("1" (expand value_of_type)
                            (("1" (typepred "nS`redex_type")
                              (("1"
                                (expand newintRedex?)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand is_well_typed)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lift-if)
                      (("2" (assert)
                        (("2" (typepred "nS2`dom_types")
                          (("2" (inst?)
                            (("1" (inst -1 j)
                              (("1" (expand* nS2 set_new_type) nil nil)
                               ("2"
                                (expand* nS2 set_new_type)
                                nil
                                nil))
                              nil)
                             ("2" (expand* nS2 set_new_type)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand nS2) (("2" (propax) nil nil)) nil)
         ("3" (delete 9)
          (("3" (expand newintRedex?)
            (("3" (assert)
              (("3" (typepred "nS`redex_type")
                (("3" (expand is_well_typed) (("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (delete 9)
        (("2" (expand newintRedex?)
          (("2" (assert)
            (("2" (typepred "nS`redex_type")
              (("2" (expand is_well_typed) (("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (delete 9)
        (("3" (expand newintRedex?)
          (("3" (assert)
            (("3" (typepred "nS`redex_type")
              (("3" (expand is_well_typed) (("3" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (add const-decl "(nonempty?)" sets nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (newintRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC47 0
  (typed_reduce_TCC47-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (assert)
              ((""
                (name-replace "nS2"
                 "set_new_type(nS, leaftype(nS`redex_type) - 1)")
                (("1"
                  (case-replace
                   "set_new_type(nS, leaftype(nS`redex_type) - 1)`dom_types = nS2`dom_types")
                  (("1" (expand set_new_type -1)
                    (("1" (rewrite -1)
                      (("1" (typepred "nS2`stack_types")
                        (("1" (expand newintReduce)
                          (("1" (expand* nS2 set_new_type)
                            (("1" (skeep)
                              (("1"
                                (inst?)
                                (("1"
                                  (expand* nS2 set_new_type)
                                  (("1"
                                    (typepred i)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand nS2) (("2" (propax) nil nil)) nil)
                   ("3" (replace*) (("3" (assert) nil nil)) nil))
                  nil)
                 ("2" (replace*) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC48 0
  (typed_reduce_TCC48-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newintReduce)
      (("" (expand is_well_typed)
        (("" (expand newintRedex?)
          (("" (assert)
            (("" (typepred "nS`redex_type")
              (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newintReduce const-decl "rstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC49 0
  (typed_reduce_TCC49-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (expand newintRedex?)
        (("" (assert)
          (("" (expand is_well_typed)
            (("" (assert)
              ((""
                (name-replace "rS2"
                 "set_new_type(nS, leaftype(nS`redex_type) - 1)")
                (("1" (expand newintReduce)
                  (("1" (typepred "rS2`context_type")
                    (("1"
                      (case-replace
                       "popDepth(ref(least_out(nS`state`domain))) = popDepth(rS2`state`redex)")
                      (("1" (expand* rS2 set_new_type) nil nil)
                       ("2" (expand* rS2 set_new_type)
                        (("2" (assert)
                          (("2" (expand popDepth)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newintRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC50 0
  (typed_reduce_TCC50-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC51 0
  (typed_reduce_TCC51-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use newrefReduce_ndr)
      (("1" (use newrefReduce_arm)
        (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil)) nil)
       ("2" (split)
        (("1" (replace*)
          (("1"
            (expand* make_redex_typed typed_to_topstate make_redex
             to_topstate)
            nil nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((newrefReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (newrefReduce_arm formula-decl nil reduction_props nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC52 0
  (typed_reduce_TCC52-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC53 0
  (typed_reduce_TCC53-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC54 0
  (typed_reduce_TCC54-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (split)
                    (("1" (skeep)
                      (("1" (typepred "nS2`dom_types(x1)")
                        (("1" (expand nS2)
                          (("1" (expand set_new_type)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep* :preds? t)
                      (("2" (expand newrefReduce)
                        (("2"
                          (case-replace
                           "r = least_out(nS`state`domain)")
                          (("1" (simplify)
                            (("1" (expand value_of_type)
                              (("1" (propax) nil nil)) nil))
                            nil)
                           ("2" (lift-if)
                            (("2" (assert)
                              (("2"
                                (typepred "nS2`dom_types")
                                (("2"
                                  (inst -1 r j)
                                  (("1"
                                    (expand* nS2 set_new_type)
                                    nil
                                    nil)
                                   ("2"
                                    (expand* nS2 set_new_type)
                                    nil
                                    nil)
                                   ("3"
                                    (expand* nS2 set_new_type)
                                    (("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC55 0
  (typed_reduce_TCC55-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (typepred "nS2`stack_types")
                    (("" (expand newrefReduce)
                      (("" (expand* nS2 set_new_type)
                        (("" (skeep :preds? t)
                          (("" (inst?)
                            (("" (expand* nS2 set_new_type) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC56 0
  (typed_reduce_TCC56-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefReduce)
      (("" (expand is_well_typed)
        (("" (expand newrefRedex?)
          (("" (assert)
            (("" (typepred "nS`redex_type")
              (("" (expand is_well_typed) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC57 0
  (typed_reduce_TCC57-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand newrefRedex?)
      (("" (assert)
        (("" (typepred "nS`redex_type")
          (("" (expand is_well_typed)
            (("" (flatten)
              (("" (assert)
                ((""
                  (name-replace "nS2"
                   "set_new_type(nS, leaftype(nS`redex_type)-1)")
                  (("" (typepred "nS2`context_type")
                    ((""
                      (case-replace
                       "popDepth(newrefReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
                      (("1" (expand newrefReduce)
                        (("1" (expand* nS2 set_new_type) nil nil)) nil)
                       ("2" (expand newrefReduce)
                        (("2" (expand popDepth)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((newrefRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil)
    (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (set_new_type const-decl "typed_rstate" typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC58 0
  (typed_reduce_TCC58-1 nil 3702747756 ("" (subtype-tcc) nil nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC59 0
  (typed_reduce_TCC59-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (use popReduce_ndr)
        (("1" (use popReduce_arm)
          (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil))
          nil)
         ("2" (replace*)
          (("2"
            (expand* typed_to_topstate make_redex_typed to_topstate
             make_redex)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (popReduce_arm formula-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (popReduce_ndr judgement-tcc nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC60 0
  (typed_reduce_TCC60-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (assert)
        (("" (typepred "nS`dom_types") (("" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (popReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pure? def-decl "bool" IL nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC61 0
  (typed_reduce_TCC61-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`stack_types")
      (("" (typepred "nS`state`redex")
        (("" (case "popDepth(nS`state`redex) > 0")
          (("1" (grind) nil nil)
           ("2" (expand popRedex?)
            (("2" (flatten)
              (("2" (assert)
                (("2" (expand popDepth) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC62 0
  (typed_reduce_TCC62-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (expand popReduce)
        (("1" (assert)
          (("1" (expand pop)
            (("1" (expand tail)
              (("1" (typepred "nS`stack_types")
                (("1" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep :preds? t)
        (("2" (expand popReduce)
          (("2" (expand pop)
            (("2" (lift-if)
              (("2" (expand tail)
                (("2" (assert)
                  (("2" (typepred "nS`stack_types")
                    (("2" (inst?)
                      (("2" (ground) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((tail const-decl "finseq[T]" finseq_theorems nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pop const-decl "Stack" IL nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popReduce const-decl "rstate" rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (> const-decl "bool" reals nil) (get const-decl "(value?)" IL nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC63 0
  (typed_reduce_TCC63-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (typepred "nS`redex_type")
      (("" (case "pop?(nS`state`redex)")
        (("1" (assert)
          (("1" (expand is_well_typed) (("1" (propax) nil nil)) nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC64 0
  (typed_reduce_TCC64-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand popReduce)
      (("" (assert)
        (("" (lift-if)
          (("" (split)
            (("1" (flatten)
              (("1" (typepred "nS`redex_type")
                (("1" (case "pop?(nS`state`redex)")
                  (("1" (assert)
                    (("1" (expand is_well_typed -)
                      (("1" (flatten)
                        (("1" (rewrite value_well_typed)
                          (("1" (rewrite value_well_typed) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (case "variable?(pbody(nS`state`redex))")
                (("1" (assert)
                  (("1" (case "pop?(nS`state`redex)")
                    (("1" (assert)
                      (("1" (typepred "nS`redex_type")
                        (("1" (expand is_well_typed -)
                          (("1" (flatten)
                            (("1" (expand is_well_typed -)
                              (("1"
                                (flatten)
                                (("1"
                                  (rewrite value_well_typed)
                                  (("1"
                                    (expand get)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (typepred "nS`stack_types")
                                        (("1"
                                          (inst?)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (typepred "nS`state`redex")
                                            (("2"
                                              (inst
                                               -2
                                               "index(pbody(nS`state`redex))-1")
                                              (("1"
                                                (split -2)
                                                (("1" (grind) nil nil)
                                                 ("2" (grind) nil nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (popReduce const-decl "rstate" rreduction nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (get const-decl "(value?)" IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (singleton const-decl "(singleton?)" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (bump const-decl "finite_set[nat]" IL nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (markv const-decl "(variable?)" preprocess nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (value_well_typed formula-decl nil typed_reduction nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC65 0
  (typed_reduce_TCC65-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (case-replace "popDepth(popReduce(D)(nS`state)`redex) = 0")
      (("1" (expand popReduce +)
        (("1" (assert)
          (("1" (typepred "nS`context_type")
            (("1"
              (case-replace
               "expr_type(nS`redex_type) = expr_type(ptbody(nS`redex_type))")
              (("1"
                (case-replace
                 "popn(nS`stack_types, popDepth(nS`state`redex)) = tail[nat](nS`stack_types)")
                (("1" (case-replace "popDepth(nS`state`redex) = 1")
                  (("1" (hide-all-but 1)
                    (("1" (grind-with-ext) nil nil)) nil)
                   ("2" (expand popRedex?)
                    (("2" (flatten)
                      (("2" (assert) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "popt?(nS`redex_type)")
                (("1" (assert)
                  (("1" (expand expr_type + 1) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (typepred "nS`redex_type")
                  (("2" (assert)
                    (("2" (case "pop?(nS`state`redex)")
                      (("1" (assert)
                        (("1" (expand is_well_typed -)
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "value?(popReduce(D)(nS`state)`redex)")
        (("1" (hide-all-but (1 -1))
          (("1" (expand* value? popDepth)
            (("1" (split)
              (("1" (assert) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil)
         ("2" (expand popReduce 1) (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (< const-decl "bool" reals nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (refs def-decl "bool" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (popRedex? const-decl "bool" IL nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (popReduce const-decl "rstate" rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (popn_zero formula-decl nil typed_reduction nil)
    (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil)
    (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop const-decl "Stack" IL nil) (get const-decl "(value?)" IL nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (> const-decl "bool" reals nil)
    (nonempty_fs type-eq-decl nil finseq_theorems nil)
    (tail const-decl "finseq[T]" finseq_theorems nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC66 0
  (typed_reduce_TCC66-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand make_redex_typed)
      (("" (typepred "make_redex(t`state)")
        (("" (expand pureRedex?)
          (("" (replace -4)
            (("" (simplify)
              (("" (split -1)
                (("1" (propax) nil nil) ("2" (propax) nil nil)
                 ("3" (propax) nil nil) ("4" (propax) nil nil)
                 ("5" (propax) nil nil) ("6" (propax) nil nil)
                 ("7" (propax) nil nil) ("8" (propax) nil nil)
                 ("9" (assert)
                  (("9" (replace -3)
                    (("9"
                      (expand* make_redex typed_to_topstate
                       to_topstate)
                      nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pureRedex? const-decl "bool" IL nil)
    (IContext type-decl nil IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (atom? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC67 0
  (typed_reduce_TCC67-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case "NOT nS`state`error AND pureReleaseRedex?(nS`state`redex)")
      (("1" (flatten)
        (("1" (use releaseReduce_ndr)
          (("1" (use releaseReduce_arm)
            (("1" (typepred "nS`state") (("1" (grind) nil nil)) nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil)
       ("2" (use typed_reduce_TCC66)
        (("2" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (propax) nil nil) ("4" (propax) nil nil)
               ("5" (propax) nil nil) ("6" (propax) nil nil)
               ("7" (propax) nil nil) ("8" (propax) nil nil)
               ("9" (propax) nil nil) ("10" (propax) nil nil))
              nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pureReleaseRedex? const-decl "bool" IL nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (releaseReduce_ndr judgement-tcc nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (goodrstate type-eq-decl nil reduction_props nil)
    (Defs type-eq-decl nil reduction_props nil)
    (Definition type-eq-decl nil reduction_props nil)
    (releaseReduce_arm formula-decl nil reduction_props nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (typed_reduce_TCC66 subtype-tcc nil typed_rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC68 0
  (typed_reduce_TCC68-1 nil 3702747756
   ("" (skeep* :preds? t)
    ((""
      (case "NOT nS`state`error AND pureReleaseRedex?(nS`state`redex)")
      (("1" (flatten)
        (("1" (use releaseReduce_new_store)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (lemma value_maybe_freed_type)
                (("1" (inst? :where -4)
                  (("1" (inst?)
                    (("1" (split -1)
                      (("1" (propax) nil nil)
                       ("2" (typepred "nS`dom_types")
                        (("2" (inst?) nil nil)) nil)
                       ("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil))
            nil))
          nil))
        nil)
       ("2" (use typed_reduce_TCC66)
        (("2" (split)
          (("1" (inst?)
            (("1" (split)
              (("1" (propax) nil nil) ("2" (propax) nil nil)
               ("3" (propax) nil nil) ("4" (propax) nil nil)
               ("5" (propax) nil nil) ("6" (propax) nil nil)
               ("7" (propax) nil nil) ("8" (propax) nil nil)
               ("9" (propax) nil nil) ("10" (propax) nil nil))
              nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_reduce_TCC66 subtype-tcc nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (value_maybe_freed_type formula-decl nil typed_rreduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (releaseReduce_new_store formula-decl nil typed_rreduction nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil))
   nil))
 (typed_reduce_TCC69 0
  (typed_reduce_TCC69-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (lemma stack_still_typed)
      (("" (inst?)
        (("1" (inst -1 "nS`state`stack")
          (("1" (split -1)
            (("1" (propax) nil nil)
             ("2" (typepred "nS`stack_types") (("2" (propax) nil nil))
              nil)
             ("3" (delete 12)
              (("3" (expand releaseReduce)
                (("3" (expand decref)
                  (("3" (lift-if)
                    (("3" (split)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (typepred "nS`stack_types") (("4" (propax) nil nil))
              nil)
             ("5" (skeep* :preds? t)
              (("5" (delete 13)
                (("5" (expand releaseReduce)
                  (("5" (expand decref)
                    (("5" (lift-if)
                      (("5" (split)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1"
                              (case-replace
                               "i = nS`state`stack`length - 1 - index(rvar(nS`state`redex)) - popDepth(nS`state`redex)")
                              (("1"
                                (simplify)
                                (("1" (propax) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (use typed_reduce_TCC66)
          (("2" (split -1)
            (("1" (inst?) (("1" (prop) nil nil)) nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((stack_still_typed formula-decl nil typed_rreduction nil)
    (typed_reduce_TCC66 subtype-tcc nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (rvar adt-accessor-decl "[(release?) -> (variable?)]"
     IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (armc? def-decl "bool" preprocess nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC70 0
  (typed_reduce_TCC70-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (expand releaseReduce)
      (("" (expand decref)
        (("" (assert)
          (("" (lift-if)
            ((""
              (case "is_well_typed(rexpr(nS`state`redex), nS`redex_type,
                         nS`stack_types, nS`dom_types, nS`def_types)")
              (("1" (split)
                (("1" (flatten) (("1" (assert) nil nil)) nil)
                 ("2" (flatten) nil nil))
                nil)
               ("2" (delete 12)
                (("2" (use typed_reduce_TCC66)
                  (("2" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`redex_type")
                                (("1"
                                  (expand is_well_typed -)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil) ("3" (propax) nil nil)
                         ("4" (propax) nil nil) ("5" (propax) nil nil)
                         ("6" (propax) nil nil) ("7" (propax) nil nil)
                         ("8" (propax) nil nil) ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (delete 12)
                (("3" (use typed_reduce_TCC66)
                  (("3" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (flatten)
                          (("1" (case "release?(nS`state`redex)")
                            (("1" (assert)
                              (("1"
                                (typepred "nS`state`redex")
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (typepred "nS`stack_types")
                                      (("2"
                                        (inst
                                         -5
                                         "i-popDepth(nS`state`redex)")
                                        (("1"
                                          (rewrite cvars_vars)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil) ("3" (propax) nil nil)
                         ("4" (propax) nil nil) ("5" (propax) nil nil)
                         ("6" (propax) nil nil) ("7" (propax) nil nil)
                         ("8" (propax) nil nil) ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("4" (delete 12)
                (("4" (use typed_reduce_TCC66)
                  (("4" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil) ("4" (propax) nil nil)
                         ("5" (propax) nil nil) ("6" (propax) nil nil)
                         ("7" (propax) nil nil) ("8" (propax) nil nil)
                         ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("5" (delete 12)
                (("5" (use typed_reduce_TCC66)
                  (("5" (split -1)
                    (("1" (inst?)
                      (("1" (split -1)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (propax) nil nil) ("4" (propax) nil nil)
                         ("5" (propax) nil nil) ("6" (propax) nil nil)
                         ("7" (propax) nil nil) ("8" (propax) nil nil)
                         ("9" (propax) nil nil)
                         ("10" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil) ("3" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (rexpr adt-accessor-decl "[(release?) -> IExpression]"
     IExpression_adt nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (typed_reduce_TCC66 subtype-tcc nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (pure? def-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (cvars_vars formula-decl nil preprocess nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement
     "non_empty_finite_set[nat]" countability "sets_aux/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (atom? const-decl "bool" IL nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_TCC71 0
  (typed_reduce_TCC71-1 nil 3702747756
   ("" (skeep* :preds? t)
    (("" (use typed_reduce_TCC66)
      (("" (split -1)
        (("1" (inst?)
          (("1" (split -1)
            (("1" (flatten)
              (("1"
                (case-replace
                 "releaseReduce(D)(nS`state)`context = nS`state`context")
                (("1"
                  (case-replace
                   "popDepth(releaseReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)")
                  (("1" (typepred "nS`context_type")
                    (("1" (propax) nil nil)) nil)
                   ("2" (expand releaseReduce 1)
                    (("2" (delete 13)
                      (("2" (delete -1)
                        (("2" (lift-if)
                          (("2" (split)
                            (("1" (flatten)
                              (("1"
                                (expand decref)
                                (("1"
                                  (assert)
                                  (("1"
                                    (case "release?(nS`state`redex)")
                                    (("1"
                                      (assert)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (case "release?(nS`state`redex)")
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 13)
                  (("2" (expand releaseReduce)
                    (("2" (expand decref)
                      (("2" (assert)
                        (("2" (lift-if)
                          (("2" (split)
                            (("1" (flatten) (("1" (assert) nil nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil)
             ("4" (propax) nil nil) ("5" (propax) nil nil)
             ("6" (propax) nil nil) ("7" (propax) nil nil)
             ("8" (propax) nil nil) ("9" (propax) nil nil)
             ("10" (propax) nil nil))
            nil))
          nil)
         ("2" (propax) nil nil) ("3" (propax) nil nil))
        nil))
      nil))
    nil)
   ((typed_reduce_TCC66 subtype-tcc nil typed_rreduction nil)
    (defs_well_typed const-decl "boolean" typed_reduction nil)
    (Defs type-eq-decl nil typed_reduction nil)
    (Definition type-eq-decl nil typed_reduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (typed_rstate type-eq-decl nil typed_rreduction nil)
    (expr_type def-decl "nat" typed_reduction nil)
    (popn const-decl "finseq[nat]" typed_reduction nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (is_well_typed_ctx def-decl "bool" typed_reduction nil)
    (typeinfo_ctx type-decl nil typed_reduction nil)
    (is_well_typed def-decl "bool" typed_reduction nil)
    (tdef type-eq-decl nil typed_reduction nil)
    (value_of_type const-decl "boolean" typed_reduction nil)
    (below type-eq-decl nil naturalnumbers nil)
    (armc? def-decl "bool" preprocess nil)
    (allReleaseMarked? def-decl "bool" preprocess nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (refcount const-decl "nat" rreduction nil)
    (Store type-eq-decl nil reduction nil)
    (mark def-decl "IExpression" preprocess nil)
    (contextPure? def-decl "bool" IL nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (refs def-decl "bool" IL nil)
    (domainValue? const-decl "bool" IL nil)
    (every const-decl "bool" finseq_theorems nil)
    (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil)
    (emptyset const-decl "set" sets nil)
    (markc def-decl "IContext" preprocess nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (tdef type-eq-decl nil typed_rreduction nil)
    (typeinfo type-decl nil typeinfo_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (unmark def-decl "IExpression" preprocess nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pure? def-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (releaseRedex? const-decl "bool" IL nil)
    (release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (typed_reduce_defs 0
  (typed_reduce_defs-1 nil 3703344804
   ("" (skeep :preds? t)
    (("" (expand typed_reduce)
      (("" (expand* make_redex_typed typed_to_topstate) nil nil)) nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_reduce const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil))
   shostak))
 (typed_reduce_state_TCC1 0
  (typed_reduce_state_TCC1-1 nil 3703344804 ("" (subtype-tcc) nil nil)
   nil nil))
 (typed_reduce_state 0
  (typed_reduce_state-1 nil 3703344859
   ("" (skeep* :preds? t)
    (("" (expand typed_reduce)
      (("" (expand reduce)
        (("" (expand* make_redex_typed typed_to_topstate) nil nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (typed_reduce const-decl "typed_rstate" typed_rreduction nil)
    (make_redex_typed const-decl "typed_rstate" typed_rreduction nil)
    (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil)
    (reduce const-decl "rstate" rreduction nil))
   shostak))
 (reduce_stack_length_TCC1 0
  (reduce_stack_length_TCC1-1 nil 3703867850 ("" (subtype-tcc) nil nil)
   nil nil))
 (reduce_stack_length 0
  (reduce_stack_length-1 nil 3703867860
   ("" (skeep* :preds? t)
    (("" (expand reduce :assert? none)
      (("" (name-replace "t" "to_topstate(grS)")
        (("" (case "atom?(t`redex)")
          (("1" (assert)
            (("1" (expand* t to_topstate)
              (("1" (rewrite popdepth_fill) (("1" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (simplify :let-reduce? t)
            (("2" (name-replace "nS" "make_redex(t)")
              (("2"
                (case-replace
                 "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = nS`stack`length - popDepth(nS`redex) - popDepth(nS`context)")
                (("1" (assert)
                  (("1" (lift-if)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (expand letReduce)
                          (("1" (expand* push add)
                            (("1" (expand popDepth + (2 3 4))
                              (("1"
                                (expand popDepth + 2)
                                (("1"
                                  (case "letexpr?(nS`redex)")
                                  (("1"
                                    (case-replace
                                     "popDepth(body(nS`redex)) = 0")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (use purePopDepth)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (flatten)
                            (("1" (expand applyReduce)
                              (("1"
                                (assert)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (ground)
                                    (("1"
                                      (rewrite popdepth_letApply)
                                      (("1"
                                        (rewrite popDepth_mark)
                                        (("1"
                                          (case-replace
                                           "popDepth(nS`redex) = 0")
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (typepred
                                                   "D`seq(fun(nS`redex))`body")
                                                  (("1"
                                                    (rewrite
                                                     purePopDepth)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand ifReduce)
                                  (("1"
                                    (expand release_marked)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand popDepth + (2 4))
                                        (("1"
                                          (case-replace
                                           "popDepth(nS`redex) = 0")
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (rewrite
                                                   purePopDepth)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (case-replace
                                       "updateReduce(D)(nS)`stack`length = nS`stack`length")
                                      (("1"
                                        (rewrite updateReduce_context)
                                        (("1"
                                          (use updateReduce_redex)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (case-replace
                                               "popDepth(nS`redex) = 0")
                                              (("1"
                                                (split)
                                                (("1"
                                                  (replace -1)
                                                  (("1"
                                                    (expand popDepth)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (replace -1)
                                                  (("2"
                                                    (typepred
                                                     "get(nS`stack)(target(nS`redex))")
                                                    (("2"
                                                      (hide-all-but
                                                       (1 -1))
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but (1 -3))
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (split)
                                            (("1"
                                              (expand*
                                               nS
                                               t
                                               make_redex
                                               to_topstate)
                                              nil
                                              nil)
                                             ("2"
                                              (expand nS)
                                              (("2"
                                                (hide (-1 -2 2))
                                                (("2"
                                                  (lemma
                                                   make_redex_ndr)
                                                  (("2"
                                                    (inst -1 t)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (split)
                                          (("1"
                                            (expand*
                                             nS
                                             t
                                             make_redex
                                             to_topstate)
                                            nil
                                            nil)
                                           ("2"
                                            (expand nS)
                                            (("2"
                                              (lemma make_redex_ndr)
                                              (("2"
                                                (inst -1 t)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use updateReduce_new_stack)
                                        (("1" (flatten) nil nil)
                                         ("2"
                                          (split)
                                          (("1"
                                            (expand*
                                             nS
                                             t
                                             make_redex
                                             to_topstate)
                                            nil
                                            nil)
                                           ("2"
                                            (lemma make_redex_ndr)
                                            (("2"
                                              (inst -1 t)
                                              (("2"
                                                (expand nS)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand lookupReduce)
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand*
                                                   release_marked
                                                   setRedex)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       popDepth
                                                       +
                                                       2)
                                                      (("1"
                                                        (typepred
                                                         "nS`store(refindex(get(nS`stack)(arrayvalue(nS`redex))))`seq
                     (value(get(nS`stack)(position(nS`redex))))")
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (split)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand newintReduce)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand newrefReduce)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       popReduce)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand pop)
                                                          (("1"
                                                            (case-replace
                                                             "popDepth(nS`redex) = 1")
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (split)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (typepred
                                                                     "get(nS`stack)(pbody(nS`redex))")
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (expand
                                                       releaseReduce)
                                                      (("2"
                                                        (expand decref)
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (split)
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (case
                                                                   "releaseRedex?(nS`redex)")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (expand
                                                                     nS)
                                                                    (("2"
                                                                      (expand
                                                                       make_redex)
                                                                      (("2"
                                                                        (typepred
                                                                         "buildRedex(t`redex)")
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (case
                                                                   "releaseRedex?(nS`redex)")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (expand*
                                                                     nS
                                                                     make_redex)
                                                                    (("2"
                                                                      (typepred
                                                                       "buildRedex(t`redex)")
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete 3)
                  (("2"
                    (case-replace
                     "grS`stack`length - popDepth(grS`redex) - popDepth(grS`context) = t`stack`length - popDepth(t`redex) - popDepth(t`context)")
                    (("1" (expand nS)
                      (("1" (expand make_redex)
                        (("1" (typepred "buildRedex(t`redex)")
                          (("1" (replace -1 :dir RL)
                            (("1" (rewrite popdepth_fill)
                              (("1"
                                (replace -1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand* t to_topstate)
                      (("2" (rewrite popdepth_fill)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (to_topstate_dangling application-judgement "(noDanglingRefs?)"
     rreduction nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (markc def-decl "IContext" preprocess nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (IExpression type-decl nil IExpression_adt nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (every const-decl "bool" finseq_theorems nil)
    (domainValue? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil)
    (contextPure? def-decl "bool" IL nil)
    (mark def-decl "IExpression" preprocess nil)
    (cvars def-decl "finite_set[nat]" preprocess nil)
    (Store type-eq-decl nil reduction nil)
    (refcount const-decl "nat" rreduction nil)
    (rstate type-eq-decl nil rreduction nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (rtopstate type-eq-decl nil rreduction nil)
    (to_topstate const-decl "rtopstate" rreduction nil)
    (noDanglingRefs? const-decl "bool" rreduction nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (decref const-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil)
    (decref1_preserves_stack formula-decl nil reduction_props nil)
    (decref1_preserves_redex formula-decl nil reduction_props nil)
    (decref1_preserves_context formula-decl nil reduction_props nil)
    (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL
     nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (releaseReduce const-decl "rstate" rreduction nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (popRedex? const-decl "bool" IL nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pop const-decl "Stack" IL nil)
    (popReduce const-decl "rstate" rreduction nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newrefReduce const-decl "rstate" rreduction nil)
    (newintRedex? const-decl "bool" IL nil)
    (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil)
    (newintReduce const-decl "rstate" rreduction nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]"
     IExpression_adt nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt
     nil)
    (position adt-accessor-decl "[(lookup?) -> (variable?)]"
      IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lookupRedex? const-decl "bool" IL nil)
    (setRedex const-decl "rstate" rreduction nil)
    (lookupReduce const-decl "rstate" rreduction nil)
    (updateReduce_new_stack formula-decl nil typed_rreduction nil)
    (updateReduce_context formula-decl nil typed_rreduction nil)
    (make_redex_ndr judgement-tcc nil rreduction nil)
    (target adt-accessor-decl "[(update?) -> (variable?)]"
            IExpression_adt nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (nS skolem-const-decl "{rS | pureRedex?(rS`redex)}"
     typed_rreduction nil)
    (updateReduce_redex formula-decl nil typed_rreduction nil)
    (Definition type-eq-decl nil rreduction nil)
    (Defs type-eq-decl nil rreduction nil)
    (goodrstate type-eq-decl nil rreduction nil)
    (updateRedex? const-decl "bool" IL nil)
    (updateReduce const-decl "(noDanglingRefs?)" rreduction nil)
    (release_marked const-decl "rstate" rreduction nil)
    (thenexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (get const-decl "(value?)" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (elseexpr adt-accessor-decl "[(ift?) -> IExpression]"
     IExpression_adt nil)
    (ifReduce const-decl "rstate" rreduction nil)
    (vars_mark_type application-judgement "{C | vars(C) = vars(B)}"
     preprocess nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" sigma_set
     "sigma_set/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (popDepth_mark formula-decl nil preprocess nil)
    (applyRedex? const-decl "bool" IL nil)
    (popdepth_letApply formula-decl nil rreduction nil)
    (pure? def-decl "bool" IL nil)
    (unmark def-decl "IExpression" preprocess nil)
    (Definition type-eq-decl nil typed_rreduction nil)
    (Defs type-eq-decl nil typed_rreduction nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt
         nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (length def-decl "nat" list_props nil)
    (args adt-accessor-decl "[(application?) -> list[(variable?)]]"
          IExpression_adt nil)
    (applyReduce const-decl "rstate" rreduction nil)
    (add const-decl "finseq[T]" more_finseq nil)
    (push const-decl "Stack" IL nil)
    (body adt-accessor-decl "[(letexpr?) -> IExpression]"
          IExpression_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (purePopDepth formula-decl nil IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letReduce const-decl "rstate" rreduction nil)
    (pureRedex? const-decl "bool" IL nil)
    (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (popdepth_fill formula-decl nil IL nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (t skolem-const-decl "rtopstate" typed_rreduction nil)
    (atom? const-decl "bool" IL nil)
    (reduce const-decl "rstate" rreduction nil))
   shostak)))

