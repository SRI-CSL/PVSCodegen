(IL
 (fill_TCC1 0
  (fill_TCC1-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))
 (fill_TCC2 0
  (fill_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))
 (context_lemma 0
  (context_lemma-1 nil 3646034052
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep)
      (("4"
        (inst + "hole"
         "application(application1_var, application2_var)")
        (("4" (grind) nil nil)) nil))
      nil)
     ("5" (skeep)
      (("5" (ground)
        (("1" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)")
          (("1" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)")
            (("2" (grind) nil nil)) nil))
          nil)
         ("3" (skeep)
          (("3" (inst + "letc(K, letexpr2_var)" "B")
            (("3" (grind) nil nil)) nil))
          nil)
         ("4" (skeep)
          (("4" (skeep)
            (("4" (inst + "letc(K!1, letexpr2_var)" "B!1")
              (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep)
      (("6" (inst + "hole" "ift(ift1_var, ift2_var, ift3_var)")
        (("6" (grind) nil nil)) nil))
      nil)
     ("7" (skeep)
      (("7"
        (inst + "hole" "update(update1_var, update2_var, update3_var)")
        (("7" (grind) nil nil)) nil))
      nil)
     ("8" (skeep)
      (("8" (inst + "hole" "lookup(lookup1_var, lookup2_var)")
        (("8" (grind) nil nil)) nil))
      nil)
     ("9" (skeep)
      (("9" (inst + "hole" "newint(newint1_var)")
        (("9" (grind) nil nil)) nil))
      nil)
     ("10" (skeep)
      (("10" (inst + "hole" "newref(newref1_var)")
        (("10" (grind) nil nil)) nil))
      nil)
     ("11" (skeep)
      (("11" (ground)
        (("1" (inst + "hole" "pop(pop1_var)") (("1" (grind) nil nil))
          nil)
         ("2" (skeep)
          (("2" (inst + "popc(K)" "B") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skeep)
      (("12" (inst + "hole" "ref(ref1_var)") (("12" (grind) nil nil))
        nil))
      nil)
     ("13" (skeep)
      (("13" (inst + "hole" "release(release1_var, release2_var)")
        (("13" (grind) nil nil)) nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil)
    (ref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt
     nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt
     nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (redex? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (atom? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (buildContext_TCC1 0
  (buildContext_TCC1-1 nil 3646033320
   ("" (skosimp*)
    (("" (expand "fill" +)
      (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((fill def-decl "IExpression" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (buildContext_TCC2 0
  (buildContext_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (buildContext_TCC3 0
  (buildContext_TCC3-1 nil 3646033320
   ("" (skosimp*)
    (("" (expand "fill" +)
      (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((fill def-decl "IExpression" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (buildContext_TCC4 0
  (buildContext_TCC4-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (buildContext_TCC5 0
  (buildContext_TCC5-1 nil 3646033320 ("" (grind) nil nil)
   ((fill def-decl "IExpression" IL nil)) nil))
 (context_composition 0
  (context_composition-1 nil 3646034275
   ("" (induct-and-simplify "K1") nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fill def-decl "IExpression" IL nil)
    (compose def-decl "IContext" IL nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (pure?_TCC1 0
  (pure?_TCC1-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (pure?_TCC2 0
  (pure?_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (pure?_TCC3 0
  (pure?_TCC3-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (pure?_TCC4 0
  (pure?_TCC4-1 nil 3693185170
   ("" (skeep) (("" (replace -1) (("" (grind) nil nil)) nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (pure_contextPure 0
  (pure_contextPure-1 nil 3646034299
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (buildcontextPure_TCC1 0
  (buildcontextPure_TCC1-1 nil 3646033320
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (buildcontextPure_TCC2 0
  (buildcontextPure_TCC2-1 nil 3646033320
   ("" (skeep* :preds? t)
    (("" (typepred "v(B)") (("" (grind) nil nil)) nil)) nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (buildcontextPure_TCC3 0
  (buildcontextPure_TCC3-1 nil 3646033320
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil))
 (buildcontextPure_TCC4 0
  (buildcontextPure_TCC4-1 nil 3693185170
   ("" (skeep* :preds? t)
    (("" (typepred "v(B)") (("" (grind) nil nil)) nil)) nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (buildcontextPure_TCC5 0
  (buildcontextPure_TCC5-1 nil 3693185170 ("" (grind) nil nil)
   ((cpure? def-decl "bool" IL nil)) nil))
 (contextPurefill 0
  (contextPurefill-1 nil 3646034319
   ("" (induct-and-simplify "K") nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (pureApplyRedex 0
  (pureApplyRedex-1 nil 3682268823
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (applyRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (pureLetRedex?_TCC1 0
  (pureLetRedex?_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil))
   nil))
 (pureIftRedex?_TCC1 0
  (pureIftRedex?_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil)
   ((iftRedex? const-decl "bool" IL nil)) nil))
 (pureReleaseRedex?_TCC1 0
  (pureReleaseRedex?_TCC1-1 nil 3693185170 ("" (grind) nil nil)
   ((releaseRedex? const-decl "bool" IL nil)) nil))
 (pureRedexContextPure 0
  (pureRedexContextPure-1 nil 3646130634
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep)
      (("6" (expand "contextPure?" +)
        (("6" (expand "pureRedex?" -4)
          (("6" (split -4)
            (("1" (expand "pureLetRedex?")
              (("1" (expand "letRedex?") (("1" (propax) nil nil)) nil))
              nil)
             ("2" (expand "applyRedex?") (("2" (propax) nil nil)) nil)
             ("3" (expand "pureIftRedex?")
              (("3" (expand "iftRedex?")
                (("3" (flatten)
                  (("3" (rewrite "pure_contextPure" +)
                    (("3" (rewrite "pure_contextPure" +) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (grind) nil nil) ("5" (grind) nil nil)
             ("6" (grind) nil nil) ("7" (grind) nil nil)
             ("8" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil) ("13" (grind) nil nil)
     ("14" (grind) nil nil))
    nil)
   ((pure? def-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (ContextPurePureRedex 0
  (ContextPurePureRedex-1 nil 3682299553
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*) (("4" (grind) nil nil)) nil)
     ("5" (skeep*) (("5" (grind) nil nil)) nil)
     ("6" (skeep*)
      (("6" (hide (-1 -2 -3))
        (("6" (grind)
          (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil))
        nil))
      nil)
     ("7" (postpone) nil nil) ("8" (postpone) nil nil)
     ("9" (postpone) nil nil) ("10" (postpone) nil nil)
     ("11" (postpone) nil nil) ("12" (postpone) nil nil)
     ("13" (postpone) nil nil))
    nil)
   nil shostak))
 (refs_TCC1 0
  (refs_TCC1-1 nil 3646033320
   ("" (typepred "IExpression_adt.<<")
    (("" (expand "strict_well_founded?")
      (("" (expand "strict_order?")
        (("" (ground)
          (("" (hide -1 -2)
            (("" (grind :if-match nil)
              (("" (inst - "p!1")
                (("" (ground)
                  (("1" (skosimp*)
                    (("1" (inst + "y!2")
                      (("1" (skeep)
                        (("1" (inst?)
                          (("1" (typepred "x_1")
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (typepred "y!2") (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst + "y!1") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_founded? const-decl "bool" orders nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (strict_order? const-decl "bool" orders nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (pure_refs 0
  (pure_refs-1 nil 3646034342
   ("" (induct-and-simplify "A")
    (("" (rewrite "pure_contextPure") nil nil)) nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (refs_fill 0
  (refs_fill-1 nil 3646034363
   ("" (induct-and-simplify "K")
    (("1" (apply-extensionality) nil nil)
     ("2" (apply-extensionality) nil nil)
     ("3" (rewrite "contextPurefill") nil nil))
    nil)
   ((pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (refcount_TCC1 0
  (refcount_TCC1-1 nil 3646033320 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (refcount_pure 0
  (refcount_pure-1 nil 3676382439
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refcount def-decl "nat" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (pop_TCC1 0
  (pop_TCC1-1 nil 3646033415 ("" (subtype-tcc) nil nil) nil nil))
 (pop_TCC2 0
  (pop_TCC2-1 nil 3646033415 ("" (subtype-tcc) nil nil) nil nil))
 (get_TCC1 0
  (get_TCC1-1 nil 3646033415 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (popdepth_fill 0
  (popdepth_fill-1 nil 3646034392
   ("" (induct-and-simplify "K") nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (fill def-decl "IExpression" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (purePopDepth 0
  (purePopDepth-1 nil 3646034411 ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (popDepth def-decl "nat" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (in_varlist_TCC1 0
  (in_varlist_TCC1-1 nil 3656276690
   ("" (grind :if-match nil)
    ((""
      (inst + "length(L!1)" "LAMBDA (i | some[(variable?)]
                           (LAMBDA (v: (variable?)): index(v) = i)(L!1)): locate[(variable?)]((LAMBDA (v: (variable?)): index(v) = i), L!1)")
      (("1" (skeep)
        (("1"
          (typepred
           "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x1, L!1)")
          (("1"
            (typepred
             "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x2, L!1)")
            (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (skeep :preds? t)
        (("2" (rewrite "some_nth")
          (("2" (skeep)
            (("2" (inst?) (("2" (rewrite "member_nth") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (member def-decl "bool" list_props nil)
    (L!1 skolem-const-decl "list[(variable?)]" IL nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (some adt-def-decl "boolean" list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (locate def-decl
     "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}"
     finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (i_1 skolem-const-decl "below(length(L!1))" IL nil)
    (i skolem-const-decl
       "{i | some[(variable?)](lambda (v: (variable?)): index(v) = i)(L!1)}"
       IL nil)
    (member_nth formula-decl nil finseq_theorems nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil))
 (bumpn_TCC1 0
  (bumpn_TCC1-1 nil 3656517434 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (bumpn_TCC2 0
  (bumpn_TCC2-1 nil 3656517434
   ("" (grind :if-match nil)
    ((""
      (inst + "N!1"
       "LAMBDA (i | i >= j!1 AND X!1(i - j!1)): f!1(i - j!1)")
      (("1" (skeeps :preds? t)
        (("1" (forward-chain -) (("1" (grind) nil nil)) nil)) nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (j!1 skolem-const-decl "nat" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (X!1 skolem-const-decl "finite_set[nat]" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil))
 (bumpn_zero 0
  (bumpn_zero-1 nil 3656521531 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil))
   shostak))
 (drop_TCC1 0
  (drop_TCC1-1 nil 3656390208
   ("" (grind :if-match nil)
    (("" (inst + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)")
      (("" (grind :if-match nil)
        (("" (forward-chain -) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil))
 (drop_bump 0
  (drop_bump-1 nil 3656520613 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil))
   shostak))
 (bumpn_union 0
  (bumpn_union-1 nil 3656567110 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (bumpn_bump 0
  (bumpn_bump-1 nil 3656631410 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bump const-decl "finite_set[nat]" IL nil))
   shostak))
 (vars_TCC1 0
  (vars_TCC1-1 nil 3646033415 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil))
 (vars_decompose 0
  (vars_decompose-1 nil 3646034443
   ("" (induct-and-simplify "K") nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (fill def-decl "IExpression" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (popDepth def-decl "nat" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set[nat]" countability
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set[T]" countable_props
     "sets_aux/")
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/")
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil))
   shostak))
 (vars_finite 0
  (vars_finite-2 "" 3655616144
   ("" (induct "A")
    (("1" (grind :if-match nil)
      (("1"
        (inst + 1
         "(LAMBDA (i: (vars(variable(variable1_var!1, variable2_var!1)))): 0)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (grind :if-match nil)
      (("2"
        (inst + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("3" (grind :if-match nil)
      (("3" (inst + 0 "LAMBDA (i: (vars(nil))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("4" (skeep)
      (("4" (expand "vars" +)
        (("4" (expand "is_finite" +)
          (("4"
            (inst + "length(application2_var)"
             "(LAMBDA (i | in_varlist(application2_var)(i)): locate(LAMBDA x: index(x) = i, application2_var))")
            (("1" (expand "injective?")
              (("1" (skeep)
                (("1"
                  (typepred
                   "locate(LAMBDA x: index(x) = x1, application2_var)")
                  (("1" (assert)
                    (("1"
                      (typepred
                       "locate(LAMBDA x: index(x) = x2, application2_var)")
                      (("1" (assert)
                        (("1" (replace -6 :hide? t)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (typepred "i")
                (("2" (expand "in_varlist")
                  (("2" (rewrite "some_nth")
                    (("2" (skeep)
                      (("2" (inst?)
                        (("2" (rewrite "member_nth") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (expand "vars" +)
        (("5"
          (lemma "finite_union"
           ("A" "vars(letexpr1_var)" "B"
            "(LAMBDA i: vars(letexpr2_var)(1 + i))"))
          (("1" (expand "union")
            (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)
           ("2" (hide -1 2)
            (("2" (expand "is_finite")
              (("2" (skeep)
                (("2"
                  (inst + "N"
                   "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))")
                  (("2" (expand "injective?")
                    (("2" (skeep)
                      (("2" (forward-chain -2) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep)
      (("6" (expand "vars" +)
        (("6"
          (lemma "finite_union"
           ("A" "vars(ift1_var)" "B" "vars(ift2_var)"))
          (("1"
            (lemma "finite_union"
             ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B"
              "vars(ift3_var)"))
            (("1" (expand "union")
              (("1" (expand "member") (("1" (propax) nil nil)) nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep)
      (("7" (expand "vars")
        (("7" (expand "vars")
          (("7" (expand "is_finite" +)
            (("7"
              (inst + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                         (i = index(update2_var)) OR
                          (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)")
              (("7" (expand "injective?") (("7" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep)
      (("8" (expand "vars" +)
        (("8" (expand "is_finite" +)
          (("8"
            (inst + 2
             "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF")
            (("8" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("9" (skeep)
      (("9" (expand "vars")
        (("9" (expand "is_finite")
          (("9" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("10" (skeep)
      (("10" (expand "vars")
        (("10" (expand "is_finite")
          (("10" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skeep)
      (("11" (expand "vars" +)
        (("11" (expand "is_finite")
          (("11" (skeep)
            (("11"
              (inst + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)")
              (("11" (expand "injective?")
                (("11" (skeep)
                  (("11" (forward-chain -1) (("11" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (skeep)
      (("12" (expand "vars")
        (("12" (expand "is_finite")
          (("12" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skeep)
      (("13" (expand "vars" +)
        (("13" (expand "is_finite")
          (("13" (skeep*)
            (("13"
              (inst + "N!1 + 1"
               "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release2_var)(i) THEN f!1(i) ELSE N!1 ENDIF")
              (("1" (grind :if-match nil)
                (("1" (forward-chain -4) nil nil)
                 ("2" (forward-chain -4) nil nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression_induction formula-decl nil IExpression_adt nil)
    (vars def-decl "finite_set[nat]" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak)
  (vars_finite-1 nil 3652888177
   ("" (induct "A")
    (("1" (grind :if-match nil)
      (("1"
        (inst + 1 "(LAMBDA (i: (vars(variable(variable1_var!1)))): 0)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (grind :if-match nil)
      (("2"
        (inst + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("3" (grind :if-match nil)
      (("3" (inst + 0 "LAMBDA (i: (vars(nil))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("4" (skeep)
      (("4" (expand "vars" +)
        (("4" (expand "is_finite" +)
          (("4"
            (inst + "length(application2_var)"
             "(LAMBDA (i | member(variable(i), application2_var)): locate(LAMBDA x: index(x) = i, application2_var))")
            (("1" (expand "injective?")
              (("1" (skeep)
                (("1"
                  (typepred
                   "locate(LAMBDA x: index(x) = x1, application2_var)")
                  (("1" (assert)
                    (("1"
                      (typepred
                       "locate(LAMBDA x: index(x) = x2, application2_var)")
                      (("1" (assert)
                        (("1" (replace -6 :hide? t)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep :preds? t)
              (("2" (inst + "variable(i)") nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (expand "vars" +)
        (("5"
          (lemma "finite_union"
           ("A" "vars(letexpr1_var)" "B"
            "(LAMBDA i: vars(letexpr2_var)(1 + i))"))
          (("1" (expand "union")
            (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)
           ("2" (hide -1 2)
            (("2" (expand "is_finite")
              (("2" (skeep)
                (("2"
                  (inst + "N"
                   "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))")
                  (("2" (expand "injective?")
                    (("2" (skeep)
                      (("2" (forward-chain -2) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep)
      (("6" (expand "vars" +)
        (("6"
          (lemma "finite_union"
           ("A" "vars(ift1_var)" "B" "vars(ift2_var)"))
          (("1"
            (lemma "finite_union"
             ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B"
              "vars(ift3_var)"))
            (("1" (expand "union")
              (("1" (expand "member") (("1" (propax) nil nil)) nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep)
      (("7" (expand "vars")
        (("7" (expand "vars")
          (("7" (expand "is_finite" +)
            (("7"
              (inst + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                     (i = index(update2_var)) OR
                      (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)")
              (("7" (expand "injective?") (("7" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep)
      (("8" (expand "vars" +)
        (("8" (expand "is_finite" +)
          (("8"
            (inst + 2
             "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF")
            (("8" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("9" (skeep)
      (("9" (expand "vars")
        (("9" (expand "is_finite")
          (("9" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("10" (skeep)
      (("10" (expand "vars")
        (("10" (expand "is_finite")
          (("10" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skeep)
      (("11" (expand "vars" +)
        (("11" (expand "is_finite")
          (("11" (skeep)
            (("11"
              (inst + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)")
              (("11" (expand "injective?")
                (("11" (skeep)
                  (("11" (forward-chain -1) (("11" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (skeep)
      (("12" (expand "vars")
        (("12" (expand "is_finite")
          (("12" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skeep)
      (("13" (expand "vars" +)
        (("13" (expand "is_finite")
          (("13" (skeep*)
            (("13"
              (inst + "N + 1"
               "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release1_var)(i) THEN f(i) ELSE N ENDIF")
              (("1" (grind :if-match nil)
                (("1" (forward-chain -3) nil nil)
                 ("2" (forward-chain -3) nil nil))
                nil)
               ("2" (skeep*) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("14" (skeep)
      (("14" (expand "is_finite" +)
        (("14" (inst + 1 "LAMBDA (i | vars(mark(mark1_var))(i)): 0")
          (("14" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (locate def-decl
     "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}"
     finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil))
   shostak)))

