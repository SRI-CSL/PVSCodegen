(IL
 (fill_TCC1 0
  (fill_TCC1-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil
   (fill termination "fill(K1, A)" "nil")))
 (fill_TCC2 0
  (fill_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil
   (fill termination "fill(K1, A)" "nil")))
 (context_lemma 0
  (context_lemma-1 nil 3646034052
   ("" (induct A)
    (("1" (skeep* :preds? t)
      (("1" (inst 2 "hole" _)
        (("1" (inst?) (("1" (grind) nil nil)) nil)) nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) (("4" (inst 1 hole) (("4" (grind) nil nil)) nil))
      nil)
     ("5" (skeep*)
      (("5" (split)
        (("1" (inst 2 "hole" _)
          (("1" (inst 2 "letexpr(letexpr1_var, letexpr2_var)")
            (("1" (grind) nil nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (inst 2 "letc(K,letexpr2_var)" B)
            (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (inst 2 "hole" "ift(ift1_var,ift2_var,ift3_var)")
        (("6" (grind) nil nil)) nil))
      nil)
     ("7" (skeep*)
      (("7"
        (inst 2 "hole" "update(update1_var, update2_var, update3_var)")
        (("7" (grind) nil nil)) nil))
      nil)
     ("8" (skeep*)
      (("8" (inst 2 "hole" "lookup(lookup1_var, lookup2_var)")
        (("8" (grind) nil nil)) nil))
      nil)
     ("9" (skeep*)
      (("9" (inst 2 "hole" "newint(newint1_var)")
        (("9" (grind) nil nil)) nil))
      nil)
     ("10" (skeep*)
      (("10" (inst 2 "hole" "newref(newref1_var)")
        (("10" (grind) nil nil)) nil))
      nil)
     ("11" (skeep*)
      (("11" (split)
        (("1" (inst 2 "hole" "pop(pop1_var)") (("1" (grind) nil nil))
          nil)
         ("2" (skeep*)
          (("2" (inst 2 "popc(K)" B) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (inst 2 "hole" "release(release1_var,release2_var)")
        (("13" (grind) nil nil)) nil))
      nil))
    nil)
   ((release? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (release adt-constructor-decl
     "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil)
    (popc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (popc adt-constructor-decl "[IContext -> (popc?)]" IL nil)
    (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt
     nil)
    (newref? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt
     nil)
    (newint? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (lookup adt-constructor-decl
            "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt
            nil)
    (update? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (update adt-constructor-decl
     "[[(variable?), (variable?), (variable?)] -> (update?)]"
     IExpression_adt nil)
    (ift? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (ift adt-constructor-decl
     "[[(variable?), IExpression, IExpression] -> (ift?)]"
     IExpression_adt nil)
    (letc? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]"
     IL nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (application? adt-recognizer-decl "[IExpression -> boolean]"
                  IExpression_adt nil)
    (application adt-constructor-decl
     "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (redex? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IContext type-decl nil IL nil) (value? const-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (buildContext_TCC1 0
  (buildContext_TCC1-1 nil 3646033320
   ("" (skosimp*)
    (("" (expand "fill" +)
      (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((fill def-decl "IExpression" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (buildContext subtype "(letc(K, C), B1)"
    "{K, B | fill(K, B) = A}")))
 (buildContext_TCC2 0
  (buildContext_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (buildContext termination "buildContext(B)" "nil")))
 (buildContext_TCC3 0
  (buildContext_TCC3-1 nil 3646033320
   ("" (skosimp*)
    (("" (expand "fill" +)
      (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((fill def-decl "IExpression" IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IContext type-decl nil IL nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil
   (buildContext subtype "(popc(K), B1)" "{K, B | fill(K, B) = A}")))
 (buildContext_TCC4 0
  (buildContext_TCC4-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (buildContext termination "buildContext(B)" "nil")))
 (buildContext_TCC5 0
  (buildContext_TCC5-1 nil 3646033320 ("" (grind) nil nil)
   ((fill def-decl "IExpression" IL nil)) nil
   (buildContext subtype "(hole, A)" "{K, B | fill(K, B) = A}")))
 (context_composition 0
  (context_composition-2 nil 3706551297
   ("" (induct-and-simplify "K1") nil nil)
   ((IContext_induction formula-decl nil IL nil)
    (compose def-decl "IContext" IL nil)
    (fill def-decl "IExpression" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil))
   nil)
  (context_composition-1 nil 3646034275
   ("" (induct-and-simplify "K1") nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fill def-decl "IExpression" IL nil)
    (compose def-decl "IContext" IL nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (pure?_TCC1 0
  (pure?_TCC1-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (pure? termination "pure?(C)" "nil")))
 (pure?_TCC2 0
  (pure?_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (pure? termination "pure?(B)" "nil")))
 (pure?_TCC3 0
  (pure?_TCC3-1 nil 3646033320 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (pure? termination "pure?(C)" "nil")))
 (pure?_TCC4 0
  (pure?_TCC4-1 nil 3693185170
   ("" (skeep) (("" (replace -1) (("" (grind) nil nil)) nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (pure? termination "pure?(B)" "nil")))
 (pure_contextPure 0
  (pure_contextPure-1 nil 3646034299
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (buildcontextPure_TCC1 0
  (buildcontextPure_TCC1-1 nil 3646033320
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil (buildcontextPure_ subtype "B" "(contextPure?)")))
 (buildcontextPure_TCC2 0
  (buildcontextPure_TCC2-1 nil 3646033320
   ("" (skeep* :preds? t)
    (("" (typepred "v(B)") (("" (grind) nil nil)) nil)) nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (buildcontextPure_ subtype "(letc(K, C), B1)"
    "{K, B | cpure?(K) AND contextPure?(B)}")))
 (buildcontextPure_TCC3 0
  (buildcontextPure_TCC3-1 nil 3646033320
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil))
   nil (buildcontextPure_ subtype "B" "(contextPure?)")))
 (buildcontextPure_TCC4 0
  (buildcontextPure_TCC4-1 nil 3693185170
   ("" (skeep* :preds? t)
    (("" (typepred "v(B)") (("" (grind) nil nil)) nil)) nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (buildcontextPure_ subtype "(popc(K), B1)"
    "{K, B | cpure?(K) AND contextPure?(B)}")))
 (buildcontextPure_TCC5 0
  (buildcontextPure_TCC5-1 nil 3693185170 ("" (grind) nil nil)
   ((cpure? def-decl "bool" IL nil)) nil
   (buildcontextPure_ subtype "(hole, A)"
    "{K, B | cpure?(K) AND contextPure?(B)}")))
 (contextPurefill 0
  (contextPurefill-1 nil 3646034319
   ("" (induct-and-simplify "K") nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (contextPure? def-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cpure? def-decl "bool" IL nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (pureApplyRedex 0
  (pureApplyRedex-1 nil 3682268823
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (applyRedex? const-decl "bool" IL nil)
    (pure? def-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (pureLetRedex?_TCC1 0
  (pureLetRedex?_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil)
   ((value? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil))
   nil (pureLetRedex? subtype "A" "(IExpression_adt.letexpr?)")))
 (pureIftRedex?_TCC1 0
  (pureIftRedex?_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil)
   ((iftRedex? const-decl "bool" IL nil)) nil
   (pureIftRedex? subtype "A" "(IExpression_adt.ift?)")))
 (pureReleaseRedex?_TCC1 0
  (pureReleaseRedex?_TCC1-1 nil 3693185170 ("" (grind) nil nil)
   ((releaseRedex? const-decl "bool" IL nil)) nil
   (pureReleaseRedex? subtype "A" "(IExpression_adt.release?)")))
 (pureRedexContextPure 0
  (pureRedexContextPure-1 nil 3646130634
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skeep)
      (("6" (expand "contextPure?" +)
        (("6" (expand "pureRedex?" -4)
          (("6" (split -4)
            (("1" (expand "pureLetRedex?")
              (("1" (expand "letRedex?") (("1" (propax) nil nil)) nil))
              nil)
             ("2" (expand "applyRedex?") (("2" (propax) nil nil)) nil)
             ("3" (expand "pureIftRedex?")
              (("3" (expand "iftRedex?") (("3" (propax) nil nil)) nil))
              nil)
             ("4" (grind) nil nil) ("5" (grind) nil nil)
             ("6" (grind) nil nil) ("7" (grind) nil nil)
             ("8" (grind) nil nil) ("9" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (hide -1 -2)
        (("13" (expand contextPure?)
          (("13" (use pure_contextPure) (("13" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((pure_contextPure formula-decl nil IL nil)
    (pure? def-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (ContextPurePureRedex 0
  (ContextPurePureRedex-1 nil 3682299553
   ("" (induct "A")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*) (("4" (grind) nil nil)) nil)
     ("5" (skeep*) (("5" (grind) nil nil)) nil)
     ("6" (skeep*)
      (("6" (hide (-1 -2 -3)) (("6" (grind) nil nil)) nil)) nil)
     ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil)
     ("10" (grind) nil nil) ("11" (grind) nil nil)
     ("12" (grind) nil nil)
     ("13" (skeep*)
      (("13" (expand contextPure? -4) (("13" (grind) nil nil)) nil))
      nil))
    nil)
   ((pureReleaseRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (value? const-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (pureRedex? const-decl "bool" IL nil)
    (contextPure? def-decl "bool" IL nil)
    (redex? const-decl "bool" IL nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak))
 (buildRedex_TCC1 0
  (buildRedex_TCC1-1 nil 3699114546 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil))
   nil (buildRedex subtype "(hole, A)" "{K, B | fill(K, B) = A}")))
 (buildRedex_TCC2 0
  (buildRedex_TCC2-1 nil 3699114546 ("" (grind) nil nil)
   ((value? const-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil))
   nil (buildRedex subtype "(hole, A)" "{K, B | fill(K, B) = A}")))
 (not_value_redex_fill 0
  (not_value_redex_fill-1 nil 3706468681
   ("" (induct-and-simplify K) nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (redex? const-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (value? const-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil))
   shostak))
 (buildRedex_fill 0
  (buildRedex_fill-1 nil 3706468551
   ("" (induct K)
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (expand fill +)
        (("2" (expand buildRedex +)
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (use not_value_redex_fill)
                  (("1" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep* :preds? t)
      (("3" (expand fill +)
        (("3" (expand buildRedex +)
          (("3" (lift-if)
            (("3" (split)
              (("1" (flatten)
                (("1" (use not_value_redex_fill)
                  (("1" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (redex? const-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fill def-decl "IExpression" IL nil)
    (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil)
    (IContext_induction formula-decl nil IL nil)
    (value? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (not_value_redex_fill formula-decl nil IL nil))
   shostak))
 (buildRedexPure_TCC1 0
  (buildRedexPure_TCC4-1 nil 3705953402
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (value? const-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (cpure? def-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil))
   nil
   (buildRedexPure_ subtype "(hole, A)"
    "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}")))
 (buildRedexPure_TCC2 0
  (buildRedexPure_TCC2-1 nil 3699114546
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil))
   nil (buildRedexPure_ subtype "B" "(contextPure?)")))
 (buildRedexPure_TCC3 0
  (buildRedexPure_TCC3-1 nil 3705953402
   ("" (skeep* :preds? t)
    (("" (typepred "v(B)")
      (("" (split)
        (("1" (flatten)
          (("1" (split)
            (("1" (grind) nil nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil)
         ("2" (flatten) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((value? const-decl "bool" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (cpure? def-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil))
   nil
   (buildRedexPure_ subtype "(letc(K, C), B1)"
    "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}")))
 (buildRedexPure_TCC4 0
  (buildRedexPure_TCC7-1 nil 3705953402
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (fill def-decl "IExpression" IL nil)
    (cpure? def-decl "bool" IL nil) (value? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil))
   nil
   (buildRedexPure_ subtype "(hole, A)"
    "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}")))
 (buildRedexPure_TCC5 0
  (buildRedexPure_TCC5-1 nil 3699114546
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (contextPure? def-decl "bool" IL nil)
    (value? const-decl "bool" IL nil))
   nil (buildRedexPure_ subtype "B" "(contextPure?)")))
 (buildRedexPure_TCC6 0
  (buildRedexPure_TCC6-1 nil 3705953402
   ("" (skeep* :preds? t)
    (("" (typepred "v(B)")
      (("" (split)
        (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((value? const-decl "bool" IL nil)
    (hole adt-constructor-decl "(hole?)" IL nil)
    (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil)
    (pureRedex? const-decl "bool" IL nil)
    (cpure? def-decl "bool" IL nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (IContext type-decl nil IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil))
   nil
   (buildRedexPure_ subtype "(popc(K), B1)"
    "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}")))
 (buildRedexPure_TCC7 0
  (buildRedexPure_TCC1-1 nil 3699114546
   ("" (recursive-judgement-tcc) nil nil)
   ((contextPure? def-decl "bool" IL nil)
    (IExpression type-decl nil IExpression_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (value? const-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (cpure? def-decl "bool" IL nil)
    (letRedex? const-decl "bool" IL nil)
    (pureLetRedex? const-decl "bool" IL nil)
    (applyRedex? const-decl "bool" IL nil)
    (iftRedex? const-decl "bool" IL nil)
    (pureIftRedex? const-decl "bool" IL nil)
    (updateRedex? const-decl "bool" IL nil)
    (lookupRedex? const-decl "bool" IL nil)
    (newintRedex? const-decl "bool" IL nil)
    (newrefRedex? const-decl "bool" IL nil)
    (popRedex? const-decl "bool" IL nil)
    (releaseRedex? const-decl "bool" IL nil)
    (pureReleaseRedex? const-decl "bool" IL nil)
    (pureRedex? const-decl "bool" IL nil))
   nil
   (buildRedexPure_ subtype "(hole, A)"
    "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}")))
 (refs_TCC1 0
  (refs_TCC1-1 nil 3646033320
   ("" (typepred "IExpression_adt.<<")
    (("" (expand "strict_well_founded?")
      (("" (expand "strict_order?")
        (("" (ground)
          (("" (hide -1 -2)
            (("" (grind :if-match nil)
              (("" (inst - "p!1")
                (("" (ground)
                  (("1" (skosimp*)
                    (("1" (inst + "y!2")
                      (("1" (skeep)
                        (("1" (inst?)
                          (("1" (typepred "x_1")
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (typepred "y!2") (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst + "y!1") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_founded? const-decl "bool" orders nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (strict_order? const-decl "bool" orders nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (refs termination "refs(C)" "nil")))
 (pure_refs 0
  (pure_refs-1 nil 3646034342
   ("" (induct-and-simplify "A")
    (("" (rewrite "pure_contextPure") nil nil)) nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (refs def-decl "bool" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (refs_fill 0
  (refs_fill-1 nil 3646034363
   ("" (induct-and-simplify "K")
    (("1" (apply-extensionality) nil nil)
     ("2" (apply-extensionality) nil nil)
     ("3" (rewrite "contextPurefill") nil nil))
    nil)
   ((pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt
         nil)
    (pop? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (letexpr adt-constructor-decl
     "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil)
    (letexpr? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (contextPure? def-decl "bool" IL nil)
    (fill def-decl "IExpression" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refs def-decl "bool" IL nil)
    (IContext_induction formula-decl nil IL nil))
   shostak))
 (refcount_TCC1 0
  (refcount_TCC1-1 nil 3646033320 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (refcount termination "refcount(C)" "nil")))
 (refcount_pure 0
  (refcount_pure-1 nil 3676382439
   ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (refcount def-decl "nat" IL nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (pop_TCC1 0
  (pop_TCC1-1 nil 3646033415 ("" (subtype-tcc) nil nil) nil nil
   (pop subtype "nS`length - 1" "nat")))
 (pop_TCC2 0
  (pop_TCC2-1 nil 3646033415 ("" (subtype-tcc) nil nil) nil nil
   (pop subtype "i" "below[nS`length]")))
 (get_TCC1 0
  (get_TCC1-1 nil 3646033415 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (below type-eq-decl nil nat_types nil)
    (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (get subtype "S`length - IExpression_adt.index(x) - 1"
        "below[S`length]")))
 (popdepth_fill 0
  (popdepth_fill-1 nil 3646034392
   ("" (induct-and-simplify "K") nil nil)
   ((IContext type-decl nil IL nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fill def-decl "IExpression" IL nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IContext_induction formula-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (purePopDepth 0
  (purePopDepth-1 nil 3646034411 ("" (induct-and-simplify "A") nil nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pure? def-decl "bool" IL nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IExpression_induction formula-decl nil IExpression_adt nil))
   shostak))
 (in_varlist_TCC1 0
  (in_varlist_TCC1-1 nil 3656276690
   ("" (grind :if-match nil)
    ((""
      (inst + "length(L!1)" "LAMBDA (i | some[(variable?)]
                           (LAMBDA (v: (variable?)): index(v) = i)(L!1)): locate[(variable?)]((LAMBDA (v: (variable?)): index(v) = i), L!1)")
      (("1" (skeep)
        (("1"
          (typepred
           "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x1, L!1)")
          (("1"
            (typepred
             "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x2, L!1)")
            (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (skeep :preds? t)
        (("2" (rewrite "some_nth")
          (("2" (skeep)
            (("2" (inst?) (("2" (rewrite "member_nth") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (member def-decl "bool" list_props nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (locate def-decl
     "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}"
     finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some_nth formula-decl nil finseq_theorems nil)
    (member_nth formula-decl nil finseq_theorems nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IExpression type-decl nil IExpression_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil
   (in_varlist subtype
    "{i | list_adt[(IExpression_adt.variable?)].some(LAMBDA (v: (IExpression_adt.variable?)): IExpression_adt.index(v) = i)(L)}"
    "finite_set[nat]")))
 (bumpn_TCC1 0
  (bumpn_TCC1-1 nil 3656517434 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (bumpn subtype "i - j" "nat")))
 (bumpn_TCC2 0
  (bumpn_TCC2-1 nil 3656517434
   ("" (skeep*)
    (("" (expand is_finite)
      (("" (typepred X)
        (("" (expand is_finite)
          (("" (skeep)
            (("" (inst 1 N _)
              ((""
                (inst 1
                 "LAMBDA (i: {i | i >= j AND X(i - j)}): f(i - j)")
                (("1" (expand injective?)
                  (("1" (skeep*)
                    (("1" (inst -1 "x1-j" "x2-j")
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil))
   nil (bumpn subtype "{i | i >= j AND X(i - j)}" "finite_set[nat]")))
 (bumpn_zero 0
  (bumpn_zero-1 nil 3656521531 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bumpn const-decl "finite_set[nat]" IL nil))
   shostak))
 (drop_TCC1 0
  (drop_TCC1-1 nil 3656390208
   ("" (grind :if-match nil)
    (("" (inst + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)")
      (("" (grind :if-match nil)
        (("" (forward-chain -) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil (drop subtype "{i | X(i + 1)}" "finite_set[nat]")))
 (drop_bump 0
  (drop_bump-1 nil 3656520613 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (bump const-decl "finite_set[nat]" IL nil))
   shostak))
 (bumpn_union 0
  (bumpn_union-1 nil 3656567110 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (union const-decl "set" sets nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (finite_union application-judgement "finite_set[nat]" countability
     "sets_aux/"))
   shostak))
 (bumpn_bump 0
  (bumpn_bump-1 nil 3656631410 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bumpn const-decl "finite_set[nat]" IL nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (bump const-decl "finite_set[nat]" IL nil))
   shostak))
 (vars_TCC1 0
  (vars_TCC1-1 nil 3646033415 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[IExpression])"
     IExpression_adt nil))
   nil (vars termination "vars(C)" "nil")))
 (vars_decompose 0
  (vars_decompose-1 nil 3646034443
   ("" (induct K)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (member const-decl "bool" sets nil)
    (drop const-decl "finite_set[nat]" IL nil)
    (union const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (emptyset const-decl "set" sets nil)
    (IContext_induction formula-decl nil IL nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fill def-decl "IExpression" IL nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IContext type-decl nil IL nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (vars_finite 0
  (vars_finite-2 "" 3655616144
   ("" (induct "A")
    (("1" (grind :if-match nil)
      (("1"
        (inst + 1
         "(LAMBDA (i: (vars(variable(variable1_var!1, variable2_var!1)))): 0)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (grind :if-match nil)
      (("2"
        (inst + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("3" (grind :if-match nil)
      (("3" (inst + 0 "LAMBDA (i: (vars(nil))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("4" (skeep)
      (("4" (expand "vars" +)
        (("4" (expand "is_finite" +)
          (("4"
            (inst + "length(application2_var)"
             "(LAMBDA (i | in_varlist(application2_var)(i)): locate(LAMBDA x: index(x) = i, application2_var))")
            (("1" (expand "injective?")
              (("1" (skeep)
                (("1"
                  (typepred
                   "locate(LAMBDA x: index(x) = x1, application2_var)")
                  (("1" (assert)
                    (("1"
                      (typepred
                       "locate(LAMBDA x: index(x) = x2, application2_var)")
                      (("1" (assert)
                        (("1" (replace -6 :hide? t)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (typepred "i")
                (("2" (expand "in_varlist")
                  (("2" (rewrite "some_nth")
                    (("2" (skeep)
                      (("2" (inst?)
                        (("2" (rewrite "member_nth") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (expand "vars" +)
        (("5"
          (lemma "finite_union"
           ("A" "vars(letexpr1_var)" "B"
            "(LAMBDA i: vars(letexpr2_var)(1 + i))"))
          (("1" (expand "union")
            (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)
           ("2" (hide -1 2)
            (("2" (expand "is_finite")
              (("2" (skeep)
                (("2"
                  (inst + "N"
                   "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))")
                  (("2" (expand "injective?")
                    (("2" (skeep)
                      (("2" (forward-chain -2) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep)
      (("6" (expand "vars" +)
        (("6"
          (lemma "finite_union"
           ("A" "vars(ift1_var)" "B" "vars(ift2_var)"))
          (("1"
            (lemma "finite_union"
             ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B"
              "vars(ift3_var)"))
            (("1" (expand "union")
              (("1" (expand "member") (("1" (propax) nil nil)) nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep)
      (("7" (expand "vars")
        (("7" (expand "vars")
          (("7" (expand "is_finite" +)
            (("7"
              (inst + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                         (i = index(update2_var)) OR
                          (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)")
              (("7" (expand "injective?") (("7" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep)
      (("8" (expand "vars" +)
        (("8" (expand "is_finite" +)
          (("8"
            (inst + 2
             "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF")
            (("8" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("9" (skeep)
      (("9" (expand "vars")
        (("9" (expand "is_finite")
          (("9" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("10" (skeep)
      (("10" (expand "vars")
        (("10" (expand "is_finite")
          (("10" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skeep)
      (("11" (expand "vars" +)
        (("11" (expand "is_finite")
          (("11" (skeep)
            (("11"
              (inst + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)")
              (("11" (expand "injective?")
                (("11" (skeep)
                  (("11" (forward-chain -1) (("11" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (skeep)
      (("12" (expand "vars")
        (("12" (expand "is_finite")
          (("12" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skeep)
      (("13" (expand "vars" +)
        (("13" (expand "is_finite")
          (("13" (skeep*)
            (("13"
              (inst + "N!1 + 1"
               "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release2_var)(i) THEN f!1(i) ELSE N!1 ENDIF")
              (("1" (grind :if-match nil)
                (("1" (forward-chain -4) nil nil)
                 ("2" (forward-chain -4) nil nil))
                nil)
               ("2" (grind) nil nil) ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IExpression_induction formula-decl nil IExpression_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IExpression type-decl nil IExpression_adt nil))
   shostak)
  (vars_finite-1 nil 3652888177
   ("" (induct "A")
    (("1" (grind :if-match nil)
      (("1"
        (inst + 1 "(LAMBDA (i: (vars(variable(variable1_var!1)))): 0)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (grind :if-match nil)
      (("2"
        (inst + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("3" (grind :if-match nil)
      (("3" (inst + 0 "LAMBDA (i: (vars(nil))): 0")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil)
     ("4" (skeep)
      (("4" (expand "vars" +)
        (("4" (expand "is_finite" +)
          (("4"
            (inst + "length(application2_var)"
             "(LAMBDA (i | member(variable(i), application2_var)): locate(LAMBDA x: index(x) = i, application2_var))")
            (("1" (expand "injective?")
              (("1" (skeep)
                (("1"
                  (typepred
                   "locate(LAMBDA x: index(x) = x1, application2_var)")
                  (("1" (assert)
                    (("1"
                      (typepred
                       "locate(LAMBDA x: index(x) = x2, application2_var)")
                      (("1" (assert)
                        (("1" (replace -6 :hide? t)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep :preds? t)
              (("2" (inst + "variable(i)") nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (expand "vars" +)
        (("5"
          (lemma "finite_union"
           ("A" "vars(letexpr1_var)" "B"
            "(LAMBDA i: vars(letexpr2_var)(1 + i))"))
          (("1" (expand "union")
            (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)
           ("2" (hide -1 2)
            (("2" (expand "is_finite")
              (("2" (skeep)
                (("2"
                  (inst + "N"
                   "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))")
                  (("2" (expand "injective?")
                    (("2" (skeep)
                      (("2" (forward-chain -2) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("6" (skeep)
      (("6" (expand "vars" +)
        (("6"
          (lemma "finite_union"
           ("A" "vars(ift1_var)" "B" "vars(ift2_var)"))
          (("1"
            (lemma "finite_union"
             ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B"
              "vars(ift3_var)"))
            (("1" (expand "union")
              (("1" (expand "member") (("1" (propax) nil nil)) nil))
              nil)
             ("2" (propax) nil nil) ("3" (propax) nil nil))
            nil)
           ("2" (propax) nil nil) ("3" (propax) nil nil))
          nil))
        nil))
      nil)
     ("7" (skeep)
      (("7" (expand "vars")
        (("7" (expand "vars")
          (("7" (expand "is_finite" +)
            (("7"
              (inst + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                     (i = index(update2_var)) OR
                      (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)")
              (("7" (expand "injective?") (("7" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skeep)
      (("8" (expand "vars" +)
        (("8" (expand "is_finite" +)
          (("8"
            (inst + 2
             "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF")
            (("8" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("9" (skeep)
      (("9" (expand "vars")
        (("9" (expand "is_finite")
          (("9" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("10" (skeep)
      (("10" (expand "vars")
        (("10" (expand "is_finite")
          (("10" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("11" (skeep)
      (("11" (expand "vars" +)
        (("11" (expand "is_finite")
          (("11" (skeep)
            (("11"
              (inst + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)")
              (("11" (expand "injective?")
                (("11" (skeep)
                  (("11" (forward-chain -1) (("11" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (skeep)
      (("12" (expand "vars")
        (("12" (expand "is_finite")
          (("12" (inst + 0 "LAMBDA (i | FALSE): 0")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skeep)
      (("13" (expand "vars" +)
        (("13" (expand "is_finite")
          (("13" (skeep*)
            (("13"
              (inst + "N + 1"
               "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release1_var)(i) THEN f(i) ELSE N ENDIF")
              (("1" (grind :if-match nil)
                (("1" (forward-chain -3) nil nil)
                 ("2" (forward-chain -3) nil nil))
                nil)
               ("2" (skeep*) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("14" (skeep)
      (("14" (expand "is_finite" +)
        (("14" (inst + 1 "LAMBDA (i | vars(mark(mark1_var))(i)): 0")
          (("14" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((IExpression type-decl nil IExpression_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IExpression_induction formula-decl nil IExpression_adt nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (variable adt-constructor-decl "[[nat, bool] -> (variable?)]"
     IExpression_adt nil)
    (variable? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (constant? adt-recognizer-decl "[IExpression -> boolean]"
               IExpression_adt nil)
    (constant adt-constructor-decl "[int -> (constant?)]"
     IExpression_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (nil? adt-recognizer-decl "[IExpression -> boolean]"
     IExpression_adt nil)
    (nil adt-constructor-decl "(nil?)" IExpression_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt
           nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (locate def-decl
     "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}"
     finseq_theorems nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_union judgement-tcc nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil))
   shostak)))

