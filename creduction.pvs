creduction: THEORY
  BEGIN

    IMPORTING finite_set_theorems, list2finseq_extra

    % All types we are considering have a size of sizeof(int) or sizeof(int*)
    % We will assume these two are equal, and every size we will
    % use will mean that size times sizeof(int)

    ctype: DATATYPE
      BEGIN
        cint: cint?
        carray(arraytype: ctype): carray?
        cstruct(sfields: finseq[ctype]): cstruct?
      END ctype

    tp1, tp2, tp3: VAR ctype

    lvalue: DATATYPE
      BEGIN
        cvar(cindex: nat): cvar?
        caccess(clhs: (cvar?), crhs: (cvar?)): caccess?
        cfield(cval: (cvar?), cfindex:  nat): cfield?
      END lvalue

    lv1, lv2, lv3: VAR lvalue

    builtin_num: nat = 1

    cexpr: DATATYPE
      BEGIN
        elv(lval: lvalue): elv?
        econstant(cvalue: int): econstant?
        ecall(cfun: nat, cargs: finseq[(cvar?)]): ecall?
        ebuiltin(cbuiltin: below(builtin_num), cbv1: (cvar?), cbv2: (cvar?)): ebuiltin?
      END cexpr

    e1, e2, e3: VAR cexpr

    cstat: DATATYPE
      BEGIN
        sassign(aval: lvalue, aexpr: cexpr): sassign?
        sdecl(dtype: ctype, dstat: cstat): sdecl?
        sif(scond: (cvar?), iftrue: cstat, iffalse: cstat): sif?
        sblock(bstats: finseq[cstat]): sblock?
        smalloc(msize: nat): smalloc?
        sfree(fvar: (cvar?)): sfree?
        sreturn(rvar: (cvar?)): sreturn?
      END cstat

    s1, s2, s3: VAR cstat

    cvalue: DATATYPE
      BEGIN
        cref(crefindex: nat): cref?
        cintv(cintvalue: int): cintv?
        cnil: cnil?
      END cvalue

    dom: VAR finite_set[nat]
    Store(dom): TYPE = [(dom) -> finseq[cvalue]]
    Stack: TYPE = finseq[cvalue]
    i, j, k: VAR nat

    vars(lv1)(i) : bool =
      CASES lv1 OF
        cvar(j): i = j,
        caccess(v1, v2): i = cindex(v1) OR i = cindex(v2),
        cfield(v1, j): i = cindex(v1)
      ENDCASES

    vars(e1)(i) : bool =
      CASES e1 OF
        elv(lv1) : vars(lv1)(i),
        econstant(c) : FALSE,
        ecall(f, args) : EXISTS (j: below(args`length)): cindex(args`seq(j)) = i,
        ebuiltin(f, v1, v2) : i = cindex(v1) OR i = cindex(v2)
      ENDCASES

    vars(s1)(i) : RECURSIVE bool =
      CASES s1 OF
        sassign(lv1, e1): vars(lv1)(i) OR vars(e1)(i),
        sdecl(tp1, s2): vars(s2)(i + 1),
        sif(v1, thenc, elsec): cindex(v1) = i OR vars(thenc)(i) OR vars(elsec)(i),
        sblock(stats): EXISTS (j: below(stats`length)): vars(stats`seq(j))(i),
        smalloc(size): FALSE,
        sfree(v1): cindex(v1) = i,
        sreturn(v1): cindex(v1) = i
      ENDCASES
    MEASURE s1 BY <<

    length_cdr[T: TYPE]: LEMMA
      FORALL (l: list[T]):
        cons?(l) IMPLIES length(cdr(l)) = length(l) - 1

    nth_cdr[T: TYPE]: LEMMA
      FORALL (l: list[T]):
        cons?(l) AND i < length(cdr(l)) IMPLIEs nth(cdr(l), i) = nth(l, i + 1)

    measure_stat(s1): RECURSIVE posnat =
      CASES s1 OF
        sdecl(tp1, s2): 1 + measure_stat(s2),
        sif(v1, thenc, elsec): 1 + measure_stat(thenc) + measure_stat(elsec),
        sblock(stats): 1 + Sigma((LAMBDA j: j < stats`length), LAMBDA j: IF j < stats`length THEN measure_stat(stats`seq(j)) ELSE 0 ENDIF)
        ELSE 1
      ENDCASES
    MEASURE s1 BY <<

    measure_stat_car: LEMMA
      sblock?(s1) AND bstats(s1)`length > 0 IMPLIES
        measure_stat(car(bstats(s1))) < measure_stat(s1)

    measure_stat_cdr: LEMMA
      sblock?(s1) AND bstats(s1)`length > 0 IMPLIES
        measure_stat(sblock(cdr(bstats(s1)))) < measure_stat(s1)

    clength(s1) : RECURSIVE nat =
      CASES s1 OF
        sdecl(tp1, s2): clength(s2) + 2,
        sif(v1, thenc, elsec): clength(thenc) + clength(elsec) + 2,
        sblock(stats):
          IF stats`length = 0 THEN
            0
          ELSE
            clength(car(stats)) + clength(sblock(cdr(stats)))
          ENDIF
        ELSE 1
      ENDCASES
    MEASURE measure_stat(s1)

    %TODO definitions are well typed
    Definition: TYPE = [# arity: nat, body: {s1 | FORALL i: vars(s1)(i) IMPLIES i < arity} #]
    D: VAR finseq[Definition]

    stack_size_at(s1)(i: below(clength(s1))) : RECURSIVE nat =
      CASES s1 OF
        sdecl(tp1, s2):
          IF i = 0 THEN
            0
          ELSIF i < clength(s2) + 1 THEN
            1 + stack_size_at(s2)(i - 1)
          ELSE
            1
          ENDIF,
        sif(v1, thenc, elsec):
          IF i = 0 THEN
            0
          ELSIF i < clength(thenc) + 1 THEN
            stack_size_at(thenc)(i - 1)
          ELSIF i < clength(thenc) + clength(elsec) + 1 THEN
            stack_size_at(elsec)(i - 1 - clength(thenc))
          ELSE
            0
          ENDIF,
        sblock(stats):
          IF i < clength(car(stats)) THEN
            stack_size_at(car(stats))(i)
          ELSE
            stack_size_at(sblock(cdr(stats)))(i-clength(car(stats)))
          ENDIF
        ELSE 0
      ENDCASES
    MEASURE measure_stat(s1)

    is_fun_call_at(s1)(i: below(clength(s1))) : RECURSIVE bool =
      CASES s1 OF
        sdecl(tp1, s2):
          IF i = 0 THEN
            FALSE
          ELSIF i < clength(s2) + 1 THEN
            is_fun_call_at(s2)(i - 1)
          ELSE
            FALSE
          ENDIF,
        sif(v1, thenc, elsec):
          IF i = 0 THEN
            FALSE
          ELSIF i < clength(thenc) + 1 THEN
            is_fun_call_at(thenc)(i - 1)
          ELSIF i < clength(thenc) + clength(elsec) + 1 THEN
            is_fun_call_at(elsec)(i - 1 - clength(thenc))
          ELSE
            FALSE
          ENDIF,
        sblock(stats):
          IF i < clength(car(stats)) THEN
            is_fun_call_at(car(stats))(i)
          ELSE
            is_fun_call_at(sblock(cdr(stats)))(i-clength(car(stats)))
          ENDIF,
        sassign(lv1, e1): ecall?(e1)
        ELSE FALSE
      ENDCASES
    MEASURE measure_stat(s1)

    cstack_frame(D): TYPE = [#
      ffct: below(D`length),
      fpc: below(clength(D`seq(ffct)`body)),
      fstack: {S : Stack | S`length = stack_size_at(D`seq(ffct)`body)(fpc) + D`seq(ffct)`arity}
    #]

    cstate: TYPE = [#
      cdefs: finseq[Definition],
      callstack: {C : finseq[cstack_frame(cdefs)] |
        FORALL (i: below(C`length - 1)):
          is_fun_call_at(cdefs`seq(C`seq(i)`ffct)`body)(C`seq(i)`fpc)
      },
      domain: finite_set[nat],
      store: Store(domain)
    #]

  END creduction
