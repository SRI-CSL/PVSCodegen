creduction: THEORY
  BEGIN

    IMPORTING finite_set_theorems, list2finseq_extra, finseq_theorems

    % All types we are considering have a size of sizeof(int) or sizeof(int*)
    % We will assume these two are equal, and every size we will
    % use will mean that size times sizeof(int)

    ctype: DATATYPE
      BEGIN
        cint: cint?
        carray(arraytype: ctype): carray?
        cstruct(sfields: finseq[ctype]): cstruct?
      END ctype

    tp1, tp2, tp3: VAR ctype

    lvalue: DATATYPE
      BEGIN
        cvar(cindex: nat): cvar?
        caccess(clhs: (cvar?), crhs: (cvar?)): caccess?
        cfield(cval: (cvar?), cfindex:  nat): cfield?
        creturn: creturn?
      END lvalue

    lv1, lv2, lv3: VAR lvalue
    lrvalue?(lv1) : bool = NOT creturn?(lv1)
    lr1, lr2, lr3: VAR (lrvalue?)

    builtin_num: nat = 1

    cexpr: DATATYPE
      BEGIN
        elv(lval: (lrvalue?)): elv?
        econstant(cvalue: int): econstant?
        enil: enil?
        ecall(cfun: nat, cargs: finseq[(cvar?)]): ecall?
        ebuiltin(cbuiltin: below(builtin_num), cbv1: (cvar?), cbv2: (cvar?)): ebuiltin?
      END cexpr

    e1, e2, e3: VAR cexpr

    cstat: DATATYPE
      BEGIN
        sassign(aval: lvalue, aexpr: cexpr): sassign?
        scall(sfun: nat, sargs: finseq[(cvar?)]): scall?
        sdecl(dtype: ctype, dstat: cstat): sdecl?
        sif(scond: (cvar?), iftrue: cstat, iffalse: cstat): sif?
        sblock(bstats: finseq[cstat]): sblock?
        smalloc(msize: nat): smalloc?
        sfree(fvar: (cvar?)): sfree?
      END cstat

    s1, s2, s3: VAR cstat

    cvalue: DATATYPE
      BEGIN
        cref(crefindex: nat): cref?
        cintv(cintvalue: int): cintv?
        cnil: cnil?
      END cvalue

    dom: VAR finite_set[nat]
    Store(dom): TYPE = [(dom) -> finseq[cvalue]]
    Stack: TYPE = finseq[cvalue]
    i, j, k: VAR nat

    vars(lv1)(i) : bool =
      CASES lv1 OF
        cvar(j): i = j,
        caccess(v1, v2): i = cindex(v1) OR i = cindex(v2),
        cfield(v1, j): i = cindex(v1),
        creturn: FALSE
      ENDCASES

    vars(e1)(i) : bool =
      CASES e1 OF
        elv(lr1) : vars(lr1)(i),
        econstant(c) : FALSE,
        enil: FALSE,
        ecall(f, args) : EXISTS (j: below(args`length)): cindex(args`seq(j)) = i,
        ebuiltin(f, v1, v2) : i = cindex(v1) OR i = cindex(v2)
      ENDCASES

    vars(s1)(i) : RECURSIVE bool =
      CASES s1 OF
        sassign(lv1, e1): vars(lv1)(i) OR vars(e1)(i),
        scall(f, args): EXISTS (j: below(args`length)): cindex(args`seq(j)) = i,
        sdecl(tp1, s2): vars(s2)(i + 1),
        sif(v1, thenc, elsec): cindex(v1) = i OR vars(thenc)(i) OR vars(elsec)(i),
        sblock(stats): EXISTS (j: below(stats`length)): vars(stats`seq(j))(i),
        smalloc(size): FALSE,
        sfree(v1): cindex(v1) = i
      ENDCASES
    MEASURE s1 BY <<

    length_cdr[T: TYPE]: LEMMA
      FORALL (l: list[T]):
        cons?(l) IMPLIES length(cdr(l)) = length(l) - 1

    nth_cdr[T: TYPE]: LEMMA
      FORALL (l: list[T]):
        cons?(l) AND i < length(cdr(l)) IMPLIEs nth(cdr(l), i) = nth(l, i + 1)

    measure_stat(s1): RECURSIVE posnat =
      CASES s1 OF
        sdecl(tp1, s2): 1 + measure_stat(s2),
        sif(v1, thenc, elsec): 1 + measure_stat(thenc) + measure_stat(elsec),
        sblock(stats): 1 + Sigma((LAMBDA j: j < stats`length), LAMBDA j: IF j < stats`length THEN measure_stat(stats`seq(j)) ELSE 0 ENDIF)
        ELSE 1
      ENDCASES
    MEASURE s1 BY <<

    measure_stat_car: LEMMA
      sblock?(s1) AND bstats(s1)`length > 0 IMPLIES
        measure_stat(car(bstats(s1))) < measure_stat(s1)

    measure_stat_cdr: LEMMA
      sblock?(s1) AND bstats(s1)`length > 0 IMPLIES
        measure_stat(sblock(cdr(bstats(s1)))) < measure_stat(s1)

    clength(s1) : RECURSIVE nat =
      CASES s1 OF
        sdecl(tp1, s2): clength(s2) + 2,
        sif(v1, thenc, elsec): clength(thenc) + clength(elsec) + 1,
        sblock(stats):
          IF stats`length = 0 THEN
            0
          ELSE
            clength(car(stats)) + clength(sblock(cdr(stats)))
          ENDIF,
        scall(f, args): 1 + args`length,
        sassign(lv1, e1): IF ecall?(e1) THEN 2 + cargs(e1)`length ELSE 2 ENDIF
        ELSE 1
      ENDCASES
    MEASURE measure_stat(s1)

    stack_size_at(s1)(i: below(clength(s1))) : RECURSIVE nat =
      CASES s1 OF
        sdecl(tp1, s2):
          IF i = 0 THEN
            0
          ELSIF i < clength(s2) + 1 THEN
            1 + stack_size_at(s2)(i - 1)
          ELSE
            1
          ENDIF,
        sif(v1, thenc, elsec):
          IF i = 0 THEN
            0
          ELSIF i < clength(thenc) + 1 THEN
            stack_size_at(thenc)(i - 1)
          ELSE
            stack_size_at(elsec)(i - 1 - clength(thenc))
          ENDIF,
        sblock(stats):
          IF i < clength(car(stats)) THEN
            stack_size_at(car(stats))(i)
          ELSE
            stack_size_at(sblock(cdr(stats)))(i-clength(car(stats)))
          ENDIF
        ELSE 0
      ENDCASES
    MEASURE measure_stat(s1)

    stack_size_at_zero: LEMMA
      FORALL (s1 | clength(s1) > 0):
        stack_size_at(s1)(0) = 0

    % is_fun_call_at(s1)(i: below(clength(s1))) : RECURSIVE bool =
    %   CASES s1 OF
    %     sdecl(tp1, s2):
    %       IF i = 0 THEN
    %         FALSE
    %       ELSIF i < clength(s2) + 1 THEN
    %         is_fun_call_at(s2)(i - 1)
    %       ELSE
    %         FALSE
    %       ENDIF,
    %     sif(v1, thenc, elsec):
    %       IF i = 0 THEN
    %         FALSE
    %       ELSIF i < clength(thenc) + 1 THEN
    %         is_fun_call_at(thenc)(i - 1)
    %       ELSIF i < clength(thenc) + clength(elsec) + 1 THEN
    %         is_fun_call_at(elsec)(i - 1 - clength(thenc))
    %       ELSE
    %         FALSE
    %       ENDIF,
    %     sblock(stats):
    %       IF i < clength(car(stats)) THEN
    %         is_fun_call_at(car(stats))(i)
    %       ELSE
    %         is_fun_call_at(sblock(cdr(stats)))(i-clength(car(stats)))
    %       ENDIF,
    %     sassign(lv1, e1): ecall?(e1),
    %     scall(f, args): TRUE
    %     ELSE FALSE
    %   ENDCASES
    % MEASURE measure_stat(s1)
    
    executable_stat?(s1, (i: below(clength(s1)))): bool =
      CASES s1 OF
        sdecl(tp1, s2): i = 0 OR i = 1 + clength(s2),
        sif(v1, thenc, elsec): i = 0,
        sblock(stats): FALSE
        ELSE TRUE
      ENDCASES

    extract_stat(s1)(i: below(clength(s1))) : RECURSIVE
        {(s2, j) | j < clength(s2) AND executable_stat?(s2, j)} =
      CASES s1 OF
        sdecl(tp1, s2):
          IF i = 0 THEN
            (s1, i)
          ELSIF i < 1 + clength(s2) THEN
            extract_stat(s2)(i - 1)
          ELSE
            (s1, i)
          ENDIF,
        sif(v1, thenc, elsec):
          IF i = 0 THEN
            (s1, i)
          ELSIF i < 1 + clength(thenc) THEN
            extract_stat(thenc)(i - 1)
          ELSE
            extract_stat(elsec)(i - 1 - clength(thenc))
          ENDIF,
        sblock(stats):
          IF i < clength(car(stats)) THEN
            extract_stat(car(stats))(i)
          ELSE
            extract_stat(sblock(cdr(stats)))(i-clength(car(stats)))
          ENDIF
        ELSE (s1, i)
      ENDCASES
    MEASURE measure_stat(s1)

    is_return?(s1) : bool =
      sassign?(s1) AND creturn?(aval(s1))

    is_fun_call_at(s1)(i: below(clength(s1)), fct: nat) : bool =
      LET (s2, j) = extract_stat(s1)(i) IN
      (sassign?(s2) AND ecall?(aexpr(s2)) AND fct = cfun(aexpr(s2)) AND j = cargs(aexpr(s2))`length + 1) OR
        (scall?(s2) AND fct = sfun(s2) AND j = sargs(s2)`length)

    %TODO definitions are well typed
    Definition: TYPE = [#
        arity: nat,
        body: {s1 |
            (FORALL i: vars(s1)(i) IMPLIES i < arity)
          AND clength(s1) > 0
          AND is_return?(extract_stat(s1)(clength(s1) - 1)`1)
        }
    #]
    D: VAR finseq[Definition]

    cstack_frame(D): TYPE = [#
      ffct: below(D`length),
      fpc: below(clength(D`seq(ffct)`body)),
      %fstack: {S : Stack | S`length = stack_size_at(D`seq(ffct)`body)(fpc) + D`seq(ffct)`arity}
      fdepth: nat %TODO constraints?
    #]

    cstate: TYPE = [#
      error: boolean,
      cdefs: finseq[Definition],
      callstack: {C : finseq[cstack_frame(cdefs)] |
        FORALL (i | i < C`length - 1):
          is_fun_call_at(cdefs`seq(C`seq(i)`ffct)`body)(C`seq(i)`fpc, C`seq(i+1)`ffct)
      },
      stack: Stack,
      domain: finite_set[nat],
      store: Store(domain),
      return_value: cvalue
    #]

    cS, cS1, cS2: VAR cstate

    make_call(cS, (f: below(cS`cdefs`length))): cstate =
      cS WITH [`callstack := add((# ffct := f,
                                    fpc := 0,
                                    fdepth := cS`cdefs`seq(f)`arity
                                  #), cS`callstack)]

    next_pc(s1)(i | i < clength(s1)) : RECURSIVE upto(clength(s1)) =
      CASES s1 OF
        sdecl(tp1, s2):
          IF i = 0 THEN
            1
          ELSIF i < 1 + clength(s2) THEN
            1 + next_pc(s2)(i - 1)
          ELSE
            2 + clength(s2)
          ENDIF,
        sif(v1, thenc, elsec):
          IF i = 0 THEN % this should never matter however
            1
          ELSIF i < 1 + clength(thenc) THEN
            IF next_pc(thenc)(i - 1) = clength(thenc) THEN
              1 + clength(thenc) + clength(elsec)
            ELSE
              1 + next_pc(thenc)(i - 1)
            ENDIF
          ELSE
            1 + clength(thenc) + next_pc(elsec)(i - 1 - clength(thenc))
          ENDIF,
        sblock(stats):
          IF i < clength(car(stats)) THEN
            next_pc(car(stats))(i)
          ELSE
            clength(car(stats)) + next_pc(sblock(cdr(stats)))(i-clength(car(stats)))
          ENDIF
        ELSE i + 1
      ENDCASES
    MEASURE measure_stat(s1)

    pop[T: TYPE](S: finseq[T] | S`length > 0) : finseq[T] =
      (# length := S`length - 1,
         seq := LAMBDA (i: below(S`length - 1)): S`seq(i)
       #)

    reduce(cS | NOT cS`error): cstate =
      IF cS`callstack`length = 0 THEN
        cS
      ELSE
        LET lf = cS`callstack(cS`callstack`length - 1) IN
        LET fbody = cS`cdefs`seq(lf`ffct)`body IN
        LET (s1, i) = extract_stat(fbody)(lf`fpc) IN
        CASES s1 OF
          sdecl(tp, s2):
            IF i = 0 THEN % Push new variable
              cS WITH [`stack := add(IF tp = cint THEN cintv(0) ELSE cnil ENDIF, cS`stack),
                       `callstack`seq(cS`callstack`length - 1) :=
                         lf WITH [
                          `fdepth := lf`fdepth + 1,
                          `fpc := next_pc(fbody)(lf`fpc)
                         ]
                      ]

            ELSE % Pop it
              cS WITH [`stack := pop(cS`stack),
                       `callstack`seq(cS`callstack`length - 1) :=
                         lf WITH [
                          `fdepth := lf`fdepth - 1,
                          `fpc := next_pc(fbody)(lf`fpc)
                         ]
                      ]
            ENDIF,
          sif(v1, cthen, celse):
            IF i = 0 THEN % Check condition
              LET x = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
              IF x = cintv(0) OR x = cnil THEN
                cS WITH [`callstack`seq(cS`callstack`length - 1)`fpc := lf`fpc + clength(cthen) + 1]
              ELSE
                cS WITH [`callstack`seq(cS`callstack`length - 1)`fpc := lf`fpc + 1]
              ENDIF
            ELSE % Nop
              cS WITH [`callstack`seq(cS`callstack`length - 1)`fpc :=
                         next_pc(fbody)(lf`fpc)]
            ENDIF,
          sfree(v1):
            LET x = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
            % Freeing an int or something outside the domain is liable to memory
            % corruption, so this is an error.
            % However, freeing null it legal and is a nop.
            IF cintv?(x) OR (cref?(x) AND NOT cS`domain(crefindex(x))) THEN
              cS WITH [`error := TRUE]
            ELSE
              cS WITH [`domain := IF x = cnil THEN cS`domain ELSE remove(crefindex(x), cS`domain) ENDIF,
                       `callstack`seq(cS`callstack`length - 1)`fpc :=
                         next_pc(fbody)(lf`fpc)]
            ENDIF,
          smalloc(n):
            cS WITH [`domain := add(least_out(cS`domain), cS`domain),
                     `store := cS`store WITH
                       [(least_out(cS`domain)) |->
                         (# length := n, seq := LAMBDA (i: below(n)): cnil #)],
                     `callstack`seq(cS`callstack`length - 1)`fpc :=
                         next_pc(fbody)(lf`fpc)],
          scall(f, args):
            IF i < args`length THEN % Push arg
              cS WITH [`callstack`seq(cS`callstack`length - 1)`fpc := lf`fpc + 1,
                       `stack := add(cS`stack(cS`stack`length - 1 - i - cindex(args`seq(i))), cS`stack)
              ]
            ELSE % Call
              make_call(cS, f)
            ENDIF,
          sassign(lv1, e1):
            IF ecall?(e1) AND i <= cargs(e1)`length THEN
              IF i < cargs(e1)`length THEN % Push arg
                cS WITH [`callstack`seq(cS`callstack`length - 1)`fpc := lf`fpc + 1,
                         `stack := add(cS`stack(cS`stack`length - 1 - i - cindex(cargs(e1)`seq(i))), cS`stack)
                ]
              ELSE % Call
                make_call(cS, cfun(e1))
              ENDIF
            ELSIF i = 0 THEN % compute rhs and put in return value
              CASES e1 OF
                econstant(n):
                  cS WITH [`return_value := cintv(n),
                           `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)],
                enil:
                  cS WITH [`return_value := cnil,
                           `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)],
                ebuiltin(b, v1, v2):
                  LET x1 = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
                  LET x2 = cS`stack`seq(cS`stack`length - 1 - cindex(v2)) IN
                  IF cintv?(x1) AND cintv?(x2) THEN
                    cS WITH [`return_value := cintv(cintvalue(x1) + cintvalue(x2)),
                             `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)]
                  ELSE
                    cS WITH [`error := TRUE]
                  ENDIF,
                elv(lr1):
                  CASES lr1 OF
                    cvar(i):
                      cS WITH [`return_value := cS`stack`seq(cS`stack`length - 1 - i),
                               `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)],
                    caccess(v1, v2):
                      LET r = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
                      LET i = cS`stack`seq(cS`stack`length - 1 - cindex(v2)) IN
                      IF cref?(r) AND cS`domain(crefindex(r))
                          AND cintv?(i) AND cintvalue(i) >= 0
                          AND cintvalue(i) < cS`store(crefindex(r))`length THEN
                        cS WITH [`return_value := cS`store(crefindex(r))`seq(cintvalue(i)),
                                 `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)]
                      ELSE
                        cS WITH [`error := TRUE]
                      ENDIF,
                    cfield(v1, k):
                      LET r = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
                      IF cref?(r) AND cS`domain(crefindex(r)) AND k < cS`store(crefindex(r))`length THEN
                        cS WITH [`return_value := cS`store(crefindex(r))`seq(k),
                                 `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)]
                      ELSE
                        cS WITH [`error := TRUE]
                     ENDIF
                  ENDCASES
              ENDCASES
            ELSE
              CASES lv1 OF
                cvar(i):
                  cS WITH [`stack`seq(cS`stack`length - 1 - i) := cS`return_value,
                           `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)],
                caccess(v1, v2):
                  LET r = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
                  LET i = cS`stack`seq(cS`stack`length - 1 - cindex(v2)) IN
                  IF cref?(r) AND cS`domain(crefindex(r))
                      AND cintv?(i) AND cintvalue(i) >= 0
                      AND cintvalue(i) < cS`store(crefindex(r))`length THEN
                    cS WITH [`store(crefindex(r))`seq(cintvalue(i)) := cS`return_value,
                             `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)]
                  ELSE
                    cS WITH [`error := TRUE]
                  ENDIF,
                cfield(v1, k):
                  LET r = cS`stack`seq(cS`stack`length - 1 - cindex(v1)) IN
                  IF cref?(r) AND cS`domain(crefindex(r)) AND k < cS`store(crefindex(r))`length THEN
                    cS WITH [`store(crefindex(r))`seq(k) := cS`return_value,
                             `callstack`seq(cS`callstack`length - 1)`fpc := next_pc(fbody)(lf`fpc)]
                  ELSE
                    cS WITH [`error := TRUE]
                  ENDIF,
                creturn:
                  IF lf`fdepth > 0 THEN
                    cS WITH [`callstack`seq(cS`callstack`length - 1)`fdepth := lf`fdepth - 1]
                  ELSIF cS`callstack`length > 0 THEN
                    LET nc = pop(cS`callstack) IN
                    LET nlf = nc`seq(nc`length - 1) IN
                    cS WITH [`callstack := nc WITH
                      [`seq(nc`length - 1)`fpc :=
                          next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)]
                    ]
                  ELSE
                    cS
                  ENDIF
              ENDCASES
            ENDIF
        ENDCASES
      ENDIF

  END creduction
