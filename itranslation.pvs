itranslation: THEORY
  BEGIN

    IMPORTING IExpression, IL, finite_set_theorems, finseq_theorems, reduction, typeinfo, typeinfo_adt, preprocess, rreduction, reduction_props, iareduction, typed_reduction, typed_rreduction, typed_reduction_props, ireduction

    A, B, C: VAR IExpression
    K, K1, K2, K3: VAR IContext
    i, j, k: VAR nat
    x, y, z: VAR (variable?)
    trS, trS1, trS2: VAR typed_rstate
    iS, iS1, iS2: VAR istate
    stypes: VAR finseq[nat]
    dom_types: VAR [nat -> nat]
    tA: VAR typeinfo
    translate_vars: VAR [nat -> nat]
    dom: VAR finite_set[nat]

    Definition: TYPE = [# arity: nat,
                          body: {A |  pure?(A) AND
                                      (FORALL i: vars(A)(i) = (i < arity)) AND
                                      unmark(A) = A}
                       #]

    tdef: TYPE = [# return_type: nat, args_type: finseq[nat], body_type: typeinfo #]
    Defs: TYPE = finseq[Definition]

    D: VAR Defs
    tD: VAR finseq[tdef]

    shift(translate_vars)(i) : nat = translate_vars(i) + 1
    newvar(translate_vars)(i) : nat = IF i = 0 THEN 0 ELSE translate_vars(i - 1) + 1 ENDIF

    translate_statement(A: (pure?), rv: (ivar?),
      (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
      dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
      (translate_vars: [nat -> nat])
    ): RECURSIVE istat =
      CASES A OF
        variable(j, b): iassign(rv, ivar(translate_vars(j), b)),
        constant(n): iassign(rv, iconstant(n)),
        nil: iassign(rv, inil),
        application(f, args):
          iassign(rv, icall(f, map(LAMBDA x: ivar(translate_vars(index(x)), marked(x)))(args))),
        letexpr(B, C):
          idecl(lettype(tA), iblock(
            translate_statement(B, ivar(0, FALSE), stypes, dom_types, tD, lrhs(tA), shift(translate_vars)),
            iblock(iskip,
            translate_statement(C, ivar(vindex(rv) + 1, FALSE), add(lettype(tA), stypes),
                                dom_types, tD, lbody(tA), newvar(translate_vars)))))
        ,
        ift(x, B, C):
          iif(ivar(translate_vars(index(x)), marked(x)),
            translate_statement(B, rv, stypes, dom_types, tD, tthen(tA), translate_vars),
            translate_statement(C, rv, stypes, dom_types, tD, telse(tA), translate_vars)),
        update(target, lhs, rhs):
          iassign(rv, iupdate(ivar(translate_vars(index(target)), marked(target)),
                              ivar(translate_vars(index(lhs)), marked(lhs)),
                              ivar(translate_vars(index(rhs)), marked(rhs)))),
        lookup(arr, pos):
          LET s = iassign(rv, ilookup(ivar(translate_vars(index(arr)), FALSE),
                                      ivar(translate_vars(index(pos)), marked(pos)))) IN
          IF marked(arr) THEN
            iblock(s, irelease(ivar(translate_vars(index(arr)), TRUE)))
          ELSE
            s
          ENDIF,
        newint(n): iassign(rv, inewint(n)),
        newref(n): iassign(rv, inewref(n)),
        release(x, B):
          iblock(irelease(ivar(translate_vars(index(x)), marked(x))),
            translate_statement(B, rv, stypes, dom_types, tD, tA, translate_vars))
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_ivars(A: (pure?), rv: (ivar?), (translate_vars: [nat -> nat]))(i: nat):
        RECURSIVE bool =
      CASES A OF
        variable(j, b): i = vindex(rv) OR i = translate_vars(j),
        constant(n): i = vindex(rv),
        nil: i = vindex(rv),
        application(f, args):
          i = vindex(rv) OR some(LAMBDA x: i = translate_vars(index(x)))(args),
        letexpr(B, C):
          translate_ivars(B, ivar(0, FALSE), shift(translate_vars))(i + 1) OR
          translate_ivars(C, ivar(vindex(rv) + 1, FALSE), newvar(translate_vars))(i + 1),
        ift(x, B, C):
          i = translate_vars(index(x)) OR
            translate_ivars(B, rv, translate_vars)(i) OR
            translate_ivars(C, rv, translate_vars)(i),
        update(target, lhs, rhs):
          i = vindex(rv) OR i = translate_vars(index(target)) OR
            i = translate_vars(index(lhs)) OR i = translate_vars(index(rhs)),
        lookup(arr, pos):
          i = vindex(rv) OR i = translate_vars(index(arr)) OR
            i = translate_vars(index(pos)),
        newint(n): i = vindex(rv),
        newref(n): i = vindex(rv),
        release(x, B):
          i = translate_vars(index(x)) OR translate_ivars(B, rv, translate_vars)(i)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_ivars_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), i):
          vars(translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars))(i) =
            translate_ivars(A, rv, translate_vars)(i)
    AUTO_REWRITE+ translate_ivars_def

    translate_ivars_vars: LEMMA
      FORALL (A: (pure?), rv: (ivar?), translate_vars: [nat -> nat]):
        translate_ivars(A, rv, translate_vars)(i) =
          (i = vindex(rv) OR EXISTS j: vars(A)(j) AND translate_vars(j) = i)

    translate_definitions(D, (tD | defs_well_typed(D, tD))): finseq[ireduction.Definition] =
      (# length := D`length,
         seq := LAMBDA (i: below(D`length)):
           (# arity := D`seq(i)`arity,
              body := translate_statement(D`seq(i)`body, ivar(D`seq(i)`arity, FALSE),
                        tD`seq(i)`args_type, (LAMBDA j: 0), tD, tD`seq(i)`body_type,
                        (LAMBDA j: j))
            #)
       #)

    translate_length(A: (pure?)): RECURSIVE posnat =
      CASES A OF
        variable(j, b): 1,
        constant(n): 1,
        nil: 1,
        application(f, args): 1,
        letexpr(B, C):
          3 + translate_length(B) + translate_length(C),
        ift(x, B, C):
          1 + translate_length(B) + translate_length(C),
        update(target, lhs, rhs): 1,
        lookup(arr, pos):
          IF marked(arr) THEN 2 ELSE 1 ENDIF,
        newint(n): 1,
        newref(n): 1,
        release(x, B): 1 + translate_length(B)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_length_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat])):
      slength(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars)) =
        translate_length(A)
    AUTO_REWRITE+ translate_length_def

    % translate_extract(A: (pure?), rv: (ivar?),
    %   (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
    %   dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
    %   (translate_vars: [nat -> nat])(pc: below(translate_length(A))):
    %     RECURSIVE {(s, j) | j < slength(s) AND executable_stat?(s, j)} =
    %   CASES A OF
    %     letexpr(B, C):
    %       IF pc = 0 THEN
    %         (translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars), 0)
    %       ELSIF pc < 1 + translate_length(B) THEN
    %         translate_extract(B, ivar(0, FALSE), stypes, dom_types, tD, lrhs(tA), shift(translate_vars))(pc - 1)
    %       ELSIF pc = 1 + translate_length(B) THEN
    %         (iskip, 0)
    %       ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
    %         translate_extract(C, ivar(vindex(rv) + 1, FALSE), add(lettype(tA), stypes),
    %                             dom_types, tD, lbody(tA), newvar(translate_vars))
    %                          (pc - 2 - translate_length(C))
    %       ELSE
    %         (translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars), 0)
    %       ENDIF,

    translate_stack_size_at(A: (pure?), pc: upto(translate_length(A))): RECURSIVE nat =
      CASES A OF
        variable(j, b): 0,
        constant(n): 0,
        nil: 0,
        application(f, args): 0,
        letexpr(B, C):
          IF pc = 0 THEN
            0
          ELSIF pc <= 1+translate_length(B) THEN
            1 + translate_stack_size_at(B, pc - 1)
          ELSIF pc <= 2+translate_length(B) + translate_length(C) THEN
            1 + translate_stack_size_at(C, pc - 2 - translate_length(B))
          ELSE
            0
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            0
          ELSIF pc <= 1 + translate_length(B) THEN
            translate_stack_size_at(B, pc - 1)
          ELSE
            translate_stack_size_at(C, pc - 1 - translate_length(B))
          ENDIF,
        update(target, lhs, rhs): 0,
        lookup(arr, pos): 0,
        newint(n): 0,
        newref(n): 0,
        release(x, B): IF pc = 0 THEN 0 ELSE translate_stack_size_at(B, pc - 1) ENDIF
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_stack_size_at_zero: LEMMA
      FORALL (A: (pure?)): translate_stack_size_at(A, 0) = 0
    AUTO_REWRITE+ translate_stack_size_at_zero
    translate_stack_size_at_end: LEMMA
      FORALL (A: (pure?)): translate_stack_size_at(A, translate_length(A)) = 0
    AUTO_REWRITE+ translate_stack_size_at_end

    translate_stack_size_at_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: upto(translate_length(A))):
      stack_size_at(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc) =
        translate_stack_size_at(A, pc)
    AUTO_REWRITE+ translate_stack_size_at_def

    translate_is_fun_call_at(A: (pure?), (pc: upto(translate_length(A))), f: nat):
        RECURSIVE bool =
      CASES A OF
        application(f2, args): pc = 0 AND f = f2,
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1+translate_length(B) THEN
            translate_is_fun_call_at(B, pc - 1, f)
          ELSIF pc = 1+translate_length(B) THEN
            FALSE
          ELSIF pc <= 2+translate_length(B) + translate_length(C) THEN
            translate_is_fun_call_at(C, pc - 2 - translate_length(B), f)
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_is_fun_call_at(B, pc - 1, f)
          ELSE
            translate_is_fun_call_at(C, pc - 1 - translate_length(B), f)
          ENDIF,
        release(x, B): pc > 0 AND translate_is_fun_call_at(B, pc - 1, f)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_is_fun_call_at_end: LEMMA
      FORALL (A: (pure?)): NOT translate_is_fun_call_at(A, translate_length(A), k)

    translate_is_fun_call_at_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: upto(translate_length(A)), f: nat):
      is_fun_call_at(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc, f) =
        translate_is_fun_call_at(A, pc, f)
    AUTO_REWRITE+ translate_is_fun_call_at_def

    translate_next_pc(A: (pure?), pc: below(translate_length(A))):
        RECURSIVE upto(translate_length(A)) =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            1
          ELSIF pc < 1+translate_length(B) THEN
            1 + translate_next_pc(B, pc - 1)
          ELSIF pc = 1+translate_length(B) THEN
            2 + translate_length(B)
          ELSIF pc < 2+translate_length(B) + translate_length(C) THEN
            2 + translate_length(B) + translate_next_pc(C, pc - 2 - translate_length(B))
          ELSE
            translate_length(A)
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            1
          ELSIF pc < 1 + translate_length(B) THEN
            IF translate_next_pc(B, pc - 1) < translate_length(B) THEN
              1 + translate_next_pc(B, pc - 1)
            ELSE
              translate_length(A)
            ENDIF
          ELSE
            1 + translate_length(B) + translate_next_pc(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B): IF pc = 0 THEN 1 ELSE 1 + translate_next_pc(B, pc - 1) ENDIF
        ELSE pc + 1
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_next_pc_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      next_pc(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc) =
        translate_next_pc(A, pc)
    AUTO_REWRITE+ translate_next_pc
        
    translate_extract_decl_begin(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            TRUE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_begin(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_decl_begin(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_begin(B, pc - 1)
          ELSE
            translate_extract_decl_begin(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_decl_begin(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_decl_end(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_end(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_decl_end(C, pc - 2 - translate_length(B))
          ELSE
            TRUE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_end(B, pc - 1)
          ELSE
            translate_extract_decl_end(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_decl_end(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_decl_begin_decl_end: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_decl_end(A, pc)

    translate_extract_skip(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_skip(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            TRUE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_skip(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_skip(B, pc - 1)
          ELSE
            translate_extract_skip(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_skip(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_decl_begin_skip: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_skip(A, pc)
    translate_extract_decl_end_skip: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES NOT translate_extract_skip(A, pc)

    translate_extract_is_assign(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_is_assign(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_is_assign(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_is_assign(B, pc - 1)
          ELSE
            translate_extract_is_assign(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_is_assign(B, pc - 1)
        ELSE pc = 0
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_decl_begin_is_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_is_assign(A, pc)
    translate_extract_decl_end_is_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES NOT translate_extract_is_assign(A, pc)
    translate_extract_skip_is_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_skip(A, pc) IMPLIES NOT translate_extract_is_assign(A, pc)

    translate_extract_assign(A: (pure?), rv: (ivar?), (translate_vars: [nat -> nat]),
      (pc: below(translate_length(A)) | translate_extract_is_assign(A, pc))):
        RECURSIVE (iassign?) =
      CASES A OF
        letexpr(B, C):
          IF pc < 1 + translate_length(B) THEN
            translate_extract_assign(B, ivar(0, FALSE), shift(translate_vars), pc - 1)
          ELSE
            translate_extract_assign(C, ivar(vindex(rv) + 1, FALSE),
              newvar(translate_vars), pc - 2 - translate_length(B))
          ENDIF,
        ift(x, B, C):
          IF pc < 1 + translate_length(B) THEN
            translate_extract_assign(B, rv, translate_vars, pc - 1)
          ELSE
            translate_extract_assign(C, rv, translate_vars, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          translate_extract_assign(B, rv, translate_vars, pc - 1),
        variable(j, b): iassign(rv, ivar(translate_vars(j), b)),
        constant(n): iassign(rv, iconstant(n)),
        nil: iassign(rv, inil),
        application(f, args):
          iassign(rv, icall(f, map(LAMBDA x: ivar(translate_vars(index(x)), marked(x)))(args))),
        update(target, lhs, rhs):
          iassign(rv, iupdate(ivar(translate_vars(index(target)), marked(target)),
                              ivar(translate_vars(index(lhs)), marked(lhs)),
                              ivar(translate_vars(index(rhs)), marked(rhs)))),
        lookup(arr, pos):
          iassign(rv, ilookup(ivar(translate_vars(index(arr)), FALSE),
                                      ivar(translate_vars(index(pos)), marked(pos)))),
        newint(n): iassign(rv, inewint(n)),
        newref(n): iassign(rv, inewref(n))
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    ival_to_val(v: ivalue): IExpression =
      CASES v OF
        vref(u): ref(u),
        vint(n): constant(n),
        vnil: nil,
        vundef: variable(0,FALSE) % Certainly not a value
      ENDCASES

    val_to_ival(v: (value?)): ivalue =
      CASES v OF
        ref(u): vref(u),
        constant(n): vint(n),
        nil: vnil
      ENDCASES

    reconstruct_state(A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                      (pc: below(translate_length(A))),
                      (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)
    ): RECURSIVE [IExpression, IContext, [nat -> nat]] =
      CASES A OF
        letexpr(B, C):
          LET lb1 = translate_length(B) IN
          LET lb2 = 1 IN
          LET lb3 = translate_length(C) IN
          IF pc = 0 THEN
            (A, hole, translate_vars)
          ELSIF pc < 1+lb1 THEN
            LET (nA, nK, tv) = reconstruct_state(B,shift(translate_vars),S,
                                                 pc-1,ivar(0, FALSE)) IN
            (nA, letc(nK, C), tv)
          ELSIF pc < 1+lb1+lb2 THEN
            (letexpr(ival_to_val(endi(S, 0)), C), hole, shift(translate_vars))
          ELSIF pc < 1+lb1+lb2+lb3 THEN
            LET (nA, nK, tv) = reconstruct_state(C,newvar(translate_vars),S,
                                     pc-1-lb1-lb2,ivar(vindex(rv)+1, FALSE)) IN
            (nA, popc(nK), tv)
          ELSE
            (pop(ival_to_val(endi(S, vindex(rv) + 1))), hole, newvar(translate_vars))
          ENDIF,
        ift(x, B, C):
          LET lb1 = translate_length(B) IN
          IF pc = 0 THEN
            (A, hole, translate_vars)
          ELSIF pc < 1 + lb1 THEN
            reconstruct_state(B,translate_vars,S,pc-1,rv)
          ELSE
            reconstruct_state(C,translate_vars,S,pc-1-lb1,rv)
          ENDIF,
        lookup(x, y):
          IF pc = 0 THEN
            (A,hole,translate_vars)
          ELSE
            (release(x, ival_to_val(endi(S, vindex(rv)))), hole, translate_vars)
          ENDIF,
        release(x, B):
          IF pc = 0 THEN
            (A, hole, translate_vars)
          ELSE
            reconstruct_state(B,translate_vars,S,pc-1,rv)
          ENDIF
        ELSE (A, hole, translate_vars)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    reconstruct_state_tv_high: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        j >= popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) + popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1) IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`3(j) =
            translate_vars(j - popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) - popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1)) + translate_stack_size_at(A, pc)

    reconstruct_state_tv_low: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        j < popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) + popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1)
          IMPLIES
            reconstruct_state(A, translate_vars, S, pc, rv)`3(j) <
              translate_stack_size_at(A, pc)

    reconstruct_state_popDepth: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1) <= 1

    translate_stack_size_at_next_pc: LEMMA
      FORALL (A: (pure?), (pc: below(translate_length(A)))):
        NOT translate_extract_decl_begin(A, pc) AND NOT translate_extract_decl_end(A, pc)
        AND NOT translate_extract_skip(A, pc)
        IMPLIES translate_stack_size_at(A, translate_next_pc(A, pc)) = translate_stack_size_at(A, pc)

    reconstruct_state_zero: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (rv: (ivar?) | vindex(rv) < S`length)):
        reconstruct_state(A, translate_vars, S, 0, rv) = (A, hole, translate_vars)
    AUTO_REWRITE+ reconstruct_state_zero

    reconstruct_state_tv_next_pc_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        NOT translate_extract_decl_begin(A, pc) AND NOT translate_extract_decl_end(A, pc)
        AND NOT translate_extract_skip(A, pc)
        AND translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`3 =
            translate_vars

    reconstruct_state_tv_next_pc: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack), (S2 : ireduction.Stack | S2`length = S`length),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        NOT translate_extract_decl_begin(A, pc) AND NOT translate_extract_decl_end(A, pc)
        AND NOT translate_extract_skip(A, pc)
        AND translate_next_pc(A, pc) < translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, translate_next_pc(A, pc), rv)`3 =
            reconstruct_state(A, translate_vars, S2, pc, rv)`3

    avar_assign_vindex_bound: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (rv: (ivar?)),
              (pc: below(translate_length(A)))):
        translate_extract_is_assign(A, pc)
        IMPLIES
          vindex(avar(translate_extract_assign(A, rv, translate_vars, pc))) <=
            vindex(rv) + translate_stack_size_at(A, pc)

    avar_assign_next_pc_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (rv: (ivar?)),
              (pc: below(translate_length(A)))):
        translate_extract_is_assign(A, pc) AND
        translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          avar(translate_extract_assign(A, rv, translate_vars, pc)) = rv

    reconstruct_state_assign_hole_pc_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) AND
        translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`2 = hole

    reconstruct_state_ctx_stack: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S, S2 : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length AND
                         vindex(rv) + translate_stack_size_at(A, pc) < S2`length)):
        reconstruct_state(A, translate_vars, S, pc, rv)`2 =
          reconstruct_state(A, translate_vars, S2, pc, rv)`2
 

    reconstruct_state_next_pc: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) AND
        NOT ilookup?(aexpr(translate_extract_assign(A, rv, translate_vars, pc))) AND
        translate_next_pc(A, pc) < translate_length(A)
        IMPLIES
          fill(reconstruct_state(A, translate_vars, S, translate_next_pc(A, pc), rv)`2,
            reconstruct_state(A, translate_vars, S, translate_next_pc(A, pc), rv)`1) =
              fill(reconstruct_state(A, translate_vars, S2, pc, rv)`2,
                ival_to_val(endi(S, vindex(avar(translate_extract_assign(A, rv, translate_vars, pc))))))

    npopcs(n: nat, K): RECURSIVE IContext =
      IF n = 0 THEN K ELSE popc(npopcs(n - 1, K)) ENDIF
    MEASURE n

    npopcs_popDepth: LEMMA
      popDepth(npopcs(k, K)) = k + popDepth(K)

    npopcs_fill: LEMMA
      fill(npopcs(k, K), A) = npops(k, fill(K, A))

    npops_end: LEMMA
      npops(k, pop(A)) = npops(k + 1, A)

    fct_reconstruct_state(A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: upto(translate_length(A)) |
          pc = translate_length(A) OR translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        [IExpression, IContext, [nat -> nat]] =
      IF pc = translate_length(A) THEN
        IF fdepth = 1 THEN
          (ival_to_val(endi(S, fdepth - 1)), hole, LAMBDA j: j)
        ELSE
          (pop(ival_to_val(endi(S, fdepth - 1))), npopcs(fdepth - 2, hole), LAMBDA j: j)
        ENDIF
      ELSE
        LET (B, K, tv) = reconstruct_state(A, (LAMBDA j: j), S, pc, ivar(arity, FALSE)) IN
        (B, npopcs(arity, K), tv)
      ENDIF

    fct_reconstruct_state_tv: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: upto(translate_length(A)) |
          pc = translate_length(A) OR translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
          j < popDepth(fct_reconstruct_state(A, S, arity, fdepth, pc)`2) + popDepth(fct_reconstruct_state(A, S, arity, fdepth, pc)`1) IMPLIES
            fct_reconstruct_state(A, S, arity, fdepth, pc)`3(j) < fdepth

    fct_reconstruct_state_tv_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
          (S2 : ireduction.Stack | S2`length = S`length),
          (arity : nat), (fdepth : posnat | fdepth <= S`length),
          (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        NOT translate_extract_decl_begin(A, pc) AND
        NOT translate_extract_decl_end(A, pc) AND
        NOT translate_extract_skip(A, pc)
        IMPLIES
          fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`3 =
            fct_reconstruct_state(A, S2, arity, fdepth, pc)`3

    fct_reconstruct_state_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
          (S2 : ireduction.Stack | S2`length = S`length),
          (arity : nat), (fdepth : posnat | fdepth <= S`length),
          (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_is_assign(A, pc) AND
        NOT ilookup?(aexpr(translate_extract_assign(A,
          ivar(arity, FALSE), (LAMBDA j: j), pc)))
        IMPLIES
          fill(fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`2,
            fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`1) =
              fill(fct_reconstruct_state(A, S2, arity, fdepth, pc)`2,
                ival_to_val(endi(S, vindex(avar(translate_extract_assign(A,
                  ivar(arity, FALSE), (LAMBDA j: j), pc))))))

    call_reconstruct_state(A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))
    ): RECURSIVE [IContext, [nat -> nat]] =
      CASES A OF
        letexpr(B, C):
          LET lb1 = translate_length(B) IN
          IF pc < 1+lb1 THEN
            LET (nK, tv) = call_reconstruct_state(B,shift(translate_vars),f,pc-1) IN
            (letc(nK, C), tv)
          ELSE
            LET (nK, tv) = call_reconstruct_state(C,newvar(translate_vars),f,pc-2-lb1) IN
            (popc(nK), tv)
          ENDIF,
        ift(x, B, C):
          LET lb1 = translate_length(B) IN
          IF pc < 1 + lb1 THEN
            call_reconstruct_state(B,translate_vars,f,pc-1)
          ELSE
            call_reconstruct_state(C,translate_vars,f,pc-1-lb1)
          ENDIF,
        release(x, B):
          call_reconstruct_state(B,translate_vars,f,pc-1),
        application(f, args):
          (hole, translate_vars)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    call_reconstruct_state_tv_high: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))):
        j >= popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1) IMPLIES
          call_reconstruct_state(A, translate_vars, f, pc)`2(j) =
            translate_vars(j - popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1)) + translate_stack_size_at(A, pc)

    call_reconstruct_state_tv_low: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))):
        j < popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1) IMPLIES
          call_reconstruct_state(A, translate_vars, f, pc)`2(j) <
            translate_stack_size_at(A, pc)

    compose_all(l: finseq[IContext]): RECURSIVE IContext =
      IF l`length = 0 THEN
        hole
      ELSE
        compose(compose_all(pop(l)), endi(l, 0))
      ENDIF
    MEASURE l`length

    compose_popDepth: LEMMA
      popDepth(compose(K1, K2)) = popDepth(K1) + popDepth(K2)

    pop_add[T: TYPE]: LEMMA
      FORALL (l: finseq[T], x: T):
        pop(add(x, l)) = l
    AUTO_REWRITE+ pop_add

    sum[T: TYPE](f: [T -> nat], l: finseq[T]): nat =
      Sigma((LAMBDA i: i < l`length), (LAMBDA i: IF i < l`length THEN f(l`seq(i)) ELSE 0 ENDIF))

    sum_pop[T: TYPE]: LEMMA
      FORALL (f: [T -> nat], l: finseq[T]):
        l`length > 0 IMPLIES sum(f, l) = f(endi(l, 0)) + sum(f, pop(l))

    sum_add[T: TYPE]: LEMMA
      FORALL (f: [T -> nat], l: finseq[T], a: T):
        sum(f, add(a, l)) = sum(f, l) + f(a)
    AUTO_REWRITE+ sum_add

    sum_emptyseq[T: TYPE]: LEMMA
      FORALL (f: [T -> nat]):
        sum(f, empty_seq[T]) = 0
    AUTO_REWRITE+ sum_emptyseq

    sum_eq[T1, T2: TYPE]: LEMMA
      FORALL (f1: [T1 -> nat], l1: finseq[T1], f2: [T2 -> nat], l2: finseq[T2]):
        l1`length = l2`length AND
        (FORALL (i: below(l1`length)): f1(l1`seq(i)) = f2(l2`seq(i))) IMPLIES
          sum(f1, l1) = sum(f2, l2)

    sum_map[T: TYPE]: LEMMA
      FORALL (f: [T -> nat], l: finseq[T]):
        sum(f, l) = sum((LAMBDA i: i), (#
          length := l`length, seq := LAMBDA (i: below(l`length)): f(l`seq(i)) #))

    fdepth_sum_sum: LEMMA
      FORALL (D: finseq[ireduction.Definition], C: finseq[stack_frame(D)]):
        fdepth_sum(D)(C) = sum((LAMBDA (cf: stack_frame(D)): cf`fdepth), C)

    istate_stack_length: LEMMA
      iS`stack`length = 1 + sum((LAMBDA (cf: stack_frame(iS`defs)): cf`fdepth), iS`callstack)

    compose_all_popDepth: LEMMA
      FORALL (l: finseq[IContext]):
        popDepth(compose_all(l)) = sum(popDepth, l)

    compose_translate_vars(tv1, tv2: [nat -> nat], pdepth, fdepth: nat)(i) : nat =
      IF i < pdepth THEN
        tv1(i)
      ELSE
        fdepth + tv2(i - pdepth)
      ENDIF

    compose_all_tv(l: finseq[[[nat -> nat], nat, nat]]): RECURSIVE [nat -> nat] =
      IF l`length = 0 THEN
        (LAMBDA j: j)
      ELSE
        LET (tv, p, f) = endi(l, 0) IN
        compose_translate_vars(tv, compose_all_tv(pop(l)), p, f)
      ENDIF
    MEASURE l`length

    compose_all_tv_bound: LEMMA
      FORALL (l: finseq[[[nat -> nat], nat, nat]], k):
        (FORALL (i: below(l`length)):
          FORALL (j: below(l`seq(i)`2)): l`seq(i)`1(j) < l`seq(i)`3) AND
        k < sum((LAMBDA (r: [[nat -> nat], nat, nat]): r`2), l) IMPLIES
          compose_all_tv(l)(k) < sum((LAMBDA (r: [[nat -> nat], nat, nat]): r`3), l)

    store_matches(dom, (str1: [(dom) -> finseq[(value?)]]), (str2: [(dom) -> finseq[ivalue]])): bool =
      FORALL (i: (dom)):
        str1(i)`length = str2(i)`length AND
        FORALL (j: below(str1(i)`length)):
          str2(i)`seq(j) = val_to_ival(str1(i)`seq(j))

    count_matches(dom, (cnt1, cnt2: [(dom) -> int])): bool =
      FORALL (i: (dom)): cnt1(i) = cnt2(i)

    translate_defs_funcall: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)), iS):
        iS`defs = translate_definitions(D, tD) IMPLIES
          FORALL (i | i < iS`callstack`length - 1):
            translate_is_fun_call_at(D`seq(iS`callstack`seq(i)`ffct)`body,
              iS`callstack`seq(i)`fpc, iS`callstack`seq(i + 1)`ffct)

    translate_defs_funcall2: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)), iS):
        iS`defs = translate_definitions(D, tD) IMPLIES
          FORALL (i: below(iS`callstack`length - 1)):
            iS`callstack`seq(i)`fpc <= translate_length(D`seq(iS`callstack`seq(i)`ffct)`body) AND
            translate_is_fun_call_at(D`seq(iS`callstack`seq(i)`ffct)`body,
              iS`callstack`seq(i)`fpc, iS`callstack`seq(i + 1)`ffct)

    extract_call_context(D, (tD | defs_well_typed(D, tD)),
        (iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD))): IContext =
      compose_all((#
        length := iS`callstack`length - 1,
        seq := LAMBDA (i: below(iS`callstack`length - 1)):
          npopcs(D`seq(iS`callstack`seq(i)`ffct)`arity,
            call_reconstruct_state(D`seq(iS`callstack`seq(i)`ffct)`body,
            (LAMBDA j: j), iS`callstack`seq(i + 1)`ffct, iS`callstack`seq(i)`fpc)`1)
      #))

    extract_call_context_eq: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
               (iS, iS2: {iS | iS`callstack`length > 0 AND
                               iS`defs = translate_definitions(D, tD)})):
        pop(iS`callstack) = pop(iS2`callstack) AND
        endi(iS`callstack, 0)`ffct = endi(iS2`callstack, 0)`ffct
        IMPLIES
          extract_call_context(D, tD, iS) = extract_call_context(D, tD, iS2)

    extract_call_tv(D, (tD | defs_well_typed(D, tD)),
        (iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD))): [nat -> nat] =
      compose_all_tv((#
          length := iS`callstack`length - 1,
          seq := LAMBDA (i: below(iS`callstack`length - 1)):
            LET (K2, tv2) = call_reconstruct_state(D`seq(iS`callstack`seq(i)`ffct)`body,
                              (LAMBDA j: j), iS`callstack`seq(i + 1)`ffct,
                              iS`callstack`seq(i)`fpc) IN
            (tv2, popDepth(K2) + D`seq(iS`callstack`seq(i)`ffct)`arity,
                  iS`callstack`seq(i)`fdepth)
      #))

    extract_call_tv_eq: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
               (iS, iS2: {iS | iS`callstack`length > 0 AND
                               iS`defs = translate_definitions(D, tD)})):
        pop(iS`callstack) = pop(iS2`callstack) AND
        endi(iS`callstack, 0)`ffct = endi(iS2`callstack, 0)`ffct
        IMPLIES
          extract_call_tv(D, tD, iS) = extract_call_tv(D, tD, iS2)

    extract_call_tv_bound: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
        (iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD))):
        k < popDepth(extract_call_context(D, tD, iS)) IMPLIES
          extract_call_tv(D, tD, iS)(k) < fdepth_sum(iS`defs)(pop(iS`callstack))

    redex_matches(D, (trS | defs_well_typed(D, trS`def_types)),
      (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)): bool =
      LET fv = endi(iS`callstack, 0) IN
      LET (A, K, tv) = fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                         D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc) IN
      LET K1 = extract_call_context(D, trS`def_types, iS) IN
      LET tv1 = extract_call_tv(D, trS`def_types, iS) IN
      LET tv2 = compose_translate_vars(tv, tv1, popDepth(K) + popDepth(A), fv`fdepth) IN
      fill(compose(K1, K), A) = fill(trS`state`context, trS`state`redex) AND
      FORALL (i: below(popDepth(trS`state`redex) + popDepth(trS`state`context))):
        endi(iS`stack, tv2(i)) = val_to_ival(endi(trS`state`stack, i))

    redex_matches_l: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
        (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)):
        redex_matches(D, trS, iS) =
        (FORALL ((fv: stack_frame(iS`defs)), A, K, K1, (tv, tv1, tv2: [nat -> nat])):
          fv = endi(iS`callstack, 0) AND
          (A, K, tv) = fct_reconstruct_state(D`seq(fv`ffct)`body, iS`stack,
                         D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc) AND
          K1 = extract_call_context(D, trS`def_types, iS) AND
          tv1 = extract_call_tv(D, trS`def_types, iS) AND
          tv2 = compose_translate_vars(tv, tv1, popDepth(K) + popDepth(A), fv`fdepth) IMPLIES
          fill(compose(K1, K), A) = fill(trS`state`context, trS`state`redex) AND
          FORALL (i: below(popDepth(trS`state`redex) + popDepth(trS`state`context))):
            endi(iS`stack, tv2(i)) = val_to_ival(endi(trS`state`stack, i)))

    redex_stillmatch1: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
                 (trS2 | trS2`def_types = trS`def_types),
                 (iS, iS2: {iS | iS`defs = translate_definitions(D, trS`def_types) AND
                            iS`callstack`length > 0}),
                 (fv1, fv2: stack_frame(iS`defs)),
                 (A1, A2: IExpression), (K1, K2, K3: IContext), (tv1, tv2: [nat -> nat])):
        trS`state`context = trS2`state`context AND
        pop(iS`callstack) = pop(iS2`callstack) AND
        fv1 = endi(iS`callstack, 0) AND
        fv2 = endi(iS2`callstack, 0) AND
        fv1`ffct = fv2`ffct AND
        redex_matches(D, trS, iS) AND
        (A1, K1, tv1) = fct_reconstruct_state(D`seq(fv1`ffct)`body, iS`stack,
          D`seq(fv1`ffct)`arity, fv1`fdepth, fv1`fpc) AND
        (A2, K2, tv2) = fct_reconstruct_state(D`seq(fv2`ffct)`body, iS2`stack,
           D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc) AND
        A1 = trS`state`redex AND
        K1 = compose(K2, K3) AND
        fill(K3, trS2`state`redex) = A2 AND
        trS`state`stack`length - popDepth(trS`state`redex) =
          trS2`state`stack`length - popDepth(trS2`state`redex) AND
        (FORALL (i: below(popDepth(A2) + popDepth(K2))):
          endi(iS2`stack, tv2(i)) = val_to_ival(endi(trS2`state`stack, i))) AND
        (FORALL (i: below(iS`stack`length - fv1`fdepth)):
          endi(iS`stack, i + fv1`fdepth) = endi(iS2`stack, i + fv2`fdepth)) AND
        (FORALL (i: below(trS`state`stack`length - popDepth(A1) - popDepth(K1))):
          endi(trS`state`stack, i + popDepth(A1) + popDepth(K1)) =
            endi(trS2`state`stack, i + popDepth(A2) + popDepth(K2)))
        IMPLIES
          redex_matches(D, trS2, iS2)

    fill_fill_eq: LEMMA
      fill(K1, A) = fill(K2, B) IMPLIES
        ((EXISTS K: K1 = compose(K2, K) AND B = fill(K, A)) OR
         (EXISTS K: NOT K = hole AND K2 = compose(K1, K) AND A = fill(K, B)))

    fill_fill_eq2: LEMMA
      fill(K1, A) = fill(K2, B) AND NOT letexpr?(A) AND NOT pop?(A) IMPLIES
        (EXISTS K: K1 = compose(K2, K) AND B = fill(K, A))

    redex_stillmatch_assign: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
                 (trS2 | trS2`def_types = trS`def_types),
                 (iS, iS2: {iS | iS`defs = translate_definitions(D, trS`def_types) AND
                            iS`callstack`length > 0}),
                 (fv1, fv2: stack_frame(iS`defs)),
                 (A1: IExpression), (K1: IContext), (tv1: [nat -> nat])):
        trS`state`context = trS2`state`context AND
        pop(iS`callstack) = pop(iS2`callstack) AND
        fv1 = endi(iS`callstack, 0) AND
        fv2 = endi(iS2`callstack, 0) AND
        fv1`ffct = fv2`ffct AND
        fv1`fpc < translate_length(D`seq(fv1`ffct)`body) AND
        fv2`fpc = translate_next_pc(D`seq(fv1`ffct)`body, fv1`fpc) AND
        fv1`fdepth = fv2`fdepth AND
        translate_extract_is_assign(D`seq(fv1`ffct)`body, fv1`fpc) AND
        NOT ilookup?(aexpr(translate_extract_assign(D`seq(fv1`ffct)`body,
          ivar(D`seq(fv1`ffct)`arity, FALSE), (LAMBDA j: j), fv1`fpc))) AND
        redex_matches(D, trS, iS) AND
        (A1, K1, tv1) = fct_reconstruct_state(D`seq(fv1`ffct)`body, iS`stack,
          D`seq(fv1`ffct)`arity, fv1`fdepth, fv1`fpc) AND
        A1 = trS`state`redex AND
        popDepth(trS`state`redex) = 0 AND popDepth(trS2`state`redex) = 0 AND
        trS`state`stack`length = trS2`state`stack`length AND
        trS2`state`redex = ival_to_val(endi(iS2`stack,
          vindex(avar(translate_extract_assign(D`seq(fv1`ffct)`body,
            ivar(D`seq(fv1`ffct)`arity, FALSE), (LAMBDA j: j), fv1`fpc))))) AND
        (FORALL (i: below(popDepth(K1))):
          endi(iS2`stack, tv1(i)) = val_to_ival(endi(trS2`state`stack, i))) AND
        (FORALL (i: below(iS`stack`length - fv1`fdepth)):
          endi(iS`stack, i + fv1`fdepth) = endi(iS2`stack, i + fv1`fdepth)) AND
        (FORALL (i: below(trS`state`stack`length - popDepth(K1))):
          endi(trS`state`stack, i + popDepth(K1)) =
            endi(trS2`state`stack, i + popDepth(K1)))
        IMPLIES
          redex_matches(D, trS2, iS2)

    state_matches(D, (trS | defs_well_typed(D, trS`def_types)), iS): bool =
      iS`defs = translate_definitions(D, trS`def_types) AND
      iS`domain = trS`state`domain AND
      store_matches(trS`state`domain, trS`state`store, iS`store) AND
      count_matches(trS`state`domain, trS`state`count, iS`count) AND
      IF iS`callstack`length = 0 THEN
        trS`state`context = hole AND
          value?(trS`state`redex) AND
          iS`stack`seq(0) = val_to_ival(trS`state`redex)
      ELSE
        redex_matches(D, trS, iS)
      ENDIF

    pushReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND pushRedex?(iS) IMPLIES
          state_matches(D, trS, pushReduce(iS))

END itranslation
