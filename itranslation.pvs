itranslation: THEORY
  BEGIN

    IMPORTING IExpression, IL, finite_set_theorems, finseq_theorems, reduction, typeinfo, typeinfo_adt, preprocess, rreduction, reduction_props, iareduction, typed_reduction, typed_rreduction, typed_reduction_props, ireduction

    A, B, C: VAR IExpression
    K, K1, K2, K3: VAR IContext
    i, j, k: VAR nat
    x, y, z: VAR (variable?)
    trS, trS1, trS2: VAR typed_rstate
    iS, iS1, iS2: VAR istate
    stypes: VAR finseq[nat]
    dom_types: VAR [nat -> nat]
    tA: VAR typeinfo
    translate_vars: VAR [nat -> nat]
    dom: VAR finite_set[nat]

    Definition: TYPE = [# arity: nat,
                          body: {A |  pure?(A) AND
                                      (FORALL i: vars(A)(i) = (i < arity)) AND
                                      unmark(A) = A}
                       #]

    me(A: (pure?)): (pure?) = mark(emptyset)(A)

    tdef: TYPE = [# return_type: nat, args_type: finseq[nat], body_type: typeinfo #]
    Defs: TYPE = finseq[Definition]

    D: VAR Defs
    tD: VAR finseq[tdef]

    shift(translate_vars)(i) : nat = translate_vars(i) + 1
    newvar(translate_vars)(i) : nat = IF i = 0 THEN 0 ELSE translate_vars(i - 1) + 1 ENDIF

    translate_statement(A: (pure?), rv: (ivar?),
      (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
      dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
      (translate_vars: [nat -> nat])
    ): RECURSIVE istat =
      CASES A OF
        variable(j, b): iassign(rv, ivar(translate_vars(j), b)),
        constant(n): iassign(rv, iconstant(n)),
        nil: iassign(rv, inil),
        application(f, args):
          iassign(rv, icall(f, map(LAMBDA x: ivar(translate_vars(index(x)), marked(x)))(args))),
        letexpr(B, C):
          idecl(lettype(tA), iblock(
            translate_statement(B, ivar(0, FALSE), stypes, dom_types, tD, lrhs(tA), shift(translate_vars)),
            iblock(iskip,
            translate_statement(C, ivar(vindex(rv) + 1, FALSE), add(lettype(tA), stypes),
                                dom_types, tD, lbody(tA), newvar(translate_vars)))))
        ,
        ift(x, B, C):
          iif(ivar(translate_vars(index(x)), marked(x)),
            translate_statement(B, rv, stypes, dom_types, tD, tthen(tA), translate_vars),
            translate_statement(C, rv, stypes, dom_types, tD, telse(tA), translate_vars)),
        update(target, lhs, rhs):
          iassign(rv, iupdate(ivar(translate_vars(index(target)), marked(target)),
                              ivar(translate_vars(index(lhs)), marked(lhs)),
                              ivar(translate_vars(index(rhs)), marked(rhs)))),
        lookup(arr, pos):
          iassign(rv, ilookup(ivar(translate_vars(index(arr)), marked(arr)),
                                      ivar(translate_vars(index(pos)), marked(pos)))),
        newint(n): iassign(rv, inewint(n)),
        newref(n): iassign(rv, inewref(n)),
        release(x, B):
          iblock(irelease(ivar(translate_vars(index(x)), marked(x))),
            translate_statement(B, rv, stypes, dom_types, tD, tA, translate_vars))
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_ivars(A: (pure?), rv: (ivar?), (translate_vars: [nat -> nat]))(i: nat):
        RECURSIVE bool =
      CASES A OF
        variable(j, b): i = vindex(rv) OR i = translate_vars(j),
        constant(n): i = vindex(rv),
        nil: i = vindex(rv),
        application(f, args):
          i = vindex(rv) OR some(LAMBDA x: i = translate_vars(index(x)))(args),
        letexpr(B, C):
          translate_ivars(B, ivar(0, FALSE), shift(translate_vars))(i + 1) OR
          translate_ivars(C, ivar(vindex(rv) + 1, FALSE), newvar(translate_vars))(i + 1),
        ift(x, B, C):
          i = translate_vars(index(x)) OR
            translate_ivars(B, rv, translate_vars)(i) OR
            translate_ivars(C, rv, translate_vars)(i),
        update(target, lhs, rhs):
          i = vindex(rv) OR i = translate_vars(index(target)) OR
            i = translate_vars(index(lhs)) OR i = translate_vars(index(rhs)),
        lookup(arr, pos):
          i = vindex(rv) OR i = translate_vars(index(arr)) OR
            i = translate_vars(index(pos)),
        newint(n): i = vindex(rv),
        newref(n): i = vindex(rv),
        release(x, B):
          i = translate_vars(index(x)) OR translate_ivars(B, rv, translate_vars)(i)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_ivars_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), i):
          vars(translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars))(i) =
            translate_ivars(A, rv, translate_vars)(i)
    AUTO_REWRITE+ translate_ivars_def

    translate_ivars_vars: LEMMA
      FORALL (A: (pure?), rv: (ivar?), translate_vars: [nat -> nat]):
        translate_ivars(A, rv, translate_vars)(i) =
          (i = vindex(rv) OR EXISTS j: vars(A)(j) AND translate_vars(j) = i)

    translate_definitions(D, (tD | defs_well_typed(D, tD))): finseq[ireduction.Definition] =
      (# length := D`length,
         seq := LAMBDA (i: below(D`length)):
           (# arity := D`seq(i)`arity,
              body := translate_statement(me(D`seq(i)`body), ivar(D`seq(i)`arity, FALSE),
                        tD`seq(i)`args_type, (LAMBDA j: 0), tD, tD`seq(i)`body_type,
                        (LAMBDA j: j))
            #)
       #)

    translate_length(A: (pure?)): RECURSIVE posnat =
      CASES A OF
        variable(j, b): 1,
        constant(n): 1,
        nil: 1,
        application(f, args): 1,
        letexpr(B, C):
          3 + translate_length(B) + translate_length(C),
        ift(x, B, C):
          1 + translate_length(B) + translate_length(C),
        update(target, lhs, rhs): 1,
        lookup(arr, pos): 1,
        newint(n): 1,
        newref(n): 1,
        release(x, B): 1 + translate_length(B)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_length_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat])):
      slength(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars)) =
        translate_length(A)
    AUTO_REWRITE+ translate_length_def

    % translate_extract(A: (pure?), rv: (ivar?),
    %   (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
    %   dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
    %   (translate_vars: [nat -> nat])(pc: below(translate_length(A))):
    %     RECURSIVE {(s, j) | j < slength(s) AND executable_stat?(s, j)} =
    %   CASES A OF
    %     letexpr(B, C):
    %       IF pc = 0 THEN
    %         (translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars), 0)
    %       ELSIF pc < 1 + translate_length(B) THEN
    %         translate_extract(B, ivar(0, FALSE), stypes, dom_types, tD, lrhs(tA), shift(translate_vars))(pc - 1)
    %       ELSIF pc = 1 + translate_length(B) THEN
    %         (iskip, 0)
    %       ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
    %         translate_extract(C, ivar(vindex(rv) + 1, FALSE), add(lettype(tA), stypes),
    %                             dom_types, tD, lbody(tA), newvar(translate_vars))
    %                          (pc - 2 - translate_length(C))
    %       ELSE
    %         (translate_statement(A, rv, stypes, dom_types, tD, tA, translate_vars), 0)
    %       ENDIF,

    translate_stack_size_at(A: (pure?), pc: upto(translate_length(A))): RECURSIVE nat =
      CASES A OF
        variable(j, b): 0,
        constant(n): 0,
        nil: 0,
        application(f, args): 0,
        letexpr(B, C):
          IF pc = 0 THEN
            0
          ELSIF pc <= 1+translate_length(B) THEN
            1 + translate_stack_size_at(B, pc - 1)
          ELSIF pc <= 2+translate_length(B) + translate_length(C) THEN
            1 + translate_stack_size_at(C, pc - 2 - translate_length(B))
          ELSE
            0
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            0
          ELSIF pc <= 1 + translate_length(B) THEN
            translate_stack_size_at(B, pc - 1)
          ELSE
            translate_stack_size_at(C, pc - 1 - translate_length(B))
          ENDIF,
        update(target, lhs, rhs): 0,
        lookup(arr, pos): 0,
        newint(n): 0,
        newref(n): 0,
        release(x, B): IF pc = 0 THEN 0 ELSE translate_stack_size_at(B, pc - 1) ENDIF
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_stack_size_at_zero: LEMMA
      FORALL (A: (pure?)): translate_stack_size_at(A, 0) = 0
    AUTO_REWRITE+ translate_stack_size_at_zero
    translate_stack_size_at_end: LEMMA
      FORALL (A: (pure?)): translate_stack_size_at(A, translate_length(A)) = 0
    AUTO_REWRITE+ translate_stack_size_at_end

    translate_stack_size_at_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: upto(translate_length(A))):
      stack_size_at(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc) =
        translate_stack_size_at(A, pc)
    AUTO_REWRITE+ translate_stack_size_at_def

    translate_is_fun_call_at(A: (pure?), (pc: upto(translate_length(A))), f: nat):
        RECURSIVE bool =
      CASES A OF
        application(f2, args): pc = 0 AND f = f2,
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1+translate_length(B) THEN
            translate_is_fun_call_at(B, pc - 1, f)
          ELSIF pc = 1+translate_length(B) THEN
            FALSE
          ELSIF pc <= 2+translate_length(B) + translate_length(C) THEN
            translate_is_fun_call_at(C, pc - 2 - translate_length(B), f)
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_is_fun_call_at(B, pc - 1, f)
          ELSE
            translate_is_fun_call_at(C, pc - 1 - translate_length(B), f)
          ENDIF,
        release(x, B): pc > 0 AND translate_is_fun_call_at(B, pc - 1, f)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_is_fun_call_at_end: LEMMA
      FORALL (A: (pure?)): NOT translate_is_fun_call_at(A, translate_length(A), k)

    translate_is_fun_call_at_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: upto(translate_length(A)), f: nat):
      is_fun_call_at(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc, f) =
        translate_is_fun_call_at(A, pc, f)
    AUTO_REWRITE+ translate_is_fun_call_at_def

    translate_next_pc(A: (pure?), pc: below(translate_length(A))):
        RECURSIVE upto(translate_length(A)) =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            1
          ELSIF pc < 1+translate_length(B) THEN
            1 + translate_next_pc(B, pc - 1)
          ELSIF pc = 1+translate_length(B) THEN
            2 + translate_length(B)
          ELSIF pc < 2+translate_length(B) + translate_length(C) THEN
            2 + translate_length(B) + translate_next_pc(C, pc - 2 - translate_length(B))
          ELSE
            translate_length(A)
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            1
          ELSIF pc < 1 + translate_length(B) THEN
            IF translate_next_pc(B, pc - 1) < translate_length(B) THEN
              1 + translate_next_pc(B, pc - 1)
            ELSE
              translate_length(A)
            ENDIF
          ELSE
            1 + translate_length(B) + translate_next_pc(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B): IF pc = 0 THEN 1 ELSE 1 + translate_next_pc(B, pc - 1) ENDIF
        ELSE pc + 1
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_next_pc_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      next_pc(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc) =
        translate_next_pc(A, pc)
    AUTO_REWRITE+ translate_next_pc
        
    translate_extract_decl_begin(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            TRUE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_begin(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_decl_begin(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_begin(B, pc - 1)
          ELSE
            translate_extract_decl_begin(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_decl_begin(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_decl_begin_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      (idecl?(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) AND
      extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`2 = 0) =
        translate_extract_decl_begin(A, pc)

    translate_extract_decl_end(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_end(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_decl_end(C, pc - 2 - translate_length(B))
          ELSE
            TRUE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_decl_end(B, pc - 1)
          ELSE
            translate_extract_decl_end(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_decl_end(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_decl_end_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      (idecl?(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) AND
      extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`2 =
        slength(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) - 1) =
          translate_extract_decl_end(A, pc)

    translate_extract_decl_begin_decl_end: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_decl_end(A, pc)

    translate_extract_skip(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_skip(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            TRUE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_skip(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_skip(B, pc - 1)
          ELSE
            translate_extract_skip(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_skip(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_skip_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      iskip?(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) =
        translate_extract_skip(A, pc)

    translate_extract_decl_begin_skip: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_skip(A, pc)
    translate_extract_decl_end_skip: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES NOT translate_extract_skip(A, pc)

    translate_extract_is_assign(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_is_assign(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_is_assign(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_is_assign(B, pc - 1)
          ELSE
            translate_extract_is_assign(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_is_assign(B, pc - 1)
        ELSE pc = 0
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_is_assign_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      iassign?(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) =
        translate_extract_is_assign(A, pc)

    translate_extract_decl_begin_is_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_is_assign(A, pc)
    translate_extract_decl_end_is_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES NOT translate_extract_is_assign(A, pc)
    translate_extract_skip_is_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_skip(A, pc) IMPLIES NOT translate_extract_is_assign(A, pc)

    translate_extract_if(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_if(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_if(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            TRUE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_if(B, pc - 1)
          ELSE
            translate_extract_if(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc > 0 AND translate_extract_if(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_if_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      iif?(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) =
        translate_extract_if(A, pc)

    translate_extract_decl_begin_if: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_if(A, pc)
    translate_extract_decl_end_if: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES NOT translate_extract_if(A, pc)
    translate_extract_skip_if: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_skip(A, pc) IMPLIES NOT translate_extract_if(A, pc)
    translate_extract_is_assign_if: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_is_assign(A, pc) IMPLIES NOT translate_extract_if(A, pc)


    translate_extract_assign(A: (pure?), rv: (ivar?), (translate_vars: [nat -> nat]),
      (pc: below(translate_length(A)) | translate_extract_is_assign(A, pc))):
        RECURSIVE (iassign?) =
      CASES A OF
        letexpr(B, C):
          IF pc < 1 + translate_length(B) THEN
            translate_extract_assign(B, ivar(0, FALSE), shift(translate_vars), pc - 1)
          ELSE
            translate_extract_assign(C, ivar(vindex(rv) + 1, FALSE),
              newvar(translate_vars), pc - 2 - translate_length(B))
          ENDIF,
        ift(x, B, C):
          IF pc < 1 + translate_length(B) THEN
            translate_extract_assign(B, rv, translate_vars, pc - 1)
          ELSE
            translate_extract_assign(C, rv, translate_vars, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          translate_extract_assign(B, rv, translate_vars, pc - 1),
        variable(j, b): iassign(rv, ivar(translate_vars(j), b)),
        constant(n): iassign(rv, iconstant(n)),
        nil: iassign(rv, inil),
        application(f, args):
          iassign(rv, icall(f, map(LAMBDA x: ivar(translate_vars(index(x)), marked(x)))(args))),
        update(target, lhs, rhs):
          iassign(rv, iupdate(ivar(translate_vars(index(target)), marked(target)),
                              ivar(translate_vars(index(lhs)), marked(lhs)),
                              ivar(translate_vars(index(rhs)), marked(rhs)))),
        lookup(arr, pos):
          iassign(rv, ilookup(ivar(translate_vars(index(arr)), marked(arr)),
                                      ivar(translate_vars(index(pos)), marked(pos)))),
        newint(n): iassign(rv, inewint(n)),
        newref(n): iassign(rv, inewref(n))
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    ival_to_val(v: ivalue): IExpression =
      CASES v OF
        vref(u): ref(u),
        vint(n): constant(n),
        vnil: nil,
        vundef: variable(0,FALSE) % Certainly not a value
      ENDCASES

    val_to_ival(v: (value?)): ivalue =
      CASES v OF
        ref(u): vref(u),
        constant(n): vint(n),
        nil: vnil
      ENDCASES

    reconstruct_state(A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                      (pc: below(translate_length(A))),
                      (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)
    ): RECURSIVE [IExpression, IContext, [nat -> nat]] =
      CASES A OF
        letexpr(B, C):
          LET lb1 = translate_length(B) IN
          LET lb2 = 1 IN
          LET lb3 = translate_length(C) IN
          IF pc = 0 THEN
            (A, hole, translate_vars)
          ELSIF pc < 1+lb1 THEN
            LET (nA, nK, tv) = reconstruct_state(B,shift(translate_vars),S,
                                                 pc-1,ivar(0, FALSE)) IN
            (nA, letc(nK, C), tv)
          ELSIF pc < 1+lb1+lb2 THEN
            (letexpr(ival_to_val(endi(S, 0)), C), hole, shift(translate_vars))
          ELSIF pc < 1+lb1+lb2+lb3 THEN
            LET (nA, nK, tv) = reconstruct_state(C,newvar(translate_vars),S,
                                     pc-1-lb1-lb2,ivar(vindex(rv)+1, FALSE)) IN
            (nA, popc(nK), tv)
          ELSE
            (pop(ival_to_val(endi(S, vindex(rv) + 1))), hole, newvar(translate_vars))
          ENDIF,
        ift(x, B, C):
          LET lb1 = translate_length(B) IN
          IF pc = 0 THEN
            (A, hole, translate_vars)
          ELSIF pc < 1 + lb1 THEN
            reconstruct_state(B,translate_vars,S,pc-1,rv)
          ELSE
            reconstruct_state(C,translate_vars,S,pc-1-lb1,rv)
          ENDIF,
        release(x, B):
          IF pc = 0 THEN
            (A, hole, translate_vars)
          ELSE
            reconstruct_state(B,translate_vars,S,pc-1,rv)
          ENDIF
        ELSE (A, hole, translate_vars)
      ENDCASES
    MEASURE (A :: IExpression) BY <<


    translate_is_result_defined(A: (pure?), S: ireduction.Stack,
      pc: below(translate_length(A)),
      (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
    RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            TRUE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_is_result_defined(B, S, pc - 1, ivar(0, FALSE))
          ELSIF pc = 1 + translate_length(B) THEN
            NOT vundef?(endi(S, 0))
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_is_result_defined(C, S, pc - 2 - translate_length(B), ivar(vindex(rv) + 1, FALSE))
          ELSE
            NOT vundef?(endi(S, vindex(rv) + 1))
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            TRUE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_is_result_defined(B, S, pc - 1, rv)
          ELSE
            translate_is_result_defined(C, S, pc - 1 - translate_length(B), rv)
          ENDIF,
        release(x, B):
          pc = 0 OR translate_is_result_defined(B, S, pc - 1, rv)
        ELSE
          pc = 0 OR NOT vundef?(endi(S, vindex(rv)))
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    reconstruct_state_tv_high: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        j >= popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) + popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1) IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`3(j) =
            translate_vars(j - popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) - popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1)) + translate_stack_size_at(A, pc)

    reconstruct_state_tv_low: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        j < popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) + popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1)
          IMPLIES
            reconstruct_state(A, translate_vars, S, pc, rv)`3(j) <
              translate_stack_size_at(A, pc)

    reconstruct_state_popDepth: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1) <= 1

    translate_stack_size_at_next_pc: LEMMA
      FORALL (A: (pure?), (pc: below(translate_length(A)))):
        NOT translate_extract_decl_begin(A, pc) AND NOT translate_extract_decl_end(A, pc)
        AND NOT translate_extract_skip(A, pc)
        IMPLIES translate_stack_size_at(A, translate_next_pc(A, pc)) = translate_stack_size_at(A, pc)

    decl_begin_next_pc: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES
          translate_next_pc(A, pc) < translate_length(A)

    translate_stack_size_at_next_pc_decl_begin: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES
          translate_stack_size_at(A, translate_next_pc(A, pc)) =
            translate_stack_size_at(A, pc) + 1

    translate_stack_size_at_next_pc_decl_end: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES
          translate_stack_size_at(A, translate_next_pc(A, pc)) = translate_stack_size_at(A, pc) - 1

    skip_next_pc: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_skip(A, pc) IMPLIES
          translate_next_pc(A, pc) < translate_length(A)    

    translate_stack_size_at_next_pc_skip: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_skip(A, pc) IMPLIES
          translate_stack_size_at(A, translate_next_pc(A, pc)) =
            translate_stack_size_at(A, pc)

    reconstruct_state_zero: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (rv: (ivar?) | vindex(rv) < S`length)):
        reconstruct_state(A, translate_vars, S, 0, rv) = (A, hole, translate_vars)
    AUTO_REWRITE+ reconstruct_state_zero

    reconstruct_state_vars: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_is_result_defined(A, S, pc, rv) AND
        vars(fill(reconstruct_state(A, translate_vars, S, pc, rv)`2,
          reconstruct_state(A, translate_vars, S, pc, rv)`1))(i) IMPLIES
            vars(A)(i)

    reconstruct_state_tv_next_pc_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        NOT translate_extract_decl_begin(A, pc) AND NOT translate_extract_decl_end(A, pc)
        AND NOT translate_extract_skip(A, pc)
        AND translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`3 =
            translate_vars

    reconstruct_state_tv_next_pc: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack), (S2 : ireduction.Stack | S2`length = S`length),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        NOT translate_extract_decl_begin(A, pc) AND NOT translate_extract_decl_end(A, pc)
        AND NOT translate_extract_skip(A, pc)
        AND translate_next_pc(A, pc) < translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, translate_next_pc(A, pc), rv)`3 =
            reconstruct_state(A, translate_vars, S2, pc, rv)`3

    avar_assign_vindex_bound: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (rv: (ivar?)),
              (pc: below(translate_length(A)))):
        translate_extract_is_assign(A, pc)
        IMPLIES
          vindex(avar(translate_extract_assign(A, rv, translate_vars, pc))) <=
            vindex(rv) + translate_stack_size_at(A, pc)

    avar_assign_next_pc_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (rv: (ivar?)),
              (pc: below(translate_length(A)))):
        translate_extract_is_assign(A, pc) AND
        translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          avar(translate_extract_assign(A, rv, translate_vars, pc)) = rv

    translate_is_result_defined_assign_next_pc: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack,
        translate_vars: [nat -> nat],
        pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) AND
        translate_next_pc(A, pc) < translate_length(A) IMPLIES
          translate_is_result_defined(A, S, translate_next_pc(A, pc), rv) =
            NOT vundef?(endi(S,
              vindex(avar(translate_extract_assign(A, rv, translate_vars, pc)))))

    translate_is_result_defined_zero: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack,
        (rv: (ivar?) | vindex(rv) < S`length)):
          translate_is_result_defined(A, S, 0, rv)
    AUTO_REWRITE+ translate_is_result_defined_zero

    translate_is_result_defined_decl_begin_next_pc: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack, pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) + 1 < S`length)):    
        translate_extract_decl_begin(A, pc) IMPLIES
          translate_is_result_defined(A, S, translate_next_pc(A, pc), rv)

    translate_is_result_defined_skip: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack, pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_skip(A, pc) IMPLIES
          translate_is_result_defined(A, S, pc, rv) = NOT vundef?(endi(S, 0))

    translate_is_result_defined_skip_next_pc: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack, pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_skip(A, pc) IMPLIES
          translate_is_result_defined(A, S, translate_next_pc(A, pc), rv)

    translate_is_result_defined_decl_end_overflow: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack, pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):    
        translate_extract_decl_end(A, pc) AND
        translate_next_pc(A, pc) = translate_length(A) IMPLIES
        translate_is_result_defined(A, S, pc, rv) = NOT vundef?(endi(S, vindex(rv) + 1))

    translate_is_result_defined_decl_end_next_pc: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack, pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):    
        translate_extract_decl_end(A, pc) AND
        translate_next_pc(A, pc) < translate_length(A) AND
        translate_is_result_defined(A, S, pc, rv) IMPLIES
          translate_is_result_defined(A, pop(S), translate_next_pc(A, pc), rv)

    reconstruct_state_assign_hole_pc_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) AND
        translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`2 = hole

    reconstruct_state_ctx_stack: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S, S2 : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length AND
                         vindex(rv) + translate_stack_size_at(A, pc) < S2`length)):
        reconstruct_state(A, translate_vars, S, pc, rv)`2 =
          reconstruct_state(A, translate_vars, S2, pc, rv)`2
 
    reconstruct_state_next_pc: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) AND
        translate_next_pc(A, pc) < translate_length(A)
        IMPLIES
          fill(reconstruct_state(A, translate_vars, S, translate_next_pc(A, pc), rv)`2,
            reconstruct_state(A, translate_vars, S, translate_next_pc(A, pc), rv)`1) =
              fill(reconstruct_state(A, translate_vars, S2, pc, rv)`2,
                ival_to_val(endi(S, vindex(avar(translate_extract_assign(A, rv, translate_vars, pc))))))

    reconstruct_state_decl_begin_letexpr: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_decl_begin(A, pc) IMPLIES
          letexpr?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_next_pc_decl_begin: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length + 1),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_decl_begin(A, pc)
        IMPLIES
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`1 =
            letrhs(reconstruct_state(A, translate_vars, S, pc, rv)`1) AND
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`2 =
            compose(reconstruct_state(A, translate_vars, S, pc, rv)`2,
              letc(hole, body(reconstruct_state(A, translate_vars, S, pc, rv)`1))) AND
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`3 =
            shift(reconstruct_state(A, translate_vars, S, pc, rv)`3)

    reconstruct_state_skip_letexpr: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_skip(A, pc) IMPLIES
          letexpr?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_skip_letrhs: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_skip(A, pc) IMPLIES
        letrhs(reconstruct_state(A, translate_vars, S, pc, rv)`1) = ival_to_val(endi(S, 0))

    reconstruct_state_skip_pureLetRedex: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_skip(A, pc) AND translate_is_result_defined(A, S, pc, rv)
        IMPLIES
          pureLetRedex?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_next_pc_skip: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_skip(A, pc)
        IMPLIES
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`1 =
            body(reconstruct_state(A, translate_vars, S, pc, rv)`1) AND
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`2 =
            compose(reconstruct_state(A, translate_vars, S, pc, rv)`2, popc(hole)) AND
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`3 =
            (LAMBDA i: IF i = 0 THEN 0 ELSE reconstruct_state(A, translate_vars, S, pc, rv)`3(i - 1) ENDIF)

    reconstruct_state_decl_end_pop: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_decl_end(A, pc) IMPLIES
          pop?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_decl_end_pop_redex: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_decl_end(A, pc) AND
        translate_is_result_defined(A, S, pc, rv) IMPLIES
          popRedex?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_next_pc_decl_end_overflow: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_decl_end(A, pc) AND translate_next_pc(A, pc) = translate_length(A)
        IMPLIES
          reconstruct_state(A, translate_vars, S, pc, rv)`1 =
            pop(ival_to_val(endi(S, vindex(rv) + 1))) AND
          reconstruct_state(A, translate_vars, S, pc, rv)`2 = hole AND
          reconstruct_state(A, translate_vars, S, pc, rv)`3 = newvar(translate_vars)

    reconstruct_state_next_pc_decl_end: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_decl_end(A, pc) AND translate_next_pc(A, pc) < translate_length(A)
        IMPLIES
          fill(reconstruct_state(A, translate_vars, pop(S), translate_next_pc(A, pc), rv)`2,
            reconstruct_state(A, translate_vars, pop(S), translate_next_pc(A, pc), rv)`1) =
              fill(reconstruct_state(A, translate_vars, S, pc, rv)`2,
                pbody(reconstruct_state(A, translate_vars, S, pc, rv)`1)) AND
          reconstruct_state(A, translate_vars, pop(S), translate_next_pc(A, pc), rv)`3 =
            LAMBDA i: reconstruct_state(A, translate_vars, S, pc, rv)`3(i + 1) - 1

    npopcs(n: nat, K): RECURSIVE IContext =
      IF n = 0 THEN K ELSE popc(npopcs(n - 1, K)) ENDIF
    MEASURE n

    npopcs_popDepth: LEMMA
      popDepth(npopcs(k, K)) = k + popDepth(K)

    npopcs_fill: LEMMA
      fill(npopcs(k, K), A) = npops(k, fill(K, A))

    npopcs_compose: LEMMA
      compose(npopcs(k, K1), K2) = npopcs(k, compose(K1, K2))

    npops_end: LEMMA
      npops(k, pop(A)) = npops(k + 1, A)

    fct_reconstruct_state(A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: upto(translate_length(A)) |
          pc = translate_length(A) OR translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        [IExpression, IContext, [nat -> nat]] =
      IF pc = translate_length(A) THEN
        IF fdepth = 1 THEN
          (ival_to_val(endi(S, fdepth - 1)), hole, LAMBDA j: j)
        ELSE
          (pop(ival_to_val(endi(S, fdepth - 1))), npopcs(fdepth - 2, hole), LAMBDA j: j)
        ENDIF
      ELSE
        LET (B, K, tv) = reconstruct_state(A, (LAMBDA j: j), S, pc, ivar(arity, FALSE)) IN
        (B, npopcs(arity, K), tv)
      ENDIF

    fct_is_result_defined(A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: upto(translate_length(A)) |
          pc = translate_length(A) OR translate_stack_size_at(A, pc) + arity + 1 = fdepth)): bool =
      IF pc = translate_length(A) THEN
        NOT vundef?(endi(S, fdepth - 1))
      ELSE
        translate_is_result_defined(A, S, pc, ivar(arity, FALSE))
      ENDIF

    fct_is_result_defined_assign_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_is_assign(A, pc) IMPLIES
        fct_is_result_defined(A, S, arity, fdepth, translate_next_pc(A, pc)) =
          NOT vundef?(endi(S,
            vindex(avar(translate_extract_assign(A, ivar(arity, FALSE), (LAMBDA j: j), pc)))))


    fct_is_result_defined_decl_end_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_decl_end(A, pc) AND
        fct_is_result_defined(A, S, arity, fdepth, pc) IMPLIES
          fct_is_result_defined(A, pop(S), arity, fdepth - 1, translate_next_pc(A, pc))

    fct_reconstruct_state_tv: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: upto(translate_length(A)) |
          pc = translate_length(A) OR translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
          j < popDepth(fct_reconstruct_state(A, S, arity, fdepth, pc)`2) + popDepth(fct_reconstruct_state(A, S, arity, fdepth, pc)`1) IMPLIES
            fct_reconstruct_state(A, S, arity, fdepth, pc)`3(j) < fdepth

    fct_reconstruct_state_tv_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
          (S2 : ireduction.Stack | S2`length = S`length),
          (arity : nat), (fdepth : posnat | fdepth <= S`length),
          (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        NOT translate_extract_decl_begin(A, pc) AND
        NOT translate_extract_decl_end(A, pc) AND
        NOT translate_extract_skip(A, pc)
        IMPLIES
          fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`3 =
            fct_reconstruct_state(A, S2, arity, fdepth, pc)`3

    fct_reconstruct_state_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
          (S2 : ireduction.Stack | S2`length = S`length),
          (arity : nat), (fdepth : posnat | fdepth <= S`length),
          (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_is_assign(A, pc) IMPLIES
          fill(fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`2,
            fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`1) =
              fill(fct_reconstruct_state(A, S2, arity, fdepth, pc)`2,
                ival_to_val(endi(S, vindex(avar(translate_extract_assign(A,
                  ivar(arity, FALSE), (LAMBDA j: j), pc))))))

    fct_reconstruct_state_next_pc_decl_begin: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length + 1),
                (arity : nat), (fdepth : posnat | fdepth <= S`length),
                (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_decl_begin(A, pc)
        IMPLIES
          fct_reconstruct_state(A, S2, arity, fdepth + 1, translate_next_pc(A, pc))`1 =
            letrhs(fct_reconstruct_state(A, S, arity, fdepth, pc)`1) AND
          fct_reconstruct_state(A, S2, arity, fdepth + 1, translate_next_pc(A, pc))`2 =
            compose(fct_reconstruct_state(A, S, arity, fdepth, pc)`2,
              letc(hole, body(fct_reconstruct_state(A, S, arity, fdepth, pc)`1))) AND
          fct_reconstruct_state(A, S2, arity, fdepth + 1, translate_next_pc(A, pc))`3 =
            shift(fct_reconstruct_state(A, S, arity, fdepth, pc)`3)

    fct_reconstruct_state_next_pc_skip: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length),
                (arity : nat), (fdepth : posnat | fdepth <= S`length),
                (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_skip(A, pc)
        IMPLIES
          fct_reconstruct_state(A, S2, arity, fdepth, translate_next_pc(A, pc))`1 =
            body(fct_reconstruct_state(A, S, arity, fdepth, pc)`1) AND
          fct_reconstruct_state(A, S2, arity, fdepth, translate_next_pc(A, pc))`2 =
            compose(fct_reconstruct_state(A, S, arity, fdepth, pc)`2, popc(hole)) AND
          fct_reconstruct_state(A, S2, arity, fdepth, translate_next_pc(A, pc))`3 =
            (LAMBDA i: IF i = 0 THEN 0 ELSE fct_reconstruct_state(A, S, arity, fdepth, pc)`3(i - 1) ENDIF)

    fct_reconstruct_state_next_pc_decl_end: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (arity: nat), (fdepth : posnat | fdepth <= S`length),
                (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_decl_end(A, pc)
        IMPLIES
          fill(fct_reconstruct_state(A, pop(S), arity, fdepth - 1, translate_next_pc(A, pc))`2,
            fct_reconstruct_state(A, pop(S), arity, fdepth - 1, translate_next_pc(A, pc))`1) =
              fill(fct_reconstruct_state(A, S, arity, fdepth, pc)`2,
                pbody(fct_reconstruct_state(A, S, arity, fdepth, pc)`1)) AND
          fct_reconstruct_state(A, pop(S), arity, fdepth - 1, translate_next_pc(A, pc))`3 =
            LAMBDA i: fct_reconstruct_state(A, S, arity, fdepth, pc)`3(i + 1) - 1

    call_reconstruct_state(A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))
    ): RECURSIVE [IContext, [nat -> nat]] =
      CASES A OF
        letexpr(B, C):
          LET lb1 = translate_length(B) IN
          IF pc < 1+lb1 THEN
            LET (nK, tv) = call_reconstruct_state(B,shift(translate_vars),f,pc-1) IN
            (letc(nK, C), tv)
          ELSE
            LET (nK, tv) = call_reconstruct_state(C,newvar(translate_vars),f,pc-2-lb1) IN
            (popc(nK), tv)
          ENDIF,
        ift(x, B, C):
          LET lb1 = translate_length(B) IN
          IF pc < 1 + lb1 THEN
            call_reconstruct_state(B,translate_vars,f,pc-1)
          ELSE
            call_reconstruct_state(C,translate_vars,f,pc-1-lb1)
          ENDIF,
        release(x, B):
          call_reconstruct_state(B,translate_vars,f,pc-1),
        application(f, args):
          (hole, translate_vars)
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    call_reconstruct_state_tv_high: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))):
        j >= popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1) IMPLIES
          call_reconstruct_state(A, translate_vars, f, pc)`2(j) =
            translate_vars(j - popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1)) + translate_stack_size_at(A, pc)

    call_reconstruct_state_tv_low: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))):
        j < popDepth(call_reconstruct_state(A, translate_vars, f, pc)`1) IMPLIES
          call_reconstruct_state(A, translate_vars, f, pc)`2(j) <
            translate_stack_size_at(A, pc)

    compose_all(l: finseq[IContext]): RECURSIVE IContext =
      IF l`length = 0 THEN
        hole
      ELSE
        compose(compose_all(pop(l)), endi(l, 0))
      ENDIF
    MEASURE l`length

    compose_popDepth: LEMMA
      popDepth(compose(K1, K2)) = popDepth(K1) + popDepth(K2)

    pop_add[T: TYPE]: LEMMA
      FORALL (l: finseq[T], x: T):
        pop(add(x, l)) = l
    AUTO_REWRITE+ pop_add

    sum[T: TYPE](f: [T -> nat], l: finseq[T]): nat =
      Sigma((LAMBDA i: i < l`length), (LAMBDA i: IF i < l`length THEN f(l`seq(i)) ELSE 0 ENDIF))

    sum_pop[T: TYPE]: LEMMA
      FORALL (f: [T -> nat], l: finseq[T]):
        l`length > 0 IMPLIES sum(f, l) = f(endi(l, 0)) + sum(f, pop(l))

    sum_add[T: TYPE]: LEMMA
      FORALL (f: [T -> nat], l: finseq[T], a: T):
        sum(f, add(a, l)) = sum(f, l) + f(a)
    AUTO_REWRITE+ sum_add

    sum_emptyseq[T: TYPE]: LEMMA
      FORALL (f: [T -> nat]):
        sum(f, empty_seq[T]) = 0
    AUTO_REWRITE+ sum_emptyseq

    sum_eq[T1, T2: TYPE]: LEMMA
      FORALL (f1: [T1 -> nat], l1: finseq[T1], f2: [T2 -> nat], l2: finseq[T2]):
        l1`length = l2`length AND
        (FORALL (i: below(l1`length)): f1(l1`seq(i)) = f2(l2`seq(i))) IMPLIES
          sum(f1, l1) = sum(f2, l2)

    sum_map[T: TYPE]: LEMMA
      FORALL (f: [T -> nat], l: finseq[T]):
        sum(f, l) = sum((LAMBDA i: i), (#
          length := l`length, seq := LAMBDA (i: below(l`length)): f(l`seq(i)) #))

    fdepth_sum_sum: LEMMA
      FORALL (D: finseq[ireduction.Definition], C: finseq[stack_frame(D)]):
        fdepth_sum(D)(C) = sum((LAMBDA (cf: stack_frame(D)): cf`fdepth), C)

    istate_stack_length: LEMMA
      iS`stack`length = 1 + sum((LAMBDA (cf: stack_frame(iS`defs)): cf`fdepth), iS`callstack)

    compose_all_popDepth: LEMMA
      FORALL (l: finseq[IContext]):
        popDepth(compose_all(l)) = sum(popDepth, l)

    compose_translate_vars(tv1, tv2: [nat -> nat], pdepth, fdepth: nat)(i) : nat =
      IF i < pdepth THEN
        tv1(i)
      ELSE
        fdepth + tv2(i - pdepth)
      ENDIF

    compose_all_tv(l: finseq[[[nat -> nat], nat, nat]]): RECURSIVE [nat -> nat] =
      IF l`length = 0 THEN
        (LAMBDA j: j)
      ELSE
        LET (tv, p, f) = endi(l, 0) IN
        compose_translate_vars(tv, compose_all_tv(pop(l)), p, f)
      ENDIF
    MEASURE l`length

    compose_all_tv_bound: LEMMA
      FORALL (l: finseq[[[nat -> nat], nat, nat]], k):
        (FORALL (i: below(l`length)):
          FORALL (j: below(l`seq(i)`2)): l`seq(i)`1(j) < l`seq(i)`3) AND
        k < sum((LAMBDA (r: [[nat -> nat], nat, nat]): r`2), l) IMPLIES
          compose_all_tv(l)(k) < sum((LAMBDA (r: [[nat -> nat], nat, nat]): r`3), l)

    store_matches(dom, (str1: [(dom) -> finseq[(value?)]]), (str2: [(dom) -> finseq[ivalue]])): bool =
      FORALL (i: (dom)):
        str1(i)`length = str2(i)`length AND
        FORALL (j: below(str1(i)`length)):
          str2(i)`seq(j) = val_to_ival(str1(i)`seq(j))

    count_matches(dom, (cnt1, cnt2: [(dom) -> int])): bool =
      FORALL (i: (dom)): cnt1(i) = cnt2(i)

    translate_defs_funcall: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)), iS):
        iS`defs = translate_definitions(D, tD) IMPLIES
          FORALL (i | i < iS`callstack`length - 1):
            translate_is_fun_call_at(me(D`seq(iS`callstack`seq(i)`ffct)`body),
              iS`callstack`seq(i)`fpc, iS`callstack`seq(i + 1)`ffct)

    translate_defs_funcall2: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)), iS):
        iS`defs = translate_definitions(D, tD) IMPLIES
          FORALL (i: below(iS`callstack`length - 1)):
            iS`callstack`seq(i)`fpc <= translate_length(me(D`seq(iS`callstack`seq(i)`ffct)`body)) AND
            translate_is_fun_call_at(me(D`seq(iS`callstack`seq(i)`ffct)`body),
              iS`callstack`seq(i)`fpc, iS`callstack`seq(i + 1)`ffct)

    extract_call_context(D, (tD | defs_well_typed(D, tD)),
        (iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD))): IContext =
      compose_all((#
        length := iS`callstack`length - 1,
        seq := LAMBDA (i: below(iS`callstack`length - 1)):
          npopcs(D`seq(iS`callstack`seq(i)`ffct)`arity,
            call_reconstruct_state(me(D`seq(iS`callstack`seq(i)`ffct)`body),
            (LAMBDA j: j), iS`callstack`seq(i + 1)`ffct, iS`callstack`seq(i)`fpc)`1)
      #))

    extract_call_context_eq: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
               (iS, iS2: {iS | iS`callstack`length > 0 AND
                               iS`defs = translate_definitions(D, tD)})):
        pop(iS`callstack) = pop(iS2`callstack) AND
        endi(iS`callstack, 0)`ffct = endi(iS2`callstack, 0)`ffct
        IMPLIES
          extract_call_context(D, tD, iS) = extract_call_context(D, tD, iS2)

    extract_call_tv(D, (tD | defs_well_typed(D, tD)),
        (iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD))): [nat -> nat] =
      compose_all_tv((#
          length := iS`callstack`length - 1,
          seq := LAMBDA (i: below(iS`callstack`length - 1)):
            LET (K2, tv2) = call_reconstruct_state(me(D`seq(iS`callstack`seq(i)`ffct)`body),
                              (LAMBDA j: j), iS`callstack`seq(i + 1)`ffct,
                              iS`callstack`seq(i)`fpc) IN
            (tv2, popDepth(K2) + D`seq(iS`callstack`seq(i)`ffct)`arity,
                  iS`callstack`seq(i)`fdepth)
      #))

    extract_call_tv_eq: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
               (iS, iS2: {iS | iS`callstack`length > 0 AND
                               iS`defs = translate_definitions(D, tD)})):
        pop(iS`callstack) = pop(iS2`callstack) AND
        endi(iS`callstack, 0)`ffct = endi(iS2`callstack, 0)`ffct
        IMPLIES
          extract_call_tv(D, tD, iS) = extract_call_tv(D, tD, iS2)

    extract_call_tv_bound: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
        (iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD))):
        k < popDepth(extract_call_context(D, tD, iS)) IMPLIES
          extract_call_tv(D, tD, iS)(k) < fdepth_sum(iS`defs)(pop(iS`callstack))

    redex_matches(D, (trS | defs_well_typed(D, trS`def_types)),
      (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)): bool =
      LET fv = endi(iS`callstack, 0) IN
      LET (A, K, tv) = fct_reconstruct_state(me(D`seq(fv`ffct)`body), iS`stack,
                         D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc) IN
      LET K1 = extract_call_context(D, trS`def_types, iS) IN
      LET tv1 = extract_call_tv(D, trS`def_types, iS) IN
      LET tv2 = compose_translate_vars(tv, tv1, popDepth(K) + popDepth(A), fv`fdepth) IN
      fill(compose(K1, K), A) = fill(trS`state`context, trS`state`redex) AND
      (FORALL (i: below(popDepth(trS`state`redex) + popDepth(trS`state`context))):
        endi(iS`stack, tv2(i)) = val_to_ival(endi(trS`state`stack, i))) AND
      fct_is_result_defined(me(D`seq(fv`ffct)`body), iS`stack, D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc)

    redex_matches_l: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
        (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)):
        redex_matches(D, trS, iS) =
        (FORALL ((fv: stack_frame(iS`defs)), A, K, K1, (tv, tv1, tv2: [nat -> nat])):
          fv = endi(iS`callstack, 0) AND
          (A, K, tv) = fct_reconstruct_state(me(D`seq(fv`ffct)`body), iS`stack,
                         D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc) AND
          K1 = extract_call_context(D, trS`def_types, iS) AND
          tv1 = extract_call_tv(D, trS`def_types, iS) AND
          tv2 = compose_translate_vars(tv, tv1, popDepth(K) + popDepth(A), fv`fdepth) IMPLIES
          fill(compose(K1, K), A) = fill(trS`state`context, trS`state`redex) AND
          (FORALL (i: below(popDepth(trS`state`redex) + popDepth(trS`state`context))):
            endi(iS`stack, tv2(i)) = val_to_ival(endi(trS`state`stack, i))) AND
          fct_is_result_defined(me(D`seq(fv`ffct)`body), iS`stack, D`seq(fv`ffct)`arity, fv`fdepth, fv`fpc))

    redex_stillmatch1: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
                 (trS2 | trS2`def_types = trS`def_types),
                 (iS, iS2: {iS | iS`defs = translate_definitions(D, trS`def_types) AND
                            iS`callstack`length > 0}),
                 (fv1, fv2: stack_frame(iS`defs)),
                 (A1, A2: IExpression), (K1, K2, K3: IContext), (tv1, tv2: [nat -> nat])):
        trS`state`context = trS2`state`context AND
        pop(iS`callstack) = pop(iS2`callstack) AND
        fv1 = endi(iS`callstack, 0) AND
        fv2 = endi(iS2`callstack, 0) AND
        fv1`ffct = fv2`ffct AND
        redex_matches(D, trS, iS) AND
        (A1, K1, tv1) = fct_reconstruct_state(me(D`seq(fv1`ffct)`body), iS`stack,
          D`seq(fv1`ffct)`arity, fv1`fdepth, fv1`fpc) AND
        (A2, K2, tv2) = fct_reconstruct_state(me(D`seq(fv2`ffct)`body), iS2`stack,
           D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc) AND
        A1 = trS`state`redex AND
        K1 = compose(K2, K3) AND
        fill(K3, trS2`state`redex) = A2 AND
        trS`state`stack`length - popDepth(trS`state`redex) =
          trS2`state`stack`length - popDepth(trS2`state`redex) AND
        (FORALL (i: below(popDepth(A2) + popDepth(K2))):
          endi(iS2`stack, tv2(i)) = val_to_ival(endi(trS2`state`stack, i))) AND
        (FORALL (i: below(iS`stack`length - fv1`fdepth)):
          endi(iS`stack, i + fv1`fdepth) = endi(iS2`stack, i + fv2`fdepth)) AND
        (FORALL (i: below(trS`state`stack`length - popDepth(A1) - popDepth(K1))):
          endi(trS`state`stack, i + popDepth(A1) + popDepth(K1)) =
            endi(trS2`state`stack, i + popDepth(A2) + popDepth(K2))) AND
        fct_is_result_defined(me(D`seq(fv2`ffct)`body), iS2`stack, D`seq(fv2`ffct)`arity, fv2`fdepth, fv2`fpc)
        IMPLIES
          redex_matches(D, trS2, iS2)

    fill_fill_eq: LEMMA
      fill(K1, A) = fill(K2, B) IMPLIES
        ((EXISTS K: K1 = compose(K2, K) AND B = fill(K, A)) OR
         (EXISTS K: NOT K = hole AND K2 = compose(K1, K) AND A = fill(K, B)))

    fill_fill_eq2: LEMMA
      fill(K1, A) = fill(K2, B) AND NOT letexpr?(A) AND NOT pop?(A) IMPLIES
        (EXISTS K: K1 = compose(K2, K) AND B = fill(K, A))

    redex_stillmatch_assign: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
                 (trS2 | trS2`def_types = trS`def_types),
                 (iS, iS2: {iS | iS`defs = translate_definitions(D, trS`def_types) AND
                            iS`callstack`length > 0}),
                 (fv1, fv2: stack_frame(iS`defs)),
                 (A1: IExpression), (K1: IContext), (tv1: [nat -> nat])):
        trS`state`context = trS2`state`context AND
        pop(iS`callstack) = pop(iS2`callstack) AND
        fv1 = endi(iS`callstack, 0) AND
        fv2 = endi(iS2`callstack, 0) AND
        fv1`ffct = fv2`ffct AND
        fv1`fpc < translate_length(me(D`seq(fv1`ffct)`body)) AND
        fv2`fpc = translate_next_pc(me(D`seq(fv1`ffct)`body), fv1`fpc) AND
        fv1`fdepth = fv2`fdepth AND
        translate_extract_is_assign(me(D`seq(fv1`ffct)`body), fv1`fpc) AND
        redex_matches(D, trS, iS) AND
        (A1, K1, tv1) = fct_reconstruct_state(me(D`seq(fv1`ffct)`body), iS`stack,
          D`seq(fv1`ffct)`arity, fv1`fdepth, fv1`fpc) AND
        A1 = trS`state`redex AND
        popDepth(trS`state`redex) = 0 AND popDepth(trS2`state`redex) = 0 AND
        trS`state`stack`length = trS2`state`stack`length AND
        value?(trS2`state`redex) AND
        trS2`state`redex = ival_to_val(endi(iS2`stack,
          vindex(avar(translate_extract_assign(me(D`seq(fv1`ffct)`body),
            ivar(D`seq(fv1`ffct)`arity, FALSE), (LAMBDA j: j), fv1`fpc))))) AND
        (FORALL (i: below(popDepth(K1))):
          endi(iS2`stack, tv1(i)) = val_to_ival(endi(trS2`state`stack, i))) AND
        (FORALL (i: below(iS`stack`length - fv1`fdepth)):
          endi(iS`stack, i + fv1`fdepth) = endi(iS2`stack, i + fv1`fdepth)) AND
        (FORALL (i: below(trS`state`stack`length - popDepth(K1))):
          endi(trS`state`stack, i + popDepth(K1)) =
            endi(trS2`state`stack, i + popDepth(K1)))
        IMPLIES
          redex_matches(D, trS2, iS2)

    state_matches(D, (trS | defs_well_typed(D, trS`def_types)), iS): bool =
      iS`defs = translate_definitions(D, trS`def_types) AND
      iS`domain = trS`state`domain AND
      store_matches(trS`state`domain, trS`state`store, iS`store) AND
      count_matches(trS`state`domain, trS`state`count, iS`count) AND
      IF iS`callstack`length = 0 THEN
        trS`state`context = hole AND
          value?(trS`state`redex) AND
          iS`stack`seq(0) = val_to_ival(trS`state`redex)
      ELSE
        redex_matches(D, trS, iS)
      ENDIF AND
      iS`error = trS`state`error

    ival_to_val_val_to_ival: LEMMA
      FORALL (u: (value?)):
        ival_to_val(val_to_ival(u)) = u
    AUTO_REWRITE+ ival_to_val_val_to_ival

    ival_to_val_value: LEMMA
      FORALL (u: ivalue):
        NOT vundef?(u) IMPLIES value?(ival_to_val(u))

    ival_to_val_rvalue: LEMMA
      FORALL (u: ivalue):
        value?(ival_to_val(u)) IMPLIES NOT vundef?(u)

    val_to_ival_ival_to_val: LEMMA
      FORALL (u: ivalue):
        NOT vundef?(u) IMPLIES
          val_to_ival(ival_to_val(u)) = u
    AUTO_REWRITE+ val_to_ival_ival_to_val

    redex_matches_fill: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), trS2, (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)):
        trS2`def_types = trS`def_types AND
        fill(trS2`state`context, trS2`state`redex) = fill(trS`state`context, trS`state`redex) AND
        trS2`state`stack = trS`state`stack IMPLIES
          redex_matches(D, trS2, iS) = redex_matches(D, trS, iS)

    state_matches_fill: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), trS2, iS):
        trS2`def_types = trS`def_types AND
        iS`callstack`length > 0 AND
        fill(trS2`state`context, trS2`state`redex) = fill(trS`state`context, trS`state`redex) AND
        trS2`state`domain = trS`state`domain AND
        trS2`state`store = trS`state`store AND
        trS2`state`stack = trS`state`stack AND
        trS2`state`count = trS`state`count AND
        trS2`state`error = trS`state`error IMPLIES
          state_matches(D, trS2, iS) = state_matches(D, trS, iS)

    redex_matches_to_topstate: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)):
        redex_matches(D, typed_to_topstate(trS), iS) = redex_matches(D, trS, iS)

    redex_matches_make_redex: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), (iS | iS`defs = translate_definitions(D, trS`def_types) AND iS`callstack`length > 0)):
        trS`state`context = hole AND NOT value?(trS`state`redex) IMPLIES
          redex_matches(D, make_redex_typed(trS), iS) = redex_matches(D, trS, iS)

    state_matches_to_topstate: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        state_matches(D, typed_to_topstate(trS), iS) = state_matches(D, trS, iS)

    state_matches_make_redex: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        trS`state`context = hole AND NOT value?(trS`state`redex) IMPLIES
          state_matches(D, make_redex_typed(trS), iS) = state_matches(D, trS, iS)

    pushReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND pushRedex?(iS) IMPLIES
          state_matches(D, trS, pushReduce(iS))

    skipRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        skipRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    skipRedex_skip: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        skipRedex?(iS) IMPLIES
          translate_extract_skip(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    skipReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND skipRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), skipReduce(iS))

    popRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        popRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    popRedex_decl_end: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        popRedex?(iS) IMPLIES
          translate_extract_decl_end(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    popReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND popRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), popReduce(iS))

    returnReduce_match1: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND returnRedex?(iS) AND
        endi(iS`callstack, 0)`fdepth > 1
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), returnReduce(iS))      

    returnReduce_match2: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length = 1 AND returnRedex?(iS) AND
        endi(iS`callstack, 0)`fdepth = 1
        IMPLIES
          state_matches(D, trS, returnReduce(iS))

    reconstruct_state_extract_call: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length),
          (f: nat | translate_is_fun_call_at(A, pc, f))):
        reconstruct_state(A, translate_vars, S, pc, rv)`2 =
          call_reconstruct_state(A, translate_vars, f, pc)`1 AND
        reconstruct_state(A, translate_vars, S, pc, rv)`3 =
          call_reconstruct_state(A, translate_vars, f, pc)`2

    translate_extract_assign_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      translate_extract_is_assign(A, pc) IMPLIES
        extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1 =
          translate_extract_assign(A, rv, translate_vars, pc)

    extract_call_context_pop: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
       (iS, iS2: {iS | iS`callstack`length > 0 AND
               iS`defs = translate_definitions(D, tD)})):
        iS`callstack`length > 1 AND
        endi(iS`callstack, 1)`ffct = endi(iS2`callstack, 0)`ffct AND
        pop(iS2`callstack) = pop(pop(iS`callstack)) IMPLIES
          extract_call_context(D, tD, iS) =
            compose(extract_call_context(D, tD, iS2),
              npopcs(D`seq(endi(iS`callstack, 1)`ffct)`arity,
                call_reconstruct_state(me(D`seq(endi(iS`callstack, 1)`ffct)`body),
                  (LAMBDA j: j), endi(iS`callstack, 0)`ffct,
                  endi(iS`callstack, 1)`fpc)`1))

    extract_call_tv_pop: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
        (iS, iS2: {iS | iS`callstack`length > 0 AND
              iS`defs = translate_definitions(D, tD)})):
      iS`callstack`length > 1 AND
      endi(iS`callstack, 1)`ffct = endi(iS2`callstack, 0)`ffct AND
      pop(iS2`callstack) = pop(pop(iS`callstack)) IMPLIES
        extract_call_tv(D, tD, iS) =
            LET (K2, tv2) =
              call_reconstruct_state(me(D`seq(endi(iS`callstack, 1)`ffct)`body),
                (LAMBDA j: j), endi(iS`callstack, 0)`ffct,
                endi(iS`callstack, 1)`fpc) IN
            compose_translate_vars(tv2, extract_call_tv(D, tD, iS2),
              popDepth(K2) + D`seq(endi(iS`callstack, 1)`ffct)`arity,
              endi(iS`callstack, 1)`fdepth)

    translate_is_fun_call_at_assign: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A)), f: nat):
        translate_is_fun_call_at(A, pc, f) IMPLIES
          translate_extract_is_assign(A, pc)

    return_pc_end: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)), iS):
        iS`defs = translate_definitions(D, tD) AND iS`callstack`length > 1 IMPLIES
          endi(iS`callstack, 1)`fpc <
            translate_length(me(D`seq(endi(iS`callstack, 1)`ffct)`body))

    return_pc_assign: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)), iS):
        iS`defs = translate_definitions(D, tD) AND iS`callstack`length > 1 IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 1)`ffct)`body),
            endi(iS`callstack, 1)`fpc)

    reconstruct_state_assign_popDepth: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) IMPLIES
          popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`1) = 0

    avar_assign_vindex_bound2: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]),
                (pc: below(translate_length(A))),
                (rv: (ivar?))):
        translate_extract_is_assign(A, pc) IMPLIES
          vindex(avar(translate_extract_assign(A, rv, translate_vars, pc))) =
            vindex(rv) + translate_stack_size_at(A, pc) OR
          vindex(avar(translate_extract_assign(A, rv, translate_vars, pc))) <
            translate_stack_size_at(A, pc)

    avar_assign_neq: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length),
                (i: nat)):
        translate_extract_is_assign(A, pc) AND
        i < popDepth(reconstruct_state(A, translate_vars, S, pc, rv)`2) IMPLIES
          NOT reconstruct_state(A, translate_vars, S, pc, rv)`3(i) =
            vindex(avar(translate_extract_assign(A, rv, translate_vars, pc)))

    avar_assign_neq_next_pc: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (arity: nat), (fdepth : posnat | fdepth <= S`length),
                (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth),
              (i: nat)):
        translate_extract_is_assign(A, pc) AND
        i < popDepth(fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`1) +
            popDepth(fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`2)
        IMPLIES
        NOT fct_reconstruct_state(A, S, arity, fdepth, translate_next_pc(A, pc))`3(i) =
          vindex(avar(translate_extract_assign(A, ivar(arity, FALSE), (LAMBDA j: j), pc)))

    returnReduce_match3: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 1 AND returnRedex?(iS) AND
        endi(iS`callstack, 0)`fdepth = 1
        IMPLIES
          state_matches(D, trS, returnReduce(iS))

    ifRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        ifRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    ifRedex_if: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        ifRedex?(iS) IMPLIES
          translate_extract_if(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    fct_reconstruct_state_vars_bound: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: upto(translate_length(A)) |
          pc = translate_length(A) OR translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
          fct_is_result_defined(A, S, arity, fdepth, pc) AND
          (FORALL k: vars(A)(k) IMPLIES k < arity) AND
          vars(fct_reconstruct_state(A, S, arity, fdepth, pc)`1)(j) IMPLIES
            j < popDepth(fct_reconstruct_state(A, S, arity, fdepth, pc)`2)

    reconstruct_state_ifRedex: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          iftRedex?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_if_pure: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          pure?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_if_condition: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length),
          (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
          dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD))):
        translate_extract_if(A, pc) IMPLIES
          vindex(icond(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1)) =
            reconstruct_state(A, translate_vars, S, pc, rv)`3
              (index(condition(reconstruct_state(A, translate_vars, S, pc, rv)`1)))

    reconstruct_state_if_length: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length),
          (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
          dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD))):
        translate_extract_if(A, pc) IMPLIES
          slength(iftrue(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1)) =
            translate_length(thenexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1))

    transalte_extract_if_next_pc_no_overflow: LEMMA
      FORALL (A: (pure?), (pc: below(translate_length(A)))):
        translate_extract_if(A, pc) IMPLIES
          pc + 1 < translate_length(A)

    reconstruct_state_if_next_pc_no_overflow: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          pc + translate_length(thenexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1)) + 1
            < translate_length(A)

    translate_stack_size_at_next_pc_iftrue: LEMMA
       FORALL (A: (pure?), (pc: below(translate_length(A)))):
        translate_extract_if(A, pc) IMPLIES
          translate_stack_size_at(A, pc + 1) = translate_stack_size_at(A, pc)

    translate_stack_size_at_next_pc_iffalse: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          translate_stack_size_at(A, pc + 1 +
            translate_length(thenexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1))) =
              translate_stack_size_at(A, pc)

    reconstruct_state_if_next_iftrue: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          reconstruct_state(A, translate_vars, S, pc + 1, rv) =
            (thenexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1),
             reconstruct_state(A, translate_vars, S, pc, rv)`2,
             reconstruct_state(A, translate_vars, S, pc, rv)`3)

    reconstruct_state_if_next_iffalse: LEMMA
       FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          reconstruct_state(A, translate_vars, S, pc + 1 + translate_length(thenexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1)), rv) =
            (elseexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1),
             reconstruct_state(A, translate_vars, S, pc, rv)`2,
             reconstruct_state(A, translate_vars, S, pc, rv)`3)

    fct_reconstruct_state_if_next_iftrue: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_if(A, pc) IMPLIES
          fct_reconstruct_state(A, S, arity, fdepth, pc + 1) =
            (thenexpr(fct_reconstruct_state(A, S, arity, fdepth, pc)`1),
             fct_reconstruct_state(A, S, arity, fdepth, pc)`2,
             fct_reconstruct_state(A, S, arity, fdepth, pc)`3)

    fct_reconstruct_state_if_next_iffalse: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_if(A, pc) IMPLIES
          fct_reconstruct_state(A, S, arity, fdepth, pc + 1 + translate_length(thenexpr(fct_reconstruct_state(A, S, arity, fdepth, pc)`1))) =
            (elseexpr(fct_reconstruct_state(A, S, arity, fdepth, pc)`1),
             fct_reconstruct_state(A, S, arity, fdepth, pc)`2,
             fct_reconstruct_state(A, S, arity, fdepth, pc)`3)

    ifRedex_condition_bound: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        fct_is_result_defined(me(D`seq(endi(iS`callstack, 0)`ffct)`body), iS`stack,
          D`seq(endi(iS`callstack, 0)`ffct)`arity, endi(iS`callstack, 0)`fdepth,
          endi(iS`callstack, 0)`fpc) AND
        ifRedex?(iS) IMPLIES
          index(condition(fct_reconstruct_state(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
            iS`stack, D`seq(endi(iS`callstack, 0)`ffct)`arity,
            endi(iS`callstack, 0)`fdepth, endi(iS`callstack, 0)`fpc)`1)) <
              popDepth(fct_reconstruct_state(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
                iS`stack, D`seq(endi(iS`callstack, 0)`ffct)`arity,
                endi(iS`callstack, 0)`fdepth, endi(iS`callstack, 0)`fpc)`2)

    translate_is_result_defined_if_next_iftrue: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
            translate_extract_if(A, pc) IMPLIES
              translate_is_result_defined(A, S, pc + 1, rv)

    translate_is_result_defined_if_next_iffalse: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_if(A, pc) IMPLIES
          translate_is_result_defined(A, S, pc + 1 + translate_length(thenexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1)), rv)

    fct_is_result_defined_if_next_iftrue: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
            translate_extract_if(A, pc) IMPLIES
              fct_is_result_defined(A, S, arity, fdepth, pc + 1)

    fct_is_result_defined_if_next_iffalse: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_if(A, pc) IMPLIES
          fct_is_result_defined(A, S, arity, fdepth, pc + 1 + translate_length(thenexpr(fct_reconstruct_state(A, S, arity, fdepth, pc)`1)))    

    ifReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND ifRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), ifReduce(iS))

    stat_is_assign?(A: IExpression): boolean =
      NOT letexpr?(A) AND NOT release?(A) AND NOT ift?(A) AND NOT pop?(A) AND NOT ref?(A)

    translate_statement_assign(A: (stat_is_assign?), (translate_vars: [nat -> nat])): iexpr =
      CASES A OF
        variable(j, b): ivar(translate_vars(j), b),
        constant(n): iconstant(n),
        nil: inil,
        application(f, args):
          icall(f, map(LAMBDA x: ivar(translate_vars(index(x)), marked(x)))(args)),
        update(target, lhs, rhs):
          iupdate(ivar(translate_vars(index(target)), marked(target)),
                  ivar(translate_vars(index(lhs)), marked(lhs)),
                  ivar(translate_vars(index(rhs)), marked(rhs))),
        lookup(arr, pos):
          ilookup(ivar(translate_vars(index(arr)), marked(arr)),
                  ivar(translate_vars(index(pos)), marked(pos))),
        newint(n): inewint(n),
        newref(n): inewref(n)
      ENDCASES

    reconstruct_state_assign_aexpr: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_is_assign(A, pc) IMPLIES
          stat_is_assign?(reconstruct_state(A, translate_vars, S, pc, rv)`1) AND
          aexpr(translate_extract_assign(A, rv, translate_vars, pc)) =
            translate_statement_assign(reconstruct_state(A, translate_vars, S, pc, rv)`1,
              reconstruct_state(A, translate_vars, S, pc, rv)`3)

    fct_reconstruct_state_assign_aexpr: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_is_assign(A, pc) IMPLIES
          stat_is_assign?(fct_reconstruct_state(A, S, arity, fdepth, pc)`1) AND
          aexpr(translate_extract_assign(A, ivar(arity, FALSE), (LAMBDA j: j), pc)) =
            translate_statement_assign(fct_reconstruct_state(A, S, arity, fdepth, pc)`1,
              fct_reconstruct_state(A, S, arity, fdepth, pc)`3)

    applicationRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        applicationRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    applicationRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        applicationRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    iapply_nstack_match: LEMMA
      FORALL ((arity: nat), dom,
              (S : finseq[(value?)] | every(IL.domainValue?(dom))(S)),
              (S2 : ireduction.Stack),
              (k : upto(S`length)),
              (translate_vars: [nat -> nat] |
                injective?(translate_vars) AND
                FORALL i: i < k IMPLIES translate_vars(i) < S2`length AND
                  endi(S2, translate_vars(i)) = val_to_ival(endi(S, i))),
              (args: list[(variable?)] | length(args) = arity AND
                      FORALL i: in_varlist(args)(i) IMPLIES i < k),
              (args2: list[(ivar?)] | length(args2) = arity AND
                (FORALL i: in_varlist(args2)(i) IMPLIES
                  i < S2`length AND domainValue?(dom)(endi(S2, i))) AND
                (FORALL (i: below(arity)):
                  nth(args2, i) = ivar(translate_vars(index(nth(args, i))), marked(nth(args, i))))),
              (str: reduction.Store(dom)), A,
              (cnt: [i:(dom) -> {j|j=refcount(dom,str,S,A)(i)}]),
              (cnt2: [(dom) -> int])
              ) :
         count_matches(dom, cnt, cnt2) IMPLIES
           count_matches(dom, iareduction.iapply_nstack(arity, dom, S, args, str, A, cnt)`2, ireduction.iapply_nstack(arity, dom, S2, args2, cnt2)`2) AND
           FORALL i: i < k + arity IMPLIES
             endi(ireduction.iapply_nstack(arity, dom, S2, args2, cnt2)`1,
               compose_translate_vars((LAMBDA i: i), translate_vars, arity, arity)(i)) =
                 val_to_ival(endi(iareduction.iapply_nstack(arity, dom, S, args, str, A, cnt)`1, i))

    reconstruct_state_tv_inj: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        injective?(translate_vars) IMPLIES
          injective?(reconstruct_state(A, translate_vars, S, pc, rv)`3)

    fct_reconstruct_state_tv_inj: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        injective?(fct_reconstruct_state(A, S, arity, fdepth, pc)`3)

    call_reconstruct_state_tv_inj: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), f: nat,
            (pc: upto(translate_length(A)) | translate_is_fun_call_at(A, pc, f))):
        injective?(translate_vars) IMPLIES
          injective?(call_reconstruct_state(A, translate_vars, f, pc)`2)

    compose_translate_vars_inj: LEMMA
      FORALL (tv1, tv2: [nat -> nat], pdepth, fdepth: nat):
        injective?(tv1) AND injective?(tv2) AND
          (FORALL i: i < pdepth IMPLIES tv1(i) < fdepth)
          IMPLIES
            injective?(compose_translate_vars(tv1, tv2, pdepth, fdepth))

    compose_all_tv_inj: LEMMA
      FORALL (l: finseq[[[nat -> nat], nat, nat]]):
        (FORALL (i: below(l`length)):
           injective?(l`seq(i)`1) AND
           (FORALL j: j < l`seq(i)`2 IMPLIES l`seq(i)`1(j) < l`seq(i)`3))
        IMPLIES
          injective?(compose_all_tv(l))

    extract_call_tv_inj: LEMMA
      FORALL (D, (tD | defs_well_typed(D, tD)),
                 (iS | iS`callstack`length > 0 AND
                       iS`defs = translate_definitions(D, tD))):
        injective?(extract_call_tv(D, tD, iS))

    endi_add_zero[T: TYPE]: LEMMA
      FORALL (x: T, l: finseq[T]):
        endi(add(x, l), 0) = x

    endi_add_tl[T: TYPE]: LEMMA
      FORALL (x: T, l: finseq[T]):
        i > 0 AND i <= l`length IMPLIES
          endi(add(x, l), i) = endi(l, i - 1)

    applicationReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND applicationRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), applicationReduce(iS))

    valueRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        valueRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    valueRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        valueRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    valueReduce_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        valueRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth

    valueReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND valueRedex?(iS)
        IMPLIES
          state_matches(D, trS, valueReduce(iS))

    redex_stillmatch_assign2: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
                 (trS2 | trS2`def_types = trS`def_types),
                 (iS, iS2: {iS | iS`defs = translate_definitions(D, trS`def_types) AND
                            iS`callstack`length > 0}),
                 (fv1, fv2: stack_frame(iS`defs)),
                 (s: istat)):
        trS`state`context = trS2`state`context AND
        pop(iS`callstack) = pop(iS2`callstack) AND
        fv1 = endi(iS`callstack, 0) AND
        fv2 = endi(iS2`callstack, 0) AND
        fv1`ffct = fv2`ffct AND
        fv1`fpc < slength(iS`defs`seq(fv1`ffct)`body) AND
        fv2`fpc = next_pc(iS`defs`seq(fv1`ffct)`body, fv1`fpc) AND
        fv1`fdepth = fv2`fdepth AND
        s = extract_stat(iS`defs`seq(fv1`ffct)`body, fv1`fpc)`1 AND
        iassign?(s) AND
        stat_is_assign?(trS`state`redex) AND
        redex_matches(D, trS, iS) AND
        fct_reconstruct_state(me(D`seq(fv1`ffct)`body), iS`stack,
          D`seq(fv1`ffct)`arity, fv1`fdepth, fv1`fpc)`1 = trS`state`redex AND
%        popDepth(trS`state`redex) = 0 AND
        trS`state`stack`length = trS2`state`stack`length AND
        value?(trS2`state`redex) AND
        trS2`state`redex = ival_to_val(endi(iS2`stack, vindex(avar(s)))) AND
        (FORALL (i: below(trS`state`stack`length)):
          vars(trS`state`redex)(i) IMPLIES
            endi(iS2`stack,
              fct_reconstruct_state(me(D`seq(fv1`ffct)`body), iS`stack,
                D`seq(fv1`ffct)`arity, fv1`fdepth, fv1`fpc)`3(i)) =
              val_to_ival(endi(trS2`state`stack, i))) AND
        (FORALL i:
          NOT vars(s)(i) IMPLIES
            endi(iS`stack, i) = endi(iS2`stack, i)) AND
        (FORALL (i: below(trS`state`stack`length)):
          NOT vars(trS`state`redex)(i) IMPLIES
            endi(trS`state`stack, i) =
              endi(trS2`state`stack, i))
        IMPLIES
          redex_matches(D, trS2, iS2)

    redex_matches_vars: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)),
                 (iS | iS`defs = translate_definitions(D, trS`def_types) AND
                       iS`callstack`length > 0)):
        redex_matches(D, trS, iS) AND
        fct_reconstruct_state(me(D`seq(endi(iS`callstack, 0)`ffct)`body), iS`stack,
          D`seq(endi(iS`callstack, 0)`ffct)`arity, endi(iS`callstack, 0)`fdepth,
          endi(iS`callstack, 0)`fpc)`1 = trS`state`redex AND
        vars(trS`state`redex)(i) IMPLIES
          endi(iS`stack, 
            fct_reconstruct_state(me(D`seq(endi(iS`callstack, 0)`ffct)`body), iS`stack,
              D`seq(endi(iS`callstack, 0)`ffct)`arity, endi(iS`callstack, 0)`fdepth,
              endi(iS`callstack, 0)`fpc)`3(i)) = val_to_ival(endi(trS`state`stack, i))

    variableRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        variableRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    variableRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        variableRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    variableRedex_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        variableRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth

    assign_is_result_defined: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
            translate_extract_is_assign(A, pc) IMPLIES
              translate_is_result_defined(A, S, pc, rv)

    fct_avar_assign_neq_vars: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat | FORALL k: vars(A)(k) IMPLIES k < arity),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_is_assign(A, pc) AND
        vars(translate_statement_assign(fct_reconstruct_state(A, S, arity, fdepth, pc)`1,
              fct_reconstruct_state(A, S, arity, fdepth, pc)`3))(i) IMPLIES
          NOT i = vindex(avar(translate_extract_assign(A, ivar(arity, FALSE), (LAMBDA j: j), pc)))

    variableReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND variableRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), variableReduce(iS))

    tdecref(trS, (r: (trS`state`domain)), (i: upto(trS`state`store(r)`length))): typed_rstate =
      trS WITH [`state := decref(trS`state, r, i)]

    state_matches_tdecref: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS, (r: (iS`domain)), (i: upto(iS`store(r)`length))):
        state_matches(D, trS, iS) IMPLIES
          state_matches(D, tdecref(trS, r, i), idecref(iS, r, i))

    state_matches_decref: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), trS2, iS, (r: (trS`state`domain)), (i: upto(trS`state`store(r)`length))):
        state_matches(D, trS, iS) AND
        trS2`def_types = trS`def_types AND
        trS2`state = decref1(trS`state, r, i) IMPLIES
          state_matches(D, trS2, idecref(iS, r, i))

    releaseRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        releaseRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    releaseRedex_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        releaseRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth    

    translate_extract_release(A: (pure?), pc: below(translate_length(A))): RECURSIVE bool =
      CASES A OF
        letexpr(B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_release(B, pc - 1)
          ELSIF pc = 1 + translate_length(B) THEN
            FALSE
          ELSIF pc < 2 + translate_length(B) + translate_length(C) THEN
            translate_extract_release(C, pc - 2 - translate_length(B))
          ELSE
            FALSE
          ENDIF,
        ift(x, B, C):
          IF pc = 0 THEN
            FALSE
          ELSIF pc < 1 + translate_length(B) THEN
            translate_extract_release(B, pc - 1)
          ELSE
            translate_extract_release(C, pc - 1 - translate_length(B))
          ENDIF,
        release(x, B):
          pc = 0 OR translate_extract_release(B, pc - 1)
        ELSE FALSE
      ENDCASES
    MEASURE (A :: IExpression) BY <<

    translate_extract_release_def: LEMMA
      FORALL (A: (pure?), rv: (ivar?),
        (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
        dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD)),
        (translate_vars: [nat -> nat]), pc: below(translate_length(A))):
      irelease?(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1) =
        translate_extract_release(A, pc)

    translate_extract_decl_begin_release: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_begin(A, pc) IMPLIES NOT translate_extract_release(A, pc)
    translate_extract_decl_end_release: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_decl_end(A, pc) IMPLIES NOT translate_extract_release(A, pc)
    translate_extract_skip_release: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_skip(A, pc) IMPLIES NOT translate_extract_release(A, pc)
    translate_extract_is_assign_release: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_is_assign(A, pc) IMPLIES NOT translate_extract_release(A, pc)
    translate_extract_if_release: LEMMA
      FORALL (A: (pure?), pc: below(translate_length(A))):
        translate_extract_if(A, pc) IMPLIES NOT translate_extract_release(A, pc)

    reconstruct_state_releaseRedex: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_release(A, pc) IMPLIES
          releaseRedex?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    reconstruct_state_release_var: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
          (pc: below(translate_length(A))),
          (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length),
          (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
          dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD))):
        translate_extract_release(A, pc) IMPLIES
          vindex(rvar(extract_stat(translate_statement(A,rv,stypes,dom_types,tD,tA,translate_vars), pc)`1)) =
            reconstruct_state(A, translate_vars, S, pc, rv)`3
              (index(rvar(reconstruct_state(A, translate_vars, S, pc, rv)`1)))

    fct_reconstruct_state_release_var: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
          (arity : nat), (fdepth : posnat | fdepth <= S`length),
          (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth),
          (stypes | FORALL i: cvars(A)(i) IMPLIES i < stypes`length),
          dom_types, tD, (tA | is_well_typed(A, tA, stypes, dom_types, tD))):
        translate_extract_release(A, pc) IMPLIES
          vindex(rvar(extract_stat(translate_statement(A,ivar(arity,FALSE),stypes,dom_types,tD,tA,(LAMBDA j: j)), pc)`1)) =
            fct_reconstruct_state(A, S, arity, fdepth, pc)`3
              (index(rvar(fct_reconstruct_state(A, S, arity, fdepth, pc)`1)))


    translate_next_pc_release_no_overflow: LEMMA
      FORALL (A: (pure?), (pc: below(translate_length(A)))):
        translate_extract_release(A, pc) IMPLIES translate_next_pc(A, pc) < translate_length(A)

    reconstruct_state_next_pc_release: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_release(A, pc)
        IMPLIES
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`1 =
            rexpr(reconstruct_state(A, translate_vars, S, pc, rv)`1) AND
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`2 =
            reconstruct_state(A, translate_vars, S, pc, rv)`2 AND
          reconstruct_state(A, translate_vars, S2, translate_next_pc(A, pc), rv)`3 =
            reconstruct_state(A, translate_vars, S, pc, rv)`3

    fct_reconstruct_state_next_pc_release: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack),
                (S2 : ireduction.Stack | S2`length = S`length),
                (arity : nat), (fdepth : posnat | fdepth <= S`length),
                (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_release(A, pc)
        IMPLIES
          fct_reconstruct_state(A, S2, arity, fdepth, translate_next_pc(A, pc))`1 =
            rexpr(fct_reconstruct_state(A, S, arity, fdepth, pc)`1) AND
          fct_reconstruct_state(A, S2, arity, fdepth, translate_next_pc(A, pc))`2 =
            fct_reconstruct_state(A, S, arity, fdepth, pc)`2 AND
          fct_reconstruct_state(A, S2, arity, fdepth, translate_next_pc(A, pc))`3 =
            fct_reconstruct_state(A, S, arity, fdepth, pc)`3
    
    translate_is_result_defined_release_next_pc: LEMMA
      FORALL (A: (pure?), S: ireduction.Stack,
        translate_vars: [nat -> nat],
        pc: below(translate_length(A)),
        (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_release(A, pc) IMPLIES
          translate_is_result_defined(A, S, translate_next_pc(A, pc), rv)
 
    fct_is_result_defined_release_next_pc: LEMMA
      FORALL (A: (pure?), (S : ireduction.Stack), (arity: nat),
        (fdepth: posnat | fdepth <= S`length),
        (pc: below(translate_length(A)) | translate_stack_size_at(A, pc) + arity + 1 = fdepth)):
        translate_extract_release(A, pc) IMPLIES
          fct_is_result_defined(A, S, arity, fdepth, translate_next_pc(A, pc))

    releaseRedex_release: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        releaseRedex?(iS) IMPLIES
          translate_extract_release(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    reconstruct_state_release_pure: LEMMA
      FORALL (A: (pure?), (translate_vars: [nat -> nat]), (S : ireduction.Stack),
                (pc: below(translate_length(A))),
                (rv: (ivar?) | vindex(rv) + translate_stack_size_at(A, pc) < S`length)):
        translate_extract_release(A, pc) IMPLIES
          pure?(reconstruct_state(A, translate_vars, S, pc, rv)`1)

    releaseReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND releaseRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), releaseReduce(iS))


    newintRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        newintRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    newintRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        newintRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    newintRedex_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        newintRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth

    newintReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND newintRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), newintReduce(iS))


    newrefRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        newrefRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    newrefRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        newrefRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    newrefRedex_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        newrefRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth

    newrefReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND newrefRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), newrefReduce(iS))



    lookupRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        lookupRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    lookupRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        lookupRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    lookupRedex_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        lookupRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth

    state_error_stillmatch: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        state_matches(D, trS, iS) IMPLIES
          state_matches(D, trS WITH [`state := trS`state WITH [`error := TRUE]], iS WITH [`error := TRUE])

    lookupReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND lookupRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), lookupReduce(iS))


    state_matches_decref_chk: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), trS2, iS, (v: (IL.domainValue?(trS`state`domain)))):
        state_matches(D, trS, iS) AND
        trS2`def_types = trS`def_types AND
        trS2`state = decref1_chk(trS`state, v) IMPLIES
          state_matches(D, trS2, idecref_chk(iS, val_to_ival(v)))

    state_error_stillmatch2: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS, (n: nat)):
        state_matches(D, trS, iS) IMPLIES
          state_matches(D, trS WITH [`state := trS`state WITH [`error := TRUE], `dom_types := trS`dom_types WITH [(least_out(trS`state`domain)) := n]], iS WITH [`error := TRUE])


    updateRedex_pc: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        updateRedex?(iS) IMPLIES
          endi(iS`callstack, 0)`fpc < translate_length(me(D`seq(endi(iS`callstack, 0)`ffct)`body))

    updateRedex_assign: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        updateRedex?(iS) IMPLIES
          translate_extract_is_assign(me(D`seq(endi(iS`callstack, 0)`ffct)`body), endi(iS`callstack, 0)`fpc)

    updateRedex_fdepth: LEMMA
      FORALL (tD | defs_well_typed(D, tD)):
        iS`defs = translate_definitions(D, tD) AND
        iS`callstack`length > 0 AND
        updateRedex?(iS) IMPLIES
          1 + D`seq(endi(iS`callstack, 0)`ffct)`arity +
            translate_stack_size_at(me(D`seq(endi(iS`callstack, 0)`ffct)`body),
              endi(iS`callstack, 0)`fpc) =
          endi(iS`callstack, 0)`fdepth

    updateReduce_match: LEMMA
      FORALL (D, (trS | defs_well_typed(D, trS`def_types)), iS):
        NOT trS`state`error AND NOT iS`error AND
        state_matches(D, trS, iS) AND iS`callstack`length > 0 AND updateRedex?(iS)
        IMPLIES
          state_matches(D, typed_iareduce(D)(trS), updateReduce(iS))



END itranslation
