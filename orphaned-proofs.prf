("intermediateLanguage" intermediateLanguage popDepth_TCC5 0 (popDepth_TCC5-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC4 0 (popDepth_TCC4-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC3 0 (popDepth_TCC3-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC2 0 (popDepth_TCC2-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pure?_TCC4 0 (pure?_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage purePopDepthContext 0 (purePopDepthContext-1 nil 3645515823 ("" (induct-and-simplify "K") (("" (postpone) nil nil)) nil) nil shostak))("intermediateLanguage" intermediateLanguage refcount_TCC4 0 (refcount_TCC4-1 nil 3645614580 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC3 0 (refcount_TCC3-1 nil 3645614580 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage estate_TCC1 0 (estate_TCC1-1 nil 3645702721 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage fill_TCC1 0 (fill_TCC1-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage fill_TCC2 0 (fill_TCC2-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_lemma 0 (context_lemma-1 nil 3645177902 ("" (induct "A") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (inst + "hole" "application(application1_var, application2_var)") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("1" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst + "letc(K, letexpr2_var)" "B") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst + "letc(K!1, letexpr2_var)" "B!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("5" (grind) nil nil)) nil)) nil) ("6" (skeep*) (("6" (inst + "hole" "update(update1_var, update2_var, update3_var)") (("6" (grind) nil nil)) nil)) nil) ("7" (skeep*) (("7" (inst + "hole" "lookup(lookup1_var, lookup2_var)") (("7" (grind) nil nil)) nil)) nil) ("8" (skeep) (("8" (inst + "hole" "newint(newint1_var)") (("8" (grind) nil nil)) nil)) nil) ("9" (skeep) (("9" (inst + "hole" "newref(newref1_var)") (("9" (grind) nil nil)) nil)) nil) ("10" (skeep) (("10" (ground) (("1" (inst + "hole" "pop(pop1_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "popc(K)" "B") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (inst + "hole" "ref(ref1_var)") (("11" (grind) nil nil)) nil)) nil)) nil) ((ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popc adt-constructor-decl "[IContext -> (popc?)]" intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt nil) (newref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt nil) (newint? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup adt-constructor-decl "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (letc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]" intermediateLanguage nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (application adt-constructor-decl "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (hole adt-constructor-decl "(hole?)" intermediateLanguage nil) (hole? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popRedex? const-decl "bool" intermediateLanguage nil) (newrefRedex? const-decl "bool" intermediateLanguage nil) (newintRedex? const-decl "bool" intermediateLanguage nil) (lookupRedex? const-decl "bool" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (iftRedex? const-decl "bool" intermediateLanguage nil) (applyRedex? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (redex? const-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildContext_TCC1 0 (buildContext_TCC1-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC2 0 (buildContext_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC3 0 (buildContext_TCC3-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC4 0 (buildContext_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC5 0 (buildContext_TCC5-1 nil 3645328217 ("" (grind) nil nil) ((fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_composition 0 (context_composition-1 nil 3645324754 ("" (induct-and-simplify "K1") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (compose def-decl "IContext" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pure?_TCC1 0 (pure?_TCC1-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC2 0 (pure?_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC3 0 (pure?_TCC3-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_contextPure 0 (pure_contextPure-1 nil 3645472996 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC1 0 (buildcontextPure_TCC1-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC2 0 (buildcontextPure_TCC2-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC3 0 (buildcontextPure_TCC3-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage contextPurefill 0 (contextPurefill-1 nil 3645477567 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pureLetRedex?_TCC1 0 (pureLetRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage pureIftRedex?_TCC1 0 (pureIftRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((iftRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC1 0 (refs_TCC1-1 nil 3645594035 ("" (typepred "IExpression_adt.<<") (("" (expand "strict_well_founded?") (("" (expand "strict_order?") (("" (ground) (("" (hide -1 -2) (("" (grind :if-match nil) (("" (inst - "p!1") (("" (ground) (("1" (skosimp*) (("1" (inst + "y!2") (("1" (skeep) (("1" (inst?) (("1" (typepred "x_1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "y!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst + "y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (well_founded? const-decl "bool" orders nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (p!1 skolem-const-decl "pred[(contextPure?)]" intermediateLanguage nil) (y!2 skolem-const-decl "(extend[IExpression, (contextPure?), bool, FALSE](p!1))" intermediateLanguage nil) (x_1 skolem-const-decl "(p!1)" intermediateLanguage nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (strict_order? const-decl "bool" orders nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC2 0 (refs_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC3 0 (refs_TCC3-1 nil 3645594035 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC4 0 (refs_TCC4-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC5 0 (refs_TCC5-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC6 0 (refs_TCC6-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC7 0 (refs_TCC7-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3645614580 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs 0 (pure_refs-1 nil 3645614582 ("" (induct-and-simplify "A") (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3645614695 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_fill 0 (refs_fill-1 nil 3645614697 ("" (induct-and-simplify "K") (("1" (apply-extensionality) nil nil) ("2" (apply-extensionality) nil nil) ("3" (rewrite "contextPurefill") nil nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (refs def-decl "bool" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage refcount_TCC1 0 (refcount_TCC1-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC2 0 (refcount_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC1 0 (push_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil intermediateLanguage nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC2 0 (push_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("intermediateLanguage" intermediateLanguage pop_TCC1 0 (pop_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pop_TCC2 0 (pop_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage get_TCC1 0 (get_TCC1-1 nil 3645245227 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage popDepth_TCC1 0 (popDepth_TCC1-1 nil 3645226267 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage popdepth_fill 0 (popdepth_fill-1 nil 3645226269 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (fill def-decl "IExpression" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage purePopDepth 0 (purePopDepth-1 nil 3645515794 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression_induction formula-decl nil IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak))("intermediateLanguage" intermediateLanguage vars_TCC1 0 (vars_TCC1-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC2 0 (vars_TCC2-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC3 0 (vars_TCC3-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC4 0 (vars_TCC4-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC5 0 (vars_TCC5-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC6 0 (vars_TCC6-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_decompose 0 (vars_decompose-1 nil 3645245511 ("" (induct-and-simplify "K") nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage letReduce_TCC1 0 (letReduce_TCC1-1 nil 3645245508 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC2 0 (letReduce_TCC2-1 nil 3645245508 ("" (skosimp*) (("" (rewrite "contextPurefill") (("1" (typepred "A!1") (("1" (expand "contextPure?" +) (("1" (ground) (("1" (grind) (("1" (rewrite "pure_contextPure") nil nil) ("2" (rewrite "pure_contextPure") nil nil) ("3" (rewrite "pure_contextPure") nil nil) ("4" (rewrite "pure_contextPure") nil nil)) nil) ("2" (skeep) (("2" (rewrite "refs_fill") (("1" (typepred "gS!1`expr") (("1" (typepred "gS!1") (("1" (replace -) (("1" (hide -1) (("1" (inst?) (("1" (ground) (("1" (rewrite "refs_fill") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (use "pure_refs") (("1" (ground) (("1" (inst?) (("1" (expand "refs" -) (("1" (use "pure_refs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "contextPurefill") (("2" (expand "pureLetRedex?") (("2" (ground) (("2" (expand "contextPure?" +) (("2" (rewrite "pure_contextPure") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "pureLetRedex?") (("3" (ground) (("3" (skeep) (("3" (rewrite "vars_decompose") (("3" (ground) (("1" (typepred "K!1") (("1" (typepred "gS!1") (("1" (typepred "gS!1`expr") (("1" (inst?) (("1" (inst - "i") (("1" (replace -3 :hide? t) (("1" (rewrite "vars_decompose") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`expr") (("2" (hide -1 -2) (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst - "i") (("2" (rewrite "vars_decompose") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "A!1") (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (Stack type-eq-decl nil intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (pure_refs formula-decl nil intermediateLanguage nil) (refs_fill formula-decl nil intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (pure_contextPure formula-decl nil intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC3 0 (letReduce_TCC3-1 nil 3645245508 ("" (skosimp*) (("" (typepred "gS!1`stack") (("" (typepred "gS!1`expr") (("" (typepred "gS!1") (("" (replace - :hide? t) (("" (rewrite "popdepth_fill") (("" (typepred "A!1") (("" (hide -3) (("" (inst - "index(letrhs(A!1)) - popDepth(K!1)") (("1" (rewrite "vars_decompose") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC4 0 (letReduce_TCC4-1 nil 3645245508 ("" (skosimp*) (("" (typepred "A!1") (("" (grind) nil nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC5 0 (letReduce_TCC5-1 nil 3645477565 ("" (skosimp*) (("" (ground) (("1" (typepred "gS!1`stack") (("1" (rewrite "popdepth_fill") (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (rewrite "popdepth_fill") (("1" (rewrite "popDepth" +) (("1" (typepred "A!1") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (forward-chain "purePopDepth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "i!1") (("2" (lift-if) (("2" (ground) (("1" (expand "push") (("1" (ground) (("1" (typepred "gS!1`stack") (("1" (expand "get") (("1" (inst?) (("1" (typepred "A!1") (("1" (typepred "gS!1`expr") (("1" (hide -1 -2) (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (assert) (("1" (inst - "index(letrhs(A!1)) - gS!1`stack`length") (("1" (rewrite "vars_decompose") (("1" (ground) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (grind) (("2" (typepred "gS!1`expr") (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst?) (("2" (rewrite "refs_fill") (("2" (ground) (("2" (typepred "A!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (push const-decl "Stack" intermediateLanguage nil) (get const-decl "(value?)" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (gS!1 skolem-const-decl "{gS | gS`expr = fill(K!1, A!1)}" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs_fill formula-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC1 0 (updateReduce_TCC1-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC2 0 (updateReduce_TCC2-1 nil 3645791010 ("" (skeep* :preds? t) (("" (replace -6 :hide? t) (("" (hide -2) (("" (inst - "index(target(A)) - stack`length") (("1" (replace -8 :hide? t) (("1" (rewrite "vars_decompose") (("1" (hide -5) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vars def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC3 0 (updateReduce_TCC3-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3) (("" (replace -6) (("" (replace -11) (("" (inst - "index(lhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC4 0 (updateReduce_TCC4-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3 -4 10) (("" (replace -6 :hide? t) (("" (replace -10 :hide? t) (("" (inst - "index(rhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC5 0 (updateReduce_TCC5-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC6 0 (updateReduce_TCC6-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC7 0 (updateReduce_TCC7-1 nil 3645791010 ("" (skeep* :preds? t) (("" (inst - "refindex(aval)") (("" (assert) (("" (replace -14) (("" (replace -9) (("" (rewrite "refs_fill") (("" (hide-all-but (-8 2 4 -11 -15)) (("" (grind :if-match nil) (("" (inst?) (("1" (ground) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC8 0 (updateReduce_TCC8-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC9 0 (updateReduce_TCC9-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC10 0 (updateReduce_TCC10-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC11 0 (updateReduce_TCC11-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("IL" IL popDepth_TCC1 0 (popDepth_TCC1-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL refcount_TCC2 0 (refcount_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((IContext type-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (contextPurefill formula-decl nil IL nil)) nil))("IL" IL pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((IExpression type-decl nil IExpression_adt nil) (pure_contextPure formula-decl nil IL nil)) nil))("IL" IL refs_TCC9 0 (refs_TCC9-1 nil 3646130633 ("" (termination-tcc) nil nil) nil nil))("IL" IL refs_TCC8 0 (refs_TCC8-1 nil 3646130633 ("" (subtype-tcc) nil nil) nil nil))("IL" IL refs_TCC7 0 (refs_TCC7-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC6 0 (refs_TCC6-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC5 0 (refs_TCC5-1 nil 3646033320 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL refs_TCC4 0 (refs_TCC4-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC3 0 (refs_TCC3-1 nil 3646033320 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" IL nil)) nil))("IL" IL refs_TCC2 0 (refs_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL push_TCC2 0 (push_TCC2-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("IL" IL push_TCC1 0 (push_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("finite_set_theorems" finite_set_theorems nat_fullset_infinite 0 (nat_fullset_infinite-1 nil 3649860953 ("" (induct "n") (("1" (skeep) (("1" (typepred "f(0)") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (inst + "LAMBDA (i: nat): IF f(i + 1) = 0 THEN f(0) - 1 ELSE f(i + 1) - 1 ENDIF") (("1" (expand "injective?") (("1" (skeep) (("1" (apply (repeat (lift-if))) (("1" (ground) (("1" (inst - "x1 + 1" "x2 + 1") (("1" (ground) nil nil)) nil) ("2" (inst - 0 "x2 + 1") (("2" (assert) nil nil)) nil) ("3" (inst - 0 "x1 + 1") (("3" (assert) nil nil)) nil) ("4" (inst - "x1 + 1" "x2 + 1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (j skolem-const-decl "nat" finite_set_theorems nil) (f skolem-const-decl "(injective?[nat, below(1 + j)])" finite_set_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("finite_set_theorems" finite_set_theorems least_out_rec_TCC5 0 (least_out_rec_TCC5-1 nil 3649907982 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems least_out_rec_TCC4 0 (least_out_rec_TCC4-1 nil 3649901266 ("" (skeep :preds? t) (("" (ground) (("" (skeep :preds? t) (("" (typepred "v(NS, 1 + i)") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3647118642 ("" (grind) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (Store type-eq-decl nil reduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil) (vars def-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction" reduction pushlist_TCC1 0 (pushlist_TCC1-1 nil 3650126116 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (value? const-decl "bool" IL nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("IL" IL vars_decompose_TCC1 0 (vars_decompose_TCC1-1 nil 3650427978 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3650549580 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcount_TCC1 0 (refcount_TCC1-1 nil 3650675711 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3650550591 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("IL" IL vars_TCC10 0 (vars_TCC10-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC25 0 (mark_TCC25-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC24 0 (mark_TCC24-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC23 0 (mark_TCC23-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC22 0 (mark_TCC22-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC21 0 (mark_TCC21-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC20 0 (mark_TCC20-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC19 0 (mark_TCC19-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC18 0 (mark_TCC18-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC17 0 (mark_TCC17-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC16 0 (mark_TCC16-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC15 0 (mark_TCC15-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC14 0 (mark_TCC14-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC13 0 (mark_TCC13-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC12 0 (mark_TCC12-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655095779 ("" (grind) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC7 0 (vars_TCC7-1 nil 3650256398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC6 0 (vars_TCC6-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC5 0 (vars_TCC5-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC4 0 (vars_TCC4-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3655657128 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("preprocess" preprocess markc_TCC3 0 (markc_TCC3-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC10 0 (mark_TCC10-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC9 0 (mark_TCC9-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3655327556 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems finite_set_induction_TCC1 0 (finite_set_induction_TCC1-1 nil 3656130778 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_TCC3 0 (vars_TCC3-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_fill_TCC1 0 (mark_fill_TCC1-1 nil 3656268735 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess drop_TCC1 0 (drop_TCC1-1 nil 3656388994 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (grind :if-match nil) (("" (forward-chain -) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC2 0 (bump_TCC2-1 nil 3655508728 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (X!1 skolem-const-decl "finite_set[nat]" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC1 0 (bump_TCC1-1 nil 3655508728 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_TCC2 0 (bump_TCC2-1 nil 3656390208 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (X!1 skolem-const-decl "finite_set[nat]" IL nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil))("IL" IL bump_TCC1 0 (bump_TCC1-1 nil 3656390208 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_drop 0 (bump_drop-1 nil 3656520497 ("" (skeep) (("" (apply-extensionality) (("" (hide 2) (("" (grind :if-match nil) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("finite_set_theorems" finite_set_theorems bump_finite 0 (bump_finite-1 nil 3655675856 ("" (skeep) (("" (typepred "X") (("" (expand "is_finite") (("" (skosimp) (("" (inst + "N!1" "LAMBDA (i: (bump(X))): f!1(i+1)") (("1" (grind :if-match nil) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bump const-decl "bool" finite_set_theorems nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("preprocess" preprocess wellformed?_TCC1 0 (wellformed?_TCC1-1 nil 3656737588 ("" (skeep) (("" (rewrite "every_nth") (("" (skeep) (("" (expand "<<") (("" (ground) (("" (rewrite "some_nth") (("" (inst + "i") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (some_nth formula-decl nil finseq_theorems nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (restrict const-decl "R" restrict nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (A skolem-const-decl "IExpression" preprocess nil) (i skolem-const-decl "below(length(args))" preprocess nil) (args skolem-const-decl "list[(variable?)]" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("preprocess" preprocess wellformed_mark_TCC14 0 (wellformed_mark_TCC14-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markvar const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC13 0 (wellformed_mark_TCC13-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("preprocess" preprocess wellformed_mark_TCC12 0 (wellformed_mark_TCC12-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((bump const-decl "finite_set[nat]" IL nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC11 0 (wellformed_mark_TCC11-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC10 0 (wellformed_mark_TCC10-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC9 0 (wellformed_mark_TCC9-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC8 0 (wellformed_mark_TCC8-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC7 0 (wellformed_mark_TCC7-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC6 0 (wellformed_mark_TCC6-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC5 0 (wellformed_mark_TCC5-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC4 0 (wellformed_mark_TCC4-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC3 0 (wellformed_mark_TCC3-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC2 0 (wellformed_mark_TCC2-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC1 0 (wellformed_mark_TCC1-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("IL" IL buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((cpure? def-decl "bool" IL nil)) nil))("IL" IL buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (cpure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems compose_append 0 (compose_append-1 nil 3676394329 ("" (postpone) nil nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list2finseq 0 (finseq2list2finseq-1 nil 3676394691 ("" (induct-and-simplify "L") (("" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append 0 (finseq2list_append-1 nil 3676428779 ("" (induct "l") (("1" (grind) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append_TCC3 0 (finseq2list_append_TCC3-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC2 0 (finseq2list_append_TCC2-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC1 0 (finseq2list_append_TCC1-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseqtolist_TCC2 0 (finseqtolist_TCC2-1 nil 3676433703 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC2 0 (addroundlist_TCC2-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC1 0 (addroundlist_TCC1-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan treelevel_monotone 0 (treelevel_monotone-1 nil 3677729690 ("" (induct-and-simplify "X") (("" (postpone) nil nil)) nil) nil shostak))("lindstrom_scan" lindstrom_scan scan_TCC7 0 (scan_TCC7-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC6 0 (scan_TCC6-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC5 0 (scan_TCC5-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC4 0 (scan_TCC4-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC3 0 (scan_TCC3-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC28 0 (sscan_correct_TCC28-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC27 0 (sscan_correct_TCC27-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC26 0 (sscan_correct_TCC26-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC25 0 (sscan_correct_TCC25-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC24 0 (sscan_correct_TCC24-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC23 0 (sscan_correct_TCC23-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC22 0 (sscan_correct_TCC22-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC21 0 (sscan_correct_TCC21-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC20 0 (sscan_correct_TCC20-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC19 0 (sscan_correct_TCC19-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC18 0 (sscan_correct_TCC18-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC17 0 (sscan_correct_TCC17-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC16 0 (sscan_correct_TCC16-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC15 0 (sscan_correct_TCC15-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC14 0 (sscan_correct_TCC14-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC13 0 (sscan_correct_TCC13-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC12 0 (sscan_correct_TCC12-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC11 0 (sscan_correct_TCC11-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC10 0 (sscan_correct_TCC10-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC9 0 (sscan_correct_TCC9-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC8 0 (sscan_correct_TCC8-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC7 0 (sscan_correct_TCC7-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC6 0 (sscan_correct_TCC6-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC5 0 (sscan_correct_TCC5-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC4 0 (sscan_correct_TCC4-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC3 0 (sscan_correct_TCC3-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC2 0 (sscan_correct_TCC2-1 nil 3677897058 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (tree type-decl nil lindstrom_scan nil) (goodtree def-decl "bool" lindstrom_scan nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC1 0 (sscan_correct_TCC1-1 nil 3677897058 ("" (skeep :preds? t) (("" (expand "goodtree" -) (("" (assert) (("" (ground) (("1" (expand "goodtree") (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((goodtree def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_TCC35 0 (sscan_TCC35-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC34 0 (sscan_TCC34-1 nil 3677897058 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC33 0 (sscan_TCC33-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC7 0 (letApply_TCC7-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC6 0 (letApply_TCC6-1 nil 3683776766 ("" (termination-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC5 0 (letApply_TCC5-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction applyReduce_TCC4 0 (applyReduce_TCC4-1 nil 3650158977 ("" (skeeps :preds? t) (("" (typepred "popit(arity)(body)") (("" (ground) (("1" (lazy-grind) nil nil) ("2" (lazy-grind) nil nil) ("3" (rewrite "popit_popDepth") (("3" (expand "pushlist" +) (("3" (expand "o") (("3" (expand "list2finseq") (("3" (rewrite "map_length") (("3" (forward-chain "purePopDepth") (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Definition type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (popit def-decl "IExpression" reduction nil) (vars def-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popit_pure rec-application-judgement "{B | (forall j: NOT refs(B)(j))}" reduction nil) (popitContextPure rec-application-judgement "(contextPure?)" reduction nil) (popit_var rec-application-judgement "{B | (forall j: vars(B)(j) = vars(A)(j + i))}" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popit_popDepth formula-decl nil reduction nil) (map_length formula-decl nil more_map_props nil) (get const-decl "(value?)" IL nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (drop const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil IL nil) (below type-eq-decl nil nat_types nil) (Defs type-eq-decl nil reduction nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (pushlist const-decl "Stack" reduction nil) (O const-decl "finseq" finite_sequences nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (popDepth def-decl "nat" IL nil) (in_varlist const-decl "finite_set[nat]" IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction pure_letApply_TCC2 0 (pure_letApply_TCC2-1 nil 3683818064 ("" (recursive-judgement-tcc) nil nil) nil nil))("reduction" reduction vars_letApply_TCC1 0 (vars_letApply_TCC1-1 nil 3683816779 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (in_varlist const-decl "finite_set[nat]" IL nil)) nil))("refcount" refcount applyReduce_TCC7 0 (applyReduce_TCC7-1 nil 3682124599 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil)) nil))("refcount" refcount applyReduce_TCC6 0 (applyReduce_TCC6-1 nil 3682124599 ("" (skeep*) (("" (expand "refcount") (("" (expand "refcountStack") (("" (expand "pushlist") (("" (rewrite "count_compose") (("" (typepred "grS`count(i)") (("" (expand "refcount") (("" (replace -5) (("" (replace -1) (("" (expand "refcountStack") (("" (expand "refcountExpr" +) (("" (typepred "grS") (("" (rewrite "popit_refs") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") (("1" (assert) nil nil)) nil) ("2" (rewrite "pureApplyRedex") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refcountStack const-decl "nat" refcount nil) (count_compose formula-decl nil finseq_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (< const-decl "bool" reals nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (map adt-def-decl "list[T1]" list_adt_map nil) (get const-decl "(value?)" IL nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (value? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refcountExpr const-decl "nat" refcount nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (popit_refs formula-decl nil reduction nil) (pureApplyRedex formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure_refs formula-decl nil IL nil) (pushlist const-decl "Stack" reduction nil) (refcount const-decl "nat" refcount nil)) nil))("refcount" refcount applyReduce_TCC5 0 (applyReduce_TCC5-1 nil 3676345135 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems count_update_TCC1 0 (count_update_TCC1-1 nil 3684271525 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC2 0 (refcountStore_ref_TCC2-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC1 0 (refcountStore_ref_TCC1-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_update_TCC1 0 (refcountStore_update_TCC1-1 nil 3692670917 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount store_update_TCC3 0 (store_update_TCC3-1 nil 3692717400 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount finite_enumeration_inverse_TCC2 0 (finite_enumeration_inverse_TCC2-1 nil 3692735784 ("" (existence-tcc) nil nil) nil nil))("refcount" refcount decr_TCC16 0 (decr_TCC16-1 nil 3685624183 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC15 0 (decr_TCC15-1 nil 3685569175 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC14 0 (decr_TCC14-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC13 0 (decr_TCC13-2 "" 3692915495 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (lift-if) (("" (ground) (("" (expand "allcountStore") (("" (hide 3) (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "o") (("2" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (hide -1) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (decr_TCC13-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC12 0 (decr_TCC12-1 nil 3685100066 ("" (skeep*) (("" (lift-if) (("" (ground) (("1" (typepred "v(rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1],
                     refindex(subref), rS`store(refindex(subref))`length)") (("1" (inst?) (("1" (ground) nil nil)) nil) ("2" (ground) (("1" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (skeep :preds? t) (("2" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("2" (typepred "v(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (skeep) (("1" (inst - "r") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (replace -6 :hide? t) (("1" (typepred "i") (("1" (inst - "j") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (inst - "j") (("2" (replace -8 :hide? t) (("2" (replace -2 :hide? t) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "decr_TCC9") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") (("2" (inst - "rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1]") (("1" (assert) nil nil) ("2" (assert) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (skeep) (("3" (inst - "j") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (subref skolem-const-decl "(domainValue?(rS`domain))" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (decr_TCC9 subtype-tcc nil refcount nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" refcount nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC11 0 (decr_TCC11-2 "" 3685584855 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) shostak) (decr_TCC11-1 nil 3685100066 ("" (termination-tcc) nil nil) nil nil))("refcount" refcount decr_TCC10 0 (decr_TCC10-1 nil 3684597206 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 3) (("" (ground) (("" (hide 1) (("" (expand "allcountStore") (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (replace -6 :hide? t) (("2" (assert) (("2" (expand "o") (("2" (case "(LAMBDA (x: below[card(newrS`domain)]):
                              rS WITH [`store(r)`seq(i - 1) := nil, `count(subrefindex) := newsubrefcount]`count
                                  (finite_enumeration(rS`domain)(x))) = (LAMBDA (x: below[card(rS`domain)]):
                               rS`count(finite_enumeration(rS`domain)(x))) WITH [(inverse(finite_enumeration(rS`domain))(subrefindex)) := rS`count(subrefindex) - 1]") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))
                                 WITH [(inverse(finite_enumeration(rS`domain))(subrefindex))
                                         := rS`count(subrefindex) - 1]" "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))" "rS`count(subrefindex) - 1" "card(rS`domain) - 1" "inverse(finite_enumeration(rS`domain))(subrefindex)" "0") (("1" (ground) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_injective") (("1" (use "finite_enumeration_bij") (("1" (expand "bijective?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst - "subrefindex") (("2" (assert) (("2" (inst?) (("2" (ground) (("2" (rewrite "inverse_surjective") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (assert) nil nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (use "decr_TCC7") (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (allcountStore const-decl "nat" refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (allcount const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (card_is_0 formula-decl nil finite_sets nil) (O const-decl "T3" function_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (inverse_injective formula-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (newrS skolem-const-decl "rstate" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (newsubrefcount skolem-const-decl "int" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (subrefindex skolem-const-decl "(rS`domain)" refcount nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (bijective? const-decl "bool" functions nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (sigma_with formula-decl nil sigma "reals/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC9 0 (decr_TCC9-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep*) (("2" (assert) (("2" (typepred "j") (("2" (assert) (("2" (case "r = subrefindex") (("1" (replace*) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil)) nil))("refcount" refcount decr_TCC8 0 (decr_TCC8-1 nil 3684597206 ("" (skeep*) (("" (ground) (("" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "rS`store(r)`seq(i - 1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC7 0 (decr_TCC7-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (typepred "rS`count(subrefindex)") (("1" (expand "refcount") (("1" (use "refcountStore_ref") (("1" (ground) (("1" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(subrefindex)") (("2" (expand "refcount") (("2" (expand "refcountStore") (("2" (lift-if) (("2" (ground) (("1" (typepred "subref") (("1" (grind) nil nil)) nil) ("2" (expand "o") (("2" (expand "refcountArray") (("2" (case-replace "(LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store WITH [(r)`seq(i - 1) := nil]
                               (finite_enumeration(rS`domain)(x)))) = ((LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(finite_enumeration(rS`domain)(x)))) WITH [(inverse(finite_enumeration(rS`domain))(r)) := count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(r)) - 1])") (("1" (hide -1) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                           count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                 rS`store(finite_enumeration(rS`domain)(x))))
                          WITH [(inverse(finite_enumeration(rS`domain))(r))
                                  := count(lambda u:
                                             ref?(u) AND refindex(u) = subrefindex,
                                           rS`store(r))
                                      - 1]" "_" "_" "_" "_" "_") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                             count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                   rS`store(finite_enumeration(rS`domain)(x))))" "count(lambda u:
                                               ref?(u) AND refindex(u) = subrefindex,
                                             rS`store(r))
                                        - 1" "card(rS`domain) - 1" "(inverse(finite_enumeration(rS`domain))(r))" "0") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (rewrite "inverse_surjective") (("1" (assert) nil nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (case "inverse(finite_enumeration(rS`domain))(r) = x!1") (("1" (assert) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (rewrite "count_update") (("1" (expand "value?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "injective_inverse") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "count_elem[(value?)]") (("2" (ground) (("2" (inst + "i - 1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("3" (use "count_elem[(value?)]") (("3" (ground) (("3" (inst + "i - 1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refcountStore_ref formula-decl nil refcount nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (O const-decl "T3" function_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (sigma_with formula-decl nil sigma "reals/") (integer nonempty-type-from-decl nil integers nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (bijective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (sigma def-decl "real" sigma "reals/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_elem formula-decl nil finseq_theorems nil) (count_update formula-decl nil finseq_theorems nil) (injective_inverse formula-decl nil function_inverse nil) (refcountArray const-decl "nat" refcount nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (refcountExpr const-decl "nat" refcount nil) (count const-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (refcountStore const-decl "nat" refcount nil)) nil))("refcount" refcount decr_TCC6 0 (decr_TCC6-1 nil 3684597206 ("" (termination-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil)) nil))("refcount" refcount decr_TCC5 0 (decr_TCC5-1 nil 3684597206 ("" (skeep*) (("" (typepred "subref") (("" (grind) nil nil)) nil)) nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC4 0 (decr_TCC4-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC3 0 (decr_TCC3-1 nil 3684597206 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC2 0 (decr_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("refcount" refcount decr_TCC1 0 (decr_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("IL" IL vars_TCC2 0 (vars_TCC2-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3683170974 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC2 0 (markvars_markX_TCC2-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC1 0 (markvars_markX_TCC1-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_idem_subset 0 (mark_idem_subset-1 nil 3693496691 ("" (induct "A") (("1" (skeep*) (("1" (expand "mark") (("1" (expand "markv") (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak))("refreduction" refreduction lookupReduce_TCC26 0 (lookupReduce_TCC26-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC25 0 (lookupReduce_TCC25-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC24 0 (lookupReduce_TCC24-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" |finite_set_theorems| |sigma_sigma_set| 0 (|sigma_sigma_set-1| NIL 3698607396 NIL ("" (INDUCT "X" :NAME "finite_set_induction") (("1" (GRIND :REWRITES "sigma_empty") NIL NIL) ("2" (SKEEP*) (("2" (EXPAND "Sigma" 1 1) (("2" (EXPAND "nonempty?") (("2" (ASSERT) (("2" (INST?) (("2" (REWRITE "sigma_remove") (("2" (LIFT-IF) (("2" (GROUND) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (SKEEP) (("3" (USE "sigma_sigma_set_TCC1") NIL NIL)) NIL)) NIL)) NIL) NIL ((SIGMA_SIGMA_SET_TCC1 SUBTYPE-TCC NIL FINITE_SET_THEOREMS NIL) (NONEMPTY? CONST-DECL "bool" SETS NIL) (REAL_MINUS_REAL_IS_REAL APPLICATION-JUDGEMENT "real" REALS NIL) (SIGMA_REMOVE FORMULA-DECL NIL SIGMA_SET "sigma_set/") (CHOOSE CONST-DECL "(p)" SETS NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (FINITE_REMOVE APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" SIGMA_SET "sigma_set/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (SIGMA_EMPTY FORMULA-DECL NIL SIGMA_SET "sigma_set/") (EMPTY? CONST-DECL "bool" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (FINITE_SET_INDUCTION FORMULA-DECL NIL FINITE_SET_THEOREMS NIL) (SIGMA CONST-DECL "real" SIGMA_SET "sigma_set/") (SIGMA DEF-DECL "nat" FINITE_SET_THEOREMS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/")) NIL NIL NIL SHOSTAK))("finite_set_theorems" |finite_set_theorems| |sigma_sigma_set_TCC1| 0 (|sigma_sigma_set_TCC1-1| NIL 3698607394 NIL ("" (SKEEP) (("" (EXPAND "convergent?") (("" (GROUND) (("1" (USE "countable_props[nat].finite_countable") (("1" (LEMMA "countable_props[nat].finite_countable") (("1" (INST? :POLARITY? T) (("1" (USE "finite_nonzero_elts") NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "convergent?") (("2" (GROUND) (("2" (USE "finite_nonzero_elts") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/") (CONVERGENT? CONST-DECL "bool" COUNTABLE_CONVERGENCE "sigma_set/") (FINITE_COUNTABLE JUDGEMENT-TCC NIL COUNTABLE_PROPS "sets_aux/") (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (X SKOLEM-CONST-DECL "finite_set[nat]" FINITE_SET_THEOREMS NIL) (F SKOLEM-CONST-DECL "[nat -> nat]" FINITE_SET_THEOREMS NIL) (FINITE_NONZERO_ELTS FORMULA-DECL NIL FINITE_SET_THEOREMS NIL)) NIL NIL NIL NIL))("finite_set_theorems" |finite_set_theorems| |finite_nonzero_elts| 0 (|finite_nonzero_elts-1| NIL 3698607891 NIL ("" (SKEEP) (("" (CASE "subset?(nonzero_elts(f, X), X)") (("1" (FORWARD-CHAIN "finite_subset") NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) NIL ((FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (SUBSET? CONST-DECL "bool" SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (FINITE_SUBSET FORMULA-DECL NIL FINITE_SETS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (/= CONST-DECL "boolean" NOTEQUAL NIL) (SUBSET_IS_PARTIAL_ORDER NAME-JUDGEMENT "(partial_order?[set[T]])" SETS_LEMMAS NIL)) NIL NIL NIL SHOSTAK))("preprocess" |preprocess| |mark_idem_subset| 0 (|mark_idem_subset-1| NIL 3693496691 NIL ("" (INDUCT "A") (("1" (SKEEP*) (("1" (EXPAND "mark") (("1" (EXPAND "markv") (("1" (GRIND) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL) ("4" (POSTPONE) NIL NIL) ("5" (POSTPONE) NIL NIL) ("6" (POSTPONE) NIL NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (POSTPONE) NIL NIL) ("11" (POSTPONE) NIL NIL) ("12" (POSTPONE) NIL NIL) ("13" (POSTPONE) NIL NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("rreduction" |rreduction| |allcount_TCC2| 0 (|allcount_TCC2-1| NIL 3684597206 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |allcount_TCC1| 0 (|allcount_TCC1-1| NIL 3684597206 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |refcountStore_TCC2| 0 (|refcountStore_TCC2-1| NIL 3650675711 NIL ("" (SKEEP) (("" (POSTPONE) NIL NIL)) NIL) NIL ((EMPTY_CARD FORMULA-DECL NIL FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |refcountStore_TCC1| 0 (|refcountStore_TCC1-1| NIL 3650675711 NIL ("" (SKEEP :PREDS? T) (("" (EXPAND "convergent?") (("" (GROUND) (("1" (USE "finite_countable") (("1" (CASE "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (FORWARD-CHAIN "countable_subset[(dom)]") NIL NIL) ("2" (HIDE -1 -2 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "convergent?") (("2" (FLATTEN) (("2" (HIDE 2) (("2" (CASE "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (FORWARD-CHAIN "finite_subset[(dom)]") NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/") (CONVERGENT? CONST-DECL "bool" COUNTABLE_CONVERGENCE "sigma_set/") (FINITE_SUBSET FORMULA-DECL NIL FINITE_SETS NIL) (FINITE_COUNTABLE JUDGEMENT-TCC NIL COUNTABLE_PROPS "sets_aux/") (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (SUBSET_IS_PARTIAL_ORDER NAME-JUDGEMENT "(partial_order?[set[T]])" SETS_LEMMAS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (/= CONST-DECL "boolean" NOTEQUAL NIL) (COUNT CONST-DECL "nat" FINSEQ_THEOREMS NIL) (COUNTABLE_SUBSET FORMULA-DECL NIL COUNTABILITY "sets_aux/") (IS_COUNTABLE CONST-DECL "bool" COUNTABILITY "sets_aux/") (COUNTABLE_SET NONEMPTY-TYPE-EQ-DECL NIL COUNTABILITY "sets_aux/") (SUBSET? CONST-DECL "bool" SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (REFCOUNTARRAY CONST-DECL "nat" RREDUCTION NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (RESTRICT CONST-DECL "R" RESTRICT NIL) (FINITE_RESTRICT APPLICATION-JUDGEMENT "finite_set[S]" RESTRICT_SET_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC13| 0 (|lookupReduce_TCC13-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC12| 0 (|lookupReduce_TCC12-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC11| 0 (|lookupReduce_TCC11-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((GET CONST-DECL "(value?)" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC10| 0 (|lookupReduce_TCC10-1| NIL 3696570131 NIL ("" (SKEEP* :PREDS? T) (("" (GROUND) (("1" (TYPEPRED "grS`count(avalindex)") (("1" (EXPAND "refcount") (("1" (EXPAND "refcountStack") (("1" (USE "count_elem[(IL.value?)]") (("1" (GROUND) (("1" (INST + "stack`length - 1 - index(avar)") (("1" (ASSERT) (("1" (EXPAND "get") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "lookupReduce_TCC7") (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST - "pos") (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "refcount") (("2" (EXPAND "refcountStack") (("2" (REWRITE "count_update") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "grS`count(avalindex)") (("1" (EXPAND "refcount") (("1" (EXPAND "refcountStack") (("1" (ASSERT) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC9| 0 (|lookupReduce_TCC9-1| NIL 3696570131 NIL ("" (SKEEP* :PREDS? T) (("" (USE "reduction.lookupReduce_TCC6") (("" (INST - "rstate2estate(grS)" "stack") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST - "pos") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (GROUND) (("1" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL) ("3" (HIDE 3) (("3" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((LOOKUPREDUCE_TCC6 SUBTYPE-TCC NIL REDUCTION NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (GET CONST-DECL "(value?)" IL NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (ADD CONST-DECL "(nonempty?)" SETS NIL) (NONEMPTY_ADD_FINITE APPLICATION-JUDGEMENT "non_empty_finite_set[nat]" COUNTABILITY "sets_aux/") (MARKV CONST-DECL "(variable?)" PREPROCESS NIL) (CONSTANT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (VALUE ADT-ACCESSOR-DECL "[(constant?) -> int]" IEXPRESSION_ADT NIL) (POSITION ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]" IEXPRESSION_ADT NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" SIGMA_SET "sigma_set/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (REFINDEX ADT-ACCESSOR-DECL "[(ref?) -> nat]" IEXPRESSION_ADT NIL) (ARRAYVALUE ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]" IEXPRESSION_ADT NIL) (LOOKUP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EXPR SKOLEM-CONST-DECL "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" RREDUCTION NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (STORE SKOLEM-CONST-DECL "Store(grS`domain)" RREDUCTION NIL) (IFF CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (GOODSTATE TYPE-EQ-DECL NIL REDUCTION NIL) (STACK SKOLEM-CONST-DECL "{S: Stack | every(domainValue?(grS`domain))(S)}" RREDUCTION NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (< CONST-DECL "bool" REALS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" REALS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (ESTATE TYPE-EQ-DECL NIL REDUCTION NIL) (RSTATE2ESTATE CONST-DECL "estate" RREDUCTION NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (GRS SKOLEM-CONST-DECL "{grS | lookupRedex?(grS`redex)}" RREDUCTION NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC8| 0 (|lookupReduce_TCC8-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((GET CONST-DECL "(value?)" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |ifReduce_TCC8| 0 (|ifReduce_TCC8-1| NIL 3696194804 NIL ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "grS`count(x1)") (("" (EXPAND "refcount") (("" (EXPAND "pureIftRedex?") (("" (EXPAND "iftRedex?") (("" (GROUND) (("" (EXPAND "refcountExpr") (("" (REWRITE "pure_refs") (("1" (REWRITE "pure_refs") NIL NIL) ("2" (EXPAND "pure?" +) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((PUREIFTREDEX? CONST-DECL "bool" IL NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" REALS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (< CONST-DECL "bool" REALS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (REFS DEF-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (PURE_REFS FORMULA-DECL NIL IL NIL) (PURE? DEF-DECL "bool" IL NIL) (REFCOUNTEXPR CONST-DECL "nat" RREDUCTION NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |ifReduce_TCC7| 0 (|ifReduce_TCC7-1| NIL 3696194804 NIL ("" (SKEEP* :PREDS? T) (("" (USE "reduction.ifReduce_TCC4") (("" (INST - "rstate2estate(grS)" "stack") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST - "thenexpr") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (GROUND) (("1" (LAZY-GRIND :REWRITES "purePopDepth") NIL NIL) ("2" (LAZY-GRIND :REWRITES "purePopDepth") NIL NIL) ("3" (GRIND :REWRITES "purePopDepth" :IF-MATCH NIL) NIL NIL) ("4" (EXPAND "pureIftRedex?") (("4" (EXPAND "iftRedex?") (("4" (GROUND) (("4" (EXPAND "mark" -) (("4" (DECOMPOSE-EQUALITY -) (("4" (REPLACE -22) (("4" (REPLACE -2 :DIR RL) (("4" (REWRITE "mark_release_set") (("1" (REWRITE "mark_idem") NIL NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND :REWRITES "vars_mark") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (INST -12 "i") (("5" (GROUND) (("5" (EXPAND "pureIftRedex?") (("5" (EXPAND "iftRedex?") (("5" (GROUND) (("5" (EXPAND "mark" -) (("5" (DECOMPOSE-EQUALITY -) (("5" (REPLACE -23) (("5" (REPLACE -2 :DIR RL) (("5" (REWRITE "vars_release_set") (("5" (HIDE-ALL-BUT (-1 -4 -22 2 3 5)) (("5" (GRIND :REWRITES "vars_mark") (("5" (REPLACE -1 :DIR RL) (("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE 5) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((IFREDUCE_TCC4 SUBTYPE-TCC NIL REDUCTION NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARS_RELEASE_SET FORMULA-DECL NIL PREPROCESS NIL) (ADD CONST-DECL "(nonempty?)" SETS NIL) (NONEMPTY_ADD_FINITE APPLICATION-JUDGEMENT "non_empty_finite_set[nat]" COUNTABILITY "sets_aux/") (DIFFERENCE CONST-DECL "set" SETS NIL) (RELEASE_SET DEF-DECL "IExpression" PREPROCESS NIL) (ELSEEXPR ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" IEXPRESSION_ADT NIL) (THENEXPR ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" IEXPRESSION_ADT NIL) (UNION CONST-DECL "set" SETS NIL) (MARKV CONST-DECL "(variable?)" PREPROCESS NIL) (IFT ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression, IExpression] -> (ift?)]" IEXPRESSION_ADT NIL) (CONDITION ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" IEXPRESSION_ADT NIL) (IFT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (FINITE_DIFFERENCE APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_INTERSECTION1 APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (VARS_MARK FORMULA-DECL NIL PREPROCESS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (INTERSECTION CONST-DECL "set" SETS NIL) (EMPTY? CONST-DECL "bool" SETS NIL) (DISJOINT? CONST-DECL "bool" SETS NIL) (MARK_IDEM FORMULA-DECL NIL PREPROCESS NIL) (MARK_RELEASE_SET FORMULA-DECL NIL PREPROCESS NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (GET CONST-DECL "(value?)" IL NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EXPR SKOLEM-CONST-DECL "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" RREDUCTION NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (STORE SKOLEM-CONST-DECL "Store(grS`domain)" RREDUCTION NIL) (IFF CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (GOODSTATE TYPE-EQ-DECL NIL REDUCTION NIL) (STACK SKOLEM-CONST-DECL "{S: Stack | every(domainValue?(grS`domain))(S)}" RREDUCTION NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (< CONST-DECL "bool" REALS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" REALS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (ESTATE TYPE-EQ-DECL NIL REDUCTION NIL) (RSTATE2ESTATE CONST-DECL "estate" RREDUCTION NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (PUREIFTREDEX? CONST-DECL "bool" IL NIL) (GRS SKOLEM-CONST-DECL "{grS | pureIftRedex?(grS`redex)}" RREDUCTION NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("IL" IL VARS_FINITE 0 (VARS_FINITE-2 "" 3655616144 ("" (INDUCT "A") (("1" (GRIND :IF-MATCH NIL) (("1" (INST + 1 "(LAMBDA (i: (vars(variable(variable1_var!1, variable2_var!1)))): 0)") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND :IF-MATCH NIL) (("2" (INST + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND :IF-MATCH NIL) (("3" (INST + 0 "LAMBDA (i: (vars(nil))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (EXPAND "vars" +) (("4" (EXPAND "is_finite" +) (("4" (INST + "length(application2_var)" "(LAMBDA (i | in_varlist(application2_var)(i)): locate(LAMBDA x: index(x) = i, application2_var))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x1, application2_var)") (("1" (ASSERT) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x2, application2_var)") (("1" (ASSERT) (("1" (REPLACE -6 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "i") (("2" (EXPAND "in_varlist") (("2" (REWRITE "some_nth") (("2" (SKEEP) (("2" (INST?) (("2" (REWRITE "member_nth") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (EXPAND "vars" +) (("5" (LEMMA "finite_union" ("A" "vars(letexpr1_var)" "B" "(LAMBDA i: vars(letexpr2_var)(1 + i))")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (EXPAND "is_finite") (("2" (SKEEP) (("2" (INST + "N" "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (FORWARD-CHAIN -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (EXPAND "vars" +) (("6" (LEMMA "finite_union" ("A" "vars(ift1_var)" "B" "vars(ift2_var)")) (("1" (LEMMA "finite_union" ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B" "vars(ift3_var)")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (EXPAND "vars") (("7" (EXPAND "vars") (("7" (EXPAND "is_finite" +) (("7" (INST + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                         (i = index(update2_var)) OR
                          (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)") (("7" (EXPAND "injective?") (("7" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (EXPAND "vars" +) (("8" (EXPAND "is_finite" +) (("8" (INST + 2 "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF") (("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (EXPAND "vars") (("9" (EXPAND "is_finite") (("9" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (EXPAND "vars") (("10" (EXPAND "is_finite") (("10" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (EXPAND "vars" +) (("11" (EXPAND "is_finite") (("11" (SKEEP) (("11" (INST + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)") (("11" (EXPAND "injective?") (("11" (SKEEP) (("11" (FORWARD-CHAIN -1) (("11" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (EXPAND "vars") (("12" (EXPAND "is_finite") (("12" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (EXPAND "vars" +) (("13" (EXPAND "is_finite") (("13" (SKEEP*) (("13" (INST + "N!1 + 1" "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release2_var)(i) THEN f!1(i) ELSE N!1 ENDIF") (("1" (GRIND :IF-MATCH NIL) (("1" (FORWARD-CHAIN -4) NIL NIL) ("2" (FORWARD-CHAIN -4) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK) (VARS_FINITE-1 NIL 3652888177 ("" (INDUCT "A") (("1" (GRIND :IF-MATCH NIL) (("1" (INST + 1 "(LAMBDA (i: (vars(variable(variable1_var!1)))): 0)") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND :IF-MATCH NIL) (("2" (INST + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND :IF-MATCH NIL) (("3" (INST + 0 "LAMBDA (i: (vars(nil))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (EXPAND "vars" +) (("4" (EXPAND "is_finite" +) (("4" (INST + "length(application2_var)" "(LAMBDA (i | member(variable(i), application2_var)): locate(LAMBDA x: index(x) = i, application2_var))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x1, application2_var)") (("1" (ASSERT) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x2, application2_var)") (("1" (ASSERT) (("1" (REPLACE -6 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (INST + "variable(i)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (EXPAND "vars" +) (("5" (LEMMA "finite_union" ("A" "vars(letexpr1_var)" "B" "(LAMBDA i: vars(letexpr2_var)(1 + i))")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (EXPAND "is_finite") (("2" (SKEEP) (("2" (INST + "N" "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (FORWARD-CHAIN -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (EXPAND "vars" +) (("6" (LEMMA "finite_union" ("A" "vars(ift1_var)" "B" "vars(ift2_var)")) (("1" (LEMMA "finite_union" ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B" "vars(ift3_var)")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (EXPAND "vars") (("7" (EXPAND "vars") (("7" (EXPAND "is_finite" +) (("7" (INST + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                     (i = index(update2_var)) OR
                      (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)") (("7" (EXPAND "injective?") (("7" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (EXPAND "vars" +) (("8" (EXPAND "is_finite" +) (("8" (INST + 2 "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF") (("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (EXPAND "vars") (("9" (EXPAND "is_finite") (("9" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (EXPAND "vars") (("10" (EXPAND "is_finite") (("10" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (EXPAND "vars" +) (("11" (EXPAND "is_finite") (("11" (SKEEP) (("11" (INST + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)") (("11" (EXPAND "injective?") (("11" (SKEEP) (("11" (FORWARD-CHAIN -1) (("11" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (EXPAND "vars") (("12" (EXPAND "is_finite") (("12" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (EXPAND "vars" +) (("13" (EXPAND "is_finite") (("13" (SKEEP*) (("13" (INST + "N + 1" "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release1_var)(i) THEN f(i) ELSE N ENDIF") (("1" (GRIND :IF-MATCH NIL) (("1" (FORWARD-CHAIN -3) NIL NIL) ("2" (FORWARD-CHAIN -3) NIL NIL)) NIL) ("2" (SKEEP*) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("14" (SKEEP) (("14" (EXPAND "is_finite" +) (("14" (INST + 1 "LAMBDA (i | vars(mark(mark1_var))(i)): 0") (("14" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (< CONST-DECL "bool" REALS NIL) (VARIABLE ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (CONSTANT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (CONSTANT ADT-CONSTRUCTOR-DECL "[int -> (constant?)]" IEXPRESSION_ADT NIL) (FALSE CONST-DECL "bool" BOOLEANS NIL) (NIL? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NIL ADT-CONSTRUCTOR-DECL "(nil?)" IEXPRESSION_ADT NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (MEMBER DEF-DECL "bool" LIST_PROPS NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (LENGTH DEF-DECL "nat" LIST_PROPS NIL) (BELOW TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (NTH DEF-DECL "T" LIST_PROPS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (LOCATE DEF-DECL "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}" FINSEQ_THEOREMS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (UNION CONST-DECL "set" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (FINITE_UNION JUDGEMENT-TCC NIL FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (IF CONST-DECL "[boolean, T, T -> T]" IF_DEF NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (RESTRICT CONST-DECL "R" RESTRICT NIL)) SHOSTAK))("IL" IL VARS_DECOMPOSE 0 (VARS_DECOMPOSE-1 NIL 3646034443 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (MEMBER CONST-DECL "bool" SETS NIL) (DROP CONST-DECL "finite_set[nat]" IL NIL) (UNION CONST-DECL "set" SETS NIL)) SHOSTAK))("IL" IL VARS_TCC1 0 (VARS_TCC1-1 NIL 3646033415 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUMPN_BUMP 0 (BUMPN_BUMP-1 NIL 3656631410 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_PLUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BUMP CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL BUMPN_UNION 0 (BUMPN_UNION-1 NIL 3656567110 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (UNION CONST-DECL "set" SETS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/")) SHOSTAK))("IL" IL DROP_BUMP 0 (DROP_BUMP-1 NIL 3656520613 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (DROP CONST-DECL "finite_set[nat]" IL NIL) (BUMP CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL DROP_TCC1 0 (DROP_TCC1-1 NIL 3656390208 ("" (GRIND :IF-MATCH NIL) (("" (INST + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (GRIND :IF-MATCH NIL) (("" (FORWARD-CHAIN -) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (< CONST-DECL "bool" REALS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL BUMPN_ZERO 0 (BUMPN_ZERO-1 NIL 3656521531 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL BUMPN_TCC2 0 (BUMPN_TCC2-1 NIL 3656517434 ("" (GRIND :IF-MATCH NIL) (("" (INST + "N!1" "LAMBDA (i | i >= j!1 AND X!1(i - j!1)): f!1(i - j!1)") (("1" (SKEEPS :PREDS? T) (("1" (FORWARD-CHAIN -) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ((IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (J!1 SKOLEM-CONST-DECL "nat" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (< CONST-DECL "bool" REALS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (X!1 SKOLEM-CONST-DECL "finite_set[nat]" IL NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL BUMPN_TCC1 0 (BUMPN_TCC1-1 NIL 3656517434 ("" (SUBTYPE-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (>= CONST-DECL "bool" REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL)) NIL))("IL" IL IN_VARLIST_TCC1 0 (IN_VARLIST_TCC1-1 NIL 3656276690 ("" (GRIND :IF-MATCH NIL) (("" (INST + "length(L!1)" "LAMBDA (i | some[(variable?)]
                           (LAMBDA (v: (variable?)): index(v) = i)(L!1)): locate[(variable?)]((LAMBDA (v: (variable?)): index(v) = i), L!1)") (("1" (SKEEP) (("1" (TYPEPRED "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x1, L!1)") (("1" (TYPEPRED "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x2, L!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (REWRITE "some_nth") (("2" (SKEEP) (("2" (INST?) (("2" (REWRITE "member_nth") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (MEMBER DEF-DECL "bool" LIST_PROPS NIL) (L!1 SKOLEM-CONST-DECL "list[(variable?)]" IL NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (SOME ADT-DEF-DECL "boolean" LIST_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (LENGTH DEF-DECL "nat" LIST_PROPS NIL) (< CONST-DECL "bool" REALS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (BELOW TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (NTH DEF-DECL "T" LIST_PROPS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (LOCATE DEF-DECL "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}" FINSEQ_THEOREMS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (SOME_NTH FORMULA-DECL NIL FINSEQ_THEOREMS NIL) (I_1 SKOLEM-CONST-DECL "below(length(L!1))" IL NIL) (I SKOLEM-CONST-DECL "{i | some[(variable?)](lambda (v: (variable?)): index(v) = i)(L!1)}" IL NIL) (MEMBER_NTH FORMULA-DECL NIL FINSEQ_THEOREMS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (EVERY ADT-DEF-DECL "boolean" LIST_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL PUREPOPDEPTH 0 (PUREPOPDEPTH-1 NIL 3646034411 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL POPDEPTH_FILL 0 (POPDEPTH_FILL-1 NIL 3646034392 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL)) SHOSTAK))("IL" IL GET_TCC1 0 (GET_TCC1-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (< CONST-DECL "bool" REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL))("IL" IL POP_TCC2 0 (POP_TCC2-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("IL" IL POP_TCC1 0 (POP_TCC1-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("IL" IL REFCOUNT_PURE 0 (REFCOUNT_PURE-1 NIL 3676382439 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REFCOUNT DEF-DECL "nat" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL)) SHOSTAK))("IL" IL REFCOUNT_TCC1 0 (REFCOUNT_TCC1-1 NIL 3646033320 ("" (GRIND) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL REFS_FILL 0 (REFS_FILL-1 NIL 3646034363 ("" (INDUCT-AND-SIMPLIFY "K") (("1" (APPLY-EXTENSIONALITY) NIL NIL) ("2" (APPLY-EXTENSIONALITY) NIL NIL) ("3" (REWRITE "contextPurefill") NIL NIL)) NIL) ((POP ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" IEXPRESSION_ADT NIL) (POP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LETEXPR ADT-CONSTRUCTOR-DECL "[[IExpression, IExpression] -> (letexpr?)]" IEXPRESSION_ADT NIL) (LETEXPR? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REFS DEF-DECL "bool" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL PURE_REFS 0 (PURE_REFS-1 NIL 3646034342 ("" (INDUCT-AND-SIMPLIFY "A") (("" (REWRITE "pure_contextPure") NIL NIL)) NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL REFS_TCC1 0 (REFS_TCC1-1 NIL 3646033320 ("" (TYPEPRED "IExpression_adt.<<") (("" (EXPAND "strict_well_founded?") (("" (EXPAND "strict_order?") (("" (GROUND) (("" (HIDE -1 -2) (("" (GRIND :IF-MATCH NIL) (("" (INST - "p!1") (("" (GROUND) (("1" (SKOSIMP*) (("1" (INST + "y!2") (("1" (SKEEP) (("1" (INST?) (("1" (TYPEPRED "x_1") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "y!2") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST + "y!1") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (>= CONST-DECL "bool" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (STRICT_ORDER? CONST-DECL "bool" ORDERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXTPUREPUREREDEX 0 (CONTEXTPUREPUREREDEX-1 NIL 3682299553 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (SKEEP*) (("4" (GRIND) NIL NIL)) NIL) ("5" (SKEEP*) (("5" (GRIND) NIL NIL)) NIL) ("6" (SKEEP*) (("6" (HIDE (-1 -2 -3)) (("6" (GRIND) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (POSTPONE) NIL NIL) ("11" (POSTPONE) NIL NIL) ("12" (POSTPONE) NIL NIL) ("13" (POSTPONE) NIL NIL)) NIL) NIL SHOSTAK))("IL" IL PUREREDEXCONTEXTPURE 0 (PUREREDEXCONTEXTPURE-1 NIL 3646130634 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (SKEEP) (("6" (EXPAND "contextPure?" +) (("6" (EXPAND "pureRedex?" -4) (("6" (SPLIT -4) (("1" (EXPAND "pureLetRedex?") (("1" (EXPAND "letRedex?") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (EXPAND "applyRedex?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (EXPAND "pureIftRedex?") (("3" (EXPAND "iftRedex?") (("3" (FLATTEN) (("3" (REWRITE "pure_contextPure" +) (("3" (REWRITE "pure_contextPure" +) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL) ("7" (GRIND) NIL NIL) ("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (GRIND) NIL NIL) ("8" (GRIND) NIL NIL) ("9" (GRIND) NIL NIL) ("10" (GRIND) NIL NIL) ("11" (GRIND) NIL NIL) ("12" (GRIND) NIL NIL) ("13" (GRIND) NIL NIL) ("14" (GRIND) NIL NIL)) NIL) ((PURE? DEF-DECL "bool" IL NIL) (PURERELEASEREDEX? CONST-DECL "bool" IL NIL) (RELEASEREDEX? CONST-DECL "bool" IL NIL) (POPREDEX? CONST-DECL "bool" IL NIL) (NEWREFREDEX? CONST-DECL "bool" IL NIL) (NEWINTREDEX? CONST-DECL "bool" IL NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (UPDATEREDEX? CONST-DECL "bool" IL NIL) (PUREIFTREDEX? CONST-DECL "bool" IL NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (PURELETREDEX? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (PUREREDEX? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL PURERELEASEREDEX?_TCC1 0 (PURERELEASEREDEX?_TCC1-1 NIL 3693185170 ("" (GRIND) NIL NIL) ((RELEASEREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PUREIFTREDEX?_TCC1 0 (PUREIFTREDEX?_TCC1-1 NIL 3646033320 ("" (SUBTYPE-TCC) NIL NIL) ((IFTREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PURELETREDEX?_TCC1 0 (PURELETREDEX?_TCC1-1 NIL 3646033320 ("" (SUBTYPE-TCC) NIL NIL) ((VALUE? CONST-DECL "bool" IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PUREAPPLYREDEX 0 (PUREAPPLYREDEX-1 NIL 3682268823 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (PURE? DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL CONTEXTPUREFILL 0 (CONTEXTPUREFILL-1 NIL 3646034319 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL BUILDCONTEXTPURE_TCC5 0 (BUILDCONTEXTPURE_TCC5-1 NIL 3693185170 ("" (GRIND) NIL NIL) ((CPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC4 0 (BUILDCONTEXTPURE_TCC4-1 NIL 3693185170 ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "v(B)") (("" (GRIND) NIL NIL)) NIL)) NIL) ((AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC3 0 (BUILDCONTEXTPURE_TCC3-1 NIL 3646033320 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC2 0 (BUILDCONTEXTPURE_TCC2-1 NIL 3646033320 ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "v(B)") (("" (GRIND) NIL NIL)) NIL)) NIL) ((AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC1 0 (BUILDCONTEXTPURE_TCC1-1 NIL 3646033320 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL PURE_CONTEXTPURE 0 (PURE_CONTEXTPURE-1 NIL 3646034299 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL PURE?_TCC4 0 (PURE?_TCC4-1 NIL 3693185170 ("" (SKEEP) (("" (REPLACE -1) (("" (GRIND) NIL NIL)) NIL)) NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC3 0 (PURE?_TCC3-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC2 0 (PURE?_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC1 0 (PURE?_TCC1-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXT_COMPOSITION 0 (CONTEXT_COMPOSITION-1 NIL 3646034275 ("" (INDUCT-AND-SIMPLIFY "K1") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (FILL DEF-DECL "IExpression" IL NIL) (COMPOSE DEF-DECL "IContext" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL BUILDCONTEXT_TCC5 0 (BUILDCONTEXT_TCC5-1 NIL 3646033320 ("" (GRIND) NIL NIL) ((FILL DEF-DECL "IExpression" IL NIL)) NIL))("IL" IL BUILDCONTEXT_TCC4 0 (BUILDCONTEXT_TCC4-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC3 0 (BUILDCONTEXT_TCC3-1 NIL 3646033320 ("" (SKOSIMP*) (("" (EXPAND "fill" +) (("" (TYPEPRED "v!1(B!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((FILL DEF-DECL "IExpression" IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC2 0 (BUILDCONTEXT_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC1 0 (BUILDCONTEXT_TCC1-1 NIL 3646033320 ("" (SKOSIMP*) (("" (EXPAND "fill" +) (("" (TYPEPRED "v!1(B!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((FILL DEF-DECL "IExpression" IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXT_LEMMA 0 (CONTEXT_LEMMA-1 NIL 3646034052 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (SKEEP) (("4" (INST + "hole" "application(application1_var, application2_var)") (("4" (GRIND) NIL NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (GROUND) (("1" (INST + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (INST + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (INST + "letc(K, letexpr2_var)" "B") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (INST + "letc(K!1, letexpr2_var)" "B!1") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (INST + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("6" (GRIND) NIL NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (INST + "hole" "update(update1_var, update2_var, update3_var)") (("7" (GRIND) NIL NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (INST + "hole" "lookup(lookup1_var, lookup2_var)") (("8" (GRIND) NIL NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (INST + "hole" "newint(newint1_var)") (("9" (GRIND) NIL NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (INST + "hole" "newref(newref1_var)") (("10" (GRIND) NIL NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (GROUND) (("1" (INST + "hole" "pop(pop1_var)") (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (INST + "popc(K)" "B") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (INST + "hole" "ref(ref1_var)") (("12" (GRIND) NIL NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (INST + "hole" "release(release1_var, release2_var)") (("13" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((RELEASE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (RELEASE ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression] -> (release?)]" IEXPRESSION_ADT NIL) (REF ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" IEXPRESSION_ADT NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (POPC? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (POPC ADT-CONSTRUCTOR-DECL "[IContext -> (popc?)]" IL NIL) (POP ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" IEXPRESSION_ADT NIL) (POP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NEWREF ADT-CONSTRUCTOR-DECL "[nat -> (newref?)]" IEXPRESSION_ADT NIL) (NEWREF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NEWINT ADT-CONSTRUCTOR-DECL "[nat -> (newint?)]" IEXPRESSION_ADT NIL) (NEWINT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LOOKUP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LOOKUP ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]" IEXPRESSION_ADT NIL) (UPDATE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (UPDATE ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?), (variable?)] -> (update?)]" IEXPRESSION_ADT NIL) (IFT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (IFT ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression, IExpression] -> (ift?)]" IEXPRESSION_ADT NIL) (LETC? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (LETC ADT-CONSTRUCTOR-DECL "[[IContext, IExpression] -> (letc?)]" IL NIL) (LETEXPR ADT-CONSTRUCTOR-DECL "[[IExpression, IExpression] -> (letexpr?)]" IEXPRESSION_ADT NIL) (LETEXPR? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (APPLICATION ADT-CONSTRUCTOR-DECL "[[nat, list[(variable?)]] -> (application?)]" IEXPRESSION_ADT NIL) (APPLICATION? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EVERY ADT-DEF-DECL "boolean" LIST_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (HOLE ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL) (HOLE? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (RELEASEREDEX? CONST-DECL "bool" IL NIL) (POPREDEX? CONST-DECL "bool" IL NIL) (NEWREFREDEX? CONST-DECL "bool" IL NIL) (NEWINTREDEX? CONST-DECL "bool" IL NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (UPDATEREDEX? CONST-DECL "bool" IL NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (FILL DEF-DECL "IExpression" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REDEX? CONST-DECL "bool" IL NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL FILL_TCC2 0 (FILL_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IContext])" IL NIL)) NIL))("IL" IL FILL_TCC1 0 (FILL_TCC1-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IContext])" IL NIL)) NIL))("rreduction" rreduction lookupReduce_TCC13 0 (lookupReduce_TCC13-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction lookupReduce_TCC12 0 (lookupReduce_TCC12-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction lookupReduce_TCC11 0 (lookupReduce_TCC11-1 nil 3696570131 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction lookupReduce_TCC10 0 (lookupReduce_TCC10-1 nil 3696570131 ("" (skeep* :preds? t) (("" (ground) (("1" (typepred "grS`count(avalindex)") (("1" (expand "refcount") (("1" (expand "refcountStack") (("1" (use "count_elem[(IL.value?)]") (("1" (ground) (("1" (inst + "stack`length - 1 - index(avar)") (("1" (assert) (("1" (expand "get") (("1" (assert) nil nil)) nil)) nil) ("2" (use "lookupReduce_TCC7") (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst - "pos") (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "refcount") (("2" (expand "refcountStack") (("2" (rewrite "count_update") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "grS`count(avalindex)") (("1" (expand "refcount") (("1" (expand "refcountStack") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil))("rreduction" rreduction lookupReduce_TCC9 0 (lookupReduce_TCC9-1 nil 3696570131 ("" (skeep* :preds? t) (("" (use "reduction.lookupReduce_TCC6") (("" (inst - "rstate2estate(grS)" "stack") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst - "pos") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (ground) (("1" (lazy-grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil) ("3" (hide 3) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil) ((lookupReduce_TCC6 subtype-tcc nil reduction nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (store skolem-const-decl "Store(grS`domain)" rreduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (mark def-decl "IExpression" preprocess nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (estate type-eq-decl nil reduction nil) (rstate2estate const-decl "estate" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (lookupRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction lookupReduce_TCC8 0 (lookupReduce_TCC8-1 nil 3696570131 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction ifReduce_TCC8 0 (ifReduce_TCC8-1 nil 3696194804 ("" (skeep* :preds? t) (("" (typepred "grS`count(x1)") (("" (expand "refcount") (("" (expand "pureIftRedex?") (("" (expand "iftRedex?") (("" (ground) (("" (expand "refcountExpr") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") nil nil) ("2" (expand "pure?" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureIftRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (pure_refs formula-decl nil IL nil) (pure? def-decl "bool" IL nil) (refcountExpr const-decl "nat" rreduction nil) (iftRedex? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction ifReduce_TCC7 0 (ifReduce_TCC7-1 nil 3696194804 ("" (skeep* :preds? t) (("" (use "reduction.ifReduce_TCC4") (("" (inst - "rstate2estate(grS)" "stack") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst - "thenexpr") (("1" (split) (("1" (inst?) (("1" (split) (("1" (ground) (("1" (lazy-grind :rewrites "purePopDepth") nil nil) ("2" (lazy-grind :rewrites "purePopDepth") nil nil) ("3" (grind :rewrites "purePopDepth" :if-match nil) nil nil) ("4" (expand "pureIftRedex?") (("4" (expand "iftRedex?") (("4" (ground) (("4" (expand "mark" -) (("4" (decompose-equality -) (("4" (replace -22) (("4" (replace -2 :dir RL) (("4" (rewrite "mark_release_set") (("1" (rewrite "mark_idem") nil nil) ("2" (hide-all-but 1) (("2" (grind :rewrites "vars_mark") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst -12 "i") (("5" (ground) (("5" (expand "pureIftRedex?") (("5" (expand "iftRedex?") (("5" (ground) (("5" (expand "mark" -) (("5" (decompose-equality -) (("5" (replace -23) (("5" (replace -2 :dir RL) (("5" (rewrite "vars_release_set") (("5" (hide-all-but (-1 -4 -22 2 3 5)) (("5" (grind :rewrites "vars_mark") (("5" (replace -1 :dir RL) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil) ("3" (hide 5) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((ifReduce_TCC4 subtype-tcc nil reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_release_set formula-decl nil preprocess nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (difference const-decl "set" sets nil) (release_set def-decl "IExpression" preprocess nil) (elseexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (thenexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (union const-decl "set" sets nil) (markv const-decl "(variable?)" preprocess nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (condition adt-accessor-decl "[(ift?) -> (variable?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_difference application-judgement "finite_set[nat]" countability "sets_aux/") (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (finite_intersection1 application-judgement "finite_set[nat]" countability "sets_aux/") (vars_mark formula-decl nil preprocess nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (mark_idem formula-decl nil preprocess nil) (mark_release_set formula-decl nil preprocess nil) (iftRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (store skolem-const-decl "Store(grS`domain)" rreduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (mark def-decl "IExpression" preprocess nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (estate type-eq-decl nil reduction nil) (rstate2estate const-decl "estate" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (pureIftRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | pureIftRedex?(grS`redex)}" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction allcount_TCC2 0 (allcount_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("rreduction" rreduction allcount_TCC1 0 (allcount_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("rreduction" rreduction refcountStore_TCC2 0 (refcountStore_TCC2-1 nil 3650675711 ("" (skeep) (("" (postpone) nil nil)) nil) ((empty_card formula-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("rreduction" rreduction refcountStore_TCC1 0 (refcountStore_TCC1-1 nil 3650675711 ("" (skeep :preds? t) (("" (expand "convergent?") (("" (ground) (("1" (use "finite_countable") (("1" (case "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (forward-chain "countable_subset[(dom)]") nil nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "convergent?") (("2" (flatten) (("2" (hide 2) (("2" (case "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (forward-chain "finite_subset[(dom)]") nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((convergent? const-decl "bool" convergence_set "sigma_set/") (convergent? const-decl "bool" countable_convergence "sigma_set/") (finite_subset formula-decl nil finite_sets nil) (finite_countable judgement-tcc nil countable_props "sets_aux/") (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (count const-decl "nat" finseq_theorems nil) (countable_subset formula-decl nil countability "sets_aux/") (is_countable const-decl "bool" countability "sets_aux/") (countable_set nonempty-type-eq-decl nil countability "sets_aux/") (subset? const-decl "bool" sets nil) (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/") (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (refcountArray const-decl "nat" rreduction nil) (domainValue? const-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (restrict const-decl "R" restrict nil) (finite_restrict application-judgement "finite_set[S]" restrict_set_props nil)) nil))("rreduction" rreduction check_marked_TCC7 0 (check_marked_TCC7-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction rstate_TCC1 0 (rstate_TCC1-1 nil 3693496106 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_noDangling 0 (decref_noDangling-1 nil 3698761544 ("" (postpone) nil nil) nil shostak))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3683842373 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess releaset_set_top_mark 0 (releaset_set_top_mark-1 nil 3698777829 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (difference const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_difference application-judgement "finite_set[nat]" countability "sets_aux/") (bump const-decl "finite_set[nat]" IL nil) (markv const-decl "(variable?)" preprocess nil) (IExpression_induction formula-decl nil IExpression_adt nil) (mark def-decl "IExpression" preprocess nil) (top_releases def-decl "nat" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("rreduction" rreduction lookupReduce_TCC8 0 (lookupReduce_TCC8-1 nil 3698757037 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_decompose_TCC1 0 (vars_decompose_TCC1-1 nil 3699041070 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction popReduce_TCC6 0 (popReduce_TCC6-1 nil 3699115446 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letReduce_TCC6 0 (letReduce_TCC6-1 nil 3699115446 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_context_finite 0 (vars_context_finite-1 nil 3699126124 ("" (induct "K") (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction noDanglingRefs?_TCC2 0 (noDanglingRefs?_TCC2-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_empty 0 (mark_empty-1 nil 3699192140 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (skeep*) (("4" (expand mark 1) (("4" (expand vars -2) (("4" (decompose-equality 1) (("4" (case-replace "application2_var = null") (("1" (grind) nil nil) ("2" (delete 2) (("2" (expand in_varlist -2) (("2" (expand some -2) (("2" (case-replace "application2_var = cons(car(application2_var), cdr(application2_var))") (("1" (simplify) (("1" (inst -3 "index(car(application2_var))") nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand mark 1) (("5" (expand vars -3) (("5" (expand union -3) (("5" (expand drop -3) (("5" (expand member -3) (("5" (decompose-equality 1) (("1" (rewrite vars_mark) (("1" (expand vars 1 3) (("1" (expand drop 1 2) (("1" (expand add 1) (("1" (expand drop 1 1) (("1" (expand member 1) (("1" (rewrite vars_mark) (("1" (simplify) (("1" (expand drop) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction mark_letApply_cons_TCC4 0 (mark_letApply_cons_TCC4-1 nil 3699212334 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction mark_letApply_cons_TCC3 0 (mark_letApply_cons_TCC3-1 nil 3699212334 ("" (subtype-tcc) nil nil) ((in_varlist const-decl "finite_set[nat]" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("rreduction" rreduction updateReduce_TCC55 0 (updateReduce_TCC55-1 nil 3699381161 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction check_marked_TCC7 0 (check_marked_TCC7-1 nil 3698762473 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC6 0 (check_marked_TCC6-1 nil 3698692883 ("" (skeep*) (("" (ground) (("1" (typepred "rS`count(refindex(vx))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountStack) (("1" (lemma "finseq_theorems[(IL.value?)].count_elem") (("1" (inst?) (("1" (inst?) (("1" (ground) (("1" (expand get) (("1" (inst 1 "stack`length - 1 - index(x)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(refindex(vx))") (("2" (rewrite -1) (("2" (expand refcount) (("2" (expand refcountStack) (("2" (use "finseq_theorems[(IL.value?)].count_update") (("1" (rewrite -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("rreduction" rreduction check_marked_TCC5 0 (check_marked_TCC5-1 nil 3698692883 ("" (skeep*) (("" (expand refcount) (("" (typepred "rS`count(refindex(vx))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (split) (("1" (expand refcountStack) (("1" (use "finseq_theorems[(IL.value?)].count_elem") (("1" (ground) (("1" (inst 1 "rS`stack`length - 1 - index(x)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand refcountStack) (("2" (rewrite "finseq_theorems[(IL.value?)].count_update") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (typepred "rS`stack") (("2" (grind) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (refcount const-decl "nat" rreduction nil) (count_elem formula-decl nil finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (get const-decl "(value?)" IL nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (count_update formula-decl nil finseq_theorems nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (rstate type-eq-decl nil rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction check_marked_TCC4 0 (check_marked_TCC4-1 nil 3698692883 ("" (skeep* :preds? t) (("" (ground) (("" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC3 0 (check_marked_TCC3-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC2 0 (check_marked_TCC2-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC1 0 (check_marked_TCC1-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("rreduction" rreduction updateReduce_ndr 0 (updateReduce_ndr-1 nil 3699648459 ("" (judgement-tcc) nil nil) nil nil))("rreduction" rreduction reduce_wfStore 0 (reduce_wfStore-1 nil 3699730151 ("" (skeep* :preds? t) (("" (simplify) (("" (ground) (("" (ground) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("rreduction" rreduction update_wfStore 0 (update_wfStore-1 nil 3699730594 ("" (skeep* :preds? t) (("" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction update_wfStore_TCC1 0 (update_wfStore_TCC1-1 nil 3699730594 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess cvars_TCC1 0 (cvars_TCC1-1 nil 3683843116 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))("preprocess" preprocess markc_TCC2 0 (markc_TCC2-1 nil 3655657330 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))("preprocess" preprocess markc_TCC1 0 (markc_TCC1-1 nil 3655657330 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil) (injective? const-decl "bool" functions nil) (bump const-decl "finite_set[nat]" IL nil)) nil))("reduction_props" reduction_props testlemma 0 (testlemma-1 nil 3699903711 ("" (postpone) nil nil) nil shostak))("reduction_props" reduction_props translate_refs_restrict_TCC4 0 (translate_refs_restrict_TCC4-1 nil 3699908338 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props stack_stillmatch_TCC8 0 (stack_stillmatch_TCC8-1 nil 3699975962 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props top_releases_reduce_TCC1 0 (top_releases_reduce_TCC1-1 nil 3699900445 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props release_marked_match_TCC7 0 (release_marked_match_TCC7-1 nil 3700234159 ("" (grind) nil nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props release_marked_match_TCC6 0 (release_marked_match_TCC6-1 nil 3700234159 ("" (with-labels (skeep* :preds? t) ((x2pos xvar sl_index markh stm tsr obj))) (("" (expand release_marked) (("" (simplify) (("" (propax) nil nil)) nil)) nil)) nil) ((release_marked const-decl "rstate" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props release_marked_match_TCC5 0 (release_marked_match_TCC5-1 nil 3700234159 ("" (grind) nil nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (member const-decl "bool" sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props release_marked_match_TCC4 0 (release_marked_match_TCC4-1 nil 3700234159 ("" (grind) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (state_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (stack_matches const-decl "boolean" reduction_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("reduction_props" reduction_props top_releases_ct_TCC3 0 (top_releases_ct_TCC3-1 nil 3699898987 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props top_releases_ct_TCC2 0 (top_releases_ct_TCC2-1 nil 3699898987 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction_props" reduction_props top_releases_ct_TCC1 0 (top_releases_ct_TCC1-1 nil 3699898987 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC8 0 (stack_stillmatch_TCC8-1 nil 3699980803 ("" (skeep* :preds? t) (("" (replace -3) (("" (use extend_finite) nil nil)) nil)) nil) ((extend_finite formula-decl nil reduction_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (pred type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC7 0 (stack_stillmatch_TCC7-1 nil 3699975962 ("" (skeep* :preds? t) (("" (typepred "rS2`stack") (("" (expand every) (("" (expand domainValue?) (("" (skeep*) (("" (inst? -1) (("" (assert) (("" (replace -4) (("" (expand extend) (("" (typepred "rS2`count(refindex(rS2`stack`seq(i)))") (("" (replace -1) (("" (expand refcount) (("" (expand refcountStack) (("" (use "count_elem[(value?)]") (("" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (count_elem formula-decl nil finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (injective? const-decl "bool" functions nil) (stack_matches const-decl "boolean" reduction_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (estate type-eq-decl nil reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (refcountStack const-decl "nat" rreduction nil) (extend const-decl "R" extend nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC6 0 (stack_stillmatch_TCC6-1 nil 3699975962 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (stack_matches const-decl "boolean" reduction_props nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (extend const-decl "R" extend nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (estate type-eq-decl nil reduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC5 0 (stack_stillmatch_TCC5-1 nil 3699975962 ("" (skeep* :preds? t) (("" (use extend_finite) (("" (replace -3) (("" (propax) nil nil)) nil)) nil)) nil) ((extend_finite formula-decl nil reduction_props nil) (> const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC4 0 (stack_stillmatch_TCC4-1 nil 3699975962 ("" (skeep* :preds? t) (("" (typepred "rS`stack") (("" (expand every) (("" (skeep*) (("" (inst -1 i) (("" (expand domainValue?) (("" (flatten) (("" (assert) (("" (replace -3) (("" (expand extend) (("" (typepred "rS`count(refindex(rS`stack`seq(i)))") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (use "count_elem[(value?)]") (("" (split -1) (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (extend const-decl "R" extend nil) (refcountStack const-decl "nat" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (injective? const-decl "bool" functions nil) (count_elem formula-decl nil finseq_theorems nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC3 0 (stack_stillmatch_TCC3-1 nil 3699975962 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch 0 (redex_stillmatch-1 nil 3699981686 ("" (skeep* :preds? t) (("" (simplify :let-reduce? t) (("" (skeep* :preds? t) (("" (lemma translate_refs_restrict) (("" (inst -1 "unmark(rS`redex)" "extend[nat, (rS`domain), bool, FALSE]
                         ({r: (rS`domain) | rS`count(r) > 0})" "eS`domain" "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})") (("" (split -1) (("1" (rewrite -1) (("1" (case-replace "translate2 = lambda (i:
                               (extend[nat, (rS2`domain), bool, FALSE]
                                    ({r: (rS2`domain) |
                                      rS2`count(r) > 0}))):
                       translate(i)") (("1" (grind) nil nil) ("2" (delete 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (grind) nil nil)) nil) ("3" (skeep* :preds? t) (("3" (rewrite unmark_refs) (("3" (case "rS2`domain(i)") (("1" (typepred "rS2`count(i)") (("1" (expand extend) (("1" (assert) (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountExpr) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (typepred "rS`redex") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (rewrite unmark_contextPure) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IExpression type-decl nil IExpression_adt nil) (unmark def-decl "IExpression" preprocess nil) (IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (> const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (unmark_contextPure recursive-judgement-axiom nil preprocess nil) (refcountExpr const-decl "nat" rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (unmark_refs formula-decl nil preprocess nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (translate_refs_restrict formula-decl nil reduction_props nil)) shostak))("reduction_props" reduction_props redex_stillmatch_TCC6 0 (redex_stillmatch_TCC6-1 nil 3699975962 ("" (skeep* :preds? t) (("" (typepred "rS2`domain") (("" (expand is_finite) (("" (skeep*) (("" (inst 1 N "LAMBDA (x: (dom2)): f(x)") (("1" (expand injective?) (("1" (skeep*) (("1" (inst -1 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (extend const-decl "R" extend nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC5 0 (redex_stillmatch_TCC5-1 nil 3699975962 ("" (skeep* :preds? t) (("" (split 1) (("1" (rewrite unmark_contextPure) nil nil) ("2" (rewrite unmark_refs) (("2" (skeep) (("2" (typepred "rS2`redex") (("2" (inst -1 i) (("2" (replace -9) (("2" (expand extend) (("2" (assert) (("2" (typepred "rS2`count(i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (contextPure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (unmark_contextPure recursive-judgement-axiom nil preprocess nil) (extend const-decl "R" extend nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (unmark_refs formula-decl nil preprocess nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC4 0 (redex_stillmatch_TCC4-1 nil 3699975962 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (extend const-decl "R" extend nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC3 0 (redex_stillmatch_TCC3-1 nil 3699975962 ("" (skeep* :preds? t) (("" (expand is_finite) (("" (typepred "rS`domain") (("" (expand is_finite) (("" (skeep) (("" (inst 1 N "LAMBDA (x: (dom)): f(x)") (("1" (expand injective?) (("1" (skeep) (("1" (inst -1 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (extend const-decl "R" extend nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC2 0 (redex_stillmatch_TCC2-1 nil 3699975962 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite unmark_contextPure) nil nil) ("2" (skeep*) (("2" (rewrite unmark_refs) (("2" (typepred "rS`redex") (("2" (inst -1 i) (("2" (replace -8) (("2" (expand extend) (("2" (assert) (("2" (typepred "rS`count(i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (contextPure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (unmark_contextPure recursive-judgement-axiom nil preprocess nil) (unmark_refs formula-decl nil preprocess nil) (extend const-decl "R" extend nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC1 0 (redex_stillmatch_TCC1-1 nil 3699975962 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props extend_finite 0 (extend_finite-1 nil 3699992903 ("" (skeep* :preds? t) (("" (expand is_finite) (("" (skeep*) (("" (inst 1 N "LAMBDA (x: (extend[nat, (dom), bool, FALSE]
                      ({r: (dom) | dom_pred(r)}))): f(x)") (("1" (expand injective?) (("1" (skeep* :preds? t) (("1" (inst -3 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (pred type-eq-decl nil defined_types nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("reduction_props" reduction_props state_matches_TCC6 0 (state_matches_TCC6-1 nil 3699884471 ("" (skeep* :preds? t) (("" (typepred "rS`store(r1)`seq(x1)") (("" (expand domainValue?) (("" (ground) (("" (replace -9) (("" (expand extend) (("" (match 1 "rS`count(%1)" 1 step (typepred "rS`count(%1)")) (("" (rewrite -1) (("" (expand refcount) (("" (use refcountStore_ref) (("" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (member const-decl "bool" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (union const-decl "set" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (stack_matches const-decl "boolean" reduction_props nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (extend const-decl "R" extend nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props state_matches_TCC5 0 (state_matches_TCC5-1 nil 3699880315 ("" (subtype-tcc) nil nil) ((member const-decl "bool" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (union const-decl "set" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (stack_matches const-decl "boolean" reduction_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (extend const-decl "R" extend nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props state_matches_TCC4 0 (state_matches_TCC4-1 nil 3699880315 ("" (skeep* :preds? t) (("" (typepred "rS`stack") (("" (expand every) (("" (skeep* :preds? t) (("" (inst -2 i) (("" (expand domainValue?) (("" (ground) (("" (typepred "rS`count(refindex(rS`stack`seq(i)))") (("" (expand refcount) (("" (expand refcountStack) (("" (use "finseq_theorems[(value?)].count_elem") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (count_elem formula-decl nil finseq_theorems nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (extend const-decl "R" extend nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountStack const-decl "nat" rreduction nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (Stack type-eq-decl nil IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props state_matches_TCC3 0 (state_matches_TCC3-1 nil 3699880315 ("" (skeep* :preds? t) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "R" extend nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("reduction_props" reduction_props state_matches_TCC2 0 (state_matches_TCC2-1 nil 3699880315 ("" (skeep* :preds? t) (("" (typepred "rS`domain") (("" (expand is_finite) (("" (skeep*) (("" (inst 1 "N" "LAMBDA (x: (dom)): f(x)") (("1" (expand injective?) (("1" (skeep*) (("1" (inst -1 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (injective? const-decl "bool" functions nil) (extend const-decl "R" extend nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props state_matches_TCC1 0 (state_matches_TCC1-1 nil 3699880315 ("" (skeep* :preds? t) (("" (typepred "rS`redex") (("" (split) (("1" (grind) nil nil) ("2" (rewrite unmark_refs) (("2" (skeep*) (("2" (replace -9) (("2" (simplify) (("2" (expand extend) (("2" (simplify) (("2" (split) (("1" (flatten) (("1" (typepred "rS`count(i)") (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountExpr) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (refcountExpr const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (extend const-decl "R" extend nil) (unmark_refs formula-decl nil preprocess nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props store_matches_TCC2 0 (store_matches_TCC2-1 nil 3699881750 ("" (subtype-tcc) nil nil) ((< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (Store type-eq-decl nil reduction nil) (below type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props stack_matches_TCC3 0 (stack_matches_TCC3-1 nil 3699880315 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (Stack type-eq-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_restrict2 0 (translate_refs_restrict2-1 nil 3700248597 ("" (skeep*) (("" (lemma translate_refs_restrict) (("" (inst -1 A dom dom1 dom2) (("" (split -1) (("1" (rewrite -1) (("1" (case-replace "translation2 = lambda (i: (dom2)): translation(i)") (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil) ((translate_refs_restrict formula-decl nil reduction_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("reduction_props" reduction_props translate_refs_restrict 0 (translate_refs_restrict-1 nil 3699908338 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (skeep* :preds? t) (("5" (expand translate_refs 1) (("5" (inst -4 dom dom1 dom2) (("5" (inst -5 dom dom1 dom2) (("5" (split -4) (("1" (split -5) (("1" (rewrite -1) (("1" (rewrite -2) nil nil)) nil) ("2" (propax) nil nil) ("3" (skeep) (("3" (rewrite pure_refs) (("3" (grind) nil nil)) nil)) nil) ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep* :preds? t) (("6" (expand translate_refs 1) (("6" (inst -6 dom dom1 dom2) (("6" (inst -7 dom dom1 dom2) (("6" (split -6) (("1" (split -7) (("1" (rewrite -1) (("1" (rewrite -2) nil nil)) nil) ("2" (propax) nil nil) ("3" (expand refs -8) (("3" (delete 2) (("3" (delete -6) (("3" (skeep*) (("3" (inst? -8) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (skeep*) (("3" (inst -9 i) (("3" (grind) nil nil)) nil)) nil) ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (skeep* :preds? t) (("11" (expand translate_refs 1) (("11" (inst -4 dom dom1 dom2) (("11" (split -4) (("1" (rewrite -1) nil nil) ("2" (propax) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("12" (grind) nil nil) ("13" (skeep* :preds? t) (("13" (expand translate_refs 1) (("13" (inst -6 dom dom1 dom2) (("13" (split -6) (("1" (grind) nil nil) ("2" (propax) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("14" (grind) nil nil) ("15" (grind) nil nil) ("16" (delete 2) (("16" (skeep* :preds? t) (("16" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (inst? -5) (("2" (inst? -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (translate_refs def-decl "IExpression" reduction_props nil) (IExpression_induction formula-decl nil IExpression_adt nil) (pure_refs formula-decl nil IL nil) (injective? const-decl "bool" functions nil) (pure_contextPure formula-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("reduction_props" reduction_props translate_refs_restrict_TCC3 0 (translate_refs_restrict_TCC3-1 nil 3699908338 ("" (subtype-tcc) nil nil) ((injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_restrict_TCC2 0 (translate_refs_restrict_TCC2-1 nil 3699908338 ("" (subtype-tcc) nil nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_restrict_TCC1 0 (translate_refs_restrict_TCC1-1 nil 3699908338 ("" (skeep* :preds? t) (("" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) nil))("reduction_props" reduction_props translate_refs_TCC13 0 (translate_refs_TCC13-1 nil 3699971591 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_TCC12 0 (translate_refs_TCC12-1 nil 3699971591 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (refs def-decl "bool" IL nil)) nil))("reduction_props" reduction_props translate_refs_TCC11 0 (translate_refs_TCC11-1 nil 3699880315 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_TCC10 0 (translate_refs_TCC10-1 nil 3699880315 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((refs def-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (contextPure? def-decl "bool" IL nil)) nil))("reduction_props" reduction_props translate_refs_TCC9 0 (translate_refs_TCC9-1 nil 3699880315 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_TCC8 0 (translate_refs_TCC8-1 nil 3699880315 ("" (skeep* :preds? t) (("" (split 1) (("1" (use pure_contextPure) (("1" (grind) nil nil)) nil) ("2" (use pure_refs) (("2" (grind) nil nil)) nil)) nil)) nil) ((pure_refs formula-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pure_contextPure formula-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (contextPure? def-decl "bool" IL nil)) nil))("reduction_props" reduction_props translate_refs_TCC7 0 (translate_refs_TCC7-1 nil 3699880315 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props rupdate_wfStore 0 (rupdate_wfStore-1 nil 3699793059 ("" (with-labels (skeep* :preds? t) ((grds_err grds_ndr grds_upd grds_wfs red_wfs))) (("" (expand updateReduce :assert? nil) (("" (simplify :let-reduce? nil) (("" (with-labels (split red_wfs) ((red_wfs) (red_wfs))) (("1" (with-labels (flatten) ((ref_target lhs_constant lhs_ge_0 lhs_lt_length red_wfs))) (("1" (with-labels (split red_wfs) ((red_wfs) (red_wfs))) (("1" (with-labels (flatten) ((copy_hyp red_wfs))) (("1" (expand has_wfStore?) (("1" (use wfStore_add) (("1" (grind) nil nil) ("2" (typepred "grdS`stack") (("2" (hide (red_wfs grds_wfs copy_hyp)) (("2" (case "index(rhs(grdS`redex)) < grdS`stack`length") (("1" (grind) nil nil) ("2" (typepred "grdS`redex") (("2" (inst -2 "index(rhs(grdS`redex))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (with-labels (flatten) ((refcnt_1 target_marked rval_not_aval red_upd))) (("2" (split red_upd) (("1" (with-labels (flatten) ((ref_old red_wft))) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props rupdate_wfStore_TCC1 0 (rupdate_wfStore_TCC1-1 nil 3699731469 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props wfStore_add 0 (wfStore_add-1 nil 3699813466 ("" (with-labels (skeep* :preds? t) ((dom_finite r_nat h_wf dom_r n_wf))) (("" (expand wfStore?) (("" (expand well_founded?) (("" (with-labels (skeep* n_wf :preds? t) ((dom_y p_y n_wf))) (("" (inst h_wf "LAMBDA (t: (dom)): p(t)") (("1" (with-labels (split h_wf) ((h_wf) (h_wf))) (("1" (with-labels (skolem h_wf "z" t) ((dom_z p_z h_wf))) (("1" (inst n_wf z) (("1" (skeep* 2) (("1" (inst h_wf x) (("1" (expand store_order) (("1" (simplify) (("1" (skeep* n_wf) (("1" (lift-if n_wf) (("1" (case "z = r") (("1" (grind) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand store_order) (("2" (skeep* n_wf) (("2" (lift-if n_wf) (("2" (case "z = r") (("1" (grind) nil nil) ("2" (assert) (("2" (typepred "store(z)`seq(k)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy h_wf) (("2" (inst 1 y) (("2" (case-replace "y = r") (("1" (inst n_wf r) (("1" (skeep n_wf :preds? t) (("1" (expand store_order) (("1" (skeep n_wf) (("1" (typepred "T`seq(k)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((wfStore? const-decl "bool" rreduction nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (store_order const-decl "bool" rreduction nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (well_founded? const-decl "bool" orders nil)) shostak))("reduction_props" reduction_props wfStore_add_TCC2 0 (wfStore_add_TCC2-1 nil 3699813392 ("" (skeep* :preds? t) (("" (typepred "T`seq(x1)") (("" (grind) nil nil)) nil)) nil) ((< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (wfStore? const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/")) nil))("reduction_props" reduction_props wfStore_add_TCC1 0 (wfStore_add_TCC1-1 nil 3699813392 ("" (subtype-tcc) nil nil) ((add const-decl "(nonempty?)" sets nil) (wfStore? const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil)) nil))("reduction_props" reduction_props decref_has_wfStore 0 (decref_has_wfStore-1 nil 3699815730 ("" (skeep* :preds? t) (("" (expand has_wfStore?) (("" (use decref_wfStore) nil nil)) nil)) nil) ((has_wfStore? const-decl "bool" reduction_props nil) (decref_wfStore recursive-judgement-axiom nil reduction_props nil) (IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (wfStore? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak))("reduction_props" reduction_props decref_wfStore_TCC10 0 (decref_wfStore_TCC10-1 nil 3699731469 ("" (skeep* :preds? t) (("" (case-replace "newrS`store(r)`length = rS`store(r)`length") (("1" (grind) nil nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if) (("2" (ground) (("2" (replace -11) (("2" (simplify) (("2" (typepred " decref(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil) ("2" (delete 2) (("2" (grind) nil nil)) nil) ("3" (delete 2) (("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (split) (("1" (expand refcount) (("1" (use refcountStore_ref) (("1" (grind) nil nil)) nil)) nil) ("2" (expand refcount) (("2" (rewrite refcountStore_update) (("2" (delete 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (delete 3) (("3" (grind) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (wfStore? const-decl "bool" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refcountStore_update formula-decl nil rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC9 0 (decref_wfStore_TCC9-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (wfStore? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC8 0 (decref_wfStore_TCC8-1 nil 3699731469 ("" (skeep* :preds? t) (("" (split 2) (("1" (replace -10) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (replace -9) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (simplify) (("1" (ground) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC7 0 (decref_wfStore_TCC7-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC6 0 (decref_wfStore_TCC6-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC5 0 (decref_wfStore_TCC5-1 nil 3699731469 ("" (skeep* :preds? t) (("" (split) (("1" (expand noDanglingRefs?) (("1" (skeep* :preds? t) (("1" (inst -7 "i!1") (("1" (grind) nil nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -15) (("2" (simplify) (("2" (hide-all-but (-6 1 2 -8)) (("2" (expand wfStore?) (("2" (expand well_founded?) (("2" (skeep* :preds? t) (("2" (inst -3 p) (("2" (split -3) (("1" (skeep -1) (("1" (inst 1 "y!1") (("1" (skeep*) (("1" (inst -1 x) (("1" (expand store_order) (("1" (skeep -3 :preds? t) (("1" (inst 1 k) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wfStore? const-decl "bool" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC4 0 (decref_wfStore_TCC4-1 nil 3699731469 ("" (skeep* :preds? t) (("" (replace -14) (("" (typepred "rS`count(subrefindex)") (("" (rewrite -1) (("" (expand refcount) (("" (use refcountStore_ref) (("1" (split 2) (("1" (split -1) (("1" (grind) nil nil) ("2" (delete 2) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (rewrite refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (refcountStore_update formula-decl nil rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC3 0 (decref_wfStore_TCC3-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC2 0 (decref_wfStore_TCC2-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC1 0 (decref_wfStore_TCC1-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC11 0 (decref_preserves_TCC11-1 nil 3699733220 ("" (skeep* :preds? t) (("" (case-replace "rS`redex = newrS`redex") (("1" (case-replace "rS`stack = newrS`stack") (("1" (case-replace "rS`context = newrS`context") (("1" (case-replace "rS`error = newrS`error") (("1" (typepred "v(newrS, r, i-1)") (("1" (grind) nil nil) ("2" (case-replace "newrS`store(r)`length = rS`store(r)`length") (("1" (grind) nil nil) ("2" (delete 4) (("2" (replace -13) (("2" (delete 2) (("2" (lift-if) (("2" (ground) (("2" (replace -18) (("2" (simplify) (("2" (typepred "decref(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (delete 2) (("3" (expand refcount) (("3" (split 1) (("1" (use refcountStore_ref) (("1" (hide-all-but (1 2 -20 -1 -2)) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (rewrite refcountStore_update) (("2" (hide-all-but (1 3 -19 -1)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "newrS`domain = rS`domain") (("3" (delete 2 3 4 5) (("3" (replace -13) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (delete 3) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil) ("2" (delete 3) (("2" (replace -12) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -11) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -9) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (allcountStore const-decl "nat" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC10 0 (decref_preserves_TCC10-1 nil 3699733220 ("" (skeep* :preds? t) (("" (case-replace "newrS`store(r)`length = rS`store(r)`length") (("1" (grind) nil nil) ("2" (delete 3) (("2" (replace -9) (("2" (lift-if) (("2" (ground) (("2" (replace -10) (("2" (simplify) (("2" (typepred "decref(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (delete 2) (("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (expand refcount) (("3" (split 1) (("1" (use refcountStore_ref) (("1" (grind-with-ext) nil nil)) nil) ("2" (use refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC9 0 (decref_preserves_TCC9-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC8 0 (decref_preserves_TCC8-1 nil 3699733220 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skolem 2 "i1") (("" (inst -3 "i1") (("1" (case-replace "newrS`stack = rS`stack") (("1" (case-replace "newrS`redex = rS`redex") (("1" (case-replace "newrS`context = rS`context") (("1" (delete 3) (("1" (replace -11) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (simplify) (("1" (delete -12 -2 -3) (("1" (delete -4) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -9) (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred i1) (("2" (case-replace "newrS`stack = rS`stack") (("2" (delete 4) (("2" (replace -9) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC7 0 (decref_preserves_TCC7-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC6 0 (decref_preserves_TCC6-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC5 0 (decref_preserves_TCC5-1 nil 3699733220 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (replace -14) (("" (simplify) (("" (assert) (("" (skeep) (("" (inst -5 "i_1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC4 0 (decref_preserves_TCC4-1 nil 3699733220 ("" (skeep* :preds? t) (("" (replace -13) (("" (typepred "rS`count(subrefindex)") (("" (rewrite -1) (("" (expand refcount) (("" (split 2) (("1" (use refcountStore_ref) (("1" (grind-with-ext) nil nil) ("2" (grind) nil nil)) nil) ("2" (rewrite refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC3 0 (decref_preserves_TCC3-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)) nil))("reduction_props" reduction_props decref_preserves_TCC2 0 (decref_preserves_TCC2-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC1 0 (decref_preserves_TCC1-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_match_TCC13 0 (decref_match_TCC13-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (state_matches? const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (stack_matches const-decl "boolean" reduction_props nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_match_TCC12 0 (decref_match_TCC12-1 nil 3699904294 ("" (skeep* :preds? t) (("" (typepred "v(newrS, r, i-1)") (("1" (inst -1 eS) (("1" (assert) (("1" (delete 3) (("1" (replace -9) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "v(rS
                         WITH [`store(r)`seq(i - 1) := nil,
                               `count(refindex(subref))
                                 := rS`count(refindex(subref)) - 1],
                       refindex(subref), rS`store(refindex(subref))`length)") (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (delete 2) (("2" (expand state_matches?) (("2" (skeep) (("2" (inst 1 "LAMBDA (k | rS`domain(k) AND rS`count(k) > (IF k = refindex(subref) THEN 1 ELSE 0 ENDIF)): translate(k)") (("1" (name "rS2" "rS
                      WITH [`store(r)`seq(i - 1) := nil,
                            `count(refindex(subref))
                              := rS`count(refindex(subref)) - 1]") (("1" (replace -1) (("1" (expand state_matches) (("1" (split) (("1" (grind) nil nil) ("2" (lemma redex_stillmatch) (("2" (inst -1 eS rS rS2) (("2" (simplify :let-reduce? t) (("2" (inst? -1) (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (flatten) nil nil) ("6" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 -1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (lemma stack_stillmatch) (("4" (inst -1 "union(cvars(rS`redex),
                               bumpn(cvars(rS`context),
                                     popDepth(rS`redex)))" eS rS rS2) (("4" (simplify :let-reduce? t) (("4" (inst -1 translate "lambda (k: nat
                                | rS`domain(k) AND
                                   rS`count(k) >
                                    (IF k = refindex(subref)
                                     THEN 1
                                     ELSE 0
                                     ENDIF)):
                      translate(k)") (("1" (split -1) (("1" (hide-all-but (1 -1 -2)) (("1" (replace -2 :dir RL) (("1" (simplify) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (typepred "rS`redex") (("4" (skolem 1 j) (("4" (split) (("1" (typepred j) (("1" (expand union) (("1" (expand member) (("1" (expand bumpn) (("1" (split -1) (("1" (lemma cvars_vars) (("1" (inst -1 "rS`redex" "j - popDepth(rS`redex)") (("1" (inst -4 "j - popDepth(rS`redex)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (lemma cvars_vars_ctx) (("2" (inst -1 "rS`context" "j - popDepth(rS`redex) - popDepth(rS`context)") (("1" (inst -5 "j - popDepth(rS`redex) - popDepth(rS`context)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("5" (replace -1 :dir RL) (("5" (grind) nil nil)) nil) ("6" (grind) nil nil) ("7" (grind) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (expand store_matches) (("5" (skeep* :preds? t) (("5" (case "r_2 = r") (("1" (case "rS2`count(r) = 0") (("1" (grind) nil nil) ("2" (replace -3 :dir RL) (("2" (delete 2) (("2" (lift-if) (("2" (simplify) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (case-replace "rS2`store(r_2) = rS`store(r_2)") (("1" (inst -18 r_2) (("1" (flatten) (("1" (split) (("1" (propax) nil nil) ("2" (skeep* :preds? t) (("2" (inst -20 j) (("1" (lemma translate_refs_restrict) (("1" (inst -1 "rS`store(r_2)`seq(j)" "extend[nat, (rS`domain), bool, FALSE]
                         ({r: (rS`domain) | rS`count(r) > 0})" "eS`domain" "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})") (("1" (split -1) (("1" (inst -1 translate) (("1" (case-replace "(lambda (k: nat
                                 | rS`domain(k) AND
                                    rS`count(k)
                                    >
                                    (IF k = refindex(subref)
                                     THEN 1
                                     ELSE 0
                                     ENDIF)):
                       translate(k)) = lambda (i:
                                (extend[nat, (rS2`domain), bool, FALSE]
                                     ({r: (rS2`domain) |
                                       rS2`count(r) > 0}))):
                        translate(i)") (("1" (grind) nil nil) ("2" (delete 2) (("2" (decompose-equality) (("1" (delete -1 -21) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep* :preds? t) (("3" (typepred "rS`store(r_2)`seq(j)") (("3" (typepred "rS`count(i!1)") (("1" (expand refcount) (("1" (use refcountStore_ref) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (typepred "rS`store(r_2)`seq(j)") (("4" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (delete 3) (("2" (grind) nil nil)) nil) ("3" (delete 3) (("3" (grind) nil nil)) nil) ("4" (delete 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (split) (("1" (ground) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil) ("2" (ground) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (delete 2) (("3" (expand refcount) (("3" (split) (("1" (use refcountStore_ref) (("1" (split -1) (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (rewrite refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (refcountStore_update formula-decl nil rreduction nil) (state_matches const-decl "boolean" reduction_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (translate_refs def-decl "IExpression" reduction_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountStore_ref formula-decl nil rreduction nil) (stack_stillmatch formula-decl nil reduction_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (member const-decl "bool" sets nil) (int_plus_int_is_int application-judgement "int" integers nil) (cvars_vars formula-decl nil preprocess nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (cvars_vars_ctx formula-decl nil preprocess nil) (union const-decl "set" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_matches const-decl "boolean" reduction_props nil) (stack_matches const-decl "boolean" reduction_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (IFF const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (mark def-decl "IExpression" preprocess nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (state_matches? const-decl "boolean" reduction_props nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil))("reduction_props" reduction_props decref_match_TCC11 0 (decref_match_TCC11-1 nil 3699904294 ("" (use decref_preserves_TCC10) (("" (skeep*) (("" (inst? -1) (("" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (replace -2) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC10 0 (decref_match_TCC10-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rS!1 skolem-const-decl "(noDanglingRefs?)" reduction_props nil) (r!1 skolem-const-decl "(rS!1`domain)" reduction_props nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC9 0 (decref_match_TCC9-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rS!1 skolem-const-decl "(noDanglingRefs?)" reduction_props nil) (i!2 skolem-const-decl "below(newrS!1`stack`length)" reduction_props nil) (newrS!1 skolem-const-decl "rstate" reduction_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC8 0 (decref_match_TCC8-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (r!1 skolem-const-decl "(rS!1`domain)" reduction_props nil) (rS!1 skolem-const-decl "(noDanglingRefs?)" reduction_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC7 0 (decref_match_TCC7-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC6 0 (decref_match_TCC6-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC5 0 (decref_match_TCC5-1 nil 3699904294 ("" (use decref_preserves_TCC4) (("" (skeep*) (("" (inst? -1) (("" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (inst? -1) (("1" (grind) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC4 0 (decref_match_TCC4-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC3 0 (decref_match_TCC3-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC2 0 (decref_match_TCC2-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC1 0 (decref_match_TCC1-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props stack_set_test_TCC3 0 (stack_set_test_TCC3-1 nil 3700484430 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props stack_set_test_TCC2 0 (stack_set_test_TCC2-1 nil 3700484430 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props stack_set_test_TCC1 0 (stack_set_test_TCC1-1 nil 3700484430 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil))("rreduction" rreduction stack_update_correct_TCC1 0 (stack_update_correct_TCC1-1 nil 3700487299 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props subredex_stillmatch 0 (subredex_stillmatch-1 nil 3700482773 ("" (with-labels (skeep*) ((stm domeq storeeq stackeq countimp subref subvar depth2 depth obj))) (("" (expand state_matches) (("" (with-labels (flatten) ((err trr unm stam stom))) (("" (split obj) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props subredex_stillmatch_TCC2 0 (subredex_stillmatch_TCC2-1 nil 3700426643 ("" (subtype-tcc) nil nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props subredex_stillmatch_TCC1 0 (subredex_stillmatch_TCC1-1 nil 3700426643 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (translate_refs_contextPure rec-application-judgement "(contextPure?)" reduction_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props false_thm 0 (false_thm-1 nil 3700570379 ("" (lemma att_test) (("" (inst -1 "def(1)") (("" (grind) nil nil)) nil)) nil) ((test2 type-decl nil reduction_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (def? adt-recognizer-decl "[test2 -> boolean]" reduction_props nil) (def adt-constructor-decl "[nat -> (def?)]" reduction_props nil) (tttt const-decl "nat" reduction_props nil) (att_test formula-decl nil reduction_props nil)) shostak))("reduction_props" reduction_props att_test 0 (att_test-1 nil 3700570299 ("" (skeep* :preds? t) (("" (expand tttt) (("" (all-typepreds) (("" (grind) nil nil)) nil)) nil)) nil) ((tttt const-decl "nat" reduction_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (abc_var adt-accessor-decl "[(abc?) -> {i | i + 1 = i}]" reduction_props nil) (abc? adt-recognizer-decl "[test2 -> boolean]" reduction_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (def_var adt-accessor-decl "[(def?) -> nat]" reduction_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (def? adt-recognizer-decl "[test2 -> boolean]" reduction_props nil) (test2 type-decl nil reduction_props nil) (>= const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("reduction_props" reduction_props tttt_TCC1 0 (tttt_TCC1-1 nil 3700570299 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props test2_ord_defaxiom_TCC1 0 (test2_ord_defaxiom_TCC1-1 nil 3700570299 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_match_TCC2 0 (updateReduce_match_TCC2-1 nil 3700234159 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil reduction_props nil) (updateRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (state_matches? const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props updateReduce_nocount_same 0 (updateReduce_nocount_same-1 nil 3700931347 ("" (skeep) (("" (use count_redundant) (("" (split -1) (("1" (propax) nil nil) ("2" (delete 2) (("2" (postpone) nil nil)) nil) ("3" (delete 2) (("3" (postpone) nil nil)) nil) ("4" (delete 2) (("4" (postpone) nil nil)) nil) ("5" (delete 2) (("5" (postpone) nil nil)) nil) ("6" (delete 2) (("6" (case-replace "updateReduce(D)(grS)`context = grS`context") (("1" (expand updateReduce_nocount) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (split) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (postpone) nil nil)) nil)) nil)) nil) ("7" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props updateReduce_nocount_same_TCC1 0 (updateReduce_nocount_same_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil reduction_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction_props" reduction_props updateReduce_nocount_TCC22 0 (updateReduce_nocount_TCC22-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC21 0 (updateReduce_nocount_TCC21-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC20 0 (updateReduce_nocount_TCC20-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC19 0 (updateReduce_nocount_TCC19-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC18 0 (updateReduce_nocount_TCC18-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC17 0 (updateReduce_nocount_TCC17-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC16 0 (updateReduce_nocount_TCC16-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC15 0 (updateReduce_nocount_TCC15-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC14 0 (updateReduce_nocount_TCC14-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC13 0 (updateReduce_nocount_TCC13-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC12 0 (updateReduce_nocount_TCC12-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC11 0 (updateReduce_nocount_TCC11-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC10 0 (updateReduce_nocount_TCC10-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC9 0 (updateReduce_nocount_TCC9-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC8 0 (updateReduce_nocount_TCC8-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC7 0 (updateReduce_nocount_TCC7-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC6 0 (updateReduce_nocount_TCC6-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC5 0 (updateReduce_nocount_TCC5-1 nil 3700931213 ("" (skeep* :preds? t) (("" (typepred "grS`stack") (("" (postpone) nil nil)) nil)) nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC4 0 (updateReduce_nocount_TCC4-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC3 0 (updateReduce_nocount_TCC3-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC2 0 (updateReduce_nocount_TCC2-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC1 0 (updateReduce_nocount_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil reduction_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction_props" reduction_props stack_clear_if_marked_ref_TCC2 0 (stack_clear_if_marked_ref_TCC2-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (value? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil)) nil))("reduction_props" reduction_props stack_clear_if_marked_ref_TCC1 0 (stack_clear_if_marked_ref_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props count_redundant_TCC1 0 (count_redundant_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("falso" falso att_test 0 (att_test-1 nil 3700571090 ("" (skeep) (("" (expand tttt) (("" (all-typepreds) (("" (grind) nil nil)) nil)) nil)) nil) ((tttt const-decl "nat" falso nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (abc_var adt-accessor-decl "[(abc?) -> {i | i + 1 = i}]" falso nil) (abc? adt-recognizer-decl "[test2 -> boolean]" falso nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (def_var adt-accessor-decl "[(def?) -> nat]" falso nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (def? adt-recognizer-decl "[test2 -> boolean]" falso nil) (test2 type-decl nil falso nil) (>= const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("falso" falso tttt_TCC1 0 (tttt_TCC1-1 nil 3700571083 ("" (subtype-tcc) nil nil) nil nil))("falso" falso test2_ord_defaxiom_TCC1 0 (test2_ord_defaxiom_TCC1-1 nil 3700571083 ("" (subtype-tcc) nil nil) nil nil))("falso" falso tccf_test 0 (tccf_test-1 nil 3701028640 ("" (skeep) (("" (name "v" "x WITH [`aa := 1, `bb := x`bb WITH [(0) |-> 1]]") (("" (name "v2" "x WITH [`aa := 1, `bb(0) |-> 1]") (("" (name "w" "v`bb") (("" (expand v -1) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("rreduction" rreduction reduce_TCC13 0 (reduce_TCC13-1 nil 3699714517 ("" (skeep* :preds? t) (("" (typepred "buildRedex(t`redex)") (("" (case "pureRedex?(redex)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((atom? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rtopstate type-eq-decl nil rreduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction reduce_TCC12 0 (reduce_TCC12-1 nil 3699648459 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction reduce_TCC11 0 (reduce_TCC11-1 nil 3699648459 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction make_redex_ndr_TCC1 0 (make_redex_ndr_TCC1-1 nil 3701199310 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction reduce_TCC10 0 (reduce_TCC10-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction" reduction reduce_TCC9 0 (reduce_TCC9-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction_props" reduction_props bisimulation_theorem 0 (bisimulation_theorem-1 nil 3701439594 ("" (measure-induct+ "top_releases_ct(grS`redex)" ("grS")) (("" (name-replace grS "x!1") (("" (label hrec -1) (("" (with-labels (skeep) ((ndr arm armc stm obj))) (("" (inst obj "top_releases_ct(grS`redex) + 1") (("" (case "top_releases_ct(grS`redex) > 0") (("1" (inst hrec "reduce(D)(grS)") (("1" (inst hrec D gS) (("1" (split hrec) (("1" (postpone) nil nil) ("2" (use reduce_ndr) nil nil) ("3" (use reduce_arm) (("1" (assert) nil nil) ("2" (prop) nil nil)) nil) ("4" (use reduce_arm) (("1" (prop) nil nil) ("2" (prop) nil nil)) nil) ("5" (delete obj) (("5" (expand reduce) (("5" (case "atom?(to_topstate(grS)`redex)") (("1" (delete hrec) (("1" (expand to_topstate) (("1" (case "top_releases_ct(fill(grS`context, grS`redex)) > 0") (("1" (grind) nil nil) ("2" (rewrite top_releases_ct_fill) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "pureReleaseRedex?(make_redex(to_topstate(grS))`redex)") (("1" (name-replace rS "make_redex(to_topstate(grS))") (("1" (case "pureReleaseRedex?(rS`redex)") (("1" (case "noDanglingRefs?(rS)") (("1" (case "allReleaseMarked?(rS`redex)") (("1" (lemma releaseReduce_match) (("1" (inst -1 D gS rS) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props make_redex_matches 0 (make_redex_matches-1 nil 3701452316 ("" (postpone) nil nil) nil shostak))("reduction_props" reduction_props make_redex_matches_TCC2 0 (make_redex_matches_TCC2-1 nil 3701452316 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_TCC1 0 (make_redex_matches_TCC1-1 nil 3701452316 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_aux_TCC2 0 (make_redex_matches_aux_TCC2-1 nil 3701452895 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_aux_TCC1 0 (make_redex_matches_aux_TCC1-1 nil 3701452895 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_aux 0 (make_redex_matches_aux-2 "" 3701454322 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (with-labels (skeep* :preds? t) ((esc rsc ap1 ap2 ap2h rsreq atr ate relr stm obj))) (("4" (case-replace "make_redex(rS) = rS") (("1" (case-replace "make_redex_e(eS) = eS") (("1" (case "application?(eS`redex)") (("1" (hide-all-but (1 -1 esc)) (("1" (expand make_redex_e) (("1" (expand buildRedex) (("1" (assert) (("1" (replace esc :dir RL) (("1" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 rsreq rsc)) (("2" (grind) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak) (make_redex_matches_aux-1 nil 3701452895 ("" (induct A) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil) ("14" (postpone) nil nil) ("15" (postpone) nil nil) ("16" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction reduce_ndr_TCC1 0 (reduce_ndr_TCC1-1 nil 3701438337 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction is_well_typed_TCC43 0 (is_well_typed_TCC43-1 nil 3701611553 ("" (termination-tcc) nil nil) nil nil))("typed_reduction" typed_reduction is_well_typed_TCC44 0 (is_well_typed_TCC44-1 nil 3701626353 ("" (skeep :preds? t) (("" (skeep) (("" (replace -9) (("" (expand <<) (("" (rewrite some_nth) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (contextPure? def-decl "bool" IL nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (cvars def-decl "finite_set[nat]" preprocess nil) (in_varlist const-decl "finite_set[nat]" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (some_nth formula-decl nil finseq_theorems nil)) nil))("typed_reduction" typed_reduction ctx_type_TCC1 0 (ctx_type_TCC1-1 nil 3701633858 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])" typed_reduction nil)) nil))("reduction_props" reduction_props record_update_self 0 (record_update_self-1 nil 3701454374 ("" (skeep) (("" (grind) nil nil)) nil) ((estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak))("reduction_props" reduction_props record_update_self_TCC2 0 (record_update_self_TCC2-1 nil 3701454430 ("" (skeep) (("" (typepred "eS`redex") (("" (grind) nil nil)) nil)) nil) ((topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props record_update_self_TCC1 0 (record_update_self_TCC1-1 nil 3701454430 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil)) nil))("typed_reduction" typed_reduction if_well_typed_letApply 0 (if_well_typed_letApply-1 nil 3702729592 ("" (induct arity) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (delete 2) (("3" (skeep* :preds? t) (("3" (postpone) nil nil)) nil)) nil) ("4" (delete 2) (("4" (skeep* :preds? t) (("4" (use pure_contextPure) (("4" (use pure_letApply) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (delete 2) (("5" (skeep* :preds? t) (("5" (case-replace "list2finseq[nat](args_type)`length = length(args_type)") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil)) nil) nil shostak))("typed_reduction" typed_reduction if_well_typed_letApply_TCC8 0 (if_well_typed_letApply_TCC8-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC7 0 (if_well_typed_letApply_TCC7-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC6 0 (if_well_typed_letApply_TCC6-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC5 0 (if_well_typed_letApply_TCC5-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC4 0 (if_well_typed_letApply_TCC4-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC3 0 (if_well_typed_letApply_TCC3-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC2 0 (if_well_typed_letApply_TCC2-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC1 0 (if_well_typed_letApply_TCC1-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction make_redex_typed_TCC7 0 (make_redex_typed_TCC7-1 nil 3702819277 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction decref_new_values_TCC3 0 (decref_new_values_TCC3-1 nil 3702831701 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction decref_TCC17 0 (decref_TCC17-1 nil 3698762473 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (allcount const-decl "nat" rreduction nil) (allcountStore const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC16 0 (decref_TCC16-1 nil 3698762473 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_TCC15 0 (decref_TCC15-1 nil 3692972887 ("" (skeep*) (("" (ground) (("1" (lift-if) (("1" (ground) (("1" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (replace -6 :dir RL) (("1" (case "allcountStore(newrS) <= allcountStore(rS)") (("1" (typepred "v(newrS, r, i - 1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (use allcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred rS) (("3" (grind) nil nil)) nil) ("4" (use allcountStore_update_TCC1) (("4" (grind-with-ext) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil) ("3" (lift-if) (("3" (skeep*) (("3" (split -3) (("1" (flatten) (("1" (name-replace "newrS2" "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (typepred newrS2) (("1" (inst -3 s) (("1" (typepred "v(newrS, r, i - 1)") (("1" (inst -3 s) (("1" (hide (-8 -5 -4 -2 -1)) (("1" (flatten) (("1" (rewrite -9) (("1" (rewrite -1) (("1" (rewrite -4) (("1" (split 1) (("1" (grind) nil nil) ("2" (hide (-2 -3 -5)) (("2" (hide -4) (("2" (hide (-3 -4)) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (hide-all-but (1 -5 -9)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (rewrite -6) (("2" (delete 2) (("2" (use allcountStore_update) (("2" (delete -4) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("3" (rewrite -6) (("3" (delete -1 -2 -3) (("3" (typepred newrS2) (("3" (inst -3 r) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (rewrite -6) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred rS) (("3" (grind) nil nil)) nil) ("4" (use allcountStore_update_TCC1) (("4" (grind-with-ext) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (typepred "v(rS, r, i - 1)") (("1" (ground) (("1" (grind) nil nil) ("2" (inst -3 s) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (allcountStore_update_TCC1 subtype-tcc nil rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (allcountStore_update formula-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (allcountStore const-decl "nat" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC14 0 (decref_TCC14-1 nil 3692915538 ("" (skeep*) (("" (lift-if) (("" (prop) (("1" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (delete -2 -3 -4) (("1" (replace -3 -1 :dir RL) (("1" (lemma allcountStore_decrease) (("1" (inst -1 "rS" "rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1]" "refindex(subref)") (("1" (ground) (("1" (grind) nil nil)) nil) ("2" (expand refcount) (("2" (rewrite refcountStore_update) (("1" (typepred "rS`count(refindex(subref))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (lemma refcountStore_ref) (("1" (delete -4 3) (("1" (delete -2) (("1" (inst -1 "rS" "r" "refindex(subref)" "i - 1") (("1" (grind) (("1" (delete 3) (("1" (grind) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 -5)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred rS) (("3" (grind) nil nil)) nil) ("4" (expand refcount) (("4" (rewrite refcountStore_update) (("1" (typepred "rS`count(refindex(subref))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (lemma refcountStore_ref) (("1" (inst -1 "rS" "r" "refindex(subref)" "i - 1") (("1" (delete -3) (("1" (delete 3) (("1" (grind) (("1" (delete 3) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allcountStore const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_update formula-decl nil rreduction nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (allcountStore_decrease formula-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC13 0 (decref_TCC13-1 nil 3692915538 ("" (skeep*) (("" (ground) (("" (lift-if) (("" (ground) (("" (typepred "v(rS
                           WITH [`store(r)`seq(i - 1) := nil,
                                 `count(refindex(subref))
                                   := rS`count(refindex(subref)) - 1],
                         refindex(subref), rS`store(refindex(subref))`length)") (("1" (hide -2 -3) (("1" (lemma "allcountStore_decrease") (("1" (inst - "rS" "rS
                                   WITH [`store(r)`seq(i - 1) := nil,
                                         `count(refindex(subref))
                                           := rS`count(refindex(subref)) - 1]" "refindex(subref)") (("1" (ground) (("1" (typepred i) (("1" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "decref_TCC6") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (use "decref_TCC6") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (expand noDanglingRefs?) (("3" (typepred rS) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand refcount) (("4" (rewrite refcountStore_update) (("1" (typepred "rS`count(refindex(subref))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (use refcountStore_ref) (("1" (ground) (("1" (hide-all-but (1 -4 -1)) (("1" (rewrite -2) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 -4)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decref_TCC6 subtype-tcc nil rreduction nil) (allcountStore_decrease formula-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (allcountStore const-decl "nat" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC12 0 (decref_TCC12-1 nil 3692915538 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC11 0 (decref_TCC11-1 nil 3692915538 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC10 0 (decref_TCC10-1 nil 3692915538 ("" (skeep*) (("" (rewrite -6) (("" (use allcountStore_update) (("1" (ground) (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (< def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (allcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (allcountStore_update formula-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC9 0 (decref_TCC9-1 nil 3692915538 ("" (skeep*) (("" (lemma "allcountStore_decrease") (("" (inst?) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((allcountStore_decrease formula-decl nil rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (allcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC8 0 (decref_TCC8-1 nil 3692915538 ("" (skeep*) (("" (replace -6 :hide? t) (("" (assert) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC7 0 (decref_TCC7-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_TCC6 0 (decref_TCC6-1 nil 3692915538 ("" (skeep*) (("" (expand "refcount") (("" (rewrite "refcountStore_update") (("1" (ground) (("1" (typepred "rS`count(subrefindex)") (("1" (replace -1 :hide? t) (("1" (expand "refcount") (("1" (use "refcountStore_ref") (("1" (ground) (("1" (case "ref(refindex(subref)) = subref") (("1" (assert) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(subrefindex)") (("2" (expand "refcount") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (case "ref(refindex(subref)) = subref") (("1" (assert) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ((refcount const-decl "nat" rreduction nil) (int_plus_int_is_int application-judgement "int" integers nil) (refcountStore_ref formula-decl nil rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (refcountStore_update formula-decl nil rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC5 0 (decref_TCC5-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil)) nil))("rreduction" rreduction decref_TCC4 0 (decref_TCC4-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_TCC3 0 (decref_TCC3-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil)) nil))("rreduction" rreduction decref_TCC2 0 (decref_TCC2-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (allcount const-decl "nat" rreduction nil) (allcountStore const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_rreduction" typed_rreduction decref1_preserves_store_TCC2 0 (decref1_preserves_store_TCC2-1 nil 3702994821 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC11 0 (updateReduce_new_store_TCC11-1 nil 3702995511 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC10 0 (updateReduce_new_store_TCC10-1 nil 3702995511 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 nil 3702993203 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props releaseReduce_reduce_match_TCC1 0 (releaseReduce_reduce_match_TCC1-1 nil 3703360180 ("" (subtype-tcc) nil nil) nil nil))("creduction" creduction nth_cdr_TCC2 0 (nth_cdr_TCC2-1 nil 3703618864 ("" (subtype-tcc) nil nil) nil nil))("creduction" creduction stack_size_at_TCC8 0 (stack_size_at_TCC8-1 nil 3703854481 ("" (skeep* :preds? t) (("" (replace -2) (("" (expand clength -) (("" (lift-if) (("" (split -) (("1" (grind) nil nil) ("2" (flatten) (("2" (split) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clength def-decl "nat" creduction nil)) nil))("rreduction" rreduction reduce_stack_length 0 (reduce_stack_length-1 nil 3703860789 ("" (skeep* :preds? t) (("" (expand reduce :assert? none) (("" (name-replace t "to_topstate(grS)") (("" (case "atom?(t`redex)") (("1" (assert) (("1" (expand t) (("1" (expand to_topstate) (("1" (rewrite popdepth_fill) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (simplify :let-reduce? t) (("2" (name-replace nS "make_redex(t)") (("2" (lift-if) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand letReduce) (("1" (assert) (("1" (expand popDepth 1 (3 4 5)) (("1" (expand popDepth 1 3) (("1" (expand push) (("1" (expand add) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand applyReduce) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (rewrite popdepth_letApply) (("1" (rewrite popDepth_mark) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand ifReduce) (("1" (expand release_marked) (("1" (assert) (("1" (expand popDepth + (3 5)) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand lookupReduce) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand release_marked) (("1" (expand setRedex) (("1" (assert) (("1" (expand popDepth + 3) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand newintReduce) (("1" (postpone) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand newrefReduce) (("1" (postpone) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand popReduce) (("1" (lift-if) (("1" (expand pop) (("1" (split) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("creduction" creduction is_fun_call_at_TCC1 0 (is_fun_call_at_TCC1-1 nil 3703956313 ("" (subtype-tcc) nil nil) nil nil))("creduction" creduction extract_stat_TCC8 0 (extract_stat_TCC8-1 nil 3703876546 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (below type-eq-decl nil naturalnumbers nil) (executable_stat? const-decl "bool" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("creduction" creduction next_pc_TCC11 0 (next_pc_TCC11-1 nil 3703872785 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("creduction" creduction next_pc_TCC12 0 (next_pc_TCC12-1 nil 3703872785 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil) (clength def-decl "nat" creduction nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil)) nil))("creduction" creduction next_pc_TCC13 0 (next_pc_TCC13-1 nil 3703872785 ("" (skeep* :preds? t) (("" (lemma measure_stat_car) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_car formula-decl nil creduction nil) (clength def-decl "nat" creduction nil) (measure_stat def-decl "posnat" creduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (finseq2list const-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil))("creduction" creduction next_pc_TCC14 0 (next_pc_TCC14-1 nil 3703872785 ("" (skeep* :preds? t) (("" (typepred "v(car[cstat](finseq2list[cstat](stats)))(i)") (("" (replace -4) (("" (expand clength +) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq2list const-decl "list[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (below type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_stat def-decl "posnat" creduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (cstat type-decl nil creduction nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("creduction" creduction next_pc_TCC15 0 (next_pc_TCC15-1 nil 3703872785 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil)) nil))("creduction" creduction next_pc_TCC16 0 (next_pc_TCC16-1 nil 3703872785 ("" (skeep* :preds? t) (("" (split) (("1" (grind) nil nil) ("2" (replace -2) (("2" (expand clength -1) (("2" (lift-if -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil) (clength def-decl "nat" creduction nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("creduction" creduction next_pc_TCC17 0 (next_pc_TCC17-1 nil 3703872785 ("" (skeep* :preds? t) (("" (lemma measure_stat_cdr) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_cdr formula-decl nil creduction nil) (clength def-decl "nat" creduction nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (measure_stat def-decl "posnat" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil))("creduction" creduction next_pc_TCC18 0 (next_pc_TCC18-1 nil 3703872785 ("" (skeep* :preds? t) (("" (replace -2) (("" (expand clength 3 3) (("" (typepred "v(sblock(list2finseq[cstat](cdr[cstat](finseq2list[cstat](stats)))))
       (i - clength(car[cstat](finseq2list[cstat](stats))))") (("1" (lift-if) (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (finseq2list const-decl "list[T]" list2finseq nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (list type-decl nil list_adt nil) (sblock adt-constructor-decl "[finseq[cstat] -> (sblock?)]" creduction nil) (sblock? adt-recognizer-decl "[cstat -> boolean]" creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_stat def-decl "posnat" creduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (cstat type-decl nil creduction nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clength def-decl "nat" creduction nil)) nil))("creduction" creduction next_pc_TCC19 0 (next_pc_TCC19-1 nil 3703872785 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("creduction" creduction reduce_TCC24 0 (reduce_TCC24-1 nil 3704041017 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "below(cS`cdefs`length)")))("creduction" creduction reduce_TCC28 0 (reduce_TCC28-1 nil 3704041017 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cfun(e1)" "below(cS`cdefs`length)")))("creduction" creduction Definition_TCC1 0 (Definition_TCC1-1 nil 3703956313 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Definition subtype "clength(s1) - 1" "below(clength(s1))")))("creduction" creduction next_pc_no_overflow_TCC1 0 (next_pc_no_overflow_TCC1-1 nil 3704119039 ("" (subtype-tcc) nil nil) nil nil (next_pc_no_overflow subtype "clength(s1) - 1" "below(clength(s1))")))("creduction" creduction is_return_at_end_clength_TCC1 0 (is_return_at_end_clength_TCC1-1 nil 3704126932 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil)) shostak (is_return_at_end_clength_ subtype "s2" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC2 0 (is_return_at_end_clength_TCC2-1 nil 3704126938 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil)) shostak (is_return_at_end_clength_ subtype "thenc" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC3 0 (is_return_at_end_clength_TCC3-1 nil 3704126942 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil)) shostak (is_return_at_end_clength_ subtype "elsec" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC4 0 (is_return_at_end_clength_TCC4-1 nil 3704126945 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil)) shostak (is_return_at_end_clength_ subtype "0" "posnat")))("creduction" creduction is_return_at_end_clength_TCC5 0 (is_return_at_end_clength_TCC5-1 nil 3704126949 ("" (postpone) nil nil) nil shostak (is_return_at_end_clength_ subtype "car(finseq2list[cstat](stats))" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC6 0 (is_return_at_end_clength_TCC6-1 nil 3704126877 ("" (skeep* :preds? t) (("" (postpone) nil nil)) nil) nil shostak (is_return_at_end_clength_ subtype "sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats))))" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction reduce_TCC65 0 (reduce_TCC65-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (cstack_frame type-eq-decl nil creduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "lf`fdepth - 1" "nat")))("creduction" creduction stack_size_at_next_pc_TCC1 0 (stack_size_at_next_pc_TCC1-1 nil 3704131088 ("" (subtype-tcc) nil nil) nil nil (stack_size_at_next_pc subtype "next_pc(s1)(i)" "below(clength(s1))")))("creduction" creduction reduce_TCC18 0 (reduce_TCC15-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC19 0 (reduce_TCC19-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC22 0 (reduce_TCC18-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC23 0 (reduce_TCC23-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC27 0 (reduce_TCC22-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC28 0 (reduce_TCC28-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC31 0 (reduce_TCC25-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "lf`fpc + 1" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC32 0 (reduce_TCC32-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc))}")))("creduction" creduction reduce_TCC37 0 (reduce_TCC30-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "lf`fpc + 1" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC38 0 (reduce_TCC38-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc))}")))("creduction" creduction reduce_TCC43 0 (reduce_TCC35-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC44 0 (reduce_TCC44-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC46 0 (reduce_TCC37-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC47 0 (reduce_TCC47-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC51 0 (reduce_TCC41-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC52 0 (reduce_TCC52-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC54 0 (reduce_TCC43-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC55 0 (reduce_TCC55-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC60 0 (reduce_TCC48-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC61 0 (reduce_TCC61-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC64 0 (reduce_TCC51-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC65 0 (reduce_TCC65-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC69 0 (reduce_TCC55-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC70 0 (reduce_TCC70-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC75 0 (reduce_TCC60-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC76 0 (reduce_TCC76-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC79 0 (reduce_TCC63-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC80 0 (reduce_TCC80-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC81 0 (reduce_TCC64-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (cstack_frame type-eq-decl nil creduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC84 0 (reduce_TCC67-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)" "below(clength(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC85 0 (reduce_TCC85-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "nc`seq(nc`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body)(next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)) OR (k <= cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body)(next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)) AND is_return?(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body)(next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)))}")))("creduction" creduction reduce_TCC86 0 (reduce_TCC68-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "nc WITH [`seq(nc`length - 1)`fpc := next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)]" "{C: finseq[cstack_frame(cS`cdefs)] | FORALL (i: nat | i < C`length - 1): is_fun_call_at(cS`cdefs`seq(C`seq(i)`ffct)`body)(C`seq(i)`fpc, C`seq(1 + i)`ffct)}")))("creduction" creduction stack_size_at2_alt_TCC4 0 (stack_size_at2_alt_TCC4-1 nil 3705156410 ("" (subtype-tcc) nil nil) nil nil (stack_size_at2_alt subtype "finseq2list[cstat](stats)" "(cons?[cstat])")))("creduction" creduction reduce_TCC29 0 (reduce_TCC28-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "{f: below(cS`cdefs`length) | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction reduce_TCC34 0 (reduce_TCC33-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cfun(e1)" "{f: below(cS`cdefs`length) | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction reduce_TCC5 0 (reduce_TCC6-1 nil 3704127090 ("" (skeep* :preds? t) (("" (delete 4) (("" (typepred "lf`fdepth") (("" (split) (("1" (replace -1) (("1" (assert) (("1" (lemma stack_size_at_next_pc_decl_begin) (("1" (inst?) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (use next_pc_decl_begin_no_overflow) (("3" (split) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (next_pc_decl_begin_no_overflow formula-decl nil creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_size_at_next_pc_decl_begin formula-decl nil creduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil)) nil (reduce subtype "lf`fdepth - 1" "nat")))("creduction" creduction reduce_TCC6 0 (reduce_TCC5-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC11 0 (reduce_TCC10-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC14 0 (reduce_TCC12-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC18 0 (reduce_TCC14-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC22 0 (reduce_TCC17-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC25 0 (reduce_TCC21-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC30 0 (reduce_TCC24-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC35 0 (reduce_TCC29-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC37 0 (reduce_TCC34-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC41 0 (reduce_TCC36-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (builtin_num const-decl "nat" creduction nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC43 0 (reduce_TCC40-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (lvalue type-decl nil creduction nil) (lrvalue? const-decl "bool" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC48 0 (reduce_TCC42-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (lrvalue? const-decl "bool" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC51 0 (reduce_TCC47-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (lrvalue? const-decl "bool" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC55 0 (reduce_TCC50-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC60 0 (reduce_TCC54-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC63 0 (reduce_TCC59-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC65 0 (reduce_TCC62-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC16 0 (reduce_TCC20-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`store" "Store(IF x = cnil THEN cS`domain ELSE remove(crefindex(x), cS`domain) ENDIF)")))("creduction" creduction reduce_TCC20 0 (reduce_TCC26-1 nil 3704127090 ("" (skeep* :preds? t) (("" (case "cindex(args`seq(i)) + i < cS`stack`length") (("1" (grind) nil nil) ("2" (hide 4) (("2" (postpone) nil nil)) nil) ("3" (postpone) nil nil)) nil)) nil) nil nil (reduce subtype "cS`stack`length - 1 - i - cindex(args`seq(i))" "below[length(cS`stack)]")))("creduction" creduction reduce_TCC26 0 (reduce_TCC31-1 nil 3704127090 ("" (skeep* :preds? t) (("" (case "cindex(cargs(e1)`seq(i)) < cS`stack`length") (("1" (case "cindex(cargs(e1)`seq(i)) + i < cS`stack`length") (("1" (grind) nil nil) ("2" (hide 4) (("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) nil nil (reduce subtype "cS`stack`length - 1 - i - cindex(cargs(e1)`seq(i))" "below[length(cS`stack)]")))("creduction" creduction extra_size_at_expand_TCC1 0 (extra_size_at_expand_TCC1-1 nil 3705336017 ("" (subtype-tcc) nil nil) nil nil (extra_size_at_expand subtype "i - 1" "below(clength(s2))")))("creduction" creduction reduce_TCC32 0 (reduce_TCC29-1 nil 3705167090 ("" (skeep* :preds? t) (("" (replace -6 :dir RL) (("" (replace -7 :dir RL) (("" (expand is_fun_call_at +) (("" (flatten) (("" (replace* -8 -9 :dir RL) (("" (case "i < clength(s1)") (("1" (grind) nil nil) ("2" (typepred "extract_stat(fbody)(lf`fpc)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_fun_call_at const-decl "bool" creduction nil) (cstate type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Stack type-eq-decl nil creduction nil) (cvalue type-decl nil creduction nil) (finite_set type-eq-decl nil finite_sets nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (> const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (extract_stat def-decl "{s2, j | j < clength(s2) AND executable_stat?(s2, j)}" creduction nil) (executable_stat? const-decl "bool" creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil)) nil (reduce subtype "f" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction reduce_TCC40 0 (reduce_TCC34-1 nil 3705167090 ("" (skeep* :preds? t) (("" (case-replace "i = 2 * cargs(e1)`length") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil) ((mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (cexpr type-decl nil creduction nil) (ecall? adt-recognizer-decl "[cexpr -> boolean]" creduction nil) (below type-eq-decl nil nat_types nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq type-eq-decl nil finite_sequences nil) (cargs adt-accessor-decl "[(ecall?) -> finseq[(cvar?)]]" creduction nil) (is_fun_call_at const-decl "bool" creduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (reduce subtype "cfun(e1)" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction make_call_TCC2 0 (make_call_TCC2-1 nil 3705349460 ("" (subtype-tcc) nil nil) nil nil (make_call subtype "f" "below[cS`cdefs`length]")))("creduction" creduction reduce_TCC32 0 (reduce_TCC32-1 nil 3705349460 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity}")))("creduction" creduction reduce_TCC40 0 (reduce_TCC40-1 nil 3705349460 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cfun(e1)" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity}")))("creduction" creduction expected_stack_size_TCC1 0 (expected_stack_size_TCC1-1 nil 3705328350 ("" (skeep*) (("" (use below_finite) nil nil)) nil) ((cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (clength def-decl "nat" creduction nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_finite formula-decl nil finite_set_theorems nil)) nil (expected_stack_size subtype "(LAMBDA i: i < C`length)" "finite_set[nat]")))("creduction" creduction reduce_TCC71 0 (reduce_TCC71-1 nil 3705328350 ("" (skeep* :preds? t) (("" (typepred "cS`stack") (("" (rewrite -1) (("" (expand expected_stack_size) (("" (use fdepth_sum_eq) (("1" (split) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "cS`stack" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1)`fdepth := lf`fdepth - 1])}")))("finite_set_theorems" finite_set_theorems pick_new_TCC2 0 (pick_new_TCC2-1 nil 3649901266 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (complement const-decl "set" sets nil)) nil (pick_new subtype "(choose! j: complement(NS)(j))" "{j | NOT NS(j)}")))("creduction" creduction clength_TCC6 0 (clength_TCC6-1 nil 3703617429 ("" (skeep*) (("" (lemma measure_stat_cdr) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_cdr formula-decl nil creduction nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (measure_stat def-decl "posnat" creduction nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil (clength termination "clength(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats)))))" "nil")))("creduction" creduction stack_size_at_TCC6 0 (stack_size_at_TCC6-1 nil 3703854481 ("" (skeep* :preds? t) (("" (lemma measure_stat_cdr) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_cdr formula-decl nil creduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (clength def-decl "nat" creduction nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (measure_stat def-decl "posnat" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil (stack_size_at termination "stack_size_at(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats)))))" "nil")))("creduction" creduction stack_size_at_TCC7 0 (stack_size_at_TCC7-1 nil 3703854481 ("" (skeep* :preds? t) (("" (replace -2) (("" (expand clength -) (("" (lift-if -) (("" (split -) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clength def-decl "nat" creduction nil)) nil (stack_size_at subtype "i - clength(car(finseq2list[cstat](stats)))" "below(clength(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats))))))")))("creduction" creduction next_pc_TCC9 0 (next_pc_TCC9-1 nil 3703872785 ("" (skeep* :preds? t) (("" (typepred "v(sblock(list2finseq[cstat](cdr[cstat](finseq2list[cstat](stats)))))
        (i - clength(car[cstat](finseq2list[cstat](stats))))") (("1" (replace -3) (("1" (expand clength 2 3) (("1" (lift-if) (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (finseq2list const-decl "list[T]" list2finseq nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (list type-decl nil list_adt nil) (sblock adt-constructor-decl "[finseq[cstat] -> (sblock?)]" creduction nil) (sblock? adt-recognizer-decl "[cstat -> boolean]" creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_stat def-decl "posnat" creduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (cstat type-decl nil creduction nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (next_pc subtype "clength(car(finseq2list[cstat](stats))) + next_pc(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats)))))(i - clength(car(finseq2list[cstat](stats))))" "upto(clength(s1))")))("creduction" creduction make_call_TCC2 0 (make_call_TCC1-1 nil 3704041017 ("" (skeep* :preds? t) (("" (case-replace "x1 = cS`callstack`length") (("1" (expand add) (("1" (typepred "cS`cdefs`seq(f)`body") (("1" (split) (("1" (split) (("1" (grind) nil nil) ("2" (propax) nil nil) ("3" (rewrite stack_size_at_zero) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (expand add) (("2" (assert) (("2" (typepred "cS`callstack`seq(x1)`fpc") (("2" (split) (("1" (propax) nil nil) ("2" (typepred "cS`callstack`seq(x1)`fdepth") (("2" (grind) nil nil)) nil) ("3" (typepred "cS`callstack`seq(x1)`fdepth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (seq type-eq-decl nil more_finseq nil) (finseq type-eq-decl nil finite_sequences nil) (add const-decl "finseq[T]" more_finseq nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (below type-eq-decl nil naturalnumbers nil) (is_fun_call_at const-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (> const-decl "bool" reals nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (extra_size_at const-decl "nat" creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_size_at_zero formula-decl nil creduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (make_call subtype "add((# ffct := f, fpc := 0, fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)" "finseq[cstack_frame(cS`cdefs)]")))("creduction" creduction make_call_TCC3 0 (make_call_TCC3-1 nil 3704118130 ("" (skeep* :preds? t) (("" (split) (("1" (split) (("1" (skeep* :preds? t) (("1" (expand add) (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (grind) nil nil) ("2" (rewrite stack_size_at_zero) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "cS`callstack`seq(x1)`fdepth") (("1" (typepred "cS`callstack`seq(x1)`fpc") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (expand add) (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (typepred "cS`callstack") (("2" (inst -1 i) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ((rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even? const-decl "bool" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) nil nil nil (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_size_at_zero formula-decl nil creduction nil) (cstat type-decl nil creduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (extra_size_at const-decl "nat" creduction nil) (seq type-eq-decl nil more_finseq nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil)) nil (make_call subtype "add((# ffct := f, fpc := 0, fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)" "{C: finseq[cstack_frame(cS`cdefs)] | FORALL (i: nat | i < C`length - 1): is_fun_call_at(cS`cdefs`seq(C`seq(i)`ffct)`body)(C`seq(i)`fpc, C`seq(1 + i)`ffct)}")))("creduction" creduction make_call_TCC4 0 (make_call_TCC4-1 nil 3705328350 ("" (skeep* :preds? t) (("" (typepred "cS`stack") (("" (rewrite -1) (("" (expand expected_stack_size) (("" (assert) (("" (expand add) (("" (case-replace "extra_size_at(cS`cdefs`seq
                        (cS`callstack`seq
                             (cS`callstack`length - 1)`ffct)`body)
                   (cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity") (("" (rewrite extra_size_at_zero) (("" (expand fdepth_sum) (("" (lemma sigma_add) (("" (inst -1 "LAMBDA i: i < 1 + cS`callstack`length" "LAMBDA i:
               IF i < 1 + cS`callstack`length
                 THEN add((# ffct := f,
                                      fpc := 0,
                                      fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)`seq
                          (i)`fdepth
               ELSE 0
               ENDIF" "cS`callstack`length") (("1" (split) (("1" (expand add) (("1" (rewrite -1) (("1" (assert) (("1" (case-replace "remove(cS`callstack`length,
                    LAMBDA i: i < 1 + cS`callstack`length) = LAMBDA i: i < cS`callstack`length") (("1" (lemma sigma_eq) (("1" (inst -1 "LAMBDA i: i < cS`callstack`length" "LAMBDA i:
              IF i < cS`callstack`length THEN cS`callstack`seq(i)`fdepth
              ELSE 0
              ENDIF" _) (("1" (inst -1 "LAMBDA i:
               IF i < 1 + cS`callstack`length
                 THEN add((# ffct := f,
                                      fpc := 0,
                                      fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)`seq
                          (i)`fdepth
               ELSE 0
               ENDIF") (("1" (split) (("1" (expand add) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use below_finite) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (use below_finite) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cstate type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Stack type-eq-decl nil creduction nil) (cvalue type-decl nil creduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (clength def-decl "nat" creduction nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (add const-decl "finseq[T]" more_finseq nil) (extra_size_at_zero formula-decl nil creduction nil) (sigma_add formula-decl nil finite_set_theorems nil) (remove const-decl "set" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (even? const-decl "bool" integers nil) (below_finite formula-decl nil finite_set_theorems nil) (sigma_eq formula-decl nil finite_set_theorems nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (/= const-decl "boolean" notequal nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) nil (seq type-eq-decl nil more_finseq nil) nil (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (fdepth_sum const-decl "nat" creduction nil) (extra_size_at const-decl "nat" creduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (make_call subtype "cS`stack" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(add((# ffct := f, fpc := 0, fdepth := cS`cdefs`seq(f)`arity #), cS`callstack))}")))("creduction" creduction reduce_TCC5 0 (reduce_TCC5-1 nil 3705328350 ("" (skeep* :preds? t) (("" (expand add) (("" (typepred "cS`stack") (("" (rewrite -1) (("" (expand expected_stack_size) (("" (assert) (("" (replace* (-5 -6 -7 -8) :dir RL) (("" (assert) (("" (rewrite extra_size_at_next_pc) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "add(cundef, cS`stack)" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1) := lf WITH [`fdepth := 1 + lf`fdepth, `fpc := next_pc(fbody)(lf`fpc)]])}")))("creduction" creduction reduce_TCC24 0 (reduce_TCC23-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (add const-decl "(nonempty?)" sets nil)) nil (reduce subtype "least_out(cS`domain)" "(add(least_out(cS`domain), cS`domain))")))("creduction" creduction reduce_TCC28 0 (reduce_TCC28-1 nil 3705328350 ("" (skeep* :preds? t) (("" (expand expected_stack_size) (("" (expand fdepth_sum) (("" (assert) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "add(finseq_appl(cS`stack)(cS`stack`length - 1 - (i / 2) - cindex(args`seq(i / 2))), cS`stack)" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1) := cframe_next_pc(cS`cdefs)(lf)])}")))("creduction" creduction reduce_TCC36 0 (reduce_TCC36-1 nil 3705328350 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "add(finseq_appl(cS`stack)(cS`stack`length - 1 - (i / 2) - cindex(cargs(e1)`seq(i / 2))), cS`stack)" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1) := cframe_next_pc(cS`cdefs)(lf)])}")))("creduction" creduction expected_stack_size_TCC1 0 (expected_stack_size_TCC2-1 nil 3705328350 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (expected_stack_size subtype "C`length - 1" "below[C`length]")))("creduction" creduction reduce_TCC32 0 (reduce_TCC32-1 nil 3705431130 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND (f < cS`cdefs`length IMPLIES extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity)}")))("creduction" creduction reduce_TCC40 0 (reduce_TCC40-1 nil 3705431130 ("" (skeep* :preds? t) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand extra_size_at) (("2" (replace* (-6 -7 -8 -9) :dir RL) (("2" (assert) (("2" (replace -12) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "cfun(e1)" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND (f < cS`cdefs`length IMPLIES extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity)}")))("creduction" creduction reduce_TCC24 0 (reduce_TCC24-1 nil 3705684103 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (add const-decl "(nonempty?)" sets nil)) nil (reduce subtype "finite_set_theorems.least_out(cS`domain)" "(sets[nat].add(finite_set_theorems.least_out(cS`domain), cS`domain))")))("reduction" reduction letReduce_TCC5 0 (letReduce_TCC5-1 nil 3646200513 ("" (skeep*) (("" (ground) (("1" (typepred "gS`redex") (("1" (typepred gS) (("1" (skeep*) (("1" (expand refs -7) (("1" (inst -2 i) (("1" (delete -3 -4) (("1" (use pure_refs) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (typepred "gS`redex") (("2" (expand push) (("2" (expand add) (("2" (expand popDepth 1) (("2" (rewrite purePopDepth 1) (("1" (expand vars -6) (("1" (expand drop -6) (("1" (inst -2 i) (("1" (delete -3) (("1" (delete -1) (("1" (grind) (("1" (typepred "gS") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred gS) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (expand push) (("3" (expand add) (("3" (typepred "gS`redex") (("3" (typepred gS) (("3" (inst -4 i) (("3" (delete -2 -3) (("3" (expand popDepth 2 1) (("3" (rewrite -6) (("3" (rewrite purePopDepth 2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand popDepth 1 1) (("4" (expand push) (("4" (expand add) (("4" (typepred "gS`redex") (("4" (typepred gS) (("4" (rewrite purePopDepth 2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand contextPure?) (("5" (rewrite pure_contextPure) (("5" (typepred gS) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (letRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (pure_refs formula-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (pureLetRedex? const-decl "bool" IL nil) (add const-decl "finseq[T]" more_finseq nil) (purePopDepth formula-decl nil IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (drop const-decl "finite_set[nat]" IL nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (push const-decl "Stack" IL nil) (pure_contextPure formula-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction" reduction popReduce_TCC5 0 (popReduce_TCC5-1 nil 3650430902 ("" (ground) (("" (skeep*) (("" (case-replace "gS`redex = pop(body)") (("1" (typepred "gS`redex") (("1" (typepred gS) (("1" (replace -7) (("1" (split 2) (("1" (skeep) (("1" (expand refs -3) (("1" (inst -3 i) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (typepred "gS`stack") (("1" (expand popRedex?) (("1" (expand vars -5) (("1" (expand popDepth -5) (("1" (delete -6) (("1" (expand drop -5) (("1" (expand popDepth -6 1) (("1" (case-replace "value = ref(refindex(value))") (("1" (expand refs -4) (("1" (rewrite -4) (("1" (rewrite -9) (("1" (expand get -3) (("1" (replace -1 -3 :dir RL) (("1" (replace -3 3) (("1" (expand every -2) (("1" (expand domainValue? -2) (("1" (inst -2 "gS`stack`length - 1 -index(body)") (("1" (grind) nil nil) ("2" (inst -4 "index(body)-1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete -1) (("2" (delete -1) (("2" (grind-with-ext) nil nil)) nil)) nil) ("3" (typepred "get(stack)(body)") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (lift-if) (("2" (ground) (("1" (grind) nil nil) ("2" (typepred "get(stack)(body)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (inst -5 i) (("3" (lift-if) (("3" (ground) (("1" (grind) nil nil) ("2" (typepred "get(stack)(body)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lift-if) (("4" (ground) (("1" (grind) nil nil) ("2" (typepred "get(stack)(body)") (("2" (grind) nil nil)) nil)) nil)) nil) ("5" (lift-if) (("5" (ground) (("1" (grind) nil nil) ("2" (typepred "get(stack)(body)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (drop const-decl "finite_set[nat]" IL nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (atom? const-decl "bool" IL nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (pop const-decl "Stack" IL nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (IExpression_pop_extensionality formula-decl nil IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil)) nil))("rreduction" rreduction popReduce_TCC6 0 (popReduce_TCC6-1 nil 3699031813 ("" (skeep*) (("" (typepred "grS`redex") (("" (typepred "grS") (("" (expand popRedex?) (("" (ground) (("1" (expand atom?) (("1" (propax) nil nil)) nil) ("2" (expand atom?) (("2" (case-replace "grS`redex = pop(body)") (("1" (expand vars -6) (("1" (expand drop -6) (("1" (expand popDepth -6) (("1" (inst -6 "index(body) - 1") (("1" (grind) nil nil) ("2" (expand popDepth -7 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (bump const-decl "finite_set[nat]" IL nil) (markv const-decl "(variable?)" preprocess nil) (IExpression_pop_extensionality formula-decl nil IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (int_plus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (singleton const-decl "(singleton?)" sets nil) nil (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") nil (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (drop const-decl "finite_set[nat]" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (atom? const-decl "bool" IL nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC7 0 (popReduce_TCC7-1 nil 3699031813 ("" (skeep*) (("" (typepred stack) (("" (grind) (("" (typepred "grS`redex") (("" (typepred grS) (("" (inst -4 "index(pbody(grS`redex)) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (drop const-decl "finite_set[nat]" IL nil) (singleton const-decl "(singleton?)" sets nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (atom? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) nil (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC8 0 (popReduce_TCC8-1 nil 3699031813 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (popRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (atom? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (value? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction popReduce_TCC9 0 (popReduce_TCC9-1 nil 3699031813 ("" (skeep*) (("" (typepred "grS`redex") (("" (typepred "grS") (("" (inst -4 "index(body) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) nil (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (drop const-decl "finite_set[nat]" IL nil) (singleton const-decl "(singleton?)" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (atom? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC10 0 (popReduce_TCC10-1 nil 3699033156 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC11 0 (popReduce_TCC11-1 nil 3699033156 ("" (skeep*) (("" (typepred "grS`redex") (("" (typepred grS) (("" (grind) nil nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC12 0 (popReduce_TCC12-1 nil 3699033156 ("" (skeep* :preds? t) (("" (expand every) (("" (expand pop 3) (("" (skeep :preds? t) (("" (expand pop -1) (("" (lift-if) (("" (typepred "grS`stack") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (every const-decl "bool" finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (get const-decl "(value?)" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (atom? const-decl "bool" IL nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (neStack type-eq-decl nil IL nil) (> const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (Stack type-eq-decl nil IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (popRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (pop const-decl "Stack" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC13 0 (popReduce_TCC13-1 nil 3699033156 ("" (skeep* :preds? t) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep*) (("3" (inst -6 i) (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil) ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) nil (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil) (pop const-decl "Stack" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (singleton const-decl "(singleton?)" sets nil) (drop const-decl "finite_set[nat]" IL nil) nil (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC14 0 (popReduce_TCC14-1 nil 3699033156 ("" (skeep* :preds? t) (("" (typepred "grS`count(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (case-replace "pop(grS`stack
                    WITH [(seq)(stack`length - 1 - index(body)) := nil]) = IF index(body) = 0 THEN pop(grS`stack) ELSE pop(grS`stack) WITH [(seq)(stack`length - 1 - index(body)) := nil] ENDIF") (("1" (case "grS`stack = add(stack`seq(stack`length - 1), pop(stack))") (("1" (replace -1 3) (("1" (rewrite count_add) (("1" (replace -1 3 :dir RL) (("1" (lift-if) (("1" (lift-if) (("1" (replace -15) (("1" (simplify) (("1" (lift-if) (("1" (simplify) (("1" (rewrite count_update) (("1" (simplify) (("1" (expand pop) (("1" (expand refcountExpr) (("1" (case-replace "refs(grS`redex)(x1) = FALSE") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (simplify) (("1" (expand get) (("1" (replace -21 :dir RL) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (expand noDanglingRefs?) (("3" (inst -18 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("4" (expand noDanglingRefs?) (("4" (inst -15 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "index(body) = 0") (("1" (replace -1) (("1" (expand refcountExpr) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ("2" (delete 5) (("2" (inst -7 "index(body) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 4) (("2" (grind-with-ext) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil) ("2" (delete 4) (("2" (lift-if) (("2" (expand pop) (("2" (ground) (("1" (apply-extensionality 1) nil nil) ("2" (apply-extensionality 2) (("1" (lift-if) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil) ("3" (inst -5 "index(body) - 1") (("3" (grind) nil nil)) nil) ("4" (grind) nil nil) ("5" (inst -5 "index(body) - 1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (inst -5 "index(body) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (inst -5 "index(body) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (neStack type-eq-decl nil IL nil) (pop const-decl "Stack" IL nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (markv const-decl "(variable?)" preprocess nil) (bump const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) nil (odd_plus_odd_is_even application-judgement "even_int" integers nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (refcountExpr const-decl "nat" rreduction nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (drop const-decl "finite_set[nat]" IL nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (singleton const-decl "(singleton?)" sets nil) nil (atom? const-decl "bool" IL nil) (int_plus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) nil (get const-decl "(value?)" IL nil) (FALSE const-decl "bool" booleans nil) (count_update formula-decl nil finseq_theorems nil) (below type-eq-decl nil naturalnumbers nil) (count_add formula-decl nil finseq_theorems nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (add const-decl "finseq[T]" more_finseq nil) (seq type-eq-decl nil more_finseq nil) nil (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC15 0 (popReduce_TCC15-1 nil 3699033156 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) nil (drop const-decl "finite_set[nat]" IL nil) (singleton const-decl "(singleton?)" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC16 0 (popReduce_TCC16-1 nil 3699301654 ("" (skeep* :preds? t) (("" (expand every) (("" (expand pop) (("" (skeep* :preds? t) (("" (expand pop) (("" (inst? -12) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every const-decl "bool" finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil nil (below type-eq-decl nil naturalnumbers nil) nil (noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (neStack type-eq-decl nil IL nil) (> const-decl "bool" reals nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (pop const-decl "Stack" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC17 0 (popReduce_TCC17-1 nil 3699301654 ("" (skeep* :preds? t) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep*) (("3" (inst -6 i) (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil) ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) nil (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (pop const-decl "Stack" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (singleton const-decl "(singleton?)" sets nil) (drop const-decl "finite_set[nat]" IL nil) nil (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC18 0 (popReduce_TCC18-1 nil 3699301654 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC19 0 (popReduce_TCC19-1 nil 3699301654 ("" (skeep* :preds? t) (("" (typepred "grS`count(refindex(value))") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (case "grS`stack = add(grS`stack`seq(grS`stack`length - 1), pop(grS`stack))") (("1" (replace -1 4) (("1" (rewrite count_add) (("1" (replace -1 4 :dir RL) (("1" (expand refcountExpr) (("1" (case-replace "refs(value)(refindex(value)) = TRUE") (("1" (case-replace "refs(grS`redex)(refindex(value)) = FALSE") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (simplify) (("1" (split 5) (("1" (flatten) (("1" (expand noDanglingRefs?) (("1" (inst -14 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand noDanglingRefs?) (("2" (inst -12 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 5) (("2" (grind-with-ext) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pop const-decl "Stack" IL nil) (neStack type-eq-decl nil IL nil) (> const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (add const-decl "finseq[T]" more_finseq nil) (seq type-eq-decl nil more_finseq nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_add formula-decl nil finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (FALSE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) nil (below type-eq-decl nil naturalnumbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (bumpn const-decl "finite_set[nat]" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) nil (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (drop const-decl "finite_set[nat]" IL nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bump const-decl "finite_set[nat]" IL nil) (markv const-decl "(variable?)" preprocess nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC20 0 (popReduce_TCC20-1 nil 3699301654 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((odd_plus_even_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil (drop const-decl "finite_set[nat]" IL nil) (singleton const-decl "(singleton?)" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) nil (IExpression type-decl nil IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC21 0 (popReduce_TCC21-1 nil 3699301654 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (popRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (atom? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) nil (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (pop const-decl "Stack" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction popReduce_TCC22 0 (popReduce_TCC22-1 nil 3699301654 ("" (skeep* :preds? t) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep*) (("3" (inst -6 i) (("3" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (skeep*) (("9" (inst -6 i) (("9" (grind) nil nil)) nil)) nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil)) nil)) nil) ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (singleton const-decl "(singleton?)" sets nil) (drop const-decl "finite_set[nat]" IL nil) nil (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (pop const-decl "Stack" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction popReduce_TCC23 0 (popReduce_TCC23-1 nil 3699301654 ("" (skeep*) (("" (typepred "grS`count(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (case "grS`stack = add(grS`stack`seq(grS`stack`length - 1), pop(grS`stack))") (("1" (replace -1) (("1" (rewrite count_add) (("1" (replace -1 :dir RL) (("1" (typepred grS) (("1" (expand noDanglingRefs?) (("1" (inst -2 0) (("1" (expand refcountExpr) (("1" (case-replace "refs(grS`redex)(x1) = FALSE") (("1" (case-replace "refs(value)(x1) = FALSE") (("1" (lift-if) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil) ("2" (delete 6) (("2" (typepred value) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (delete 6) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "grS`redex") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "grS`redex") (("2" (grind-with-ext) (("1" (typepred "grS`redex") (("1" (typepred grS) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred grS) (("2" (grind) nil nil)) nil) ("3" (typepred grS) (("3" (grind) nil nil)) nil) ("4" (typepred grS) (("4" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred grS) (("3" (typepred "grS`redex") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (popRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pop const-decl "Stack" IL nil) (neStack type-eq-decl nil IL nil) (> const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (add const-decl "finseq[T]" more_finseq nil) (seq type-eq-decl nil more_finseq nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (count_add formula-decl nil finseq_theorems nil) nil (below type-eq-decl nil naturalnumbers nil) (FALSE const-decl "bool" booleans nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (singleton const-decl "(singleton?)" sets nil) nil (get const-decl "(value?)" IL nil) (atom? const-decl "bool" IL nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (refcountExpr const-decl "nat" rreduction nil) (drop const-decl "finite_set[nat]" IL nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (count const-decl "nat" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (refcountStack const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction letReduce_TCC6 0 (letReduce_TCC6-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (pureLetRedex? const-decl "bool" IL nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (atom? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction letReduce_TCC7 0 (letReduce_TCC7-1 nil 3699107903 ("" (skeep*) (("" (typepred "grS`count(refindex(value))") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountExpr) (("" (typepred "grS") (("" (case-replace "grS`redex = letexpr(letrhs(expr), body(expr))") (("1" (expand refs 2 1) (("1" (case-replace "refs(letrhs(expr))(refindex(value)) = FALSE") (("1" (case-replace "refs(nredex)(refindex(value)) = FALSE") (("1" (expand refcountStack) (("1" (expand push) (("1" (rewrite count_add) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if) (("2" (expand refs 1) (("2" (expand refs 1 1) (("2" (use pure_refs) (("2" (typepred grS) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pureLetRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression_letexpr_extensionality formula-decl nil IExpression_adt nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (add const-decl "finseq[T]" more_finseq nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (push const-decl "Stack" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (get const-decl "(value?)" IL nil) (letRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (count_add formula-decl nil finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (pure_refs formula-decl nil IL nil) (FALSE const-decl "bool" booleans nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refcountExpr const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction letReduce_TCC8 0 (letReduce_TCC8-1 nil 3699107903 ("" (skeep*) (("" (typepred "grS`count(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (expand push) (("" (rewrite count_add) (("" (ground) (("" (replace -1) (("" (simplify) (("" (expand refcountExpr) (("" (case-replace "refs(nredex)(x1) = FALSE") (("1" (lift-if) (("1" (ground) (("1" (case-replace "grS`redex = letexpr(letrhs(expr), body(expr))") (("1" (expand refs -2) (("1" (grind) nil nil)) nil) ("2" (grind-with-ext) nil nil)) nil) ("2" (case-replace "grS`redex = letexpr(letrhs(expr), body(expr))") (("1" (expand refs -2) (("1" (grind) nil nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (replace -6) (("2" (delete 3) (("2" (lift-if) (("2" (expand refs) (("2" (expand refs 1 1) (("2" (use pure_refs) (("2" (typepred grS) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureLetRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (push const-decl "Stack" IL nil) (FALSE const-decl "bool" booleans nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (IExpression_letexpr_extensionality formula-decl nil IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (pure_refs formula-decl nil IL nil) (letRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (refcountExpr const-decl "nat" rreduction nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (count_add formula-decl nil finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction letReduce_TCC9 0 (letReduce_TCC9-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (value? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction letReduce_TCC10 0 (letReduce_TCC10-1 nil 3699107903 ("" (skeep*) (("" (expand every) (("" (skeep*) (("" (expand push) (("" (expand add) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (typepred "grS`redex") (("1" (expand domainValue?) (("1" (flatten) (("1" (inst? -1) (("1" (typepred grS) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred stack) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every const-decl "bool" finseq_theorems nil) (push const-decl "Stack" IL nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (pureLetRedex? const-decl "bool" IL nil) (add const-decl "finseq[T]" more_finseq nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction letReduce_TCC11 0 (letReduce_TCC11-1 nil 3699107903 ("" (skeep*) (("" (split) (("1" (expand refs) (("1" (use pure_refs) (("1" (typepred "grS") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand vars) (("2" (expand drop) (("2" (expand popDepth) (("2" (expand push) (("2" (expand add) (("2" (skeep*) (("2" (typepred "grS`redex") (("2" (inst -2 i) (("2" (rewrite purePopDepth 1) (("1" (typepred grS) (("1" (grind) nil nil)) nil) ("2" (typepred grS) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (expand popDepth 1 1) (("3" (rewrite purePopDepth) (("1" (typepred "grS`redex") (("1" (expand push) (("1" (expand add) (("1" (inst -3 i) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred grS) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (expand popDepth 1 1) (("4" (rewrite purePopDepth) (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil) ("2" (typepred grS) (("2" (grind) nil nil)) nil)) nil)) nil) ("5" (expand contextPure?) (("5" (use pure_contextPure) (("5" (grind) (("5" (typepred grS) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (expand mark) (("6" (decompose-equality) (("6" (typepred "grS`redex") (("6" (case-replace "grS`redex = letexpr(letrhs(expr), body(expr))") (("1" (expand mark -7) (("1" (decompose-equality -7) (("1" (lift-if -2) (("1" (split -2) (("1" (grind) nil nil) ("2" (case "top_releases(release(variable(0, TRUE),
              mark(bump(cvars(grS`context)))(body(expr))))
       = top_releases(body(expr))") (("1" (expand top_releases -1 1) (("1" (rewrite top_releases_mark) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pure_refs formula-decl nil IL nil) (pureLetRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (atom? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refs def-decl "bool" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (drop const-decl "finite_set[nat]" IL nil) (push const-decl "Stack" IL nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (purePopDepth formula-decl nil IL nil) (add const-decl "finseq[T]" more_finseq nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (pure_contextPure formula-decl nil IL nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (bump const-decl "finite_set[nat]" IL nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression_pop_extensionality formula-decl nil IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (release? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (release adt-constructor-decl "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil) (variable adt-constructor-decl "[[nat, bool] -> (variable?)]" IExpression_adt nil) (TRUE const-decl "bool" booleans nil) (top_releases_mark formula-decl nil preprocess nil) (top_releases def-decl "nat" preprocess nil) (IExpression_letexpr_extensionality formula-decl nil IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction letReduce_TCC12 0 (letReduce_TCC12-1 nil 3699276705 ("" (skeep*) (("" (typepred "grS`count(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (expand push) (("" (rewrite count_add) (("" (expand refcountExpr) (("" (expand refs 2 2) (("" (case-replace "refs(body(expr))(x1) = FALSE") (("1" (typepred "grS") (("1" (case-replace "grS`redex = letexpr(letrhs(expr), body(expr))") (("1" (expand refs 3 1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (replace -4) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (use pure_refs) (("2" (typepred grS) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureLetRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (push const-decl "Stack" IL nil) (refcountExpr const-decl "nat" rreduction nil) (FALSE const-decl "bool" booleans nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (letRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (IExpression_letexpr_extensionality formula-decl nil IExpression_adt nil) (pure_refs formula-decl nil IL nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (count_add formula-decl nil finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction variableReduce_TCC2 0 (variableReduce_TCC2-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (variableReduce subtype "IExpression_adt.letrhs(expr)" "{x | IExpression_adt.index(IL.x) < stack`length}")))("rreduction" rreduction variableReduce_TCC3 0 (variableReduce_TCC3-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (variableReduce subtype "IL.get(stack)(IExpression_adt.letrhs(expr))" "(IL.domainValue?(grS`domain))")))("rreduction" rreduction variableReduce_TCC5 0 (variableReduce_TCC5-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (variableReduce subtype "stack`length - 1 - IExpression_adt.index(grS`redex)" "below[grS`stack`length]")))("rreduction" rreduction variableReduce_TCC8 0 (variableReduce_TCC8-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (variableReduce subtype "grS`count" "[i: (grS`domain) -> {j | j = refcount(grS`domain, grS`store, grS`stack WITH [`seq(stack`length - 1 - IExpression_adt.index(grS`redex)) := IExpression_adt.nil], value)(i)}]")))("typed_reduction" typed_reduction typed_reduce_TCC9 0 (typed_reduce_TCC9-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (apply-eta "nS`state`redex" "(letexpr?)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (add const-decl "finseq[T]" more_finseq nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression_letexpr_eta formula-decl nil IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC10 0 (typed_reduce_TCC10-1 nil 3701716715 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "nS`stack_types") (("1" (expand letReduce) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (with-labels (typepred "nS`stack_types") ((sll slv))) (("2" (case-replace "i = nS`stack_types`length") (("1" (expand add) (("1" (expand letReduce) (("1" (replace sll +) (("1" (expand push) (("1" (expand add) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (inst slv "nS`stack_types`length - 1 - index(letrhs(nS`state`redex))") (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "nS`state`redex") ((href hvar hcvar hsl hcp))) (("2" (inst hvar "index(letrhs(nS`state`redex))") (("2" (split hvar) (("1" (grind) nil nil) ("2" (apply-eta "nS`state`redex" "(letexpr?)") (("2" (replace -1 :dir RL) (("2" (expand vars) (("2" (expand union) (("2" (expand member) (("2" (simplify) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "value?(letrhs(nS`state`redex))") (("1" (typepred "nS`redex_type") (("1" (apply-eta "nS`state`redex" "(letexpr?)") (("1" (replace -1 :dir RL) (("1" (simplify) (("1" (expand is_well_typed) (("1" (flatten) (("1" (rewrite value_well_typed) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand add) (("2" (lift-if) (("2" (assert) (("2" (expand letReduce) (("2" (lift-if) (("2" (expand push) (("2" (expand add) (("2" (inst slv i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((letReduce const-decl "estate" reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (push const-decl "Stack" IL nil) (get const-decl "(value?)" IL nil) (add const-decl "finseq[T]" more_finseq nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_letexpr_eta formula-decl nil IExpression_adt nil) (member const-decl "bool" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (singleton const-decl "(singleton?)" sets nil) (drop const-decl "finite_set[nat]" IL nil) (union const-decl "set" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (refs def-decl "bool" IL nil) (int_plus_int_is_int application-judgement "int" integers nil) (value_well_typed formula-decl nil typed_reduction nil) (lrhs adt-accessor-decl "[(lett?) -> typeinfo]" typeinfo_adt nil) (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil) (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (seq type-eq-decl nil more_finseq nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC11 0 (typed_reduce_TCC11-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand letReduce) (("" (expand is_well_typed) (("" (typepred "nS`redex_type") (("" (apply-eta "nS`state`redex" "(letexpr?)") (("" (replace -1 :dir RL) (("" (assert) (("" (expand is_well_typed -) (("" (case-replace "popn(nS`stack_types, popDepth(letrhs(nS`state`redex))) = nS`stack_types") (("1" (assert) nil nil) ("2" (case-replace "popDepth(letrhs(nS`state`redex)) = 0") (("1" (use popn_zero) nil nil) ("2" (expand pureLetRedex?) (("2" (expand letRedex?) (("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((letReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popn_zero formula-decl nil typed_reduction nil) (letRedex? const-decl "bool" IL nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (add const-decl "finseq[T]" more_finseq nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fill def-decl "IExpression" IL nil) (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression_letexpr_eta formula-decl nil IExpression_adt nil) (is_well_typed def-decl "bool" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC12 0 (typed_reduce_TCC12-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand letReduce) (("" (expand popDepth) (("" (rewrite purePopDepth) (("1" (assert) (("1" (case-replace "popn(add(lettype(nS`redex_type), nS`stack_types), 1) = nS`stack_types") (("1" (typepred "nS`context_type") (("1" (case-replace "popDepth(nS`state`redex) = 0") (("1" (expand expr_type +) (("1" (case "lett?(nS`redex_type)") (("1" (grind) nil nil) ("2" (typepred "nS`redex_type") (("2" (apply-eta "nS`state`redex" "(letexpr?)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (apply-eta "nS`state`redex" "(letexpr?)") (("1" (case "atom?(letrhs(nS`state`redex))") (("1" (replace -2 :dir RL) (("1" (expand popDepth) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand add) (("2" (expand popn) (("2" (decompose-equality) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((letReduce const-decl "estate" reduction nil) (purePopDepth formula-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lettype adt-accessor-decl "[(lett?) -> nat]" typeinfo_adt nil) (lett? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (add const-decl "finseq[T]" more_finseq nil) (seq type-eq-decl nil more_finseq nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (IExpression_letexpr_eta formula-decl nil IExpression_adt nil) (int_plus_int_is_int application-judgement "int" integers nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fill def-decl "IExpression" IL nil) (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC13 0 (typed_reduce_TCC13-1 nil 3701716715 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC14 0 (typed_reduce_TCC14-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand applyReduce) (("" (assert) (("" (typepred "nS`dom_types") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((applyReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC15 0 (typed_reduce_TCC15-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand applyReduce) (("" (assert) (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((applyReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC16 0 (typed_reduce_TCC16-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand applyReduce) (("" (case "fun(nS`state`redex) < D`length") (("1" (assert) (("1" (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) nil nil))("typed_reduction" typed_reduction typed_reduce_TCC17 0 (typed_reduce_TCC17-1 nil 3701716715 ("" (skeep* :preds? t) (("" (case-replace "popDepth(applyReduce(D)(nS`state)`redex) = 0") (("1" (expand applyReduce) (("1" (assert) (("1" (typepred "nS`context_type") (("1" (assert) (("1" (case-replace "popDepth(nS`state`redex) = 0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand applyReduce 1) (("2" (lift-if) (("2" (ground) (("1" (rewrite popdepth_letApply) (("1" (lift-if) (("1" (ground) (("1" (rewrite purePopDepth) nil nil) ("2" (typepred "args(nS`state`redex)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (applyRedex? const-decl "bool" IL nil) (applyReduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (popn_zero formula-decl nil typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (length def-decl "nat" list_props nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popdepth_letApply formula-decl nil reduction nil) (purePopDepth formula-decl nil IL nil) (pure_letApply rec-application-judgement "(pure?)" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC18 0 (typed_reduce_TCC18-1 nil 3701716715 ("" (grind) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (popDepth def-decl "nat" IL nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC19 0 (typed_reduce_TCC19-1 nil 3701716715 ("" (skeep* :preds? t) (("" (case-replace "reduce(D)(tS`state) = ifReduce(D)(nS`state)") (("1" (typepred "nS`dom_types") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (reduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (pureIftRedex? const-decl "bool" IL nil) (ifReduce const-decl "estate" reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (letReduce const-decl "estate" reduction nil) (applyRedex? const-decl "bool" IL nil) (applyReduce const-decl "estate" reduction nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (updateReduce const-decl "estate" reduction nil) (lookupRedex? const-decl "bool" IL nil) (lookupReduce const-decl "estate" reduction nil) (newintRedex? const-decl "bool" IL nil) (newintReduce const-decl "estate" reduction nil) (newrefRedex? const-decl "bool" IL nil) (newrefReduce const-decl "estate" reduction nil) (popRedex? const-decl "bool" IL nil) (pop const-decl "Stack" IL nil) (popReduce const-decl "estate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC20 0 (typed_reduce_TCC20-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand ifReduce) (("" (typepred "nS`stack_types") (("" (assert) nil nil)) nil)) nil)) nil) ((ifReduce const-decl "estate" reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC21 0 (typed_reduce_TCC21-1 nil 3701716715 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC22 0 (typed_reduce_TCC22-1 nil 3701716715 ("" (skeep* :preds? t) (("" (with-labels (typepred "nS`state`redex") ((href hvar hcvar hsl hcp))) (("" (inst hvar "index(condition(nS`state`redex))") (("" (split hvar) (("1" (grind) nil nil) ("2" (apply-eta "nS`state`redex" "(ift?)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (add const-decl "(nonempty?)" sets nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (IExpression_ift_eta formula-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (condition adt-accessor-decl "[(ift?) -> (variable?)]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC23 0 (typed_reduce_TCC23-1 nil 3701716715 ("" (skeep* :preds? t) (("" (apply-eta "nS`state`redex" "(ift?)") (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)) nil) ((IExpression_ift_eta formula-decl nil IExpression_adt nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (get const-decl "(value?)" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC24 0 (typed_reduce_TCC24-1 nil 3701716715 ("" (skeep* :preds? t) (("" (apply-eta "nS`state`redex" "(ift?)") (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)) nil) ((IExpression_ift_eta formula-decl nil IExpression_adt nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (get const-decl "(value?)" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC25 0 (typed_reduce_TCC25-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand ifReduce) (("" (lift-if) (("" (typepred "nS`redex_type") (("" (apply-eta "nS`state`redex" "(ift?)") (("1" (replace -1 :dir RL) (("1" (simplify) (("1" (expand is_well_typed -) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((ifReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression_ift_eta formula-decl nil IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC26 0 (typed_reduce_TCC26-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand ifReduce) (("" (assert) (("" (typepred "nS`redex_type") (("" (typepred "nS`context_type") (("" (apply-eta "nS`state`redex" "(ift?)") (("1" (replace -1 :dir RL) (("1" (simplify) (("1" (expand is_well_typed -) (("1" (case-replace "expr_type(nS`redex_type) = expr_type(tthen(nS`redex_type))") (("1" (expand popDepth -) (("1" (case-replace "popDepth(elseexpr(nS`state`redex)) = 0") (("1" (case-replace "popDepth(thenexpr(nS`state`redex)) = 0") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (use purePopDepth) (("2" (grind) nil nil)) nil)) nil) ("2" (use purePopDepth) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ifReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression_ift_eta formula-decl nil IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (tthen adt-accessor-decl "[(iftt?) -> typeinfo]" typeinfo_adt nil) (iftt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (elseexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (purePopDepth formula-decl nil IL nil) (popn_zero formula-decl nil typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (get const-decl "(value?)" IL nil) (thenexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC27 0 (typed_reduce_TCC27-1 nil 3701716715 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC28 0 (typed_reduce_TCC28-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (expand updateRedex?) (("" (grind) nil nil)) nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (cvars def-decl "finite_set[nat]" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC29 0 (typed_reduce_TCC29-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (cvars def-decl "finite_set[nat]" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC30 0 (typed_reduce_TCC30-1 nil 3701716715 ("" (with-labels (skeep* :preds? t) ((tsr defswt natom ttop upr ifr apr letr nst obj))) (("" (split obj) (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil) ("2" (with-labels (skeep* obj :preds? t) ((jl rdom obj))) (("2" (name-replace "nS2" "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn                      WITH [(least_out(nS`state`domain))n                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (case-replace "nS`state = nS2`state") (("1" (expand updateReduce) (("1" (split rdom) (("1" (flatten rdom) (("1" (assert) (("1" (lift-if) (("1" (split obj) (("1" (flatten) (("1" (replace -1) (("1" (case-replace "nS2`dom_types(least_out(nS2`state`domain)) = leaftype(nS`redex_type) - 1") (("1" (case-replace "nS`redex_type = nS2`redex_type") (("1" (typepred "nS2`dom_types") (("1" (inst -1 "refindex(get(nS2`state`stack)(target(nS2`state`redex)))" j) (("1" (simplify) (("1" (lift-if) (("1" (split obj) (("1" (flatten) (("1" (replace -1) (("1" (typepred "nS2`redex_type") (("1" (case "update?(nS2`state`redex)") (("1" (assert) (("1" (expand is_well_typed -2) (("1" (flatten) (("1" (expand is_well_typed -5) (("1" (typepred "nS2`stack_types") (("1" (expand get) (("1" (inst -2 "nS2`state`stack`length - 1 - index(rhs(nS2`state`redex))") (("1" (grind) nil nil) ("2" (typepred "nS2`state`redex") (("2" (inst -2 "index(rhs(nS2`state`redex))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nS2`redex_type") (("2" (case "update?(nS2`state`redex)") (("1" (assert) (("1" (expand is_well_typed -2) (("1" (flatten) (("1" (expand is_well_typed -3) (("1" (case "value_of_type(get(nS2`state`stack)(target(nS2`state`redex)), leaftype(nS2`redex_type), nS2`dom_types)") (("1" (grind) nil nil) ("2" (typepred "nS2`stack_types") (("2" (expand get) (("2" (inst?) (("1" (grind) nil nil) ("2" (typepred "nS2`state`redex") (("2" (inst -2 "index(target(nS2`state`redex))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "nS2`dom_types") (("2" (flatten) (("2" (inst -1 r j) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten rdom) (("2" (assert) (("2" (typepred "nS2`dom_types") (("2" (inst -1 r j) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (cvars def-decl "finite_set[nat]" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ifReduce const-decl "estate" reduction nil) (get const-decl "(value?)" IL nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC31 0 (typed_reduce_TCC31-1 nil 3701716715 ("" (skeep* :preds? t) (("" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (expand updateReduce) (("1" (assert) (("1" (typepred "nS2`stack_types") (("1" (expand nS2) (("1" (skeep) (("1" (inst -2 i) (("1" (grind) nil nil) ("2" (expand nS2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil) ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (updateReduce const-decl "estate" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC32 0 (typed_reduce_TCC32-1 nil 3701716715 ("" (skeep* :preds? t) (("" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)") (("1" (case-replace "nS`dom_typesn                      WITH [(least_out(nS`state`domain))n                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (expand updateReduce) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand is_well_typed) (("1" (expand nS2) (("1" (expand set_new_type) (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nS2`redex_type") (("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (updateReduce const-decl "estate" reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC33 0 (typed_reduce_TCC33-1 nil 3701716715 ("" (skeep* :preds? t) (("" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) -1)") (("1" (case-replace "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (case-replace "popDepth(updateReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)") (("1" (expand updateReduce +) (("1" (assert) (("1" (typepred "nS2`context_type") (("1" (expand nS2) (("1" (expand set_new_type) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand updateReduce) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (expand popDepth) (("1" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (updateReduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (get const-decl "(value?)" IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC34 0 (typed_reduce_TCC34-1 nil 3701716715 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC35 0 (typed_reduce_TCC35-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand lookupReduce) (("" (assert) (("" (typepred "nS`dom_types") (("" (inst -1 r j) nil nil)) nil)) nil)) nil)) nil) ((lookupReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (lookupRedex? const-decl "bool" IL nil) (goodstate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (Defs type-eq-decl nil reduction nil) (Definition type-eq-decl nil reduction nil) (pure? def-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC36 0 (typed_reduce_TCC36-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand lookupReduce) (("" (assert) (("" (typepred "nS`stack_types") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((lookupReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC37 0 (typed_reduce_TCC37-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand lookupReduce) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (typepred "nS`dom_types") (("1" (inst?) (("1" (typepred "nS`redex_type") (("1" (case "lookup?(nS`state`redex)") (("1" (assert) (("1" (expand is_well_typed -) (("1" (expand is_well_typed -) (("1" (typepred "nS`stack_types") (("1" (inst -2 "nS`stack_types`length - 1 - index(arrayvalue(nS`state`redex))") (("1" (replace -1) (("1" (expand get) (("1" (assert) (("1" (expand value_of_type -2) (("1" (rewrite value_well_typed +) (("1" (case-replace "nS`dom_typesn                        (refindex((nS`state`stack`seqn                                       (nS`state`stack`length - 1n                                        -n                                        indexn                                        (arrayvalue(nS`state`redex)))))) = leaftype(nS`redex_type)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (typepred "nS`state`redex") (("3" (inst -2 "index(arrayvalue(nS`state`redex))") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`state`redex") (("2" (inst -2 "index(arrayvalue(nS`state`redex))") (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "nS`state`redex") (("3" (inst -2 "index(position(nS`state`redex))") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "nS`state`redex") (("2" (inst -2 "index(arrayvalue(nS`state`redex))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nS`redex_type") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lookupReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (lookupRedex? const-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (member const-decl "bool" sets nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (add const-decl "(nonempty?)" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (refs def-decl "bool" IL nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (value_well_typed formula-decl nil typed_reduction nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (Stack type-eq-decl nil IL nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC38 0 (typed_reduce_TCC38-1 nil 3701716715 ("" (skeep* :preds? t) (("" (case-replace "popDepth(lookupReduce(D)(nS`state)`redex) = popDepth(nS`state`redex)") (("1" (expand lookupReduce +) (("1" (assert) nil nil)) nil) ("2" (typepred "nS`context_type") (("2" (expand lookupReduce) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (typepred "nS`state`storen                   (refindex(get(nS`state`stack)n                                (arrayvalue(nS`state`redex))))`seqn                   (value(get(nS`state`stack)(position(nS`state`redex))))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (lookupRedex? const-decl "bool" IL nil) (lookupReduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC39 0 (typed_reduce_TCC39-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (popDepth def-decl "nat" IL nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (cvars def-decl "finite_set[nat]" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC40 0 (typed_reduce_TCC40-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC41 0 (typed_reduce_TCC41-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC42 0 (typed_reduce_TCC42-1 nil 3701716715 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil) ("2" (skeep* :preds? t) (("2" (name-replace nS2 "set_new_type(nS, 0)") (("2" (case-replace "nS`dom_typesn                      WITH [(least_out(nS`state`domain))n                              |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (expand newintReduce) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (expand value_of_type) (("1" (expand nS2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nS2`dom_types") (("2" (inst -1 r j) (("1" (expand nS2) (("1" (expand set_new_type) (("1" (propax) nil nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (assert) nil nil)) nil)) nil) ("3" (expand nS2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (typeinfo type-decl nil typeinfo_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (< const-decl "bool" reals nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (estate type-eq-decl nil reduction nil) (below type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (newintReduce const-decl "estate" reduction nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC43 0 (typed_reduce_TCC43-1 nil 3701716715 ("" (skeep* :preds? t) (("" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (expand newintReduce) (("1" (typepred "nS2`stack_types") (("1" (expand nS2) (("1" (expand set_new_type) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (expand nS2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (grind) nil nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil) ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (newintReduce const-decl "estate" reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC44 0 (typed_reduce_TCC44-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand newintReduce) (("" (expand is_well_typed) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((newintReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (is_well_typed def-decl "bool" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC45 0 (typed_reduce_TCC45-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand newintReduce) (("" (case-replace "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)") (("1" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn                         WITH [(least_out(nS`state`domain))n                                 |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (typepred "nS2`context_type") (("1" (expand nS2) (("1" (expand set_new_type) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((newintReduce const-decl "estate" reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (set_new_type const-decl "typed_state" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC46 0 (typed_reduce_TCC46-1 nil 3701716715 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC47 0 (typed_reduce_TCC47-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC48 0 (typed_reduce_TCC48-1 nil 3701716715 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC49 0 (typed_reduce_TCC49-1 nil 3701716715 ("" (skeep* :preds? t) (("" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn           WITH [(least_out(nS`state`domain))n                   |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (split) (("1" (skeep) (("1" (typepred "nS2`dom_types(x1)") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (expand newrefReduce) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (expand value_of_type) (("1" (expand nS2) (("1" (expand set_new_type) (("1" (typepred "nS`redex_type") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (assert) (("2" (typepred "nS2`dom_types") (("2" (inst -1 r j) (("1" (expand nS2) (("1" (expand set_new_type) (("1" (propax) nil nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil) ("3" (expand nS2) (("3" (expand set_new_type) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil) ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (newrefReduce const-decl "estate" reduction nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC50 0 (typed_reduce_TCC50-1 nil 3701716715 ("" (skeep* :preds? t) (("" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn                             WITH [(least_out(nS`state`domain))n                                     |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (expand newrefReduce) (("1" (typepred "nS2`stack_types") (("1" (expand nS2) (("1" (expand set_new_type) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (expand nS2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (grind) nil nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil) ("3" (typepred "nS`redex_type") (("3" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (set_new_type const-decl "typed_state" typed_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (newrefReduce const-decl "estate" reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC51 0 (typed_reduce_TCC51-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand newrefReduce) (("" (expand is_well_typed) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((newrefReduce const-decl "estate" reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (is_well_typed def-decl "bool" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC52 0 (typed_reduce_TCC52-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand newrefReduce) (("" (case-replace "popDepth(ref(least_out(nS`state`domain))) = popDepth(nS`state`redex)") (("1" (name-replace nS2 "set_new_type(nS, leaftype(nS`redex_type) - 1)") (("1" (case-replace "nS`dom_typesn                               WITH [(least_out(nS`state`domain))n                                       |-> leaftype(nS`redex_type) - 1] = nS2`dom_types") (("1" (typepred "nS2`context_type") (("1" (expand nS2) (("1" (expand set_new_type) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand nS2) (("2" (expand set_new_type) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "nS`redex_type") (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((newrefReduce const-decl "estate" reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (leaftype adt-accessor-decl "[(leaft?) -> nat]" typeinfo_adt nil) (leaft? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (set_new_type const-decl "typed_state" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC53 0 (typed_reduce_TCC53-1 nil 3701716715 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC54 0 (typed_reduce_TCC54-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand popReduce) (("" (typepred "nS`dom_types") (("" (inst -1 r j) nil nil)) nil)) nil)) nil) ((popReduce const-decl "estate" reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC55 0 (typed_reduce_TCC55-1 nil 3701716715 ("" (skeep*) (("" (typepred "nS`stack_types") (("" (typepred "nS`state`redex") (("" (case "popDepth(nS`state`redex) > 0") (("1" (grind) nil nil) ("2" (case "pop?(nS`state`redex)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC56 0 (typed_reduce_TCC56-1 nil 3701780462 ("" (skeep* :preds? t) (("" (expand popReduce) (("" (expand pop) (("" (expand tail) (("" (typepred "nS`stack_types") (("" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((popReduce const-decl "estate" reduction nil) (tail const-decl "finseq[T]" finseq_theorems nil) (> const-decl "bool" reals nil) (nonempty_fs type-eq-decl nil finseq_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (pop const-decl "Stack" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC57 0 (typed_reduce_TCC57-1 nil 3702649677 ("" (skeep* :preds? t) (("" (typepred "nS`redex_type") (("" (grind) nil nil)) nil)) nil) ((typed_state type-eq-decl nil typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (typeinfo_ctx type-decl nil typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (value_of_type const-decl "boolean" typed_reduction nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (estate type-eq-decl nil reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (typeinfo type-decl nil typeinfo_adt nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC58 0 (typed_reduce_TCC58-1 nil 3702649677 ("" (skeep* :preds? t) (("" (rewrite value_well_typed) (("1" (split) (("1" (typepred "nS`redex_type") (("1" (expand popRedex?) (("1" (flatten) (("1" (assert) (("1" (expand is_well_typed -) (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand popReduce) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (typepred "nS`redex_type") (("1" (expand popRedex?) (("1" (flatten) (("1" (assert) (("1" (expand is_well_typed) (("1" (flatten) (("1" (rewrite value_well_typed) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand popRedex?) (("2" (flatten) (("2" (assert) (("2" (typepred "nS`redex_type") (("2" (expand is_well_typed) (("2" (flatten) (("2" (assert) (("2" (case "variable?(pbody(nS`state`redex))") (("1" (assert) (("1" (expand is_well_typed) (("1" (typepred "nS`stack_types") (("1" (expand get) (("1" (inst? -2) (("1" (grind) nil nil) ("2" (typepred "nS`state`redex") (("2" (inst -2 "index(pbody(nS`state`redex)) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand popReduce) (("2" (lift-if) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "get(nS`state`stack)(pbody(nS`state`redex))") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((value_well_typed formula-decl nil typed_reduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (> const-decl "bool" reals nil) (nonempty_fs type-eq-decl nil finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (popReduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (singleton const-decl "(singleton?)" sets nil) (drop const-decl "finite_set[nat]" IL nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (buildRedexPure rec-application-judgement "{K, B |n   fill(K, B) = A ANDn    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC59 0 (typed_reduce_TCC59-1 nil 3702649677 ("" (skeep* :preds? t) (("" (case-replace "popDepth(popReduce(D)(nS`state)`redex) = 0") (("1" (expand popReduce +) (("1" (typepred "nS`context_type") (("1" (case-replace "popDepth(nS`state`redex) = 1") (("1" (case-replace "popn(nS`stack_types, 1) = popn(tail[nat](nS`stack_types), 0)") (("1" (case-replace "expr_type(nS`redex_type) = expr_type(ptbody(nS`redex_type))") (("1" (typepred "nS`redex_type") (("1" (expand popRedex?) (("1" (flatten) (("1" (assert) (("1" (expand is_well_typed -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand tail) (("2" (expand popn) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand popRedex?) (("2" (flatten) (("2" (assert) (("2" (expand popDepth) (("2" (hide-all-but (1 -6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand popReduce) (("2" (lift-if) (("2" (split) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (hide-all-but 1) (("2" (flatten) (("2" (case "value?(get(nS`state`stack)(pbody(nS`state`redex)))") (("1" (grind) nil nil) ("2" (typepred "get(nS`state`stack)(pbody(nS`state`redex))") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (popRedex? const-decl "bool" IL nil) (popReduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (atom? const-decl "bool" IL nil) (tail const-decl "finseq[T]" finseq_theorems nil) (nonempty_fs type-eq-decl nil finseq_theorems nil) (> const-decl "bool" reals nil) (popn_zero formula-decl nil typed_reduction nil) (popt? adt-recognizer-decl "[typeinfo -> boolean]" typeinfo_adt nil) (ptbody adt-accessor-decl "[(popt?) -> typeinfo]" typeinfo_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pbody adt-accessor-decl "[(pop?) -> IExpression]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_reduction" typed_reduction typed_reduce_TCC4 0 (typed_reduce_TCC4-1 nil 3705853738 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction typed_reduce_TCC5 0 (typed_reduce_TCC5-1 nil 3705853738 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction typed_reduce_TCC6 0 (typed_reduce_TCC6-1 nil 3705853738 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction typed_reduce_TCC7 0 (typed_reduce_TCC7-1 nil 3705853738 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction typed_reduce_TCC8 0 (typed_reduce_TCC8-1 nil 3705853738 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction typed_reduce_TCC17 0 (typed_reduce_TCC17-1 nil 3701716715 ("" (skeep* :preds? t) (("" (case-replace "popDepth(applyReduce(D)(nS`state)`redex) = 0") (("1" (expand applyReduce) (("1" (assert) (("1" (typepred "nS`context_type") (("1" (assert) (("1" (case-replace "popDepth(nS`state`redex) = 0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand applyReduce 1) (("2" (lift-if) (("2" (ground) (("1" (rewrite popdepth_letApply) (("1" (lift-if) (("1" (ground) (("1" (rewrite purePopDepth) nil nil) ("2" (typepred "args(nS`state`redex)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (popDepth def-decl "nat" IL nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil reduction nil) (Defs type-eq-decl nil reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (applyRedex? const-decl "bool" IL nil) (applyReduce const-decl "estate" reduction nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (popn_zero formula-decl nil typed_reduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex_e const-decl "{eS | pureRedex?(eS`redex)}" reduction nil) (make_redex_typed const-decl "typed_state" typed_reduction nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (length def-decl "nat" list_props nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popdepth_letApply formula-decl nil reduction nil) (purePopDepth formula-decl nil IL nil) (pure_letApply rec-application-judgement "(pure?)" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`context_type" "{tK | is_well_typed_ctx(reduction.applyReduce(D)(nS`state)`context, tK, popn(nS`stack_types, IL.popDepth(reduction.applyReduce(D)(nS`state)`redex)), nS`dom_types, nS`def_types, expr_type(nS`redex_type))}")))("typed_rreduction" typed_rreduction typed_rstate_TCC4 0 (typed_rstate_TCC4-1 nil 3702747756 ("" (skeep* :preds? t) (("" (expand popn) (("" (typepred "state`redex") (("" (split) (("1" (grind) nil nil) ("2" (skeep) (("2" (inst -4 "i-popDepth(state`context)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((popn const-decl "finseq[nat]" typed_reduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" typed_rreduction nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" typed_rreduction nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cvars_vars_ctx formula-decl nil preprocess nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_rstate subtype "typed_reduction.popn(stack_types, IL.popDepth(state`redex))" "{stypes | IL.popDepth(state`context) <= stypes`length AND FORALL i: preprocess.cvars(state`context)(i) IMPLIES i < stypes`length}")))("typed_rreduction" typed_rreduction is_well_typed_letApply_TCC6 0 (is_well_typed_letApply_TCC6-1 nil 3703270930 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil) ("2" (rewrite cvars_pure) (("2" (grind) nil nil)) nil)) nil)) nil) ((list2finseq const-decl "finseq[T]" list2finseq nil) (O const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression type-decl nil IExpression_adt nil) (purePopDepth formula-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (in_varlist const-decl "finite_set[nat]" IL nil) (cvars_pure formula-decl nil preprocess nil)) nil (is_well_typed_letApply subtype "finite_sequences[nat].o(stypes, list2finseq[nat](args_type))" "{stypes | IL.popDepth(A) <= stypes`length AND FORALL i: preprocess.cvars(A)(i) IMPLIES i < stypes`length}")))("typed_rreduction" typed_rreduction is_well_typed_letApply_TCC8 0 (is_well_typed_letApply_TCC8-1 nil 3703270930 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite purePopDepth) (("1" (grind) nil nil) ("2" (use "rreduction.pure_letApply") nil nil)) nil) ("2" (rewrite cvars_pure) (("1" (skeep) (("1" (rewrite vars_letApply) (("1" (split) (("1" (grind) nil nil) ("2" (rewrite cvars_pure) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "rreduction.pure_letApply") nil nil)) nil)) nil)) nil) ((pure? def-decl "bool" IL nil) (pure_letApply recursive-judgement-axiom nil rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (letApply def-decl "IExpression" rreduction nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil) (purePopDepth formula-decl nil IL nil) (O const-decl "finseq" finite_sequences nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (in_varlist const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_letApply formula-decl nil rreduction nil) (cvars_pure formula-decl nil preprocess nil)) nil (is_well_typed_letApply subtype "stypes" "{stypes | IL.popDepth(rreduction.letApply(arity, args, A)) <= stypes`length AND FORALL i: preprocess.cvars(rreduction.letApply(arity, args, A))(i) IMPLIES i < stypes`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC5 0 (updateReduce_new_store_TCC5-1 nil 3702993203 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (prop) nil nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC8 0 (updateReduce_new_store_TCC8-1 nil 3702993203 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (use updateRedex_target_index) (("" (prop) nil nil)) nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (updateRedex_target_index formula-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.target(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 nil 3703256673 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (prop) nil nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_reduction" typed_reduction typed_reduce_TCC16 0 (typed_reduce_TCC16-1 nil 3701716715 ("" (skeep* :preds? t) (("" (expand applyReduce) (("" (case "fun(nS`state`redex) < D`length") (("1" (assert) (("1" (case "length(args(nS`state`redex)) = D`seq(fun(nS`state`redex))`arity") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (applyRedex? const-decl "bool" IL nil) (typed_to_topstate const-decl "typed_state" typed_reduction nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (IExpression type-decl nil IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (estate type-eq-decl nil reduction nil) (below type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (popDepth def-decl "nat" IL nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_state type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil)) nil (typed_reduce subtype "nS`redex_type" "{tA | is_well_typed(reduction.applyReduce(D)(nS`state)`redex, tA, nS`stack_types, nS`dom_types, nS`def_types)}")))("typed_rreduction" typed_rreduction is_well_typed_letApply_TCC8 0 (is_well_typed_letApply_TCC8-1 nil 3705932019 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite popdepth_letApply) (("1" (rewrite purePopDepth) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (rewrite cvars_pure) (("1" (rewrite vars_letApply) (("1" (split) (("1" (inst -9 i) (("1" (assert) nil nil)) nil) ("2" (inst -8 "i+arity") (("2" (assert) (("2" (rewrite cvars_pure) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite pure_letApply) nil nil)) nil)) nil)) nil)) nil) ((purePopDepth formula-decl nil IL nil) (popDepth def-decl "nat" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (in_varlist const-decl "finite_set[nat]" IL nil) (O const-decl "finseq" finite_sequences nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (IExpression type-decl nil IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (popdepth_letApply formula-decl nil rreduction nil) (cvars_pure formula-decl nil preprocess nil) (letApply def-decl "IExpression" rreduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vars_letApply formula-decl nil rreduction nil) (pure_letApply recursive-judgement-axiom nil rreduction nil) (pure? def-decl "bool" IL nil)) nil (is_well_typed_letApply subtype "stypes" "{stypes | IL.popDepth(rreduction.letApply(arity, args, A)) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(rreduction.letApply(arity, args, A))(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC5 0 (updateReduce_new_store_TCC5-1 nil 3705932019 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (assert) nil nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(IL.x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 nil 3705932019 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (assert) nil nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(IL.x) < rS`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC2 0 (typed_reduce_TCC2-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IExpression_adt.variable?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC8 0 (typed_reduce_TCC8-1 nil 3705930673 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureLetRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC15 0 (typed_reduce_TCC15-1 nil 3702747756 ("" (skeep* :preds? t) (("" (replace -4) (("" (replace -2) (("" (expand typed_to_topstate) (("" (expand make_redex_typed) (("" (expand to_topstate) (("" (expand make_redex) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.applyRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC24 0 (typed_reduce_TCC24-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC29 0 (typed_reduce_TCC29-1 nil 3702747756 ("" (skeep* :preds? t) (("" (use ifReduce_correct_indexing) (("1" (assert) nil nil) ("2" (replace -5) (("2" (replace -3) (("2" (expand* make_redex_typed typed_to_topstate make_redex to_topstate) nil nil)) nil)) nil)) nil)) nil) ((ifReduce_correct_indexing formula-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (nS skolem-const-decl "typed_rstate" typed_rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate const-decl "rtopstate" rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "IExpression_adt.condition(nS`state`redex)" "{x | IExpression_adt.index(IL.x) < nS`state`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC34 0 (typed_reduce_TCC34-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.updateRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC42 0 (typed_reduce_TCC42-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC48 0 (typed_reduce_TCC48-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newintRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC56 0 (typed_reduce_TCC56-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC64 0 (typed_reduce_TCC64-1 nil 3702747756 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.popRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC72 0 (typed_reduce_TCC72-1 nil 3702747756 ("" (skeep* :preds? t) (("" (expand make_redex_typed) (("" (typepred "make_redex(t`state)") (("" (expand pureRedex?) (("" (replace -4) (("" (simplify) (("" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil) ("6" (propax) nil nil) ("7" (propax) nil nil) ("8" (propax) nil nil) ("9" (propax) nil nil) ("10" (assert) (("10" (replace -3) (("10" (expand* make_redex typed_to_topstate to_topstate) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pureRedex? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureReleaseRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("IL" IL buildRedexPure_TCC3 0 (buildRedexPure_TCC3-1 nil 3699114546 ("" (skeep*) (("" (typepred A) (("" (typepred "v(B)") (("" (grind) nil nil)) nil)) nil)) nil) ((contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (fill def-decl "IExpression" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (atom? const-decl "bool" IL nil)) nil (buildRedexPure_ subtype "(letc(K, C), B1)" "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}")))("IL" IL buildRedexPure_TCC4 0 (buildRedexPure_TCC4-1 nil 3699114546 ("" (recursive-judgement-tcc) nil nil) ((contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (fill def-decl "IExpression" IL nil) (cpure? def-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)) nil (buildRedexPure_ subtype "(hole, A)" "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}")))("IL" IL buildRedexPure_TCC6 0 (buildRedexPure_TCC6-1 nil 3699114546 ("" (skeep*) (("" (typepred A) (("" (typepred "v(B)") (("" (grind) nil nil)) nil)) nil)) nil) ((contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (fill def-decl "IExpression" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (atom? const-decl "bool" IL nil)) nil (buildRedexPure_ subtype "(popc(K), B1)" "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}")))("IL" IL buildRedexPure_TCC7 0 (buildRedexPure_TCC7-1 nil 3699114546 ("" (recursive-judgement-tcc) nil nil) ((contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (fill def-decl "IExpression" IL nil) (cpure? def-decl "bool" IL nil) (value? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil)) nil (buildRedexPure_ subtype "(hole, A)" "{K, B | fill(K, B) = A AND ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}")))("reduction" reduction letApply_TCC4 0 (letApply_TCC4-1 nil 3683776766 ("" (skeep*) (("" (rewrite "map_length") (("" (typepred "args") (("" (grind) (("" (expand "length" -) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map_length formula-decl nil more_map_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (letApply subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: x WITH [`index := IExpression_adt.index(x) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1}")))("rreduction" rreduction letApply_TCC5 0 (letApply_TCC5-1 nil 3699206216 ("" (skeep*) (("" (rewrite map_length) (("" (typepred args) (("" (grind) (("" (expand length -2) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map_length formula-decl nil more_map_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (letApply subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: x WITH [`index := IExpression_adt.index(x) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1}")))("rreduction" rreduction letApply_TCC6 0 (letApply_TCC6-1 nil 3699206216 ("" (termination-tcc) nil nil) nil nil (letApply termination "letApply(arity - 1, list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: x WITH [`index := IExpression_adt.index(x) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)), A)" "nil")))("rreduction" rreduction releaseReduce_TCC9 0 (releaseReduce_TCC9-1 nil 3699031813 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (lift-if) (("" (ground) (("" (inst -7 i) (("" (ground) (("1" (apply-eta "grS`redex" "(release?)") (("1" (replace -1 :dir RL) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (pureReleaseRedex? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (rvar adt-accessor-decl "[(release?) -> (variable?)]" IExpression_adt nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (IExpression_release_eta formula-decl nil IExpression_adt nil) (release? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (releaseRedex? const-decl "bool" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (releaseReduce subtype "grS WITH [`stack`seq(stack`length - x - 1) := IExpression_adt.nil, `count(IExpression_adt.refindex(vx)) := grS`count(IExpression_adt.refindex(vx)) - 1, `redex := IExpression_adt.rexpr(grS`redex)]" "(noDanglingRefs?)")))("rreduction" rreduction variableReduce_TCC8 0 (variableReduce_TCC8-1 nil 3705857843 ("" (skeep* :preds? t) (("" (typepred "grS`count(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (rewrite count_update) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (inst -5 "index(expr)") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (count_update formula-decl nil finseq_theorems nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (markv const-decl "(variable?)" preprocess nil) (get const-decl "(value?)" IL nil) (singleton const-decl "(singleton?)" sets nil) (refcountExpr const-decl "nat" rreduction nil) (int_plus_int_is_int application-judgement "int" integers nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (refcountStack const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (variableReduce subtype "grS`count" "[i: (grS`domain) -> {j | j = refcount(grS`domain, grS`store, grS`stack WITH [`seq(stack`length - 1 - IExpression_adt.index(expr)) := IExpression_adt.nil], value)(i)}]")))("rreduction" rreduction updateReduce_TCC24 0 (updateReduce_TCC24-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "nstack WITH [`seq(stack`length - IExpression_adt.index(IExpression_adt.target(expr)) - 1) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(newdomain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC41 0 (updateReduce_TCC41-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "grS WITH [`redex := IExpression_adt.ref(newref), `domain := newdomain, `store := nnstore, `count := nnnnncount, `stack := nnstack]" "(noDanglingRefs?)")))("rreduction" rreduction updateReduce_TCC47 0 (updateReduce_TCC47-1 nil 3699369652 ("" (skeep* :preds? t) (("" (typepred "grS`redex") (("" (split 4) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nstack WITH [`seq(stack`length - 1 - IExpression_adt.index(IExpression_adt.target(expr))) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(domain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC54 0 (updateReduce_TCC54-1 nil 3699381161 ("" (skeep* :preds? t) (("" (typepred "grS`redex") (("" (split 5) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "grS WITH [`redex := aval, `store := newstore, `stack := nnstack, `count := nncount WITH [(orf) := nncount(orf) - 1]]" "(noDanglingRefs?)")))("rreduction" rreduction updateReduce_TCC59 0 (updateReduce_TCC59-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (updateReduce subtype "grS WITH [`redex := aval, `store := newstore, `stack := nnstack, `count := nncount]" "(noDanglingRefs?)")))("typed_rreduction" typed_rreduction is_well_typed_letApply_TCC8 0 (is_well_typed_letApply_TCC8-1 nil 3705950475 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite purePopDepth) (("1" (assert) nil nil) ("2" (rewrite pure_letApply) nil nil)) nil) ("2" (skeep) (("2" (rewrite cvars_pure -1) (("1" (rewrite vars_letApply) (("1" (split) (("1" (inst -9 i) (("1" (assert) nil nil)) nil) ("2" (inst -8 "arity+i") (("2" (rewrite cvars_pure) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite pure_letApply) nil nil)) nil)) nil)) nil)) nil) ((pure? def-decl "bool" IL nil) (pure_letApply recursive-judgement-axiom nil rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (letApply def-decl "IExpression" rreduction nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil) (purePopDepth formula-decl nil IL nil) (cvars_pure formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_letApply formula-decl nil rreduction nil)) nil (is_well_typed_letApply subtype "stypes" "{stypes | IL.popDepth(rreduction.letApply(arity, args, A)) <= stypes`length AND FORALL i: preprocess.cvars(rreduction.letApply(arity, args, A))(i) IMPLIES i < stypes`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC8 0 (updateReduce_new_store_TCC8-1 nil 3705950475 ("" (skeep* :preds? t) (("" (use updateRedex_target_index) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((updateRedex_target_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.target(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 nil 3705950475 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC2 0 (typed_reduce_TCC2-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IExpression_adt.variable?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC8 0 (typed_reduce_TCC8-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureLetRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC15 0 (typed_reduce_TCC15-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.applyRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC24 0 (typed_reduce_TCC24-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureIftRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC29 0 (typed_reduce_TCC29-1 nil 3705950475 ("" (skeep* :preds? t) (("" (use ifReduce_correct_indexing) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (replace* (-5 -3)) (("2" (expand* make_redex_typed typed_to_topstate make_redex to_topstate) nil nil)) nil)) nil)) nil) ((ifReduce_correct_indexing formula-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (nS skolem-const-decl "typed_rstate" typed_rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "IExpression_adt.condition(nS`state`redex)" "{x | IExpression_adt.index(x) < nS`state`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC34 0 (typed_reduce_TCC34-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.updateRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC42 0 (typed_reduce_TCC42-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.lookupRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC48 0 (typed_reduce_TCC48-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newintRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC56 0 (typed_reduce_TCC56-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newrefRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC64 0 (typed_reduce_TCC64-1 nil 3705950475 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.popRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC72 0 (typed_reduce_TCC72-1 nil 3705950475 ("" (skeep* :preds? t) (("" (case "pureRedex?(nS`state`redex)") (("1" (split) (("1" (replace* (-5 -4)) (("1" (expand* make_redex_typed typed_to_topstate to_topstate) (("1" (expand make_redex) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand pureRedex?) (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil) ("6" (propax) nil nil) ("7" (propax) nil nil) ("8" (propax) nil nil) ("9" (propax) nil nil) ("10" (propax) nil nil)) nil)) nil) ("3" (typepred "nS`state") (("3" (propax) nil nil)) nil)) nil) ("2" (replace -3 1) (("2" (expand make_redex_typed) (("2" (expand make_redex) (("2" (typepred "buildRedex(t`state`redex)") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (typed_reduce subtype "nS`state" "{grS | IL.pureReleaseRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("rreduction" rreduction updateReduce_TCC4 0 (updateReduce_TCC4-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "grS`redex" "{A | IExpression_adt.index(IExpression_adt.target(A)) < stack`length AND IExpression_adt.index(IExpression_adt.lhs(A)) < stack`length AND IExpression_adt.index(IExpression_adt.rhs(A)) < stack`length}")))("rreduction" rreduction updateReduce_TCC5 0 (updateReduce_TCC5-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil)) nil (updateReduce subtype "expr" "(IExpression_adt.update?)")))("rreduction" rreduction setRedex_TCC2 0 (setRedex_TCC2-1 nil 3698784150 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (setRedex subtype "IExpression_adt.refindex(vv)" "(rS`domain)")))("rreduction" rreduction updateReduce_TCC3 0 (updateReduce_TCC1-1 nil 3699107903 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "grS`redex") (("1" (grind) nil nil)) nil) ("2" (typepred "grS`redex") (("2" (grind) nil nil)) nil) ("3" (typepred "grS`redex") (("3" (grind) nil nil)) nil) ("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (markv const-decl "(variable?)" preprocess nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (cvars def-decl "finite_set[nat]" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (injective? const-decl "bool" functions nil)) nil (updateReduce subtype "A" "(IExpression_adt.update?)")))("rreduction" rreduction updateReduce_TCC5 0 (updateReduce_TCC7-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (domainValue? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (N!1 skolem-const-decl "nat" rreduction nil) (grS!1 skolem-const-decl "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil (updateReduce subtype "IL.get(stack)(IExpression_adt.target(expr))" "(IL.domainValue?(domain))")))("rreduction" rreduction updateReduce_TCC7 0 (updateReduce_TCC9-1 nil 3699107903 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IL.get(stack)(IExpression_adt.lhs(expr))" "(IL.domainValue?(domain))")))("rreduction" rreduction updateReduce_TCC9 0 (updateReduce_TCC11-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IL.get(stack)(IExpression_adt.rhs(expr))" "(IL.domainValue?(domain))")))("rreduction" rreduction updateReduce_TCC11 0 (updateReduce_TCC13-1 nil 3699107903 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (updateRedex? const-decl "bool" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "stack`length - IExpression_adt.index(IExpression_adt.rhs(expr)) - 1" "below[stack`length]")))("rreduction" rreduction updateReduce_TCC13 0 (updateReduce_TCC15-1 nil 3699107903 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "stack WITH [`seq(stack`length - IExpression_adt.index(IExpression_adt.rhs(expr)) - 1) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(domain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC14 0 (updateReduce_TCC16-1 nil 3699107903 ("" (skeep* :preds? t) (("" (lift-if) (("" (typepred "grS`count(refindex(rval))") (("1" (rewrite -1) (("1" (replace -19) (("1" (replace -18) (("1" (replace -17) (("1" (replace -16) (("1" (expand refcount) (("1" (split 2) (("1" (expand refcountStack) (("1" (lemma "finseq_theorems[(value?)].count_elem") (("1" (inst -1 _ _ rval) (("1" (inst? -1) (("1" (split -1) (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil) ("2" (inst 1 "grS`stack`length - index(rhs(grS`redex)) - 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand refcountStack) (("2" (assert) (("2" (replace -29) (("2" (rewrite count_update) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (count_elem formula-decl nil finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (injective? const-decl "bool" functions nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (count_update formula-decl nil finseq_theorems nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "stack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(domain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC15 0 (updateReduce_TCC17-1 nil 3699107903 ("" (skeep* :preds? t) (("" (split 3) (("1" (grind) nil nil) ("2" (skeep* :preds? t) (("2" (typepred "grS`count(x1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (updateRedex? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (value? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(rval)" "(domain)")))("rreduction" rreduction updateReduce_TCC16 0 (updateReduce_TCC18-1 nil 3699107903 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(rval)" "(grS`domain)")))("rreduction" rreduction updateReduce_TCC17 0 (updateReduce_TCC19-1 nil 3699276705 ("" (grind) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "grS`count(IExpression_adt.refindex(rval)) - 1" "{j | j = refcount(domain, store, nstack, expr)(IExpression_adt.refindex(rval))}")))("rreduction" rreduction updateReduce_TCC18 0 (updateReduce_TCC20-1 nil 3699276705 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "grS`count" "[i: (domain) -> {j | j = refcount(domain, store, nstack, expr)(i)}]")))("rreduction" rreduction updateReduce_TCC19 0 (updateReduce_TCC21-1 nil 3699276705 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(aval)" "(domain)")))("rreduction" rreduction updateReduce_TCC20 0 (updateReduce_TCC22-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "stack`length - IExpression_adt.index(IExpression_adt.target(expr)) - 1" "below[nstack`length]")))("rreduction" rreduction updateReduce_TCC21 0 (updateReduce_TCC23-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.nil" "(IL.value?)")))("rreduction" rreduction updateReduce_TCC22 0 (updateReduce_TCC24-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "nstack WITH [`seq(stack`length - IExpression_adt.index(IExpression_adt.target(expr)) - 1) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(newdomain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC23 0 (updateReduce_TCC25-1 nil 3699369652 ("" (skeep* :preds? t) (("" (typepred "store(oldref)`seq(x1)") (("" (grind) nil nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nstack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(newdomain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC24 0 (updateReduce_TCC26-1 nil 3699369652 ("" (skeep* :preds? t) (("" (split 4) (("1" (hide-all-but (1 -36 -21 -34 -12 -26)) (("1" (grind) nil nil)) nil) ("2" (skeep* :preds? t) (("2" (replace -39) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (typepred "ncount(oldref)") (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountStack) (("1" (lemma "finseq_theorems[(value?)].count_elem") (("1" (inst -1 _ _ "aval") (("1" (inst? -1) (("1" (split -1) (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil) ("2" (inst 1 "stack`length - index(target(expr)) - 1") (("1" (replace -34) (("1" (lift-if 1) (("1" (simplify) (("1" (lift-if 1) (("1" (assert) (("1" (case "index(target(expr)) = index(rhs(expr))") (("1" (delete 1 2) (("1" (delete -41 -42 -37) (("1" (typepred "grS`redex") (("1" (case-replace "grS`redex = update(target(expr), lhs(expr), rhs(expr))") (("1" (simplify -7) (("1" (expand mark -7) (("1" (decompose-equality -7) (("1" (expand markv -1) (("1" (replace -10) (("1" (expand add -1) (("1" (expand member -1) (("1" (replace -1 :dir RL) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -33 -27)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (propax) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ncount(oldref)") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "ncount(x1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (domainValue? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (Stack type-eq-decl nil IL nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (count_elem formula-decl nil finseq_theorems nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (markv const-decl "(variable?)" preprocess nil) (nonempty? const-decl "bool" sets nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (IExpression_update_extensionality formula-decl nil IExpression_adt nil) (get const-decl "(value?)" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "oldref" "(domain)")))("rreduction" rreduction updateReduce_TCC26 0 (updateReduce_TCC28-3 "" 3699624802 ("" (skeep* :preds? t) (("" (rewrite count_copy_def) (("" (replace -39) (("" (lift-if 4) (("" (typepred "ncount(x1)") (("1" (rewrite -1) (("1" (typepred "ncount(oldref)") (("1" (rewrite -1) (("1" (expand refcount) (("1" (lemma pure_refs) (("1" (inst -1 expr _) (("1" (expand refcountExpr) (("1" (case "pure?(expr)") (("1" (rewrite -1 4) (("1" (inst-cp -1 x1) (("1" (inst -1 oldref) (("1" (assert) (("1" (expand refs) (("1" (case-replace "x1 = newref") (("1" (case-replace "(newref = oldref) = FALSE") (("1" (replace -42) (("1" (delete 1 2) (("1" (expand refcountArray) (("1" (rewrite count_none_zero) (("1" (expand refcountStack) (("1" (rewrite count_none_zero 4) (("1" (expand refcountStore) (("1" (expand allcount) (("1" (rewrite sigma_zero 4) (("1" (skeep*) (("1" (expand refcountArray) (("1" (rewrite count_none_zero) (("1" (skeep*) (("1" (replace -44) (("1" (lift-if) (("1" (delete (1 3 5 6)) (("1" (delete -42 -41 -37) (("1" (delete -35) (("1" (split -1) (("1" (flatten) (("1" (assert) (("1" (typepred "store(oldref)`seq(i)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "store(x)`seq(i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -38 -23)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -39) (("2" (delete 6) (("2" (lift-if) (("2" (skeep*) (("2" (lift-if) (("2" (simplify) (("2" (lift-if) (("2" (assert) (("2" (hide-all-but (3 -9 -1 -2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (typepred "store(oldref)`seq(i)") (("2" (hide-all-but (-2 -3 -4 -27 3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5 -23 -14 -28 -36)) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (delete 2 3) (("2" (case-replace "refcountStore(newdomain, nstore)(x1) = refcountArray(copied)(x1) + refcountStore(domain, store)(x1)") (("1" (simplify) (("1" (split 5) (("1" (flatten) (("1" (rewrite -1) (("1" (simplify) (("1" (replace -39) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (expand refcountStack) (("1" (rewrite count_update) (("1" (case-replace "nstack`seq(stack`length - 1 - index(target(expr))) = ref(oldref)") (("1" (simplify) (("1" (propax) nil nil)) nil) ("2" (delete 2) (("2" (replace -34) (("2" (simplify) (("2" (lift-if) (("2" (case "index(target(expr)) = index(rhs(expr))") (("1" (delete 1) (("1" (typepred "grS`redex") (("1" (case-replace "grS`redex = update(target(expr), lhs(expr), rhs(expr))") (("1" (expand mark -7) (("1" (decompose-equality -7) (("1" (expand markv) (("1" (replace -10) (("1" (expand add -1) (("1" (expand member -1) (("1" (replace -1 :dir RL) (("1" (simplify) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -25 -31)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("2" (simplify) (("2" (assert) (("2" (hide-all-but (-35 -25 -27 2)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand refcountStack) (("2" (lift-if) (("2" (simplify) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand refcountStack) (("2" (replace -39) (("2" (assert) (("2" (lift-if) (("2" (rewrite count_update) (("1" (split -33) (("1" (flatten) (("1" (replace -3) (("1" (simplify) (("1" (lift-if) (("1" (simplify) (("1" (case-replace "stack`seq
                                (stack`length - 1 - index(target(expr))) = ref(oldref)") (("1" (simplify) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 -38 -29 -31)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide-all-but (3 2 -25 -27 -34)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 6) (("2" (expand refcountStore) (("2" (expand allcount) (("2" (lemma sigma_add) (("2" (inst -1 newdomain _ newref) (("2" (inst? -1) (("1" (split -1) (("1" (rewrite -1) (("1" (replace -37) (("1" (rewrite remove_add_member) (("1" (expand add 1) (("1" (expand member 1) (("1" (replace -41 1) (("1" (simplify) (("1" (use sigma_eq) (("1" (split -1) (("1" (propax) nil nil) ("2" (delete 2) (("2" (skeep* :preds? t) (("2" (simplify) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (replace -23) (("2" (propax) nil nil)) nil)) nil) ("3" (replace -22) (("3" (skeep*) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (replace -37) (("2" (expand add) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -37) (("2" (expand add 1) (("2" (expand member) (("2" (replace -22) (("2" (skeep*) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (skeep*) (("1" (delete 6) (("1" (replace -37) (("1" (replace -22) (("1" (expand add) (("1" (expand member) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 6) (("2" (skeep*) (("2" (replace -41) (("2" (lift-if) (("2" (replace -40) (("2" (split 1) (("1" (flatten) (("1" (typepred "store(oldref)`seq(x2)") (("1" (expand domainValue?) (("1" (replace -40) (("1" (expand add) (("1" (expand member) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred x2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "store(x1!1)`seq(x2)") (("2" (replace -39) (("2" (expand domainValue?) (("2" (expand add) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 5) (("2" (hide-all-but (1 -19 -25)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -37) (("2" (expand add) (("2" (expand member) (("2" (split -1) (("1" (replace -1 :dir RL) (("1" (case-replace "(newref = oldref) = FALSE") (("1" (expand refcountArray) (("1" (rewrite count_none_zero 5) (("1" (expand refcount) (("1" (expand refcountStore) (("1" (replace -42) (("1" (expand allcount) (("1" (expand refcountExpr) (("1" (expand refs) (("1" (expand refcountStack) (("1" (rewrite sigma_zero) (("1" (rewrite count_none_zero) (("1" (skeep*) (("1" (case "nstack`seq(i) = ref(newref)") (("1" (hide-all-but (-1 -9 2)) (("1" (grind) nil nil)) nil) ("2" (replace -40) (("2" (hide-all-but (-1 -2 1)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 7) (("2" (expand refcountArray) (("2" (skeep*) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (rewrite count_none_zero) (("1" (skeep*) (("1" (replace -44) (("1" (typepred "store(oldref)`seq(i)") (("1" (hide-all-but (3 -27 -2 -3 -4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite count_none_zero) (("2" (skeep*) (("2" (typepred "store(x)`seq(i)") (("2" (hide-all-but (4 -27 -2 -3 -4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -22) (("3" (skeep*) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (replace -42) (("2" (typepred "store(oldref)`seq(i)") (("2" (hide-all-but (4 -26 -2 -3 -4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2 -35 -27 -25 -20 -22)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((count_copy_def formula-decl nil rreduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (pure_refs formula-decl nil IL nil) (refcountExpr const-decl "nat" rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (get const-decl "(value?)" IL nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (nonempty? const-decl "bool" sets nil) (markv const-decl "(variable?)" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression_update_extensionality formula-decl nil IExpression_adt nil) (count_update formula-decl nil finseq_theorems nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (sigma_add formula-decl nil finite_set_theorems nil) (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))" countability "sets_aux/") (finite_remove application-judgement "finite_set[nat]" countability "sets_aux/") (remove_add_member formula-decl nil sets_lemmas nil) (sigma_eq formula-decl nil finite_set_theorems nil) (FALSE const-decl "bool" booleans nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (count_none_zero formula-decl nil finseq_theorems nil) (allcount const-decl "nat" rreduction nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (below type-eq-decl nil naturalnumbers nil) (sigma_zero formula-decl nil finite_set_theorems nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (refcountStore const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (every const-decl "bool" finseq_theorems nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (updateReduce subtype "store(oldref)" "finseq[(IL.domainValue?(newdomain))]")) (updateReduce_TCC28-2 "" 3699621681 ("" (skeep* :preds? t) (("" (rewrite count_copy_def) (("" (replace -39) (("" (lift-if) (("" (expand refcount) (("" (expand refcountExpr) (("" (expand refs) (("" (split 4) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (simplify) (("1" (assert) (("1" (replace -40) (("1" (typepred "ncount(oldref)") (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountStack) (("1" (rewrite count_update) (("1" (expand refcountExpr) (("1" (case-replace "refs(expr)(oldref) = FALSE") (("1" (replace -3) (("1" (case-replace "(oldref = newref) = FALSE") (("1" (case-replace "nstack`seq(stack`length - 1 - index(target(expr))) = ref(oldref)") (("1" (simplify) (("1" (expand refcountStore) (("1" (expand allcount) (("1" (lemma sigma_add) (("1" (inst -1 newdomain _ newref) (("1" (inst? -1) (("1" (split -1) (("1" (replace -1) (("1" (case-replace "remove(newref, newdomain) = domain") (("1" (lemma sigma_eq) (("1" (inst -1 domain "lambda (j_1: nat):
               IF domain(j_1) THEN refcountArray(store(j_1))(oldref)
               ELSE 0
               ENDIF" "lambda (j_1: nat):
                IF newdomain(j_1) THEN refcountArray(nstore(j_1))(oldref)
                ELSE 0
                ENDIF") (("1" (split -1) (("1" (replace -1) (("1" (simplify) (("1" (replace -47) (("1" (simplify) (("1" (replace -43) (("1" (expand add) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand add) (("2" (skeep* :preds? t) (("2" (replace -43) (("2" (simplify) (("2" (expand member) (("2" (replace -47) (("2" (simplify) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (replace -43) (("2" (expand add) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (replace -27) (("3" (assert) (("3" (skeep*) nil nil)) nil)) nil)) nil)) nil) ("2" (apply-extensionality 1) (("2" (expand remove) (("2" (expand member) (("2" (replace -41) (("2" (expand add) (("2" (expand member) (("2" (simplify) (("2" (assert) (("2" (iff) (("2" (split 1) (("1" (ground) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -40) (("2" (expand member) (("2" (expand add) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -40) (("2" (expand add) (("2" (expand member) (("2" (skeep*) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -36) (("1" (flatten) (("1" (delete 3) (("1" (replace -3) (("1" (simplify) (("1" (hide-all-but (1 -30 -32 -39)) (("1" (grind) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide-all-but (2 -31 -38 -29)) (("2" (grind) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-20 -26 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "ncount(oldref)") (("2" (rewrite -1) (("2" (expand refcount) (("2" (replace -1) (("2" (case-replace "(oldref = newref) = FALSE") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (updateReduce subtype "store(oldref)" "finseq[(IL.domainValue?(newdomain))]")) (updateReduce_TCC28-1 nil 3699369652 ("" (skeep* :preds? t) (("" (rewrite count_copy_def) (("" (replace -39) (("" (lift-if 4) (("" (typepred "ncount(oldref)") (("" (rewrite -1) (("" (expand refcount 4) (("" (expand refcountExpr 4) (("" (case-replace "refs(expr)(oldref) = FALSE") (("1" (expand refs 4) (("1" (simplify) (("1" (assert) (("1" (split 5) (("1" (flatten) (("1" (rewrite -1) (("1" (case-replace "(oldref = newref) = FALSE") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (updateReduce subtype "store(oldref)" "finseq[(IL.domainValue?(newdomain))]")))("rreduction" rreduction updateReduce_TCC27 0 (updateReduce_TCC29-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "nncount" "[(newdomain) -> nat]")))("rreduction" rreduction updateReduce_TCC29 0 (updateReduce_TCC31-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "count_copy(newdomain, nncount, copied, copied`length)" "[i: (newdomain) -> {j | j = refcount(newdomain, nstore, nnstack, IExpression_adt.ref(newref))(i)}]")))("rreduction" rreduction updateReduce_TCC30 0 (updateReduce_TCC32-1 nil 3699369652 ("" (skeep* :preds? t) (("" (typepred "nnncount(refindex(oldvalue))") (("" (rewrite -1) (("" (expand refcount) (("" (case "refcountStore(newdomain, nstore)(refindex(oldvalue)) > 0") (("1" (hide-all-but (-1 4)) (("1" (grind) nil nil)) nil) ("2" (expand refcountStore) (("2" (delete 5) (("2" (expand allcount) (("2" (lemma sigma_add) (("2" (inst -1 newdomain _ newref) (("2" (rewrite -1) (("1" (replace -39 1) (("1" (expand add 1) (("1" (case "refcountArray(nstore(newref))(refindex(oldvalue)) > 0") (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil) ("2" (delete 2) (("2" (expand refcountArray) (("2" (lemma "finseq_theorems[(value?)].count_elem") (("2" (inst -1 "lambda u: ref?(u) AND refindex(u) = refindex(oldvalue)" "nstore(newref)" "oldvalue") (("1" (split -1) (("1" (propax) nil nil) ("2" (inst 1 "value(lval)") (("1" (replace -47) (("1" (replace -43) (("1" (simplify) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but (1 -38 -23)) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (refcount const-decl "nat" rreduction nil) (Stack type-eq-decl nil IL nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (count_elem formula-decl nil finseq_theorems nil) (add const-decl "(nonempty?)" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_add formula-decl nil finite_set_theorems nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (Sigma def-decl "nat" finite_set_theorems nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))" countability "sets_aux/") (finite_remove application-judgement "finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refcountStore const-decl "nat" rreduction nil) (> const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.value(lval)" "below[nstore(newref)`length]")))("rreduction" rreduction updateReduce_TCC31 0 (updateReduce_TCC33-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.value(lval)" "below[copied`length]")))("rreduction" rreduction updateReduce_TCC32 0 (updateReduce_TCC34-1 nil 3699369652 ("" (skeep* :preds? t) (("" (replace -47) (("" (lift-if 4) (("" (split 4) (("1" (flatten) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nnncount(refindex(oldvalue))") (("1" (rewrite -1) (("1" (replace -1) (("1" (expand refcount) (("1" (case-replace "nstore = nnstore") (("1" (delete 2) (("1" (replace -46) (("1" (apply-extensionality) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (replace -1) (("1" (apply-extensionality 1) (("1" (apply-extensionality 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (rewrite -1) (("1" (replace -45) (("1" (simplify) (("1" (replace -48 :dir RL) (("1" (hide-all-but (1 -49 -2 -3)) (("1" (case "oldvalue = ref(refindex(oldvalue))") (("1" (replace -1 1) (("1" (replace -2 1 :dir RL) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nnncount(refindex(rval))") (("2" (rewrite -1) (("2" (expand refcount) (("2" (expand refcountStore) (("2" (expand allcount) (("2" (lemma sigma_with) (("2" (inst -1 newdomain _ _ newref "refcountArray(nnstore(newref))(refindex(rval))") (("2" (inst -1 "lambda (j_1: nat):
               IF newdomain(j_1)
                 THEN refcountArray(nstore(j_1))(refindex(rval))
               ELSE 0
               ENDIF" "lambda (j_1: nat):
               IF newdomain(j_1)
                 THEN refcountArray(nnstore(j_1))(refindex(rval))
               ELSE 0
               ENDIF") (("1" (rewrite -1) (("1" (simplify) (("1" (replace -40 2) (("1" (expand add) (("1" (expand refcountArray 2) (("1" (replace -46) (("1" (simplify) (("1" (rewrite count_update 2) (("1" (simplify) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (apply-extensionality 1) (("1" (delete 2) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (rewrite -1) nil nil)) nil) ("2" (flatten) (("2" (replace -47) (("2" (simplify) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replace -41) (("1" (expand add) (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (replace -41) (("2" (expand add) (("2" (expand member) (("2" (replace -25) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -40) (("3" (expand add) (("3" (expand member) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -39 -24)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nnncount(refindex(rval))") (("2" (rewrite -1) (("2" (expand refcount) (("2" (expand refcountStore) (("2" (expand allcount) (("2" (lemma sigma_with) (("2" (inst -1 newdomain _ _ newref "refcountArray(nnstore(newref))(refindex(rval))") (("2" (inst -1 "lambda (j_1: nat):
               IF newdomain(j_1)
                 THEN refcountArray(nstore(j_1))(refindex(rval))
               ELSE 0
               ENDIF" "lambda (j_1: nat):
               IF newdomain(j_1)
                 THEN refcountArray(nnstore(j_1))(refindex(rval))
               ELSE 0
               ENDIF") (("1" (rewrite -1) (("1" (simplify) (("1" (replace -39) (("1" (expand add) (("1" (expand refcountArray) (("1" (replace -44) (("1" (simplify) (("1" (rewrite count_update) (("1" (simplify) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (apply-extensionality) (("1" (delete 2) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -46) (("2" (simplify) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (replace -40) (("1" (expand add) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -39 -24)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (hide-all-but (1 -38 -23)) (("2" (grind) nil nil)) nil) ("3" (skeep*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refcountStore const-decl "nat" rreduction nil) (sigma_with formula-decl nil finite_set_theorems nil) (member const-decl "bool" sets nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (add const-decl "(nonempty?)" sets nil) (below type-eq-decl nil naturalnumbers nil) (count_update formula-decl nil finseq_theorems nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountArray const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (Store type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (every const-decl "bool" finseq_theorems nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (finite_remove application-judgement "finite_set[nat]" countability "sets_aux/") (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))" countability "sets_aux/") (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil) (Sigma def-decl "nat" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(oldvalue)" "(newdomain)")))("rreduction" rreduction updateReduce_TCC33 0 (updateReduce_TCC35-1 nil 3699369652 ("" (skeep* :preds? t) (("" (replace -47) (("" (lift-if 5) (("" (lift-if 5) (("" (split 5) (("1" (flatten) (("1" (split 1) (("1" (flatten) (("1" (typepred "nnncount(refindex(oldvalue))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (replace -1) (("1" (simplify) (("1" (replace -47) (("1" (rewrite refcountStore_set) (("1" (simplify) (("1" (replace -45) (("1" (simplify) (("1" (replace -48 :dir RL) (("1" (hide-all-but (1 5 -2 -12)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nnncount(x1)") (("2" (rewrite -1) (("2" (expand refcount) (("2" (replace -46) (("2" (rewrite refcountStore_set) (("1" (replace -44) (("1" (simplify) (("1" (replace -47 :dir RL) (("1" (hide-all-but (1 2 6 -11)) (("1" (typepred oldvalue) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "nnncount(x1)") (("2" (rewrite -1) (("2" (expand refcount) (("2" (replace -45) (("2" (rewrite refcountStore_set) (("1" (replace -43) (("1" (simplify) (("1" (replace -46 :dir RL) (("1" (hide-all-but (1 2 6 -10)) (("1" (typepred oldvalue) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (refcountStack const-decl "nat" rreduction nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (get const-decl "(value?)" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (injective? const-decl "bool" functions nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (Sigma def-decl "nat" finite_set_theorems nil) (remove const-decl "set" sets nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (remove_preserves_bounded application-judgement "(LAMBDA (S: set[nat]):
   (bounded?)(S, restrict[[real, real], [nat, nat], boolean](<=)))" countability "sets_aux/") (finite_remove application-judgement "finite_set[nat]" countability "sets_aux/") (int_plus_int_is_int application-judgement "int" integers nil) (refcountStore_set formula-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (Store type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (every const-decl "bool" finseq_theorems nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nnncount(IExpression_adt.refindex(oldvalue)) - 1" "nat")))("rreduction" rreduction updateReduce_TCC34 0 (updateReduce_TCC36-1 nil 3699369652 ("" (skeep* :preds? t) (("" (typepred "grS`redex") (("" (split 4) (("1" (expand refs 1) (("1" (skeep*) (("1" (replace -1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand vars 1) (("2" (grind) nil nil)) nil) ("3" (expand popDepth 1 1) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(rval)" "(newdomain)")))("rreduction" rreduction updateReduce_TCC35 0 (updateReduce_TCC37-1 nil 3699369652 ("" (skeep* :preds? t) (("" (split 4) (("1" (skeep*) (("1" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (skeep*) (("2" (replace -44) (("2" (lift-if 1) (("2" (simplify) (("2" (replace -42 1) (("2" (lift-if 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (grind) nil nil) ("2" (typepred "copied`seq(x2)") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "store(x1)`seq(x2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (get const-decl "(value?)" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (add const-decl "(nonempty?)" sets nil) (emptyset const-decl "set" sets nil) (updateRedex? const-decl "bool" IL nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finseq type-eq-decl nil finite_sequences nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (Stack type-eq-decl nil IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nnnncount(IExpression_adt.refindex(rval)) + 1" "{j | j = refcount(newdomain, nnstore, nnstack, IExpression_adt.ref(newref))(IExpression_adt.refindex(rval))}")))("rreduction" rreduction updateReduce_TCC36 0 (updateReduce_TCC38-1 nil 3699369652 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (inst -21 i) (("1" (expand popDepth 5) (("1" (case-replace "popDepth(grS`redex) = 0") (("1" (typepred "grS`redex") (("1" (case-replace "grS`redex = update(target(expr), lhs(expr), rhs(expr))") (("1" (split -29) (("1" (expand cvars -1) (("1" (expand vars -1) (("1" (expand add -1) (("1" (expand emptyset -1) (("1" (expand member) (("1" (expand mark -8) (("1" (decompose-equality -8) (("1" (expand markv) (("1" (expand bumpn) (("1" (expand add) (("1" (expand member) (("1" (replace -50 -59) (("1" (simplify) (("1" (lift-if -59) (("1" (lift-if -59) (("1" (case "marked(target(expr)) AND i = index(target(expr))") (("1" (grind) nil nil) ("2" (case "ref?(nstack`seq(nstack`length -1 -i))") (("1" (replace -45 -1) (("1" (simplify) (("1" (lift-if -1) (("1" (lift-if -1) (("1" (case "ref?(rval) AND marked(rhs(expr)) AND i = index(rhs(expr))") (("1" (grind) nil nil) ("2" (case "ref?(stack`seq(stack`length - 1 - i))") (("1" (replace -3 2 :dir RL) (("1" (replace -5 1 :dir RL) (("1" (simplify) (("1" (lift-if 2) (("1" (split -6) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (replace -47 -56) (("3" (simplify) (("3" (lift-if -56) (("3" (lift-if -56) (("3" (case "marked(target(expr)) AND i = index(target(expr))") (("1" (grind) nil nil) ("2" (case "ref?(nstack`seq(nstack`length - 1 - i))") (("1" (replace -42 -1) (("1" (simplify) (("1" (lift-if -1) (("1" (lift-if -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -27 -33)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (markv const-decl "(variable?)" preprocess nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (count_copy def-decl "[(dom) -> nat]" rreduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (get const-decl "(value?)" IL nil) (injective? const-decl "bool" functions nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (IExpression_update_extensionality formula-decl nil IExpression_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nnnncount" "[i: (newdomain) -> {j | j = refcount(newdomain, nnstore, nnstack, IExpression_adt.ref(newref))(i)}]")))("rreduction" rreduction updateReduce_TCC38 0 (updateReduce_TCC40-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "nnstore" "reduction.Store(newdomain)")))("rreduction" rreduction updateReduce_TCC39 0 (updateReduce_TCC41-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "grS WITH [`redex := IExpression_adt.ref(newref), `domain := newdomain, `store := nnstore, `count := nnnnncount, `stack := nnstack]" "(noDanglingRefs?)")))("rreduction" rreduction updateReduce_TCC41 0 (updateReduce_TCC43-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "IExpression_adt.value(lval)" "below[store(oldref)`length]")))("rreduction" rreduction updateReduce_TCC42 0 (updateReduce_TCC44-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "rval" "(IL.domainValue?(grS`domain))")))("rreduction" rreduction updateReduce_TCC44 0 (updateReduce_TCC46-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.nil" "(IL.value?)")))("rreduction" rreduction updateReduce_TCC45 0 (updateReduce_TCC47-1 nil 3699369652 ("" (skeep* :preds? t) (("" (typepred "grS`redex") (("" (split 4) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nstack WITH [`seq(stack`length - 1 - IExpression_adt.index(IExpression_adt.target(expr))) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(domain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC46 0 (updateReduce_TCC48-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "IExpression_adt.refindex(rval)" "(domain)")))("rreduction" rreduction updateReduce_TCC47 0 (updateReduce_TCC49-1 nil 3699369652 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (bumpn const-decl "finite_set[nat]" IL nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "nnstack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(grS`domain))(S)}")))("rreduction" rreduction updateReduce_TCC49 0 (updateReduce_TCC51-1 nil 3699370743 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (case-replace "popDepth(aval) = 0") (("1" (case-replace "popDepth(grS`redex) = 0") (("1" (inst -23 i) (("1" (typepred "grS`redex") (("1" (case-replace "grS`redex = update(target(expr), lhs(expr), rhs(expr))") (("1" (split -30) (("1" (expand cvars -1) (("1" (expand vars -1) (("1" (expand add -1) (("1" (expand member -1) (("1" (expand emptyset -1) (("1" (expand mark -8) (("1" (decompose-equality -8) (("1" (expand markv) (("1" (expand bumpn) (("1" (expand add) (("1" (expand member) (("1" (replace -51 -55) (("1" (simplify) (("1" (lift-if -55) (("1" (split -55) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -46 -1) (("2" (simplify) (("2" (lift-if -1) (("2" (simplify) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (split -3) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -7) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -5) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (replace -1) (("3" (expand get -45) (("3" (replace -1) (("3" (replace -45 :dir RL) (("3" (replace -5 :dir RL) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (replace -48 -52) (("3" (simplify) (("3" (lift-if -52) (("3" (split -52) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -43 -1) (("2" (lift-if -1) (("2" (simplify) (("2" (lift-if -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -34 -28)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (markv const-decl "(variable?)" preprocess nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (member const-decl "bool" sets nil) (IExpression_update_extensionality formula-decl nil IExpression_adt nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "orf" "(grS`domain)")))("rreduction" rreduction updateReduce_TCC50 0 (updateReduce_TCC52-1 nil 3699381161 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil)) nil (updateReduce subtype "orf" "(domain)")))("rreduction" rreduction updateReduce_TCC51 0 (updateReduce_TCC53-1 nil 3699381161 ("" (skeep* :preds? t) (("" (replace -38) (("" (expand every) (("" (skeep* :preds? t) (("" (lift-if) (("" (split 5) (("1" (grind) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((domainValue? const-decl "bool" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (value? const-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (updateRedex? const-decl "bool" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (get const-decl "(value?)" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (below type-eq-decl nil naturalnumbers nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nncount(orf) - 1" "{j | j = refcount(grS`domain, newstore, nnstack, aval)(orf)}")))("rreduction" rreduction updateReduce_TCC52 0 (updateReduce_TCC54-1 nil 3699381161 ("" (skeep* :preds? t) (("" (typepred "grS`redex") (("" (split 5) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ((noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "grS WITH [`redex := aval, `store := newstore, `stack := nnstack, `count := nncount WITH [(orf) := nncount(orf) - 1]]" "(noDanglingRefs?)")))("rreduction" rreduction updateReduce_TCC53 0 (updateReduce_TCC55-1 nil 3699714517 ("" (skeep* :preds? t) (("" (split 5) (("1" (grind) nil nil) ("2" (skeep* :preds? t) (("2" (typepred "nncount(x1)") (("2" (replace -41) (("2" (lift-if 1) (("2" (lift-if 1) (("2" (case-replace "rval = ref(x1)") (("1" (simplify) (("1" (typepred "ncount(x1)") (("1" (rewrite -1) (("1" (expand refcount) (("1" (replace -39) (("1" (rewrite refcountStore_set) (("1" (replace -40 :dir RL) (("1" (replace -25) (("1" (simplify) (("1" (replace -41) (("1" (expand refcountStack) (("1" (rewrite count_update) (("1" (simplify) (("1" (case-replace "nstack`seq(stack`length - 1 - index(target(expr))) = aval") (("1" (expand refcountExpr) (("1" (case-replace "refs(expr)(x1) = FALSE") (("1" (case-replace "refs(oldvalue)(x1) = FALSE") (("1" (hide-all-but (1 4 -33)) (("1" (grind) nil nil)) nil) ("2" (typepred oldvalue) (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace -35 1) (("2" (lift-if 1) (("2" (simplify) (("2" (lift-if 1) (("2" (delete 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "ncount(x1) = refcount(grS`domain, newstore, nnstack, aval)(x1)") (("1" (grind-with-ext) nil nil) ("2" (delete 3) (("2" (typepred "ncount(x1)") (("2" (rewrite -1) (("2" (expand refcount) (("2" (replace -24) (("2" (replace -38) (("2" (rewrite refcountStore_set) (("2" (simplify) (("2" (replace -39 :dir RL) (("2" (case-replace "refs(oldvalue)(x1) = FALSE") (("1" (case-replace "refs(rval)(x1) = FALSE") (("1" (expand refcountStack) (("1" (replace -42) (("1" (rewrite count_update) (("1" (simplify) (("1" (case-replace "nstack`seq(stack`length - 1 - index(target(expr))) = aval") (("1" (expand refcountExpr) (("1" (case-replace "refs(expr)(x1) = FALSE") (("1" (hide-all-but (3 -31)) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace -34) (("2" (lift-if 1) (("2" (simplify) (("2" (lift-if 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (typepred rval) (("2" (grind) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 7)) (("2" (typepred oldvalue) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (value? const-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (updateRedex? const-decl "bool" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (get const-decl "(value?)" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (Stack type-eq-decl nil IL nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_set formula-decl nil rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (count_update formula-decl nil finseq_theorems nil) (FALSE const-decl "bool" booleans nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "newstore(orf)`length" "upto(newstore(orf)`length)")))("rreduction" rreduction updateReduce_TCC54 0 (updateReduce_TCC56-1 nil 3699714517 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (inst -20 i) (("1" (case-replace "popDepth(aval) = 0") (("1" (case-replace "popDepth(grS`redex) = 0") (("1" (typepred "grS`redex") (("1" (case-replace "grS`redex = update(target(expr), lhs(expr), rhs(expr))") (("1" (split -29) (("1" (expand cvars -1) (("1" (expand vars -1) (("1" (expand add -1) (("1" (expand emptyset -1) (("1" (expand member -1) (("1" (expand mark -8) (("1" (decompose-equality -8) (("1" (expand markv) (("1" (expand bumpn) (("1" (expand add) (("1" (expand member) (("1" (replace -50 -52) (("1" (simplify) (("1" (lift-if -52) (("1" (split -52) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -45 -1) (("2" (simplify) (("2" (lift-if -1) (("2" (simplify) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (split -3) (("1" (grind) nil nil) ("2" (flatten) (("2" (split -7) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -5) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (replace -1) (("3" (expand get -44) (("3" (replace -1) (("3" (replace -44 :dir RL) (("3" (replace -5 :dir RL) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (replace -47 -49) (("3" (simplify) (("3" (lift-if -49) (("3" (split -49) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -42 -1) (("2" (lift-if -1) (("2" (simplify) (("2" (lift-if -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -33 -27)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (markv const-decl "(variable?)" preprocess nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (IExpression_update_extensionality formula-decl nil IExpression_adt nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce subtype "nnstack" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(grS`domain))(S)}")))("rreduction" rreduction updateReduce_TCC55 0 (updateReduce_TCC57-1 nil 3699714517 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (get const-decl "(value?)" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "aval" "{A |      (FORALL i: IL.refs(A)(i) IMPLIES grS`domain(i)) AND (FORALL i: IL.vars(A)(i) IMPLIES i + IL.popDepth(A) < nnstack`length) AND (FORALL i: IL.vars(grS`context)(i) IMPLIES i + IL.popDepth(A) + IL.popDepth(grS`context) < nnstack`length) AND (IL.popDepth(A) + IL.popDepth(grS`context) <= nnstack`length) AND IL.contextPure?(A) AND (preprocess.mark(preprocess.cvars(grS`context))(A) = A)}")))("rreduction" rreduction updateReduce_TCC56 0 (updateReduce_TCC58-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (updateReduce subtype "nncount" "[i: (grS`domain) -> {j | j = refcount(grS`domain, newstore, nnstack, aval)(i)}]")))("rreduction" rreduction updateReduce_TCC57 0 (updateReduce_TCC59-1 nil 3705848866 ("" (subtype-tcc) nil nil) nil nil (updateReduce subtype "grS WITH [`redex := aval, `store := newstore, `stack := nnstack, `count := nncount]" "(noDanglingRefs?)")))("rreduction" rreduction maybe_clear_stack_at_TCC8 0 (maybe_clear_stack_at_TCC8-1 nil 3706028126 ("" (subtype-tcc) nil nil) nil nil (maybe_clear_stack_at subtype "(S WITH [`seq(S`length - IExpression_adt.index(x) - 1) := IExpression_adt.nil], cnt WITH [(IExpression_adt.refindex(v)) := cnt(IExpression_adt.refindex(v)) - 1])" "{((newStack: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(newStack))), ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) | newStack`length = S`length AND FORALL (i: below(S`length)): newStack`seq(newStack`length - 1 - i) = S`seq(S`length - 1 - i) OR (IExpression_adt.ref?(S`seq(S`length - 1 - i)) AND newStack`seq(newStack`length - 1 - i) = IExpression_adt.nil AND i = IExpression_adt.index(x) AND IExpression_adt.marked(x))}")))("rreduction" rreduction maybe_clear_stack_at_TCC9 0 (maybe_clear_stack_at_TCC9-1 nil 3706028126 ("" (subtype-tcc) nil nil) nil nil (maybe_clear_stack_at subtype "(S, cnt)" "{((newStack: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(newStack))), ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) | newStack`length = S`length AND FORALL (i: below(S`length)): newStack`seq(newStack`length - 1 - i) = S`seq(S`length - 1 - i) OR (IExpression_adt.ref?(S`seq(S`length - 1 - i)) AND newStack`seq(newStack`length - 1 - i) = IExpression_adt.nil AND i = IExpression_adt.index(x) AND IExpression_adt.marked(x))}")))("rreduction" rreduction maybe_clear_stack_at_TCC8 0 (maybe_clear_stack_at_TCC8-1 nil 3706032808 ("" (subtype-tcc) nil nil) nil nil (maybe_clear_stack_at subtype "(S WITH [`seq(S`length - IExpression_adt.index(x) - 1) := IExpression_adt.nil], cnt WITH [(IExpression_adt.refindex(v)) := cnt(IExpression_adt.refindex(v)) - 1])" "{((newStack: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(newStack) AND newStack`length = S`length)), ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) | FORALL (i: below(S`length)): newStack`seq(newStack`length - 1 - i) = S`seq(S`length - 1 - i) OR (IExpression_adt.ref?(S`seq(S`length - 1 - i)) AND newStack`seq(newStack`length - 1 - i) = IExpression_adt.nil AND i = IExpression_adt.index(x) AND IExpression_adt.marked(x))}")))("rreduction" rreduction maybe_clear_stack_at_TCC10 0 (maybe_clear_stack_at_TCC10-1 nil 3706032808 ("" (subtype-tcc) nil nil) nil nil (maybe_clear_stack_at subtype "(S, cnt)" "{((newStack: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(newStack) AND newStack`length = S`length)), ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) | FORALL (i: below(S`length)): newStack`seq(newStack`length - 1 - i) = S`seq(S`length - 1 - i) OR (IExpression_adt.ref?(S`seq(S`length - 1 - i)) AND newStack`seq(newStack`length - 1 - i) = IExpression_adt.nil AND i = IExpression_adt.index(x) AND IExpression_adt.marked(x))}")))("reduction_props" reduction_props decref_stillmatch 0 (decref_stillmatch-1 nil 3700419666 ("" (skeep* :preds? t) (("" (lemma decref1_induction) (("" (inst -1 "LAMBDA rS2: state_matches(eS, rS2)(translate)") (("" (split) (("1" (inst?) (("1" (prop) nil nil)) nil) ("2" (skolem 1 ("rS2" "r2" "i2")) (("2" (flatten) (("2" (hide-all-but (-1 -2 -3 1)) (("2" (expand state_matches) (("2" (flatten) (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (expand store_matches) (("5" (skeep :preds? t) (("5" (inst?) (("5" (case-replace "r!1 = r2") (("1" (grind) nil nil) ("2" (simplify) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((decref1_induction formula-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cvars def-decl "finite_set[nat]" preprocess nil) (rS2 skolem-const-decl "rstate" reduction_props nil) (r!1 skolem-const-decl "(rS2`domain)" reduction_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (translate_refs_value application-judgement "(value?)" reduction_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (unmark_cpure rec-application-judgement "(cpure?)" preprocess nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (translate_refs_contextPure rec-application-judgement "(contextPure?)" reduction_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_matches const-decl "boolean" reduction_props nil) (union const-decl "set" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (member const-decl "bool" sets nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (estate type-eq-decl nil reduction nil) (pred type-eq-decl nil defined_types nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak))("rreduction" rreduction letApply_TCC5 0 (letApply_TCC5-1 nil 3699206216 ("" (skeep*) (("" (rewrite map_length) (("" (typepred args) (("" (grind) (("" (expand length -2) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map_length formula-decl nil more_map_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (letApply subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: x WITH [`index := IExpression_adt.index(x) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1}")))("rreduction" rreduction releaseReduce_TCC9 0 (releaseReduce_TCC9-1 nil 3699031813 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (lift-if) (("" (ground) (("" (inst -7 i) (("" (ground) (("1" (apply-eta "grS`redex" "(release?)") (("1" (replace -1 :dir RL) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (pureReleaseRedex? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (grS skolem-const-decl "{grS | pureReleaseRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (rvar adt-accessor-decl "[(release?) -> (variable?)]" IExpression_adt nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (IExpression_release_eta formula-decl nil IExpression_adt nil) (release? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (cvars def-decl "finite_set[nat]" preprocess nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (releaseRedex? const-decl "bool" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (releaseReduce subtype "grS WITH [`stack`seq(stack`length - x - 1) := IExpression_adt.nil, `count(IExpression_adt.refindex(vx)) := grS`count(IExpression_adt.refindex(vx)) - 1, `redex := IExpression_adt.rexpr(grS`redex)]" "(noDanglingRefs?)")))("rreduction" rreduction maybe_clear_stack_at_TCC7 0 (maybe_clear_stack_at_TCC7-1 nil 3706028126 ("" (skeep* :preds? t) (("" (typepred "cnt(refindex(v))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (split) (("1" (expand refcountStack) (("1" (use "count_elem[(value?)]") (("1" (split) (("1" (assert) nil nil) ("2" (expand get) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (expand refcountStack) (("2" (rewrite count_update) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil) ((refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (count_elem formula-decl nil finseq_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (get const-decl "(value?)" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (count_update formula-decl nil finseq_theorems nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (count const-decl "nat" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (Store type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (every const-decl "bool" finseq_theorems nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil)) nil (maybe_clear_stack_at subtype "cnt(IExpression_adt.refindex(v)) - 1" "{j | j = refcount(dom, str, S WITH [`seq(S`length - 1 - IExpression_adt.index(x)) := IExpression_adt.nil], A)(IExpression_adt.refindex(v))}")))("rreduction" rreduction maybe_clear_stack_at_TCC8 0 (maybe_clear_stack_at_TCC8-1 nil 3706034968 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (< const-decl "bool" reals nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (Stack type-eq-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (maybe_clear_stack_at subtype "(S WITH [`seq(S`length - IExpression_adt.index(x) - 1) := IExpression_adt.nil], cnt WITH [(IExpression_adt.refindex(v)) := cnt(IExpression_adt.refindex(v)) - 1])" "{((newStack: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(newStack) AND newStack`length = S`length)), ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) | FORALL (i: below(S`length)): IExpression_adt.ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES IExpression_adt.ref?(S`seq(S`length - 1 - i)) AND NOT (i = IExpression_adt.index(x) AND IExpression_adt.marked(x))}")))("rreduction" rreduction update_store_TCC5 0 (update_store_TCC5-1 nil 3706028126 ("" (skeep* :preds? t) (("" (replace -10) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (typepred "cnt(refindex(ov))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (replace -1) (("1" (assert) (("1" (rewrite refcountStore_set) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "cnt(x1)") (("2" (rewrite -1) (("2" (expand refcount) (("2" (rewrite refcountStore_set) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (typepred "cnt(x1)") (("2" (rewrite -1) (("2" (expand refcount) (("2" (rewrite refcountStore_set) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (refcountStore_set formula-decl nil rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refs def-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (Store type-eq-decl nil reduction nil) (Stack type-eq-decl nil IL nil) (refcount const-decl "nat" rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (update_store subtype "cnt1" "[i: (dom) -> {j | j = refcount(dom, str WITH [(r)`seq(i) := nv], S, A)(i)}]")))("rreduction" rreduction updateReduce_TCC21 0 (updateReduce_TCC21-1 nil 3706028126 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (inst?) (("1" (typepred "maybe_clear_stack_at(grS`domain, grS`store, nstack, expr, ncount,
                            target(expr))") (("1" (typepred "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))") (("1" (inst -1 i) (("1" (inst -2 i) (("1" (replace* -34 -39 :dir RL) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (expand cvars -) (("1" (expand vars -) (("1" (expand add -1) (("1" (expand member) (("1" (typepred "grS`redex") (("1" (expand mark -) (("1" (decompose-equality -6) (("1" (expand popDepth +) (("1" (expand bumpn) (("1" (case-replace "i=index(rhs(grS`redex))") (("1" (assert) (("1" (replace -32) (("1" (replace -4 :dir RL) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "i = index(lhs(grS`redex))") (("1" (grind) nil nil) ("2" (replace -32) (("2" (replace -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length)),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}" rreduction nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (cvars def-decl "finite_set[nat]" preprocess nil) (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (markv const-decl "(variable?)" preprocess nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (update_store const-decl "{((newstr: Store(dom))),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (int_plus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (empty? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (nstack skolem-const-decl "{newStack: Stack |
   every(domainValue?(grS`domain))(newStack) AND
    newStack`length = stack`length}" rreduction nil) (nnstack skolem-const-decl "{newStack: Stack |
   every(domainValue?(grS`domain))(newStack) AND
    newStack`length = nstack`length}" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (i skolem-const-decl "below(nnstack`length)" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (noDanglingRefs? const-decl "bool" rreduction nil)) nil (updateReduce subtype "grS WITH [`redex := IExpression_adt.ref(newref), `domain := newdomain, `store := nnstore, `count := nnnncount, `stack := nnstack]" "(noDanglingRefs?)")))("rreduction" rreduction updateReduce_TCC26 0 (updateReduce_TCC26-1 nil 3706028126 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length)),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil (updateReduce subtype "nstack WITH [`seq(stack`length - 1 - IExpression_adt.index(IExpression_adt.target(expr))) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(grS`domain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC29 0 (updateReduce_TCC29-1 nil 3706028126 ("" (skeep* :preds? t) (("" (lemma decref1_chk_ndr) (("" (inst?) (("1" (hide 5) (("1" (expand noDanglingRefs?) (("1" (skeep* :preds? t) (("1" (assert) (("1" (expand popDepth) (("1" (expand bumpn) (("1" (inst?) (("1" (typepred "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))") (("1" (inst -1 i) (("1" (replace -35 :dir RL) (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (split -) (("1" (typepred "grS`redex") (("1" (replace -31) (("1" (replace -6 + :dir RL) (("1" (case-replace "i = index(rhs(grS`redex))") (("1" (grind) nil nil) ("2" (case-replace "i = index(lhs(grS`redex))") (("1" (grind) nil nil) ("2" (case-replace "i = index(target(grS`redex))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace -37) (("2" (split) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (split) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (typepred "grS`redex") (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (assert) (("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((decref1_chk_ndr judgement-tcc nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (update_store const-decl "{((newstr: Store(dom))),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (cvars def-decl "finite_set[nat]" preprocess nil) (markv const-decl "(variable?)" preprocess nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length)),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}" rreduction nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (newstore skolem-const-decl "Store(grS`domain)" rreduction nil) (nncount skolem-const-decl "[i: (grS`domain) ->
   {j | j = refcount(grS`domain, newstore, nnstack, aval)(i)}]" rreduction nil) (grS skolem-const-decl "{grS | updateRedex?(grS`redex) AND noDanglingRefs?(grS)}" rreduction nil) (aval skolem-const-decl "(domainValue?(grS`domain))" rreduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (nnstack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S) AND S`length = stack`length}" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "decref1_chk(grS WITH [`redex := aval, `store := newstore, `stack := nnstack, `count := nncount], oldvalue)" "(noDanglingRefs?)")))("ctranslation" ctranslation translate_statement_TCC3 0 (translate_statement_TCC3-1 nil 3706378600 ("" (well-founded-tcc) nil nil) nil nil (translate_statement well-founded "restrict[[IExpression_adt.IExpression, IExpression_adt.IExpression], [(IL.pure?), (IL.pure?)], boolean](IExpression_adt.<<)" "nil")))("creduction" creduction reduce_TCC62 0 (reduce_TCC53-1 nil 3704127090 ("" (cases-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (reduce cases "e1" "cexpr: DATATYPE
 BEGIN
  elv(lval: (lrvalue?)): elv?
  econstant(cvalue: int): econstant?
  enil: enil?
  ecall(cfun: nat, cargs: finseq[(cvar?)]): ecall?
  ebuiltin(cbuiltin: below(builtin_num), cbv1: (cvar?), cbv2: (cvar?)): ebuiltin?
 END cexpr")))("creduction" creduction reduce_TCC83 0 (reduce_TCC70-1 nil 3704127090 ("" (skeep* :preds? t) (("" (typepred "extract_stat(fbody)(lf`fpc)") (("" (grind) nil nil)) nil)) nil) ((cstate type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Stack type-eq-decl nil creduction nil) (cvalue type-decl nil creduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (> const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (extract_stat def-decl "{s2, j | j < clength(s2) AND executable_stat?(s2, j)}" creduction nil) (executable_stat? const-decl "bool" creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (cstat type-decl nil creduction nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce cases "s1" "cstat: DATATYPE
 BEGIN
  sassign(aval: lvalue, aexpr: cexpr): sassign?
  scall(sfun: nat, sargs: finseq[(cvar?)]): scall?
  sdecl(dtype: ctype, dstat: cstat): sdecl?
  sif(scond: (cvar?), iftrue: cstat, iffalse: cstat): sif?
  sblock(bstats: finseq[cstat]): sblock?
  smalloc(msize: nat): smalloc?
  sfree(fvar: (cvar?)): sfree?
 END cstat")))("creduction" creduction reduce_TCC62 0 (reduce_TCC62-1 nil 3706380043 ("" (cases-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (reduce cases "e1" "cexpr: DATATYPE
 BEGIN
  elv(lval: (lrvalue?)): elv?
  econstant(cvalue: int): econstant?
  enil: enil?
  ecall(cfun: nat, cargs: finseq[(cvar?)]): ecall?
  ebuiltin(cbuiltin: below(builtin_num), cbv1: (cvar?), cbv2: (cvar?)): ebuiltin?
  emalloc(msize: nat): emalloc?
 END cexpr")))("iareduction" iareduction iapply_nstack_TCC9 0 (iapply_nstack_TCC9-1 nil 3706450317 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), list_adt[(IExpression_adt.variable?)].cdr(args), str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706450317 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), list_adt[(IExpression_adt.variable?)].cdr(args), str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iapply_nstack_TCC13 0 (iapply_nstack_TCC13-1 nil 3706450317 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "list_adt[(IExpression_adt.variable?)].cdr(args)" "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1 AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < IL.push(u, S)`length}")))("iareduction" iareduction iapply_nstack_TCC16 0 (iapply_nstack_TCC16-1 nil 3706450317 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S), list_adt[(IExpression_adt.variable?)].cdr(args), str, A, cnt WITH [(IExpression_adt.refindex(u)) := cnt(IExpression_adt.refindex(u)) + 1])" "nil")))("iareduction" iareduction iapply_nstack_TCC17 0 (iapply_nstack_TCC17-1 nil 3706450317 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S), list_adt[(IExpression_adt.variable?)].cdr(args), str, A, cnt WITH [(IExpression_adt.refindex(u)) := cnt(IExpression_adt.refindex(u)) + 1])" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iapply_nstack_TCC21 0 (iapply_nstack_TCC21-1 nil 3706450317 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "list_adt[(IExpression_adt.variable?)].cdr(args)" "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1 AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < IL.push(u, S)`length}")))("iareduction" iareduction iapply_nstack_TCC23 0 (iapply_nstack_TCC23-1 nil 3706450317 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S), list_adt[(IExpression_adt.variable?)].cdr(args), str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC24 0 (iapply_nstack_TCC24-1 nil 3706450317 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S), list_adt[(IExpression_adt.variable?)].cdr(args), str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iapply_nstack_TCC25 0 (iapply_nstack_TCC25-1 nil 3706450317 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "args" "(cons?[(IExpression_adt.variable?)])")))("iareduction" iareduction iapply_nstack_TCC4 0 (iapply_nstack_TCC4-1 nil 3706451404 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "y WITH [`index := IExpression_adt.index(y) + 1]" "(IExpression_adt.variable?)")))("iareduction" iareduction iapply_nstack_TCC5 0 (iapply_nstack_TCC5-1 nil 3706451404 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite map_length) (("1" (expand length 1 2) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -8 "i-1") (("1" (split) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_map) (("2" (expand o) (("2" (expand some 1) (("2" (lift-if +) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (rewrite some_nth) (("2" (rewrite some_nth) (("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (in_varlist const-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (map_length formula-decl nil more_map_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (O const-decl "T3" function_props nil) (some_nth formula-decl nil finseq_theorems nil) (some_map formula-decl nil finseq_theorems nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (iapply_nstack subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))("iareduction" iareduction iapply_nstack_TCC9 0 (iapply_nstack_TCC6-1 nil 3706450317 ("" (skeep* :preds? t) (("" (expand every (-7 2)) (("" (skeep :preds? t) (("" (expand push) (("" (expand add) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (inst -9 "S`length - index(car(args)) - 1") (("1" (grind) nil nil) ("2" (inst -11 "index(car(args))") (("2" (split -11) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_nth) (("2" (inst 1 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (inst -8 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (every const-decl "bool" finseq_theorems nil) (push const-decl "Stack" IL nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nth def-decl "T" list_props nil) (some_nth formula-decl nil finseq_theorems nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil)) nil (iapply_nstack subtype "IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])" "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))("iareduction" iareduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706451404 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (push const-decl "Stack" IL nil) (add const-decl "finseq[T]" more_finseq nil) (in_varlist const-decl "finite_set[nat]" IL nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Stack type-eq-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (iapply_nstack subtype "nargs" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))("iareduction" iareduction iapply_nstack_TCC11 0 (iapply_nstack_TCC8-1 nil 3706450317 ("" (skeep* :preds? t) (("" (typepred "cnt(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand push) (("" (expand refcountStack) (("" (rewrite count_add) (("1" (rewrite count_update) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (inst -11 "index(car(args))") (("2" (split -11) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_nth) (("2" (inst 1 0) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (inst -11 "index(car(args))") (("3" (split -11) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_nth) (("2" (inst 1 0) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every const-decl "bool" finseq_theorems nil) (refcount const-decl "nat" rreduction nil) (Stack type-eq-decl nil IL nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (refcountStack const-decl "nat" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (count_update formula-decl nil finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (some_nth formula-decl nil finseq_theorems nil) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (in_varlist const-decl "finite_set[nat]" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (count_add formula-decl nil finseq_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (push const-decl "Stack" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "cnt" "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), A)(i)}]")))("iareduction" iareduction iapply_nstack_TCC12 0 (iapply_nstack_TCC12-1 nil 3706451404 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC13 0 (iapply_nstack_TCC13-1 nil 3706451404 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (push const-decl "Stack" IL nil) (add const-decl "finseq[T]" more_finseq nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (in_varlist const-decl "finite_set[nat]" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Stack type-eq-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iapplyReduce_TCC4 0 (iapplyReduce_TCC4-1 nil 3706450317 ("" (skeep* :preds? t) (("" (typepred "ncount(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountExpr) (("" (rewrite npops_refs) (("" (rewrite pure_refs) (("1" (rewrite pure_refs) (("1" (use pure_mark) (("1" (typepred "def`body") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refcountExpr const-decl "nat" rreduction nil) (pure_refs formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure_mark formula-decl nil preprocess nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (npops_refs formula-decl nil iareduction nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil iareduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (applyRedex? const-decl "bool" IL nil)) nil (iapplyReduce subtype "ncount" "[i: (grS`domain) -> {j | rreduction.j = rreduction.refcount(grS`domain, grS`store, nstack, npops(def`arity, preprocess.mark(sets[nat].emptyset)(def`body)))(i)}]")))("iareduction" iareduction iareduce_TCC4 0 (iareduce_TCC4-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureLetRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC7 0 (iareduce_TCC7-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC9 0 (iareduce_TCC9-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.updateRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction iareduce_TCC11 0 (iareduce_TCC11-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC13 0 (iareduce_TCC13-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.newintRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC15 0 (iareduce_TCC15-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC17 0 (iareduce_TCC17-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.popRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction iareduce_TCC19 0 (iareduce_TCC19-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureReleaseRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction iapply_nstack_TCC4 0 (iapply_nstack_TCC4-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1]" "(IExpression_adt.variable?)")))("iareduction" iareduction iapply_nstack_TCC5 0 (iapply_nstack_TCC5-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))("iareduction" iareduction iapply_nstack_TCC9 0 (iapply_nstack_TCC9-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])" "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))("iareduction" iareduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "nargs" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))("iareduction" iareduction iapply_nstack_TCC11 0 (iapply_nstack_TCC11-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "cnt" "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), A)(i)}]")))("iareduction" iareduction iapply_nstack_TCC12 0 (iapply_nstack_TCC12-1 nil 3706457843 ("" (termination-tcc) nil nil) nil nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC13 0 (iapply_nstack_TCC13-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iareduce_TCC7 0 (iareduce_TCC7-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureIftRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC9 0 (iareduce_TCC9-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.updateRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction iareduce_TCC11 0 (iareduce_TCC11-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.lookupRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC13 0 (iareduce_TCC13-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.newintRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC15 0 (iareduce_TCC15-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.newrefRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC17 0 (iareduce_TCC17-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.popRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction iareduce_TCC19 0 (iareduce_TCC19-1 nil 3706457843 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureReleaseRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction applyReduce_match_rec_TCC2 0 (applyReduce_match_rec_TCC2-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "IExpression_adt.args(grS`redex)" "{args: list[(IExpression_adt.variable?)] | 2 * k <= list_props[(IExpression_adt.variable?)].length(args) AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < grS`stack`length}")))("iareduction" iareduction applyReduce_match_rec_TCC4 0 (applyReduce_match_rec_TCC4-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "grS`store" "reduction.Store(nS`domain)")))("iareduction" iareduction applyReduce_match_rec_TCC5 0 (applyReduce_match_rec_TCC5-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "IExpression_adt.args(grS`redex)" "{args: list[(IExpression_adt.variable?)] | 2 + 2 * k <= list_props[(IExpression_adt.variable?)].length(args) AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < grS`stack`length}")))("iareduction" iareduction applyReduce_match_rec_TCC6 0 (applyReduce_match_rec_TCC6-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "D" "Defs")))("iareduction" iareduction applyReduce_match_rec_TCC7 0 (applyReduce_match_rec_TCC7-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "grS`store" "reduction.Store(nS`domain)")))("iareduction" iareduction iapply_nstack_iterm_TCC10 0 (iapply_nstack_iterm_TCC10-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_iterm subtype "nargs" "{args: list[(IExpression_adt.variable?)] | 2 * k - 4 <= list_props[(IExpression_adt.variable?)].length(args) AND FORALL i: IL.in_varlist(args)(i) IMPLIES i < nstack`length}")))("rreduction" rreduction letApply_TCC5 0 (letApply_TCC5-1 nil 3699206216 ("" (skeep*) (("" (rewrite map_length) (("" (typepred args) (("" (grind) (("" (expand length -2) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map_length formula-decl nil more_map_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) nil (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (letApply subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA x: x WITH [`index := IExpression_adt.index(x) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{args: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args) = arity - 1}")))("rreduction" rreduction releaseReduce_TCC9 0 (releaseReduce_TCC9-1 nil 3699031813 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (lift-if) (("" (ground) (("" (inst -7 i) (("" (ground) (("1" (apply-eta "grS`redex" "(release?)") (("1" (replace -1 :dir RL) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (pureReleaseRedex? const-decl "bool" IL nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) nil (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (rvar adt-accessor-decl "[(release?) -> (variable?)]" IExpression_adt nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (IExpression_release_eta formula-decl nil IExpression_adt nil) (release? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) nil (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (releaseRedex? const-decl "bool" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (releaseReduce subtype "grS WITH [`stack`seq(stack`length - x - 1) := IExpression_adt.nil, `count(IExpression_adt.refindex(vx)) := grS`count(IExpression_adt.refindex(vx)) - 1, `redex := IExpression_adt.rexpr(grS`redex)]" "(noDanglingRefs?)")))("rreduction" rreduction variableReduce_TCC8 0 (variableReduce_TCC8-1 nil 3705857843 ("" (skeep* :preds? t) (("" (typepred "grS`count(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (rewrite count_update) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (inst -5 "index(expr)") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (count_update formula-decl nil finseq_theorems nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (markv const-decl "(variable?)" preprocess nil) (get const-decl "(value?)" IL nil) (singleton const-decl "(singleton?)" sets nil) (refcountExpr const-decl "nat" rreduction nil) (int_plus_int_is_int application-judgement "int" integers nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (refcountStack const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (variableReduce subtype "grS`count" "[i: (grS`domain) -> {j | j = refcount(grS`domain, grS`store, grS`stack WITH [`seq(stack`length - 1 - IExpression_adt.index(expr)) := IExpression_adt.nil], value)(i)}]")))("rreduction" rreduction updateReduce_TCC21 0 (updateReduce_TCC21-1 nil 3706028126 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skeep* :preds? t) (("" (inst?) (("1" (typepred "maybe_clear_stack_at(grS`domain, grS`store, nstack, expr, ncount,
                            target(expr))") (("1" (typepred "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))") (("1" (inst -1 i) (("1" (inst -2 i) (("1" (replace* -34 -39 :dir RL) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (split -) (("1" (expand cvars -) (("1" (expand vars -) (("1" (expand add -1) (("1" (expand member) (("1" (typepred "grS`redex") (("1" (expand mark -) (("1" (decompose-equality -6) (("1" (expand popDepth +) (("1" (expand bumpn) (("1" (case-replace "i=index(rhs(grS`redex))") (("1" (assert) (("1" (replace -32) (("1" (replace -4 :dir RL) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "i = index(lhs(grS`redex))") (("1" (grind) nil nil) ("2" (replace -32) (("2" (replace -1 :dir RL) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length)),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}" rreduction nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) nil (add const-decl "(nonempty?)" sets nil) (nonempty? const-decl "bool" sets nil) (markv const-decl "(variable?)" preprocess nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (update_store const-decl "{((newstr: Store(dom))),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil) (count_copy def-decl "[(dom) -> nat]" rreduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (int_plus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (empty? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) nil nil nil nil (below type-eq-decl nil naturalnumbers nil) nil (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (noDanglingRefs? const-decl "bool" rreduction nil)) nil (updateReduce subtype "grS WITH [`redex := IExpression_adt.ref(newref), `domain := newdomain, `store := nnstore, `count := nnnncount, `stack := nnstack]" "(noDanglingRefs?)")))("rreduction" rreduction updateReduce_TCC26 0 (updateReduce_TCC26-1 nil 3706028126 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length)),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil (updateReduce subtype "nstack WITH [`seq(stack`length - 1 - IExpression_adt.index(IExpression_adt.target(expr))) := IExpression_adt.nil]" "{S: IL.Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(grS`domain))(S) AND S`length = stack`length}")))("rreduction" rreduction updateReduce_TCC29 0 (updateReduce_TCC29-1 nil 3706028126 ("" (skeep* :preds? t) (("" (lemma decref1_chk_ndr) (("" (inst?) (("1" (hide 5) (("1" (expand noDanglingRefs?) (("1" (skeep* :preds? t) (("1" (assert) (("1" (expand popDepth) (("1" (expand bumpn) (("1" (inst?) (("1" (typepred "maybe_clear_stack_at(grS`domain, grS`store, stack, expr, grS`count,
                            rhs(expr))") (("1" (inst -1 i) (("1" (replace -35 :dir RL) (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (split -) (("1" (typepred "grS`redex") (("1" (replace -31) (("1" (replace -6 + :dir RL) (("1" (case-replace "i = index(rhs(grS`redex))") (("1" (grind) nil nil) ("2" (case-replace "i = index(lhs(grS`redex))") (("1" (grind) nil nil) ("2" (case-replace "i = index(target(grS`redex))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace -37) (("2" (split) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (split) (("1" (skeep) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (typepred "grS`redex") (("3" (inst -3 i) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (assert) (("4" (typepred "grS`redex") (("4" (grind) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((decref1_chk_ndr judgement-tcc nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (update_store const-decl "{((newstr: Store(dom))),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, newstr, S, A)(i)}])) |
   newstr = str WITH [(r)`seq(i) := nv]}" rreduction nil) (get const-decl "(value?)" IL nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") nil (markv const-decl "(variable?)" preprocess nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (marked adt-accessor-decl "[(variable?) -> bool]" IExpression_adt nil) (maybe_clear_stack_at const-decl "{((newStack: Stack
       | every(domainValue?(dom))(newStack) AND
          newStack`length = S`length)),
 ((newcnt: [i: (dom) -> {j | j = refcount(dom, str, newStack, A)(i)}])) |
   FORALL (i: below(S`length)):
     ref?(newStack`seq(newStack`length - 1 - i)) IMPLIES
      ref?(S`seq(S`length - 1 - i)) AND NOT (i = index(x) AND marked(x))}" rreduction nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) nil nil nil nil nil nil (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (updateReduce subtype "decref1_chk(grS WITH [`redex := aval, `store := newstore, `stack := nnstack, `count := nncount], oldvalue)" "(noDanglingRefs?)")))("iareduction" iareduction iapply_nstack_TCC4 0 (iapply_nstack_TCC4-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "y WITH [`index := IExpression_adt.index(y) + 1]" "(IExpression_adt.variable?)")))("iareduction" iareduction iapply_nstack_TCC5 0 (iapply_nstack_TCC5-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))("iareduction" iareduction iapply_nstack_TCC9 0 (iapply_nstack_TCC9-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])" "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))("iareduction" iareduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "nargs" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))("iareduction" iareduction iapply_nstack_TCC11 0 (iapply_nstack_TCC11-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "cnt" "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), A)(i)}]")))("iareduction" iareduction iapply_nstack_TCC12 0 (iapply_nstack_TCC12-1 nil 3706461701 ("" (termination-tcc) nil nil) nil nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC13 0 (iapply_nstack_TCC13-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iapply_nstack_iterm_TCC4 0 (iapply_nstack_iterm_TCC4-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_iterm subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))("iareduction" iareduction iapply_nstack_iterm_TCC7 0 (iapply_nstack_iterm_TCC7-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_iterm subtype "IL.push(u, IF IExpression_adt.ref?(u) AND IExpression_adt.marked(list_adt[(IExpression_adt.variable?)].car(args)) THEN S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil] ELSE S ENDIF)" "{S1 | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1)}")))("iareduction" iareduction iapply_nstack_iterm_TCC7 0 (iapply_nstack_iterm_TCC7-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_iterm subtype "S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]" "{S1 | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1)}")))("iareduction" iareduction iapply_nstack_TCC4 0 (iapply_nstack_TCC4-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1]" "(IExpression_adt.variable?)")))("iareduction" iareduction iapply_nstack_TCC5 0 (iapply_nstack_TCC5-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))("iareduction" iareduction iapply_nstack_TCC9 0 (iapply_nstack_TCC9-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])" "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))("iareduction" iareduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "nargs" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))("iareduction" iareduction iapply_nstack_TCC11 0 (iapply_nstack_TCC11-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "cnt" "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), A)(i)}]")))("iareduction" iareduction iapply_nstack_TCC12 0 (iapply_nstack_TCC12-1 nil 3706468809 ("" (termination-tcc) nil nil) nil nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC13 0 (iapply_nstack_TCC13-1 nil 3706468809 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [(seq)(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iareduce_TCC7 0 (iareduce_TCC7-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC9 0 (iareduce_TCC9-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.updateRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction iareduce_TCC11 0 (iareduce_TCC11-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC13 0 (iareduce_TCC13-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.newintRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC15 0 (iareduce_TCC15-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))("iareduction" iareduction iareduce_TCC17 0 (iareduce_TCC17-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.popRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction iareduce_TCC19 0 (iareduce_TCC19-1 nil 3706461701 ("" (subtype-tcc) nil nil) nil nil (iareduce subtype "nS" "{grS | IL.pureReleaseRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction applyReduce_match_rec_TCC3 0 (applyReduce_match_rec_TCC3-1 nil 3706462664 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "rS" "{grS | rreduction.noDanglingRefs?(rreduction.grS)}")))("iareduction" iareduction iapplyReduce_ndr_TCC1 0 (iapplyReduce_ndr_TCC1-1 nil 3706456701 ("" (subtype-tcc) nil nil) nil nil (iapplyReduce_ndr_ subtype "grS" "{grS | IL.applyRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC7 0 (iareduce_TCC7-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.pureIftRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC9 0 (iareduce_TCC9-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.updateRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction iareduce_TCC11 0 (iareduce_TCC11-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.lookupRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC13 0 (iareduce_TCC13-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.newintRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC15 0 (iareduce_TCC15-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.newrefRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC17 0 (iareduce_TCC17-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.popRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction iareduce_TCC19 0 (iareduce_TCC19-1 nil 3706474326 ("" (skeep* :preds? t) (("" (split) (("1" (grind) nil nil) ("2" (typepred "make_redex(t)") (("2" (grind) nil nil)) nil) ("3" (propax) nil nil)) nil)) nil) ((buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (value? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pureRedex? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.pureReleaseRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction applyReduce_match_rec_TCC3 0 (applyReduce_match_rec_TCC3-1 nil 3706474326 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (pure? def-decl "bool" IL nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (vars def-decl "finite_set[nat]" IL nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (refs def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (apply_iterm_match const-decl "bool" iareduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (applyReduce_match_rec subtype "rS" "{grS | rreduction.noDanglingRefs?(grS)}")))("iareduction" iareduction iareduce_TCC4 0 (iareduce_TCC4-1 nil 3706457843 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "nS" "{grS | IL.pureLetRedex?(grS`redex)}")))("iareduction" iareduction iareduce_TCC5 0 (iareduce_TCC5-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC8 0 (iareduce_TCC8-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC10 0 (iareduce_TCC10-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC12 0 (iareduce_TCC12-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC14 0 (iareduce_TCC14-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC16 0 (iareduce_TCC16-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC18 0 (iareduce_TCC18-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction iareduce_TCC20 0 (iareduce_TCC20-1 nil 3706456701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (iareduce subtype "D" "Defs")))("iareduction" iareduction applyReduce_match_rec_TCC4 0 (applyReduce_match_rec_TCC3-1 nil 3706461701 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil)) nil (applyReduce_match_rec subtype "D" "Defs")))("iareduction" iareduction applyReduce_match_init_TCC4 0 (applyReduce_match_init_TCC4-1 nil 3706471298 ("" (skeep* :preds? t) (("" (typepred "D`seq(x1)`body") (("" (assert) (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Defs type-eq-decl nil iareduction nil) (Definition type-eq-decl nil iareduction nil) (unmark def-decl "IExpression" preprocess nil) (< const-decl "bool" reals nil) nil (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_pure rec-application-judgement "(pure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (applyReduce_match_init subtype "D" "Defs")))("typed_rreduction" typed_rreduction defs_subtype 0 (defs_subtype-1 nil 3706538966 ("" (judgement-tcc) nil nil) nil nil (defs_subtype subtype "x" "rreduction.Defs")))("typed_rreduction" typed_rreduction is_well_typed_letApply_TCC8 0 (is_well_typed_letApply_TCC8-1 nil 3705955367 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite purePopDepth) (("1" (assert) nil nil) ("2" (rewrite pure_letApply) nil nil)) nil) ("2" (skeep) (("2" (rewrite cvars_pure) (("1" (rewrite vars_letApply) (("1" (split) (("1" (inst -9 i) (("1" (assert) nil nil)) nil) ("2" (inst -8 "arity+i") (("2" (rewrite cvars_pure) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite pure_letApply) nil nil)) nil)) nil)) nil)) nil) ((pure? def-decl "bool" IL nil) (pure_letApply recursive-judgement-axiom nil rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (letApply def-decl "IExpression" rreduction nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil) (purePopDepth formula-decl nil IL nil) (cvars_pure formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_letApply formula-decl nil rreduction nil)) nil (is_well_typed_letApply subtype "stypes" "{stypes | IL.popDepth(rreduction.letApply(arity, args, A)) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(rreduction.letApply(arity, args, A))(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC5 0 (updateReduce_new_store_TCC9-1 nil 3705955367 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(IL.x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC8 0 (updateReduce_new_store_TCC8-1 nil 3705955367 ("" (skeep* :preds? t) (("" (use updateRedex_target_index) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((updateRedex_target_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.target(rS`redex)" "{x | IExpression_adt.index(IL.x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 "" 3706014775 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) nil shostak (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(IL.x) < rS`stack`length}")) (updateReduce_new_store_TCC2-1 nil 3702993203 ("" (skeep* :preds? t) (("" (use updateRedex_target_index) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.target(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC2 0 (typed_reduce_TCC2-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IExpression_adt.variable?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC8 0 (typed_reduce_TCC8-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureLetRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC15 0 (typed_reduce_TCC15-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.applyRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC24 0 (typed_reduce_TCC24-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureIftRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC29 0 (typed_reduce_TCC29-1 nil 3705955367 ("" (skeep* :preds? t) (("" (use ifReduce_correct_indexing) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (replace* (-5 -3)) (("2" (expand* make_redex_typed make_redex typed_to_topstate to_topstate) nil nil)) nil)) nil)) nil) ((ifReduce_correct_indexing formula-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) nil (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "IExpression_adt.condition(nS`state`redex)" "{x | IExpression_adt.index(IL.x) < nS`state`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC34 0 (typed_reduce_TCC34-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.updateRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC42 0 (typed_reduce_TCC42-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.lookupRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC48 0 (typed_reduce_TCC48-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newintRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC56 0 (typed_reduce_TCC56-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newrefRedex?(rreduction.grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC64 0 (typed_reduce_TCC64-1 nil 3705955367 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) nil (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.popRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC72 0 (typed_reduce_TCC72-1 nil 3705955367 ("" (skeep* :preds? t) (("" (case "pureRedex?(nS`state`redex)") (("1" (split) (("1" (replace* (-5 -4)) (("1" (expand* make_redex_typed make_redex typed_to_topstate to_topstate) nil nil)) nil) ("2" (expand pureRedex?) (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil) ("6" (propax) nil nil) ("7" (propax) nil nil) ("8" (propax) nil nil) ("9" (propax) nil nil) ("10" (propax) nil nil)) nil)) nil) ("3" (typepred "nS`state") (("3" (propax) nil nil)) nil)) nil) ("2" (replace -3) (("2" (expand make_redex_typed) (("2" (expand make_redex) (("2" (typepred "buildRedex(t`state`redex)") (("2" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (replace* (-1 -2)) (("2" (expand fill) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((typed_rstate type-eq-decl nil typed_rreduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) nil (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) nil (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (tdef type-eq-decl nil typed_rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pureRedex? const-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureReleaseRedex?(rreduction.grS`redex) AND rreduction.noDanglingRefs?(rreduction.grS)}")))("ctranslation" ctranslation translate_statement_TCC44 0 (translate_statement_TCC40-1 nil 3706378600 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pure? def-decl "bool" IL nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (cvars def-decl "finite_set[nat]" preprocess nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (contextPure? def-decl "bool" IL nil) (typeinfo type-decl nil typeinfo_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil ctranslation nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (cvar adt-constructor-decl "[nat -> (cvar?)]" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (add const-decl "finseq[T]" more_finseq nil) (seq1 const-decl "finseq[T]" ctranslation nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (translate_statement subtype "seq1(creduction.cvar(translate_vars(IExpression_adt.index(x))))" "finseq[(creduction.cvar?)]")))("ctranslation" ctranslation translate_statement_TCC49 0 (translate_statement_TCC45-1 nil 3706378600 ("" (skeep* :preds? t) (("" (rewrite cvars_pure) (("" (inst -3 "index(x)") (("" (grind) nil nil)) nil)) nil)) nil) ((cvars_pure formula-decl nil preprocess nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pure? def-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (add const-decl "(nonempty?)" sets nil) (vars def-decl "finite_set[nat]" IL nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil (translate_statement subtype "stypes`length - 1 - IExpression_adt.index(x)" "below[stypes`length]")))("typed_rreduction" typed_rreduction is_well_typed_letApply_TCC8 0 (is_well_typed_letApply_TCC8-1 nil 3706540664 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite purePopDepth) (("1" (assert) nil nil) ("2" (rewrite pure_letApply) nil nil)) nil) ("2" (skeep) (("2" (rewrite cvars_pure) (("1" (rewrite vars_letApply) (("1" (split) (("1" (inst -9 i) (("1" (assert) nil nil)) nil) ("2" (inst -8 "arity+i") (("2" (rewrite cvars_pure) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite pure_letApply) nil nil)) nil)) nil)) nil)) nil) ((pure? def-decl "bool" IL nil) (pure_letApply recursive-judgement-axiom nil rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (letApply def-decl "IExpression" rreduction nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil) (purePopDepth formula-decl nil IL nil) (cvars_pure formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_letApply formula-decl nil rreduction nil)) nil (is_well_typed_letApply subtype "stypes" "{stypes | IL.popDepth(rreduction.letApply(arity, args, A)) <= stypes`length AND FORALL i: preprocess.cvars(rreduction.letApply(arity, args, A))(i) IMPLIES i < stypes`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC8 0 (updateReduce_new_store_TCC8-1 nil 3706540664 ("" (skeep* :preds? t) (("" (use updateRedex_target_index) (("" (grind) nil nil)) nil)) nil) ((updateRedex_target_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.target(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 nil 3706540664 ("" (skeep* :preds? t) (("" (use updateRedex_rhs_index) (("" (grind) nil nil)) nil)) nil) ((updateRedex_rhs_index formula-decl nil rreduction nil) (updateRedex? const-decl "bool" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (updateReduce_new_store subtype "IExpression_adt.rhs(rS`redex)" "{x | IExpression_adt.index(x) < rS`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC2 0 (typed_reduce_TCC2-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IExpression_adt.variable?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC8 0 (typed_reduce_TCC8-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureLetRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC15 0 (typed_reduce_TCC15-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.applyRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC24 0 (typed_reduce_TCC24-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureIftRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC29 0 (typed_reduce_TCC29-1 nil 3706540664 ("" (skeep* :preds? t) (("" (use ifReduce_correct_indexing) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (expand* make_redex_typed typed_to_topstate make_redex to_topstate) (("2" (replace*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((ifReduce_correct_indexing formula-decl nil rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (nS skolem-const-decl "typed_rstate" typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "IExpression_adt.condition(nS`state`redex)" "{x | IExpression_adt.index(x) < nS`state`stack`length}")))("typed_rreduction" typed_rreduction typed_reduce_TCC34 0 (typed_reduce_TCC34-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.updateRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC42 0 (typed_reduce_TCC42-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.lookupRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC48 0 (typed_reduce_TCC48-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newintRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC56 0 (typed_reduce_TCC56-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.newrefRedex?(grS`redex)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC64 0 (typed_reduce_TCC64-1 nil 3706540664 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (value? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.popRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("typed_rreduction" typed_rreduction typed_reduce_TCC72 0 (typed_reduce_TCC72-1 nil 3706540664 ("" (skeep* :preds? t) (("" (expand make_redex_typed) (("" (typepred "make_redex(t`state)") (("" (split) (("1" (replace*) (("1" (expand* typed_to_topstate to_topstate make_redex) nil nil)) nil) ("2" (replace*) (("2" (assert) (("2" (grind) nil nil)) nil)) nil) ("3" (replace -4 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND value?(B)))}" IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pureRedex? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (make_redex const-decl "{rS | pureRedex?(rS`redex)}" rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (typed_reduce subtype "nS`state" "{grS | IL.pureReleaseRedex?(grS`redex) AND rreduction.noDanglingRefs?(grS)}")))("typed_rreduction" typed_rreduction typed_iareduce_TCC4 0 (typed_iareduce_TCC4-1 nil 3706538966 ("" (subtype-tcc) nil nil) nil nil (typed_iareduce subtype "typed_reduction.letApply_type(length(tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), finseq2list[nat](tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`body_type)" "{tA | typed_reduction.is_well_typed(iareduction.iapplyReduce(D)(nS`state)`redex, tA, nS`stack_types, nS`dom_types, nS`def_types)}")))("typed_rreduction" typed_rreduction typed_iareduce_TCC5 0 (typed_iareduce_TCC5-1 nil 3706538966 ("" (subtype-tcc) nil nil) nil nil (typed_iareduce subtype "nS`context_type" "{tK | typed_reduction.is_well_typed_ctx(iareduction.iapplyReduce(D)(nS`state)`context, tK, typed_reduction.popn(nS`stack_types, IL.popDepth(iareduction.iapplyReduce(D)(nS`state)`redex)), nS`dom_types, nS`def_types, typed_reduction.expr_type(typed_reduction.letApply_type(length(tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), finseq2list[nat](tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`body_type)))}")))("iareduction" iareduction iapply_nstack_indices_TCC3 0 (iapply_nstack_indices_TCC3-1 nil 3706557670 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_indices subtype "S`length - 1 - IExpression_adt.index(list_props[(IExpression_adt.variable?)].nth(args, k))" "below[S`length]")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC7 0 (iapply_nstack_types_TCC7-1 nil 3706555818 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes)`length}")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC8 0 (iapply_nstack_types_TCC8-1 nil 3706555818 ("" (termination-tcc) nil nil) nil nil (iapply_nstack_types termination "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "nil")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC9 0 (iapply_nstack_types_TCC9-1 nil 3706555818 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "{stypes2 | stypes2`length = arity + stypes`length}")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC7 0 (iapply_nstack_types_TCC7-1 nil 3706618643 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes)`length}")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC8 0 (iapply_nstack_types_TCC8-1 nil 3706618643 ("" (termination-tcc) nil nil) nil nil (iapply_nstack_types termination "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "nil")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC9 0 (iapply_nstack_types_TCC9-1 nil 3706618643 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "{stypes2 | stypes2`length = arity + stypes`length}")))("typed_rreduction" typed_rreduction typed_iareduce_TCC4 0 (typed_iareduce_TCC4-1 nil 3706555818 ("" (skeep* :preds? t) (("" (expand iapplyReduce) (("" (typepred "nS`redex_type") (("" (expand applyRedex?) (("" (assert) (("" (expand is_well_typed -) (("" (flatten) (("" (assert) (("" (expand defs_well_typed) (("" (flatten) (("" (assert) (("" (case-replace "nS`def_types = tS`def_types") (("1" (assert) (("1" (inst? -7) (("1" (flatten) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (replace* -9 -7) (("2" (expand* make_redex_typed typed_to_topstate) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (typed_iareduce subtype "tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`body_type" "{tA | typed_reduction.is_well_typed(iareduction.iapplyReduce(D)(nS`state)`redex, tA, finite_sequences[nat].o(nS`stack_types, tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), nS`dom_types, nS`def_types)}")))("typed_rreduction" typed_rreduction typed_iareduce_TCC5 0 (typed_iareduce_TCC5-2 nil 3706620786 ("" (skeep* :preds? t) (("" (expand* iapplyReduce) (("" (assert) (("" (typepred "nS`redex_type") (("" (expand applyRedex?) (("" (assert) (("" (expand is_well_typed) (("" (flatten) (("" (expand defs_well_typed) (("" (flatten) (("" (case-replace "nS`def_types = tS`def_types") (("1" (assert) (("1" (inst? -7) (("1" (flatten) (("1" (assert) (("1" (rewrite npops_popDepth) (("1" (rewrite purePopDepth) (("1" (assert) (("1" (rewrite popn_append :dir RL) (("1" (case-replace "popn(tS`def_types`seq
                                        (fun(nS`state`redex))`args_type,
                                    D`seq(fun(nS`state`redex))`arity) = empty_seq[nat]") (("1" (case-replace "nS`stack_types o empty_seq[nat] = nS`stack_types") (("1" (typepred "nS`context_type") (("1" (case-replace "popDepth(nS`state`redex) = 0") (("1" (assert) (("1" (replace -5) (("1" (replace -12 :dir RL) (("1" (replace -7) (("1" (expand expr_type -2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (replace -7) (("2" (hide-all-but 1) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite pure_mark) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace* -7 -9) (("2" (expand* make_redex_typed typed_to_topstate) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (applyRedex? const-decl "bool" IL nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil typed_rreduction nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (purePopDepth formula-decl nil IL nil) (popn_append formula-decl nil typed_reduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (D skolem-const-decl "Defs" typed_rreduction nil) (tS skolem-const-decl "{tS | NOT tS`state`error AND defs_well_typed(D, tS`def_types)}" typed_rreduction nil) (nS skolem-const-decl "typed_rstate" typed_rreduction nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (FALSE const-decl "bool" booleans nil) (O const-decl "finseq" finite_sequences nil) (popn_zero formula-decl nil typed_reduction nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (pure_mark formula-decl nil preprocess nil) (npops_popDepth formula-decl nil iareduction nil) (make_redex_typed const-decl "typed_rstate" typed_rreduction nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (typed_to_topstate const-decl "typed_rstate" typed_rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (typeinfo type-decl nil typeinfo_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (cvars def-decl "finite_set[nat]" preprocess nil) (< const-decl "bool" reals nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (iapplyReduce const-decl "rstate" iareduction nil)) nil (typed_iareduce subtype "nS`context_type" "{tK | typed_reduction.is_well_typed_ctx(iareduction.iapplyReduce(D)(nS`state)`context, tK, typed_reduction.popn(finite_sequences[nat].o(nS`stack_types, tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), IL.popDepth(iareduction.iapplyReduce(D)(nS`state)`redex)), nS`dom_types, nS`def_types, typed_reduction.expr_type(tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`body_type))}")) (typed_iareduce_TCC5-1 nil 3706555818 ("" (skeep* :preds? t) (("" (expand* iapplyReduce) (("" (assert) (("" (typepred "nS`redex_type") (("" (expand applyRedex?) (("" (assert) (("" (expand is_well_typed) (("" (flatten) (("" (expand defs_well_typed) (("" (flatten) (("" (case-replace "nS`def_types = tS`def_types") (("1" (assert) (("1" (inst? -7) (("1" (flatten) (("1" (assert) (("1" (rewrite npops_popDepth) (("1" (rewrite purePopDepth) (("1" (assert) (("1" (rewrite popn_append :dir RL) (("1" (case-replace "popn(tS`def_types`seq
                                  (fun(nS`state`redex))`args_type,
                              D`seq(fun(nS`state`redex))`arity) = empty_seq") (("1" (case-replace "nS`stack_types o empty_seq = nS`stack_types") (("1" (typepred "nS`context_type") (("1" (case-replace "popDepth(nS`state`redex) = 0") (("1" (assert) (("1" (replace -5) (("1" (replace -12 :dir RL) (("1" (replace -7) (("1" (expand expr_type -2) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (typed_iareduce subtype "nS`context_type" "{tK | typed_reduction.is_well_typed_ctx(iareduction.iapplyReduce(D)(nS`state)`context, tK, typed_reduction.popn(finite_sequences[nat].o(nS`stack_types, tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`args_type), IL.popDepth(iareduction.iapplyReduce(D)(nS`state)`redex)), nS`dom_types, nS`def_types, typed_reduction.expr_type(tS`def_types`seq(IExpression_adt.fun(nS`state`redex))`body_type))}")))("iareduction" iareduction iapply_nstack_TCC4 0 (iapply_nstack_TCC4-1 nil 3706473878 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "y WITH [`index := IExpression_adt.index(y) + 1]" "(IExpression_adt.variable?)")))("iareduction" iareduction iapply_nstack_TCC5 0 (iapply_nstack_TCC5-1 nil 3706473878 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite map_length) (("1" (expand length 1 2) (("1" (lift-if) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand in_varlist) (("2" (inst -8 "i-1") (("1" (rewrite some_map) (("1" (expand o) (("1" (rewrite some_nth) (("1" (rewrite some_nth) (("1" (split) (("1" (grind) nil nil) ("2" (skeep) (("2" (inst 1 "i_1+1") (("1" (grind) nil nil) ("2" (expand length 1) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (in_varlist const-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (map_length formula-decl nil more_map_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (some_map formula-decl nil finseq_theorems nil) (some_nth formula-decl nil finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (arity skolem-const-decl "nat" iareduction nil) (dom skolem-const-decl "finite_set[nat]" iareduction nil) (S skolem-const-decl "{S | every(domainValue?(dom))(S)}" iareduction nil) (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction nil) (below type-eq-decl nil naturalnumbers nil) (i_1 skolem-const-decl "below(length(cdr[(variable?)](args)))" iareduction nil) (nth def-decl "T" list_props nil) (O const-decl "T3" function_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" iareduction nil)) nil (iapply_nstack subtype "list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args))" "{L | list_props[(IExpression_adt.variable?)].length(L) = list_props[(IExpression_adt.variable?)].length(args) - 1 AND FORALL i: IL.in_varlist(L)(i) IMPLIES i < 1 + S`length}")))("iareduction" iareduction iapply_nstack_TCC9 0 (iapply_nstack_TCC9-1 nil 3706473878 ("" (skeep* :preds? t) (("" (expand every) (("" (skeep) (("" (expand* push add) (("" (lift-if) (("" (split +) (("1" (flatten) (("1" (inst? -8) (("1" (grind) nil nil) ("2" (inst -10 "index(car(args))") (("2" (split -10) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_nth) (("2" (inst 1 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split +) (("1" (grind) nil nil) ("2" (flatten) (("2" (inst -7 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (every const-decl "bool" finseq_theorems nil) (every adt-def-decl "boolean" list_adt nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (args skolem-const-decl "{args: list[(variable?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" iareduction nil) (< const-decl "bool" reals nil) (in_varlist const-decl "finite_set[nat]" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (arity skolem-const-decl "nat" iareduction nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (S skolem-const-decl "{S | every(domainValue?(dom))(S)}" iareduction nil) (dom skolem-const-decl "finite_set[nat]" iareduction nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (some adt-def-decl "boolean" list_adt nil) (injective? const-decl "bool" functions nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (some_nth formula-decl nil finseq_theorems nil) (nth def-decl "T" list_props nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil)) nil (iapply_nstack subtype "IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])" "{S | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S)}")))("iareduction" iareduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706473878 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (in_varlist const-decl "finite_set[nat]" IL nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "nargs" "{args_1: list[(IExpression_adt.variable?)] | list_props[(IExpression_adt.variable?)].length(args_1) = arity - 1 AND FORALL i: IL.in_varlist(args_1)(i) IMPLIES i < IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil])`length}")))("iareduction" iareduction iapply_nstack_TCC11 0 (iapply_nstack_TCC11-1 nil 3706473878 ("" (skeep* :preds? t) (("" (typepred "cnt(x1)") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (expand push) (("" (rewrite count_add) (("1" (rewrite count_update) (("1" (grind) nil nil) ("2" (inst -11 "index(car(args))") (("2" (split -11) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_nth) (("2" (inst 1 0) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (inst -11 "index(car(args))") (("3" (split) (("1" (grind) nil nil) ("2" (expand in_varlist) (("2" (rewrite some_nth) (("2" (inst 1 0) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every const-decl "bool" finseq_theorems nil) (refcount const-decl "nat" rreduction nil) (Stack type-eq-decl nil IL nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (push const-decl "Stack" IL nil) (below type-eq-decl nil naturalnumbers nil) (count_update formula-decl nil finseq_theorems nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (count const-decl "nat" finseq_theorems nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (some_nth formula-decl nil finseq_theorems nil) (nth def-decl "T" list_props nil) (< const-decl "bool" reals nil) (in_varlist const-decl "finite_set[nat]" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (count_add formula-decl nil finseq_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "cnt" "[i: (dom) -> {j | j = rreduction.refcount(dom, str, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), A)(i)}]")))("iareduction" iareduction iapply_nstack_TCC12 0 (iapply_nstack_TCC12-1 nil 3706473878 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "nil")))("iareduction" iareduction iapply_nstack_TCC13 0 (iapply_nstack_TCC13-1 nil 3706473878 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (injective? const-decl "bool" functions nil) (add const-decl "finseq[T]" more_finseq nil) (push const-decl "Stack" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, IL.push(u, S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]), nargs, str, A, cnt)" "{((S1: Stack | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1))), ((ncnt: [i: (dom) -> {j | j = rreduction.refcount(dom, str, S1, A)(i)}])) | S1`length = arity + S`length}")))("iareduction" iareduction iapply_nstack_iterm_TCC7 0 (iapply_nstack_iterm_TCC7-1 nil 3706469505 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (in_varlist const-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (args!1 skolem-const-decl "{args: list[(variable?)] |
   k!1 <= 2 * length(args) AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S!1`length}" iareduction nil) (S!1 skolem-const-decl "{S | every(domainValue?(dom!1))(S)}" iareduction nil) (k!1 skolem-const-decl "nat" iareduction nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (dom!1 skolem-const-decl "finite_set[nat]" iareduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (below type-eq-decl nil naturalnumbers nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack_iterm subtype "S WITH [`seq(S`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))) := IExpression_adt.nil]" "{S1 | finseq_theorems[(IL.value?)].every(IL.domainValue?(dom))(S1)}")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC6 0 (iapply_nstack_types_TCC2-1 nil 3706555818 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "arity - 1" "nat")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC7 0 (iapply_nstack_types_TCC7-1 nil 3706621099 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "{stypes2 | stypes2`length = arity + stypes`length}")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC7 0 (iapply_nstack_types_TCC7-1 nil 3706623564 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [(IExpression_adt.index) := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "{stypes2 | stypes2`length = arity + stypes`length}")))("typed_reduction_props" typed_reduction_props typed_reduce_n_TCC7 0 (typed_reduce_n_TCC7-1 nil 3706632220 ("" (subtype-tcc) nil nil) nil nil (typed_reduce_n subtype "D" "Defs")))("typed_reduction_props" typed_reduction_props apply_iterm_match_TCC1 0 (apply_iterm_match_TCC1-1 nil 3706632220 ("" (subtype-tcc) nil nil) nil nil (apply_iterm_match subtype "D" "Defs")))("typed_reduction_props" typed_reduction_props applyReduce_match_TCC4 0 (applyReduce_match_TCC4-1 nil 3706632220 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match subtype "D" "Defs")))("typed_reduction_props" typed_reduction_props applyReduce_match_rec_TCC3 0 (applyReduce_match_rec_TCC3-1 nil 3706632220 ("" (subtype-tcc) nil nil) nil nil (applyReduce_match_rec subtype "trS" "{tS | NOT typed_rreduction.tS`state`error AND typed_reduction.defs_well_typed(D, typed_rreduction.tS`def_types)}")))("ireduction" ireduction ifReduce_TCC10 0 (ifReduce_TCC10-1 nil 3706886185 ("" (skeep* :preds? t) (("" (typepred "lf`fdepth") (("" (rewrite -1) (("" (assert) (("" (use stack_size_at_next_pc_iftrue) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (stack_size_at_next_pc_iftrue formula-decl nil ireduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (endi const-decl "T" ireduction nil) (state_extract_stat const-decl "{s1, j | j < slength(s1) AND executable_stat?(s1, j)}" ireduction nil) (get_frame_body const-decl "[stack_frame(iS`defs), istat]" ireduction nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (istat type-decl nil ireduction nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" ireduction nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Definition type-eq-decl nil ireduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (slength def-decl "posnat" ireduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" ireduction nil) (stack_frame type-eq-decl nil ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (ivalue type-decl nil ireduction nil) (Stack type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Store type-eq-decl nil ireduction nil) (istate type-eq-decl nil ireduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ifRedex? const-decl "bool" ireduction nil)) nil (ifReduce subtype "lf`fdepth" "{k: nat | k = 1 + iS`defs`seq(lf`ffct)`arity + stack_size_at(iS`defs`seq(lf`ffct)`body, 1 + lf`fpc)}")))("ireduction" ireduction returnReduce_TCC11 0 (returnReduce_TCC11-1 nil 3706896287 ("" (skeep* :preds? t) (("" (postpone) nil nil)) nil) nil nil (returnReduce subtype "nf`fdepth" "{k: nat | k = 1 + iS`defs`seq(nf`ffct)`arity + stack_size_at(iS`defs`seq(nf`ffct)`body, next_pc(cbody, nf`fpc)) OR (next_pc(cbody, nf`fpc) = slength(iS`defs`seq(nf`ffct)`body) AND k >= 1)}")))("ireduction" ireduction returnReduce_TCC12 0 (returnReduce_TCC12-1 nil 3706896287 ("" (skeep* :preds? t) (("" (postpone) nil nil)) nil) nil nil (returnReduce subtype "nc WITH [`seq(nc`length - 1) := nf WITH [`fpc := next_pc(cbody, nf`fpc)]]" "{C: finseq[stack_frame(iS`defs)] | FORALL (i: nat | i < C`length - 1): is_fun_call_at(iS`defs`seq(C`seq(i)`ffct)`body, C`seq(i)`fpc, C`seq(1 + i)`ffct)}")))("ireduction" ireduction returnReduce_TCC14 0 (returnReduce_TCC14-1 nil 3706896287 ("" (subtype-tcc) nil nil) nil nil (returnReduce subtype "iS`stack`length - 2 - cvar" "below[pop(iS`stack)`length]")))("ireduction" ireduction returnReduce_TCC16 0 (returnReduce_TCC16-1 nil 3706896287 ("" (subtype-tcc) nil nil) nil nil (returnReduce subtype "pop(iS`stack) WITH [`seq(iS`stack`length - 2 - cvar) := endi(iS`stack, 0)]" "{S: Stack | S`length = 1 + fdepth_sum(iS`defs)(nc WITH [`seq(nc`length - 1) := nf WITH [`fpc := next_pc(cbody, nf`fpc)]])}")))("ireduction" ireduction iapply_nstack_TCC9 0 (iapply_nstack_TCC9-1 nil 3706965297 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "finseq2list[(ivar?)](nargs)" "{args: list[(ivar?)] | list_props[(ivar?)].length(args) = arity - 1 AND FORALL i: in_varlist(args)(i) IMPLIES i < nstack`length}")))("ireduction" ireduction iapply_nstack_TCC10 0 (iapply_nstack_TCC10-1 nil 3706965297 ("" (termination-tcc) nil nil) ((list2finseq const-decl "finseq[T]" list2finseq nil) (add const-decl "finseq[T]" more_finseq nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack termination "iapply_nstack(arity - 1, dom, nstack, finseq2list[(ivar?)](nargs), ncnt)" "nil")))("ireduction" ireduction iapply_nstack_TCC11 0 (iapply_nstack_TCC11-1 nil 3706965297 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (injective? const-decl "bool" functions nil) (finseq type-eq-decl nil finite_sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (in_varlist const-decl "bool" ireduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil) nil (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (iexpr type-decl nil ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (add const-decl "finseq[T]" more_finseq nil) (finseq2list const-decl "list[T]" list2finseq nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, nstack, finseq2list[(ivar?)](nargs), ncnt)" "{S1, ((ncnt: [(dom) -> int])) | S1`length = arity + S`length}")))("ireduction" ireduction iapply_nstack_TCC5 0 (iapply_nstack_TCC5-1 nil 3706965297 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite map_length) (("1" (assert) (("1" (rewrite length_cdr) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand in_varlist) (("2" (rewrite some_map) (("2" (expand o) (("2" (inst -6 "i-1") (("1" (split) (("1" (grind) nil nil) ("2" (rewrite some_nth) (("2" (rewrite some_nth) (("2" (skeep) (("2" (inst 1 "i_1+1") (("1" (grind) nil nil) ("2" (typepred "i_1") (("2" (rewrite length_cdr) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (length_cdr formula-decl nil ireduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil) (boolean nonempty-type-decl nil booleans nil) (iexpr type-decl nil ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (in_varlist const-decl "bool" ireduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (map_length formula-decl nil more_map_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (O const-decl "T3" function_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i_1 skolem-const-decl "below(length(cdr[(ivar?)](args)))" ireduction nil) (below type-eq-decl nil naturalnumbers nil) (args skolem-const-decl "{args: list[(ivar?)] |
   length(args) = arity AND
    FORALL i: in_varlist(args)(i) IMPLIES i < S`length}" ireduction nil) (S skolem-const-decl "Stack" ireduction nil) (arity skolem-const-decl "nat" ireduction nil) (nth def-decl "T" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (some_nth formula-decl nil finseq_theorems nil) (i skolem-const-decl "nat" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (some_map formula-decl nil finseq_theorems nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (iapply_nstack subtype "list2finseq[(ivar?)](list_adt_map[(ivar?), (ivar?)].map(LAMBDA x: x WITH [`vindex := vindex(x) + 1])(list_adt[(ivar?)].cdr(args)))" "{L | length(L) = list_props[(ivar?)].length(args) - 1 AND FORALL i: in_varlist(finseq2list[(ivar?)](L))(i) IMPLIES i < 1 + S`length}")))("ireduction" ireduction iapply_nstack_TCC11 0 (iapply_nstack_TCC11-1 nil 3706966331 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, nstack, nargs, ncnt)" "{S1, ((ncnt: [(dom) -> int])) | S1`length = arity + S`length}")))("ireduction" ireduction iapply_nstack_TCC10 0 (iapply_nstack_TCC9-1 nil 3706966331 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "nargs" "{args: list[(ivar?)] | list_props[(ivar?)].length(args) = arity - 1 AND FORALL i: in_varlist(args)(i) IMPLIES i < nstack`length}")))("ireduction" ireduction iapply_nstack_TCC12 0 (iapply_nstack_TCC12-1 nil 3706966964 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack subtype "iapply_nstack(arity - 1, dom, nstack, nargs, ncnt)" "{S1, ((ncnt: [(dom) -> int])) | S1`length = arity + S`length AND finseq_theorems[ivalue].every(domainValue?(dom))(S1)}")))("ireduction" ireduction applicationReduce_TCC7 0 (applicationReduce_TCC6-1 nil 3706965297 ("" (subtype-tcc) nil nil) nil nil (applicationReduce subtype "list_adt_map[(ivar?), (ivar?)].map(LAMBDA x: x WITH [`vindex := vindex(x) + 1])(iargs(aexpr(s)))" "{args: list[(ivar?)] | list_props[(ivar?)].length(args) = list_props[iexpr].length(iargs(aexpr(s))) AND FORALL i: in_varlist(args)(i) IMPLIES i < more_finseq[ivalue].add(vundef, iS`stack)`length}")))("ireduction" ireduction applicationReduce_TCC6 0 (applicationReduce_TCC4-1 nil 3706966964 ("" (subtype-tcc) nil nil) nil nil (applicationReduce subtype "more_finseq[ivalue].add(vundef, iS`stack)" "{S | finseq_theorems[ivalue].every(domainValue?(iS`domain))(S)}")))("itranslation" itranslation reconstruct_state_TCC13 0 (reconstruct_state_TCC13-1 nil 3706985635 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (translate_length def-decl "posnat" itranslation nil) (below type-eq-decl nil naturalnumbers nil) (iexpr type-decl nil ireduction nil) (ivar? adt-recognizer-decl "[iexpr -> boolean]" ireduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vindex adt-accessor-decl "[(ivar?) -> nat]" ireduction nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (translate_stack_size_at def-decl "nat" itranslation nil) (below type-eq-decl nil nat_types nil) (ivalue type-decl nil ireduction nil) (Stack type-eq-decl nil ireduction nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reconstruct_state subtype "pc - 1" "below(translate_length(B))")))("itranslation" itranslation translate_next_pc_def_TCC2 0 (translate_next_pc_def_TCC2-1 nil 3706990348 ("" (subtype-tcc) nil nil) nil nil (translate_next_pc_def subtype "pc" "below(translate_length(A))")))("itranslation" itranslation state_matches_TCC7 0 (state_matches_TCC7-1 nil 3707055204 ("" (subtype-tcc) nil nil) nil nil (state_matches subtype "iS`count" "[(trS`state`domain) -> nat]")))("itranslation" itranslation val_to_ival_TCC1 0 (val_to_ival_TCC1-1 nil 3707055204 ("" (subtype-tcc) nil nil) nil nil (val_to_ival subtype "n" "nat")))("itranslation" itranslation state_matches_TCC2 0 (state_matches_TCC2-1 nil 3707055204 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (assert) (("" (skeep) (("" (inst -2 "i-popDepth(state`redex)") (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cvars_vars formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (i skolem-const-decl "nat" itranslation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "typed_rreduction.stack_types" "{stypes | IL.popDepth(typed_rreduction.state`redex) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`redex)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation state_matches_TCC3 0 (state_matches_TCC3-1 nil 3707055204 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "IL.popDepth(typed_rreduction.state`redex)" "upto(typed_rreduction.stack_types`length)")))("itranslation" itranslation state_matches_TCC4 0 (state_matches_TCC4-1 nil 3707055204 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (split) (("1" (grind) nil nil) ("2" (skeep) (("2" (inst -4 "i-popDepth(state`context)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cvars_vars_ctx formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" itranslation nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (popn const-decl "finseq[nat]" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "typed_reduction.popn(typed_rreduction.stack_types, IL.popDepth(typed_rreduction.state`redex))" "{stypes | IL.popDepth(typed_rreduction.state`context) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`context)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation state_matches_TCC3 0 (state_matches_TCC3-1 nil 3707055824 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "IL.popDepth(state`redex)" "upto(stack_types`length)")))("itranslation" itranslation state_matches_TCC4 0 (state_matches_TCC4-1 nil 3707055824 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (split) (("1" (grind) nil nil) ("2" (skeep) (("2" (inst -4 "i-popDepth(state`context)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cvars_vars_ctx formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_plus_int_is_int application-judgement "int" integers nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (i skolem-const-decl "nat" itranslation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (popn const-decl "finseq[nat]" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "typed_reduction.popn(stack_types, IL.popDepth(state`redex))" "{stypes | IL.popDepth(state`context) <= stypes`length AND FORALL i: preprocess.cvars(state`context)(i) IMPLIES i < stypes`length}")))("itranslation" itranslation compose_all_popDepth_TCC1 0 (compose_all_popDepth_TCC1-1 nil 3707057647 ("" (subtype-tcc) nil nil) nil nil (compose_all_popDepth subtype "(LAMBDA i: i < l`length)" "finite_set[nat]")))("itranslation" itranslation state_matches_TCC21 0 (state_matches_TCC21-1 nil 3707057647 ("" (subtype-tcc) nil nil) nil nil (state_matches subtype "tv1(i)" "below(iS`stack`length)")))("itranslation" itranslation state_matches_TCC5 0 (state_matches_TCC5-1 nil 3707055204 ("" (subtype-tcc) nil nil) nil nil (state_matches subtype "trS`def_types" "{tD | typed_reduction.defs_well_typed(D, tD)}")))("itranslation" itranslation state_matches_TCC13 0 (state_matches_TCC13-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "i" "below[iS`callstack`length]")))("itranslation" itranslation state_matches_TCC14 0 (state_matches_TCC14-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (istat type-decl nil ireduction nil) (vars def-decl "bool" ireduction nil) (Definition type-eq-decl nil ireduction nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (slength def-decl "posnat" ireduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (stack_size_at def-decl "nat" ireduction nil) (stack_frame type-eq-decl nil ireduction nil) (is_fun_call_at const-decl "bool" ireduction nil) (ivalue type-decl nil ireduction nil) (Stack type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Store type-eq-decl nil ireduction nil) (istate type-eq-decl nil ireduction nil) (count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "iS`callstack`seq(i)`ffct" "below[D`length]")))("itranslation" itranslation state_matches_TCC15 0 (state_matches_TCC15-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "i + 1" "below[iS`callstack`length]")))("itranslation" itranslation state_matches_TCC17 0 (state_matches_TCC17-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "i" "below[iS`callstack`length]")))("itranslation" itranslation state_matches_TCC18 0 (state_matches_TCC18-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (is_fun_call_at const-decl "bool" ireduction nil) (stack_frame type-eq-decl nil ireduction nil) (stack_size_at def-decl "nat" ireduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Definition type-eq-decl nil ireduction nil) (vars def-decl "bool" ireduction nil) (istat type-decl nil ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "iS`callstack`seq(i)`ffct" "below[D`length]")))("itranslation" itranslation state_matches_TCC19 0 (state_matches_TCC19-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "i + 1" "below[iS`callstack`length]")))("itranslation" itranslation call_reconstruct_state_tv 0 (call_reconstruct_state_tv-1 nil 3707073158 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (skeep* :preds? t) (("6" (expand call_reconstruct_state +) (("6" (expand translate_stack_size_at +) (("6" (lift-if +) (("6" (split +) (("1" (flatten) (("1" (assert) (("1" (split -6) (("1" (inst? -1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -6) (("1" (inst -1 "j+1" _ _ _) (("1" (inst? -1) (("1" (assert) (("1" (lift-if +) (("1" (split +) (("1" (flatten) (("1" (case-replace "pc = 1 + translate_length(letexpr1_var)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (split +) (("1" (flatten) (("1" (split -2) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (postpone) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (postpone) nil nil)) nil) nil shostak))("itranslation" itranslation state_matches_TCC2 0 (state_matches_TCC2-1 nil 3707055824 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (split) (("1" (grind) nil nil) ("2" (skeep) (("2" (inst -3 "i-popDepth(state`redex)") (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cvars_vars formula-decl nil preprocess nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil)) nil (state_matches subtype "stack_types" "{stypes | IL.popDepth(state`redex) <= stypes`length AND FORALL i: preprocess.cvars(state`redex)(i) IMPLIES i < stypes`length}")))("itranslation" itranslation state_matches_TCC3 0 (state_matches_TCC3-1 nil 3707057647 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil)) nil (state_matches subtype "IL.popDepth(typed_rreduction.state`redex)" "upto(typed_rreduction.stack_types`length)")))("itranslation" itranslation state_matches_TCC4 0 (state_matches_TCC4-1 nil 3707057647 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (split) (("1" (grind) nil nil) ("2" (skeep) (("2" (inst -4 "i-popDepth(state`context)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil (int_plus_int_is_int application-judgement "int" integers nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cvars_vars_ctx formula-decl nil preprocess nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) nil (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil)) nil (state_matches subtype "typed_reduction.popn(typed_rreduction.stack_types, IL.popDepth(typed_rreduction.state`redex))" "{stypes | IL.popDepth(typed_rreduction.state`context) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`context)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation state_matches_TCC13 0 (state_matches_TCC20-1 nil 3707057647 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "iS`callstack`seq(i1)`fpc") (("1" (replace -7 -1) (("1" (expand translate_definitions -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (replace -7 -1) (("2" (inst -1 i1) (("2" (expand translate_definitions -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (translate_is_fun_call_at_def formula-decl nil itranslation nil) (istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_frame type-eq-decl nil ireduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (stack_size_at def-decl "nat" ireduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil ireduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "bool" ireduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (istat type-decl nil ireduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (translate_length_def formula-decl nil itranslation nil)) nil (state_matches subtype "iS`callstack`seq(i)`fpc" "{pc: upto(translate_length(D`seq(iS`callstack`seq(i)`ffct)`body)) | translate_is_fun_call_at(D`seq(iS`callstack`seq(i)`ffct)`body, pc, iS`callstack`seq(1 + i)`ffct)}")))("itranslation" itranslation extract_call_context_popDepth_TCC1 0 (extract_call_context_popDepth_TCC1-1 nil 3707137495 ("" (subtype-tcc) nil nil) nil nil (extract_call_context_popDepth subtype "iS`callstack" "{S: finseq[ireduction.stack_frame(iS`defs)] | S`length > 0}")))("itranslation" itranslation extract_call_context_popDepth 0 (extract_call_context_popDepth-1 nil 3707137495 ("" (skeep* :preds? t) (("" (expand extract_call_context) (("" (rewrite compose_all_popDepth) (("1" (rewrite fdepth_sum_sum) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("itranslation" itranslation state_matches_TCC8 0 (state_matches_TCC12-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (endi const-decl "T" ireduction nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (store_matches const-decl "bool" itranslation nil) (count_matches const-decl "bool" itranslation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (tdef type-eq-decl nil typed_rreduction nil) (Defs type-eq-decl nil itranslation nil) (Definition type-eq-decl nil itranslation nil) (unmark def-decl "IExpression" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "iS`callstack`length - 1" "nat")))("itranslation" itranslation state_matches_TCC9 0 (state_matches_TCC16-1 nil 3707057647 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "iS`callstack`seq(i)`fpc") (("1" (replace -7 -1) (("1" (expand translate_definitions -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (inst -1 i) (("2" (replace -7 -1) (("2" (expand translate_definitions -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (translate_is_fun_call_at_def formula-decl nil itranslation nil) (istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_frame type-eq-decl nil ireduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (stack_size_at def-decl "nat" ireduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil ireduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "bool" ireduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (istat type-decl nil ireduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (translate_length_def formula-decl nil itranslation nil)) nil (state_matches subtype "iS`callstack`seq(i)`fpc" "{pc: upto(translate_length(D`seq(iS`callstack`seq(i)`ffct)`body)) | translate_is_fun_call_at(D`seq(iS`callstack`seq(i)`ffct)`body, pc, iS`callstack`seq(1 + i)`ffct)}")))("itranslation" itranslation extract_call_context_TCC1 0 (extract_call_context_TCC1-1 nil 3707137495 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (extract_call_context subtype "typed_rreduction.i" "below[typed_rreduction.state`stack`length]")))("itranslation" itranslation extract_call_context_TCC2 0 (extract_call_context_TCC2-1 nil 3707137495 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (split) (("1" (assert) nil nil) ("2" (skeep) (("2" (inst -3 "i-popDepth(state`redex)") (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cvars_vars formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (i skolem-const-decl "nat" itranslation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (extract_call_context subtype "typed_rreduction.stack_types" "{stypes | IL.popDepth(typed_rreduction.state`redex) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`redex)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation extract_call_context_TCC3 0 (extract_call_context_TCC3-1 nil 3707137495 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (extract_call_context subtype "IL.popDepth(typed_rreduction.state`redex)" "upto(typed_rreduction.stack_types`length)")))("itranslation" itranslation extract_call_context_TCC4 0 (extract_call_context_TCC4-1 nil 3707137495 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "state`redex") (("2" (inst -3 "i-popDepth(state`context)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((popn const-decl "finseq[nat]" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (cvars_vars_ctx formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "nat" itranslation nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (extract_call_context subtype "typed_reduction.popn(typed_rreduction.stack_types, IL.popDepth(typed_rreduction.state`redex))" "{stypes | IL.popDepth(typed_rreduction.state`context) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`context)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation translate_defs_funcall_TCC1 0 (translate_defs_funcall_TCC1-1 nil 3707071271 ("" (subtype-tcc) nil nil) nil nil (translate_defs_funcall subtype "trS`def_types" "{tD | typed_reduction.defs_well_typed(D, tD)}")))("itranslation" itranslation state_matches_TCC2 0 (state_matches_TCC2-1 nil 3707141038 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "state`redex") (("2" (inst -2 "i-popDepth(state`redex)") (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (cvars_vars formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (i skolem-const-decl "nat" itranslation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "typed_rreduction.stack_types" "{stypes | IL.popDepth(typed_rreduction.state`redex) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`redex)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation state_matches_TCC3 0 (state_matches_TCC3-1 nil 3707141038 ("" (skeep* :preds? t) (("" (typepred "state`redex") (("" (grind) nil nil)) nil)) nil) ((armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "IL.popDepth(typed_rreduction.state`redex)" "upto(typed_rreduction.stack_types`length)")))("itranslation" itranslation state_matches_TCC4 0 (state_matches_TCC4-1 nil 3707141038 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "state`redex") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "state`redex") (("2" (inst -3 "i-popDepth(state`context)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((popn const-decl "finseq[nat]" typed_reduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (cvars_vars_ctx formula-decl nil preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (state skolem-const-decl "{rS: rstate |
   noDanglingRefs?(rS) AND
    allReleaseMarked?(rS`redex) AND armc?(rS`context)}" itranslation nil) (i skolem-const-decl "nat" itranslation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "typed_reduction.popn(typed_rreduction.stack_types, IL.popDepth(typed_rreduction.state`redex))" "{stypes | IL.popDepth(typed_rreduction.state`context) <= typed_reduction.stypes`length AND FORALL i: preprocess.cvars(typed_rreduction.state`context)(typed_reduction.i) IMPLIES typed_reduction.i < typed_reduction.stypes`length}")))("itranslation" itranslation state_matches_TCC5 0 (state_matches_TCC5-1 nil 3707145497 ("" (subtype-tcc) nil nil) nil nil (state_matches subtype "trS`def_types" "{tD | typed_reduction.defs_well_typed(D, tD)}")))("itranslation" itranslation state_matches_TCC8 0 (state_matches_TCC8-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil)) nil (state_matches subtype "0" "below(iS`callstack`length)")))("itranslation" itranslation state_matches_TCC9 0 (state_matches_TCC9-1 nil 3707057647 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "fv`ffct" "below[D`length]")))("itranslation" itranslation state_matches_TCC10 0 (state_matches_TCC10-1 nil 3707057647 ("" (skeep* :preds? t) (("" (split) (("1" (typepred "fv`fdepth") (("1" (grind) nil nil)) nil) ("2" (typepred "iS`stack") (("2" (rewrite fdepth_sum_pop) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (istat type-decl nil ireduction nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" ireduction nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Definition type-eq-decl nil ireduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (slength def-decl "posnat" ireduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" ireduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (stack_frame type-eq-decl nil ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (ivalue type-decl nil ireduction nil) (Stack type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Store type-eq-decl nil ireduction nil) (istate type-eq-decl nil ireduction nil) (fdepth_sum_pop formula-decl nil ireduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (endi const-decl "T" ireduction nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (store_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (count_matches const-decl "bool" itranslation nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (pop const-decl "finseq[T]" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "fv`fdepth" "{fdepth: posnat | fdepth <= iS`stack`length}")))("itranslation" itranslation state_matches_TCC11 0 (state_matches_TCC11-1 nil 3707057647 ("" (skeep* :preds? t) (("" (typepred "fv`fpc") (("" (split) (("1" (replace -6) (("1" (expand translate_definitions -1) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "fv`fdepth") (("2" (replace -7) (("2" (expand translate_definitions -1) (("2" (split) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_frame type-eq-decl nil ireduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (stack_size_at def-decl "nat" ireduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil ireduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "bool" ireduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (istat type-decl nil ireduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (translate_stack_size_at_def formula-decl nil itranslation nil) (translate_length_def formula-decl nil itranslation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "fv`fpc" "{pc: upto(translate_length(D`seq(fv`ffct)`body)) | pc = translate_length(D`seq(fv`ffct)`body) OR 1 + D`seq(fv`ffct)`arity + translate_stack_size_at(D`seq(fv`ffct)`body, pc) = fv`fdepth}")))("itranslation" itranslation state_matches_TCC12 0 (state_matches_TCC11-1 nil 3707141038 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_matches const-decl "bool" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (state_matches subtype "iS" "{iS | iS`callstack`length > 0 AND iS`defs = translate_definitions(D, trS`def_types)}")))("itranslation" itranslation state_matches_TCC13 0 (state_matches_TCC8-1 "" 3707139826 ("" (skeep* :preds? t) (("" (replace -14) (("" (expand compose_translate_vars) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (replace -9) (("1" (use fct_reconstruct_state_tv) (("1" (typepred "iS`stack") (("1" (rewrite -1) (("1" (rewrite fdepth_sum_pop) (("1" (split -1) (("1" (case-replace "iS`callstack`seq(iS`callstack`length - 1)`fdepth = fv`fdepth") (("1" (assert) nil nil) ("2" (grind) nil nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -12) (("2" (use extract_call_tv_bound) (("1" (split) (("1" (typepred "iS`stack") (("1" (rewrite -1) (("1" (rewrite fdepth_sum_pop +) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "popDepth(fill(compose(K1, K), A)) = popDepth(fill(trS`state`context, trS`state`redex))") (("1" (rewrite popdepth_fill) (("1" (rewrite popdepth_fill) (("1" (rewrite compose_popDepth) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((extract_call_tv_bound formula-decl nil itranslation nil) (tdef type-eq-decl nil itranslation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (A skolem-const-decl "IExpression" itranslation nil) (K skolem-const-decl "IContext" itranslation nil) (D skolem-const-decl "Defs" itranslation nil) (trS skolem-const-decl "{trS | defs_well_typed(D, trS`def_types)}" itranslation nil) (i skolem-const-decl "below(popDepth(trS`state`redex) + popDepth(trS`state`context))" itranslation nil) (int_plus_int_is_int application-judgement "int" integers nil) (compose def-decl "IContext" IL nil) (fill def-decl "IExpression" IL nil) (compose_popDepth formula-decl nil itranslation nil) (popdepth_fill formula-decl nil IL nil) (extract_call_tv const-decl "[nat -> nat]" itranslation nil) (fct_reconstruct_state_tv formula-decl nil itranslation nil) (translate_stack_size_at def-decl "nat" itranslation nil) (translate_length def-decl "posnat" itranslation nil) (istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (is_fun_call_at const-decl "bool" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_frame type-eq-decl nil ireduction nil) (stack_size_at def-decl "nat" ireduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Definition type-eq-decl nil ireduction nil) (vars def-decl "bool" ireduction nil) (istat type-decl nil ireduction nil) (Defs type-eq-decl nil itranslation nil) (Definition type-eq-decl nil itranslation nil) (unmark def-decl "IExpression" preprocess nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (tdef type-eq-decl nil typed_rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (popDepth def-decl "nat" IL nil) (IExpression type-decl nil IExpression_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (endi const-decl "T" ireduction nil) (ival_to_val const-decl "IExpression" itranslation nil) (fct_reconstruct_state const-decl "[IExpression, IContext, [nat -> nat]]" itranslation nil) (pop const-decl "finseq[T]" ireduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (count_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fdepth_sum_pop formula-decl nil ireduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (compose_translate_vars const-decl "nat" itranslation nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (state_matches subtype "tv2(i)" "below(iS`stack`length)")) (state_matches_TCC14-1 "" 3707136438 ("" (skeep* :preds? t) (("" (replace -14) (("" (expand compose_translate_vars +) (("" (lift-if) (("" (split +) (("1" (flatten) (("1" (rewrite istate_stack_length) (("1" (rewrite sum_pop) (("1" (replace -9) (("1" (use fct_reconstruct_state_tv) (("1" (split -1) (("1" (case-replace "endi(iS`callstack, 0)`fdepth = fv`fdepth") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "tv1(i1 - popDepth(K) - popDepth(A)) < iS`stack`length - fv`fdepth") (("1" (assert) nil nil) ("2" (hide 3) (("2" (replace -12) (("2" (use compose_all_tv_bound) (("1" (split) (("1" (replace -13 :dir RL) (("1" (rewrite sum_map) (("1" (rewrite istate_stack_length) (("1" (rewrite sum_pop +) (("1" (expand pop) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "iS`callstack`seq(i)`ffct") (("2" (grind) nil nil)) nil)) nil) ("3" (use translate_defs_funcall2) (("3" (grind) nil nil)) nil) ("4" (skeep) (("4" (typepred "iS`callstack`seq(i)`ffct") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (simplify + :let-reduce? t) (("2" (skeep* :preds? t) (("2" (rewrite call_reconstruct_state_tv_high) (("1" (typepred "iS`callstack`seq(i_1)`fdepth") (("1" (rewrite -1) (("1" (replace -8 1) (("1" (expand translate_definitions 1) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (inst -1 "i_1") (("2" (flatten) (("2" (replace -2) (("2" (assert) (("2" (expand is_fun_call_at -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "iS`callstack`seq(i_1)`fdepth") (("2" (rewrite -1) (("1" (use call_reconstruct_state_tv_low) (("1" (split -1) (("1" (assert) (("1" (replace -9 2) (("1" (expand translate_definitions +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (inst -1 "i_1") (("2" (flatten) (("2" (replace -2 -1) (("2" (expand is_fun_call_at) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (simplify + :let-reduce? t) (("3" (rewrite sum_map +) (("1" (case-replace "i1 - popDepth(K) - popDepth(A) < popDepth(K1)") (("1" (replace -12) (("1" (rewrite compose_all_popDepth -1) (("1" (rewrite sum_map) (("1" (case-replace "(LAMBDA (i_1: below(iS`callstack`length - 1)):
                                       D`seq(iS`callstack`seq(i_1)`ffct)`arity +
                                        popDepth(call_reconstruct_state(D`seq
                                                                        (iS`callstack`seq
                                                                         (i_1)`ffct)`body,
                                                                        (LAMBDA j: j),
                                                                        iS`callstack`seq
                                                                        (1 + i_1)`ffct,
                                                                        iS`callstack`seq
                                                                        (i_1)`fpc)`1)) = LAMBDA (i_1: below(iS`callstack`length - 1)):
                                       popDepth(npopcs(D`seq
                                                       (iS`callstack`seq(i_1)`ffct)`arity,
                                                       call_reconstruct_state
                                                       (D`seq
                                                        (iS`callstack`seq(i_1)`ffct)`body,
                                                        (LAMBDA j: j),
                                                        iS`callstack`seq(1 + i_1)`ffct,
                                                        iS`callstack`seq(i_1)`fpc)`1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (rewrite npopcs_popDepth) nil nil) ("2" (use translate_defs_funcall2) (("2" (grind) nil nil)) nil) ("3" (skeep :preds? t) (("3" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use translate_defs_funcall2) (("3" (grind) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep :preds? t) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use translate_defs_funcall2) (("2" (split) (("1" (grind) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use translate_defs_funcall2) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "trS`state`redex") (("2" (case "popDepth(fill(compose(K1, K), A)) = popDepth(fill(trS`state`context, trS`state`redex))") (("1" (rewrite popdepth_fill) (("1" (rewrite popdepth_fill) (("1" (rewrite compose_popDepth) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use translate_defs_funcall2) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide 2) (("3" (use translate_defs_funcall2) (("3" (grind) nil nil)) nil)) nil) ("4" (hide 2) (("4" (use translate_defs_funcall2) (("4" (grind) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (typepred "iS`callstack`seq(i)`ffct") (("5" (grind) nil nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((extract_call_tv_bound formula-decl nil itranslation nil) (tdef type-eq-decl nil itranslation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (compose def-decl "IContext" IL nil) (fill def-decl "IExpression" IL nil) (compose_popDepth formula-decl nil itranslation nil) (popdepth_fill formula-decl nil IL nil) (extract_call_tv const-decl "[nat -> nat]" itranslation nil) (fct_reconstruct_state_tv formula-decl nil itranslation nil) (translate_stack_size_at def-decl "nat" itranslation nil) (translate_length def-decl "posnat" itranslation nil) (istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (is_fun_call_at const-decl "bool" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_frame type-eq-decl nil ireduction nil) (stack_size_at def-decl "nat" ireduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Definition type-eq-decl nil ireduction nil) (vars def-decl "bool" ireduction nil) (istat type-decl nil ireduction nil) (Defs type-eq-decl nil itranslation nil) (Definition type-eq-decl nil itranslation nil) (unmark def-decl "IExpression" preprocess nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (tdef type-eq-decl nil typed_rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (IExpression type-decl nil IExpression_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (endi const-decl "T" ireduction nil) (ival_to_val const-decl "IExpression" itranslation nil) (fct_reconstruct_state const-decl "[IExpression, IContext, [nat -> nat]]" itranslation nil) (pop const-decl "finseq[T]" ireduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (count_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fdepth_sum_pop formula-decl nil ireduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (compose_translate_vars const-decl "nat" itranslation nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (state_matches subtype "tv2(i)" "below(iS`stack`length)")) (state_matches_TCC21-3 nil 3707069204 ("" (skeep* :preds? t) (("" (replace -15) (("" (expand compose_translate_vars +) (("" (lift-if) (("" (split +) (("1" (flatten) (("1" (rewrite istate_stack_length) (("1" (rewrite sum_pop) (("1" (replace -9) (("1" (use fct_reconstruct_state_tv) (("1" (split -1) (("1" (case-replace "endi(iS`callstack, 0)`fdepth = fv`fdepth") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "tv1(i1 - popDepth(K) - popDepth(A)) < iS`stack`length - fv`fdepth") (("1" (assert) nil nil) ("2" (hide 3) (("2" (replace -12) (("2" (use compose_all_tv_bound) (("1" (split) (("1" (replace -13 :dir RL) (("1" (rewrite sum_map) (("1" (rewrite istate_stack_length) (("1" (rewrite sum_pop +) (("1" (expand pop) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "iS`callstack`seq(i)`ffct") (("2" (grind) nil nil)) nil)) nil) ("3" (use translate_defs_funcall2) (("3" (grind) nil nil)) nil) ("4" (skeep) (("4" (typepred "iS`callstack`seq(i)`ffct") (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (simplify + :let-reduce? t) (("2" (skeep* :preds? t) (("2" (rewrite call_reconstruct_state_tv_high) (("1" (typepred "iS`callstack`seq(i_1)`fdepth") (("1" (rewrite -1) (("1" (replace -8 1) (("1" (expand translate_definitions 1) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (inst -1 "i_1") (("2" (flatten) (("2" (replace -2) (("2" (assert) (("2" (expand is_fun_call_at -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "iS`callstack`seq(i_1)`fdepth") (("2" (rewrite -1) (("1" (use call_reconstruct_state_tv_low) (("1" (split -1) (("1" (assert) (("1" (replace -9 2) (("1" (expand translate_definitions +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (inst -1 "i_1") (("2" (flatten) (("2" (replace -2 -1) (("2" (expand is_fun_call_at) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (simplify + :let-reduce? t) (("3" (rewrite sum_map +) (("1" (case-replace "i1 - popDepth(K) - popDepth(A) < popDepth(K1)") (("1" (replace -12) (("1" (rewrite compose_all_popDepth -1) (("1" (rewrite sum_map) (("1" (case-replace "(LAMBDA (i_1: below(iS`callstack`length - 1)):
                     D`seq(iS`callstack`seq(i_1)`ffct)`arity +
                      popDepth(call_reconstruct_state(D`seq
                                                      (iS`callstack`seq
                                                       (i_1)`ffct)`body,
                                                      (LAMBDA j: j),
                                                      iS`callstack`seq
                                                      (1 + i_1)`ffct,
                                                      iS`callstack`seq
                                                      (i_1)`fpc)`1)) = LAMBDA (i_1: below(iS`callstack`length - 1)):
                     popDepth(npopcs(D`seq
                                     (iS`callstack`seq(i_1)`ffct)`arity,
                                     call_reconstruct_state
                                     (D`seq
                                      (iS`callstack`seq(i_1)`ffct)`body,
                                      (LAMBDA j: j),
                                      iS`callstack`seq(1 + i_1)`ffct,
                                      iS`callstack`seq(i_1)`fpc)`1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (rewrite npopcs_popDepth) nil nil) ("2" (use translate_defs_funcall2) (("2" (grind) nil nil)) nil) ("3" (skeep :preds? t) (("3" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use translate_defs_funcall2) (("3" (grind) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep :preds? t) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use translate_defs_funcall2) (("2" (split) (("1" (grind) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use translate_defs_funcall2) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "trS`state`redex") (("2" (replace -19 :dir RL) (("2" (rewrite compose_popDepth) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use translate_defs_funcall2) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide 2) (("3" (use translate_defs_funcall2) (("3" (grind) nil nil)) nil)) nil) ("4" (hide 2) (("4" (use translate_defs_funcall2) (("4" (grind) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (typepred "iS`callstack`seq(i)`ffct") (("5" (grind) nil nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compose_all_tv_bound formula-decl nil itranslation nil) (call_reconstruct_state def-decl "[IContext, [nat -> nat]]" itranslation nil) (translate_is_fun_call_at def-decl "bool" itranslation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (fill def-decl "IExpression" IL nil) (compose def-decl "IContext" IL nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (compose_popDepth formula-decl nil itranslation nil) (popdepth_fill formula-decl nil IL nil) (compose_all def-decl "IContext" itranslation nil) (npopcs_popDepth formula-decl nil itranslation nil) (compose_all_popDepth formula-decl nil itranslation nil) (npopcs def-decl "IContext" itranslation nil) (call_reconstruct_state_tv_low formula-decl nil itranslation nil) (stack_size_at_end formula-decl nil ireduction nil) (translate_stack_size_at_def formula-decl nil itranslation nil) (call_reconstruct_state_tv_high formula-decl nil itranslation nil) (translate_defs_funcall2 formula-decl nil itranslation nil) (NOT const-decl "[bool -> bool]" booleans nil) (sum_map formula-decl nil itranslation nil) (int_plus_int_is_int application-judgement "int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sum_pop formula-decl nil itranslation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fct_reconstruct_state_tv formula-decl nil itranslation nil) (translate_stack_size_at def-decl "nat" itranslation nil) (translate_length def-decl "posnat" itranslation nil) (Defs type-eq-decl nil itranslation nil) (Definition type-eq-decl nil itranslation nil) (unmark def-decl "IExpression" preprocess nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (value_of_type const-decl "boolean" typed_reduction nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (tdef type-eq-decl nil typed_rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (IExpression type-decl nil IExpression_adt nil) (endi const-decl "T" ireduction nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (store_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (count_matches const-decl "bool" itranslation nil) (sum const-decl "nat" itranslation nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (pop const-decl "finseq[T]" ireduction nil) (fct_reconstruct_state const-decl "[IExpression, IContext, [nat -> nat]]" itranslation nil) (ival_to_val const-decl "IExpression" itranslation nil) (istate type-eq-decl nil ireduction nil) (Store type-eq-decl nil ireduction nil) (fdepth_sum const-decl "nat" ireduction nil) (Stack type-eq-decl nil ireduction nil) (ivalue type-decl nil ireduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" ireduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_frame type-eq-decl nil ireduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (stack_size_at def-decl "nat" ireduction nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (slength def-decl "posnat" ireduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil ireduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "bool" ireduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (istat type-decl nil ireduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (istate_stack_length formula-decl nil itranslation nil) (compose_translate_vars const-decl "nat" itranslation nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (state_matches subtype "tv2(i)" "below(iS`stack`length)")) (state_matches_TCC21-2 nil 3707069046 ("" (skeep* :preds? t) (("" (replace -15) (("" (expand compose_translate_vars +) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (postpone) nil))) ("2" (flatten) (("2" (case "tv1(i1 - popDepth(K) - popDepth(A)) < iS`stack`length - fv`fdepth") (("1" (assert) nil) ("2" (hide 3) (("2" (replace -12) (("2" (use compose_all_tv_bound) (("1" (split) (("1" (replace -13 :dir RL) (("1" (rewrite sum_map) (("1" (rewrite istate_stack_length) (("1" (rewrite sum_pop +) (("1" (expand pop) (("1" (grind) nil))))))) ("2" (skeep) (("2" (split) (("1" (typepred "iS`callstack`seq(i)`fpc") (("1" (replace -8 -1) (("1" (expand translate_definitions -1) (("1" (assert) nil))))))) ("2" (typepred "iS`callstack") (("2" (inst -1 i) (("2" (replace -8 -1) (("2" (expand translate_definitions -1) (("2" (assert) nil))))))))))))) ("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil))))))))) ("2" (hide 2) (("2" (simplify + :let-reduce? t) (("2" (postpone) nil))))) ("3" (hide 2) (("3" (simplify + :let-reduce? t) (("3" (rewrite sum_map +) (("1" (case-replace "i1 - popDepth(K) - popDepth(A) < popDepth(K1)") (("1" (replace -12) (("1" (rewrite compose_all_popDepth -1) (("1" (rewrite sum_map -1) (("1" (hide 2) (("1" (postpone) nil))) ("2" (hide 2) (("2" (skeep) (("2" (typepred "iS`callstack`seq(i)`ffct") (("2" (grind) nil))))))))) ("2" (hide 2) (("2" (postpone) nil))) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil))))))))))) ("2" (hide 2) (("2" (typepred "trS`state`redex") (("2" (replace -19 :dir RL) (("2" (rewrite compose_popDepth) (("2" (assert) (("2" (postpone) nil))))))))))))) ("2" (postpone) nil) ("3" (postpone) nil))))))))) ("2" (grind) nil) ("3" (hide 2) (("3" (postpone) nil))) ("4" (hide 2) (("4" (postpone) nil))) ("5" (hide 2) (("5" (grind) nil))))))))) ("3" (grind) nil)))))))))))))) nil) nil nil (state_matches subtype "tv2(i)" "below(iS`stack`length)")) (state_matches_TCC21-1 nil 3707064746 ("" (skeep* :preds? t) (("" (replace -15) (("" (expand compose_translate_vars +) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (case "tv1(i1 - popDepth(K)) < iS`stack`length - fv`fdepth") (("1" (assert) nil nil) ("2" (hide 3) (("2" (replace -12) (("2" (use compose_all_tv_bound) (("1" (split) (("1" (replace -13 :dir RL) (("1" (rewrite sum_map) (("1" (rewrite istate_stack_length) (("1" (rewrite sum_pop +) (("1" (expand pop) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (split) (("1" (typepred "iS`callstack`seq(i)`fpc") (("1" (replace -8 -1) (("1" (expand translate_definitions -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "iS`callstack") (("2" (inst -1 i) (("2" (replace -8 -1) (("2" (expand translate_definitions -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (simplify + :let-reduce? t) (("2" (postpone) nil nil)) nil)) nil) ("3" (hide 2) (("3" (simplify + :let-reduce? t) (("3" (rewrite sum_map +) (("1" (case-replace "i1 - popDepth(K) < popDepth(K1)") (("1" (replace -12) (("1" (rewrite compose_all_popDepth -1) (("1" (rewrite sum_map -1) (("1" (hide 2) (("1" (postpone) nil nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (typepred "iS`callstack`seq(i)`ffct") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (postpone) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "iS`callstack`seq(i)`ffct") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "trS`state`redex") (("2" (replace -19 :dir RL) (("2" (rewrite compose_popDepth) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide 2) (("3" (postpone) nil nil)) nil) ("4" (hide 2) (("4" (postpone) nil nil)) nil) ("5" (hide 2) (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (state_matches subtype "tv2(i)" "below(iS`stack`length)")))("itranslation" itranslation state_matches_TCC14 0 (state_matches_TCC9-1 "" 3707139058 ("" (skeep* :preds? t) (("" (typepred "trS`state`redex") (("" (grind) nil nil)) nil)) nil) ((Defs type-eq-decl nil itranslation nil) (Definition type-eq-decl nil itranslation nil) (unmark def-decl "IExpression" preprocess nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (Definition type-eq-decl nil typed_reduction nil) (pure? def-decl "bool" IL nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (expr_type def-decl "nat" typed_reduction nil) (popn const-decl "finseq[nat]" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (value_of_type const-decl "boolean" typed_reduction nil) (below type-eq-decl nil naturalnumbers nil) (armc? def-decl "bool" preprocess nil) (allReleaseMarked? def-decl "bool" preprocess nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (tdef type-eq-decl nil typed_rreduction nil) (typeinfo type-decl nil typeinfo_adt nil) (finseq type-eq-decl nil finite_sequences nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (extract_call_tv const-decl "[nat -> nat]" itranslation nil) (extract_call_context const-decl "IContext" itranslation nil) (fct_reconstruct_state const-decl "[IExpression, IContext, [nat -> nat]]" itranslation nil) (ival_to_val const-decl "IExpression" itranslation nil) (endi const-decl "T" ireduction nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (store_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (count_matches const-decl "bool" itranslation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (state_matches subtype "i" "below(trS`state`stack`length)")) (state_matches_TCC15-1 "" 3707135834 ("" (skeep* :preds? t) (("" (typepred "trS`state`redex") (("" (inst -3 "i1-popDepth(trS`state`redex)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (count_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (ival_to_val const-decl "IExpression" itranslation nil) (fct_reconstruct_state const-decl "[IExpression, IContext, [nat -> nat]]" itranslation nil) (extract_call_context const-decl "IContext" itranslation nil) (extract_call_tv const-decl "[nat -> nat]" itranslation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil)) shostak (state_matches subtype "i" "below(trS`state`stack`length)")) (state_matches_TCC22-1 nil 3707068669 ("" (skeep* :preds? t) (("" (typepred "trS`state`redex") (("" (split) (("1" (inst -3 "i1-popDepth(trS`state`redex)") (("1" (rewrite cvars_vars) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (inst -4 "i1-popDepth(trS`state`context)-popDepth(trS`state`redex)") (("1" (rewrite cvars_vars_ctx) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (count_matches const-decl "bool" itranslation nil) (val_to_ival const-decl "ivalue" itranslation nil) (store_matches const-decl "bool" itranslation nil) (translate_definitions const-decl "finseq[ireduction.Definition]" itranslation nil) (endi const-decl "T" ireduction nil) (ival_to_val const-decl "IExpression" itranslation nil) (fct_reconstruct_state const-decl "[IExpression, IContext, [nat -> nat]]" itranslation nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (typeinfo type-decl nil typeinfo_adt nil) (tdef type-eq-decl nil typed_rreduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allReleaseMarked? def-decl "bool" preprocess nil) (armc? def-decl "bool" preprocess nil) (below type-eq-decl nil naturalnumbers nil) (value_of_type const-decl "boolean" typed_reduction nil) (tdef type-eq-decl nil typed_reduction nil) (is_well_typed def-decl "bool" typed_reduction nil) (typeinfo_ctx type-decl nil typed_reduction nil) (is_well_typed_ctx def-decl "bool" typed_reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (popn const-decl "finseq[nat]" typed_reduction nil) (expr_type def-decl "nat" typed_reduction nil) (typed_rstate type-eq-decl nil typed_rreduction nil) (pure? def-decl "bool" IL nil) (Definition type-eq-decl nil typed_reduction nil) (Defs type-eq-decl nil typed_reduction nil) (defs_well_typed const-decl "boolean" typed_reduction nil) (unmark def-decl "IExpression" preprocess nil) (Definition type-eq-decl nil itranslation nil) (Defs type-eq-decl nil itranslation nil)) nil (state_matches subtype "i" "below(trS`state`stack`length)")))("typed_rreduction" typed_rreduction iapply_nstack_types_TCC7 0 (iapply_nstack_types_TCC7-1 nil 3706623873 ("" (subtype-tcc) nil nil) nil nil (iapply_nstack_types subtype "iapply_nstack_types(arity - 1, more_finseq[nat].add(stypes`seq(stypes`length - 1 - IExpression_adt.index(list_adt[(IExpression_adt.variable?)].car(args))), stypes), list_adt_map[(IExpression_adt.variable?), (IExpression_adt.variable?)].map(LAMBDA y: y WITH [`index := IExpression_adt.index(y) + 1])(list_adt[(IExpression_adt.variable?)].cdr(args)))" "{stypes2 | stypes2`length = arity + stypes`length}")))("itranslation" itranslation redex_stillmatch1_TCC11 0 (redex_stillmatch1_TCC11-1 nil 3707160549 ("" (subtype-tcc) nil nil) nil nil (redex_stillmatch1 subtype "i" "below(trS`state`stack`length)")))("itranslation" itranslation reconstruct_state_tv_next_pc_overflow_TCC1 0 (reconstruct_state_tv_next_pc_overflow_TCC1-1 nil 3707240197 ("" (subtype-tcc) nil nil) nil nil (reconstruct_state_tv_next_pc_overflow subtype "translate_next_pc(A, pc)" "below(translate_length(A))")))("itranslation" itranslation reconstruct_state_tv_next_pc_overflow_TCC2 0 (reconstruct_state_tv_next_pc_overflow_TCC2-1 nil 3707240197 ("" (subtype-tcc) nil nil) nil nil (reconstruct_state_tv_next_pc_overflow subtype "rv" "{rv: (ireduction.ivar?) | ireduction.vindex(rv) + translate_stack_size_at(A, translate_next_pc(A, pc)) < S`length}")))("itranslation" itranslation translate_extract_decl_skip_is_assign 0 (translate_extract_decl_skip_is_assign-1 nil 3707250678 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil) ("14" (grind) nil nil)) nil) ((release adt-constructor-decl "[[(variable?), IExpression] -> (release?)]" IExpression_adt nil) (release? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pc!1 skolem-const-decl "below(translate_length(ift(ift1_var!1, ift2_var!1, ift3_var!1)))" itranslation nil) (ift3_var!1 skolem-const-decl "IExpression" itranslation nil) (ift2_var!1 skolem-const-decl "IExpression" itranslation nil) (ift1_var!1 skolem-const-decl "(variable?)" itranslation nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (pc!1 skolem-const-decl "below(translate_length(letexpr(letexpr1_var!1, letexpr2_var!1)))" itranslation nil) (letexpr2_var!1 skolem-const-decl "IExpression" itranslation nil) (letexpr1_var!1 skolem-const-decl "IExpression" itranslation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (IExpression_induction formula-decl nil IExpression_adt nil) (translate_extract_is_assign def-decl "bool" itranslation nil) (NOT const-decl "[bool -> bool]" booleans nil) (translate_extract_skip def-decl "bool" itranslation nil) (below type-eq-decl nil naturalnumbers nil) (translate_length def-decl "posnat" itranslation nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (pure? def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("itranslation" itranslation extract_call_tv_eq_TCC1 0 (extract_call_tv_eq_TCC1-1 nil 3707141125 ("" (subtype-tcc) nil nil) ((pop const-decl "finseq[T]" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (extract_call_tv_eq subtype "0" "below(iS`callstack`length)")))("itranslation" itranslation extract_call_tv_eq_TCC2 0 (extract_call_tv_eq_TCC2-1 nil 3707141125 ("" (subtype-tcc) nil nil) ((pop const-decl "finseq[T]" ireduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (extract_call_tv_eq subtype "0" "below(iS2`callstack`length)")))("itranslation" itranslation decl_begin_next_pc_TCC1 0 (decl_begin_next_pc_TCC1-1 nil 3707504998 ("" (subtype-tcc) nil nil) nil nil (decl_begin_next_pc subtype "itranslation.A" "(IL.pure?)")))("itranslation" itranslation translate_is_result_defined_assign_TCC1 0 (translate_is_result_defined_assign_TCC1-1 nil 3707584807 ("" (subtype-tcc) nil nil) nil nil (translate_is_result_defined_assign subtype "ireduction.vindex(ireduction.avar(itranslation.translate_extract_assign(itranslation.A, itranslation.rv, itranslation.translate_vars, itranslation.pc)))" "naturalnumbers.below(itranslation.S`length)")))("itranslation" itranslation translate_is_result_defined_assign 0 (translate_is_result_defined_assign-1 nil 3707584808 ("" (induct A) (("1" (grind) nil nil) ("2" (skeep* :preds? t) (("2" (expand translate_is_result_defined) (("2" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil) ("14" (postpone) nil nil) ("15" (postpone) nil nil)) nil) nil shostak))("itranslation" itranslation state_matches_to_topstate_TCC1 0 (state_matches_to_topstate_TCC1-1 nil 3707655604 ("" (subtype-tcc) nil nil) nil nil (state_matches_to_topstate subtype "typed_rreduction.typed_to_topstate(itranslation.trS)" "{trS | typed_reduction.defs_well_typed(itranslation.D, itranslation.trS`def_types)}")))("itranslation" itranslation state_matches_make_redex_TCC1 0 (state_matches_make_redex_TCC1-1 nil 3707655604 ("" (subtype-tcc) nil nil) nil nil (state_matches_make_redex subtype "itranslation.trS" "{tS | booleans.AND(typed_rreduction.tS`state`context = IL.hole, )}")))("itranslation" itranslation state_matches_make_redex_TCC2 0 (state_matches_make_redex_TCC2-1 nil 3707655604 ("" (subtype-tcc) nil nil) nil nil (state_matches_make_redex subtype "typed_rreduction.make_redex_typed(itranslation.trS)" "{trS | typed_reduction.defs_well_typed(itranslation.D, itranslation.trS`def_types)}")))("itranslation" itranslation reconstruct_state_next_pc_decl_end_overflow_TCC1 0 (reconstruct_state_next_pc_decl_end_overflow_TCC1-1 nil 3707668586 ("" (skeep* :preds? t) (("" (case "translate_stack_size_at(A, pc) = translate_stack_size_at(A,translate_next_pc(A,pc))+1") (("1" (grind) nil nil) ("2" (rewrite translate_stack_size_at_next_pc_decl_end) (("2" (grind) nil nil)) nil)) nil)) nil) ((translate_next_pc def-decl "upto(translate_length(A))" itranslation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (translate_stack_size_at def-decl "nat" itranslation nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (translate_length def-decl "posnat" itranslation nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (pure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (translate_stack_size_at_next_pc_decl_end formula-decl nil itranslation nil)) nil (reconstruct_state_next_pc_decl_end_overflow subtype "ireduction.vindex(itranslation.rv)" "naturalnumbers.below(itranslation.S`length)")))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("rreduction" rreduction nil 0 (nil-1 nil 3714529193 nil nil nil))("prelude" modulo_arithmetic zdiv_TCC1 0 (zdiv_TCC1-1 nil 3682472010 ("" (inst + "lambda x, b:  (epsilon! (q: int): EXISTS (r: mod(b)): x = b * q + r)") (("" (skeep) (("" (use "epsilon_ax[int]") (("" (ground) (("1" (lemma "euclid_int") (("1" (inst - "b" "x") (("1" (hide 1) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "euclid_int") (("2" (inst - "b" "x") (("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (euclid_int formula-decl nil euclidean_division nil) (epsilon_ax formula-decl nil epsilons nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak))("prelude" modulo_arithmetic zrem_TCC1 0 (zrem_TCC1-1 nil 3682646912 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil)) shostak))("prelude" naturalnumbers even_nat_TCC1 0 (even_nat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_posnat_TCC1 0 (even_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers odd_posnat_TCC1 0 (odd_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_negint_TCC1 0 (even_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" naturalnumbers odd_negint_TCC1 0 (odd_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" number_fields nonzero_number_TCC1 0 (nonzero_number_TCC1-1 nil 3590856047 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak))("prelude" modulo_arithmetic zdiv_TCC1 0 (zdiv_TCC1-1 nil 3682472010 ("" (inst + "lambda x, b:  (epsilon! (q: int): EXISTS (r: mod(b)): x = b * q + r)") (("" (skeep) (("" (use "epsilon_ax[int]") (("" (ground) (("1" (lemma "euclid_int") (("1" (inst - "b" "x") (("1" (hide 1) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "euclid_int") (("2" (inst - "b" "x") (("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (euclid_int formula-decl nil euclidean_division nil) (epsilon_ax formula-decl nil epsilons nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak))("prelude" modulo_arithmetic zrem_TCC1 0 (zrem_TCC1-1 nil 3682646912 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil)) shostak))("prelude" naturalnumbers even_nat_TCC1 0 (even_nat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_posnat_TCC1 0 (even_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers odd_posnat_TCC1 0 (odd_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_negint_TCC1 0 (even_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" naturalnumbers odd_negint_TCC1 0 (odd_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" number_fields nonzero_number_TCC1 0 (nonzero_number_TCC1-1 nil 3590856047 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak))("prelude" modulo_arithmetic zdiv_TCC1 0 (zdiv_TCC1-1 nil 3682472010 ("" (inst + "lambda x, b:  (epsilon! (q: int): EXISTS (r: mod(b)): x = b * q + r)") (("" (skeep) (("" (use "epsilon_ax[int]") (("" (ground) (("1" (lemma "euclid_int") (("1" (inst - "b" "x") (("1" (hide 1) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "euclid_int") (("2" (inst - "b" "x") (("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (euclid_int formula-decl nil euclidean_division nil) (epsilon_ax formula-decl nil epsilons nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak))("prelude" modulo_arithmetic zrem_TCC1 0 (zrem_TCC1-1 nil 3682646912 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil)) shostak))("prelude" naturalnumbers even_nat_TCC1 0 (even_nat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_posnat_TCC1 0 (even_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers odd_posnat_TCC1 0 (odd_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_negint_TCC1 0 (even_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" naturalnumbers odd_negint_TCC1 0 (odd_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" number_fields nonzero_number_TCC1 0 (nonzero_number_TCC1-1 nil 3590856047 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak))("prelude" modulo_arithmetic zdiv_TCC1 0 (zdiv_TCC1-1 nil 3682472010 ("" (inst + "lambda x, b:  (epsilon! (q: int): EXISTS (r: mod(b)): x = b * q + r)") (("" (skeep) (("" (use "epsilon_ax[int]") (("" (ground) (("1" (lemma "euclid_int") (("1" (inst - "b" "x") (("1" (hide 1) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "euclid_int") (("2" (inst - "b" "x") (("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (euclid_int formula-decl nil euclidean_division nil) (epsilon_ax formula-decl nil epsilons nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak))("prelude" modulo_arithmetic zrem_TCC1 0 (zrem_TCC1-1 nil 3682646912 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil)) shostak))("prelude" naturalnumbers even_nat_TCC1 0 (even_nat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_posnat_TCC1 0 (even_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers odd_posnat_TCC1 0 (odd_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_negint_TCC1 0 (even_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" naturalnumbers odd_negint_TCC1 0 (odd_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" number_fields nonzero_number_TCC1 0 (nonzero_number_TCC1-1 nil 3590856047 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak))("prelude" modulo_arithmetic zdiv_TCC1 0 (zdiv_TCC1-1 nil 3682472010 ("" (inst + "lambda x, b:  (epsilon! (q: int): EXISTS (r: mod(b)): x = b * q + r)") (("" (skeep) (("" (use "epsilon_ax[int]") (("" (ground) (("1" (lemma "euclid_int") (("1" (inst - "b" "x") (("1" (hide 1) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "euclid_int") (("2" (inst - "b" "x") (("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (euclid_int formula-decl nil euclidean_division nil) (epsilon_ax formula-decl nil epsilons nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak))("prelude" modulo_arithmetic zrem_TCC1 0 (zrem_TCC1-1 nil 3682646912 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil)) shostak))("prelude" naturalnumbers even_nat_TCC1 0 (even_nat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_posnat_TCC1 0 (even_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers odd_posnat_TCC1 0 (odd_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_negint_TCC1 0 (even_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" naturalnumbers odd_negint_TCC1 0 (odd_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" number_fields nonzero_number_TCC1 0 (nonzero_number_TCC1-1 nil 3590856047 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak))("prelude" modulo_arithmetic zdiv_TCC1 0 (zdiv_TCC1-1 nil 3682472010 ("" (inst + "lambda x, b:  (epsilon! (q: int): EXISTS (r: mod(b)): x = b * q + r)") (("" (skeep) (("" (use "epsilon_ax[int]") (("" (ground) (("1" (lemma "euclid_int") (("1" (inst - "b" "x") (("1" (hide 1) (("1" (skeep) (("1" (inst?) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "euclid_int") (("2" (inst - "b" "x") (("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (euclid_int formula-decl nil euclidean_division nil) (epsilon_ax formula-decl nil epsilons nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak))("prelude" modulo_arithmetic zrem_TCC1 0 (zrem_TCC1-1 nil 3682646912 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil)) shostak))("prelude" naturalnumbers even_nat_TCC1 0 (even_nat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_posnat_TCC1 0 (even_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers odd_posnat_TCC1 0 (odd_posnat_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) nil shostak))("prelude" naturalnumbers even_negint_TCC1 0 (even_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" naturalnumbers odd_negint_TCC1 0 (odd_negint_TCC1-1 nil 3658943917 ("" (subtype-tcc) nil nil) ((minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak))("prelude" number_fields nonzero_number_TCC1 0 (nonzero_number_TCC1-1 nil 3590856047 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak))("itranslation" itranslation redex_stillmatch_assign2_TCC8 0 (redex_stillmatch_assign2_TCC7-1 nil 3709044939 ("" (skeep* :preds? t) (("" (assert) nil nil)) nil) ((next_pc_pos rec-application-judgement "posnat" ireduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (redex_stillmatch_assign2 subtype "itranslation.iS2" "{iS | booleans.AND(itranslation.iS`defs = itranslation.translate_definitions(itranslation.D, itranslation.trS2`def_types), reals.>(itranslation.iS`callstack`length, 0))}")))("itranslation" itranslation translate_stack_size_at_next_pc_TCC1 0 (translate_stack_size_at_next_pc_TCC1-1 nil 3707242393 ("" (subtype-tcc) nil nil) nil nil (translate_stack_size_at_next_pc subtype "itranslation.pc" "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))("itranslation" itranslation translate_stack_size_at_next_pc_decl_begin_TCC1 0 (translate_stack_size_at_next_pc_decl_begin_TCC1-1 nil 3707506190 ("" (subtype-tcc) nil nil) nil nil (translate_stack_size_at_next_pc_decl_begin subtype "itranslation.pc" "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))("itranslation" itranslation translate_stack_size_at_next_pc_decl_end_TCC1 0 (translate_stack_size_at_next_pc_decl_end_TCC1-1 nil 3707668586 ("" (subtype-tcc) nil nil) nil nil (translate_stack_size_at_next_pc_decl_end subtype "itranslation.pc" "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))("itranslation" itranslation translate_stack_size_at_next_pc_skip_TCC1 0 (translate_stack_size_at_next_pc_skip_TCC1-1 nil 3707572314 ("" (subtype-tcc) nil nil) nil nil (translate_stack_size_at_next_pc_skip subtype "itranslation.pc" "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))("itranslation" itranslation translate_is_fun_call_at_assign_TCC1 0 (translate_is_fun_call_at_assign_TCC1-1 nil 3707846540 ("" (subtype-tcc) nil nil) nil nil (translate_is_fun_call_at_assign subtype "itranslation.pc" "naturalnumbers.upto(itranslation.translate_length(itranslation.A))")))