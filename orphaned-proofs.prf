("intermediateLanguage" intermediateLanguage popDepth_TCC5 0 (popDepth_TCC5-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC4 0 (popDepth_TCC4-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC3 0 (popDepth_TCC3-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage popDepth_TCC2 0 (popDepth_TCC2-1 nil 3645226267 ("" (termination-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pure?_TCC4 0 (pure?_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage purePopDepthContext 0 (purePopDepthContext-1 nil 3645515823 ("" (induct-and-simplify "K") (("" (postpone) nil nil)) nil) nil shostak))("intermediateLanguage" intermediateLanguage refcount_TCC4 0 (refcount_TCC4-1 nil 3645614580 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC3 0 (refcount_TCC3-1 nil 3645614580 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage estate_TCC1 0 (estate_TCC1-1 nil 3645702721 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage fill_TCC1 0 (fill_TCC1-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage fill_TCC2 0 (fill_TCC2-1 nil 3645177900 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_lemma 0 (context_lemma-1 nil 3645177902 ("" (induct "A") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (inst + "hole" "application(application1_var, application2_var)") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (ground) (("1" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst + "letc(K, letexpr2_var)" "B") (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst + "letc(K!1, letexpr2_var)" "B!1") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("5" (grind) nil nil)) nil)) nil) ("6" (skeep*) (("6" (inst + "hole" "update(update1_var, update2_var, update3_var)") (("6" (grind) nil nil)) nil)) nil) ("7" (skeep*) (("7" (inst + "hole" "lookup(lookup1_var, lookup2_var)") (("7" (grind) nil nil)) nil)) nil) ("8" (skeep) (("8" (inst + "hole" "newint(newint1_var)") (("8" (grind) nil nil)) nil)) nil) ("9" (skeep) (("9" (inst + "hole" "newref(newref1_var)") (("9" (grind) nil nil)) nil)) nil) ("10" (skeep) (("10" (ground) (("1" (inst + "hole" "pop(pop1_var)") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst + "popc(K)" "B") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (inst + "hole" "ref(ref1_var)") (("11" (grind) nil nil)) nil)) nil)) nil) ((ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popc adt-constructor-decl "[IContext -> (popc?)]" intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newref adt-constructor-decl "[nat -> (newref?)]" IExpression_adt nil) (newref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (newint adt-constructor-decl "[nat -> (newint?)]" IExpression_adt nil) (newint? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lookup adt-constructor-decl "[[(variable?), (variable?)] -> (lookup?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (update adt-constructor-decl "[[(variable?), (variable?), (variable?)] -> (update?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (letc? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (letc adt-constructor-decl "[[IContext, IExpression] -> (letc?)]" intermediateLanguage nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (application adt-constructor-decl "[[nat, list[(variable?)]] -> (application?)]" IExpression_adt nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (hole adt-constructor-decl "(hole?)" intermediateLanguage nil) (hole? adt-recognizer-decl "[IContext -> boolean]" intermediateLanguage nil) (popRedex? const-decl "bool" intermediateLanguage nil) (newrefRedex? const-decl "bool" intermediateLanguage nil) (newintRedex? const-decl "bool" intermediateLanguage nil) (lookupRedex? const-decl "bool" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (iftRedex? const-decl "bool" intermediateLanguage nil) (applyRedex? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (redex? const-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildContext_TCC1 0 (buildContext_TCC1-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC2 0 (buildContext_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC3 0 (buildContext_TCC3-1 nil 3645328217 ("" (skosimp*) (("" (expand "fill" +) (("" (typepred "v!1(B!1)") (("" (assert) nil nil)) nil)) nil)) nil) ((fill def-decl "IExpression" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil intermediateLanguage nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC4 0 (buildContext_TCC4-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage buildContext_TCC5 0 (buildContext_TCC5-1 nil 3645328217 ("" (grind) nil nil) ((fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage context_composition 0 (context_composition-1 nil 3645324754 ("" (induct-and-simplify "K1") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (compose def-decl "IContext" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pure?_TCC1 0 (pure?_TCC1-1 nil 3645328217 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC2 0 (pure?_TCC2-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure?_TCC3 0 (pure?_TCC3-1 nil 3645328217 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_contextPure 0 (pure_contextPure-1 nil 3645472996 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC1 0 (buildcontextPure_TCC1-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC2 0 (buildcontextPure_TCC2-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC3 0 (buildcontextPure_TCC3-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3645473221 ("" (recursive-judgement-tcc) nil nil) ((pure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage contextPurefill 0 (contextPurefill-1 nil 3645477567 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (contextPure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage pureLetRedex?_TCC1 0 (pureLetRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage pureIftRedex?_TCC1 0 (pureIftRedex?_TCC1-1 nil 3645472989 ("" (subtype-tcc) nil nil) ((iftRedex? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC1 0 (refs_TCC1-1 nil 3645594035 ("" (typepred "IExpression_adt.<<") (("" (expand "strict_well_founded?") (("" (expand "strict_order?") (("" (ground) (("" (hide -1 -2) (("" (grind :if-match nil) (("" (inst - "p!1") (("" (ground) (("1" (skosimp*) (("1" (inst + "y!2") (("1" (skeep) (("1" (inst?) (("1" (typepred "x_1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "y!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst + "y!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (well_founded? const-decl "bool" orders nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (p!1 skolem-const-decl "pred[(contextPure?)]" intermediateLanguage nil) (y!2 skolem-const-decl "(extend[IExpression, (contextPure?), bool, FALSE](p!1))" intermediateLanguage nil) (x_1 skolem-const-decl "(p!1)" intermediateLanguage nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (strict_order? const-decl "bool" orders nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC2 0 (refs_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC3 0 (refs_TCC3-1 nil 3645594035 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC4 0 (refs_TCC4-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC5 0 (refs_TCC5-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC6 0 (refs_TCC6-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage refs_TCC7 0 (refs_TCC7-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3645614580 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage pure_refs 0 (pure_refs-1 nil 3645614582 ("" (induct-and-simplify "A") (("" (rewrite "pure_contextPure") nil nil)) nil) ((pure_contextPure formula-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IExpression_induction formula-decl nil IExpression_adt nil)) shostak))("intermediateLanguage" intermediateLanguage refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3645614695 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage refs_fill 0 (refs_fill-1 nil 3645614697 ("" (induct-and-simplify "K") (("1" (apply-extensionality) nil nil) ("2" (apply-extensionality) nil nil) ("3" (rewrite "contextPurefill") nil nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (letexpr adt-constructor-decl "[[IExpression, IExpression] -> (letexpr?)]" IExpression_adt nil) (fill def-decl "IExpression" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (IContext type-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (refs def-decl "bool" intermediateLanguage nil) (IContext_induction formula-decl nil intermediateLanguage nil)) shostak))("intermediateLanguage" intermediateLanguage refcount_TCC1 0 (refcount_TCC1-1 nil 3645594035 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage refcount_TCC2 0 (refcount_TCC2-1 nil 3645594035 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" intermediateLanguage nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC1 0 (push_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil intermediateLanguage nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage push_TCC2 0 (push_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("intermediateLanguage" intermediateLanguage pop_TCC1 0 (pop_TCC1-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage pop_TCC2 0 (pop_TCC2-1 nil 3645226267 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage get_TCC1 0 (get_TCC1-1 nil 3645245227 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage popDepth_TCC1 0 (popDepth_TCC1-1 nil 3645226267 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage popdepth_fill 0 (popdepth_fill-1 nil 3645226269 ("" (induct-and-simplify "K") nil nil) ((IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (fill def-decl "IExpression" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage purePopDepth 0 (purePopDepth-1 nil 3645515794 ("" (induct-and-simplify "A") nil nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression_induction formula-decl nil IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak))("intermediateLanguage" intermediateLanguage vars_TCC1 0 (vars_TCC1-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC2 0 (vars_TCC2-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC3 0 (vars_TCC3-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC4 0 (vars_TCC4-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC5 0 (vars_TCC5-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_TCC6 0 (vars_TCC6-1 nil 3645245227 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("intermediateLanguage" intermediateLanguage vars_decompose 0 (vars_decompose-1 nil 3645245511 ("" (induct-and-simplify "K") nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IContext type-decl nil intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (fill def-decl "IExpression" intermediateLanguage nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IContext_induction formula-decl nil intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak))("intermediateLanguage" intermediateLanguage letReduce_TCC1 0 (letReduce_TCC1-1 nil 3645245508 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC2 0 (letReduce_TCC2-1 nil 3645245508 ("" (skosimp*) (("" (rewrite "contextPurefill") (("1" (typepred "A!1") (("1" (expand "contextPure?" +) (("1" (ground) (("1" (grind) (("1" (rewrite "pure_contextPure") nil nil) ("2" (rewrite "pure_contextPure") nil nil) ("3" (rewrite "pure_contextPure") nil nil) ("4" (rewrite "pure_contextPure") nil nil)) nil) ("2" (skeep) (("2" (rewrite "refs_fill") (("1" (typepred "gS!1`expr") (("1" (typepred "gS!1") (("1" (replace -) (("1" (hide -1) (("1" (inst?) (("1" (ground) (("1" (rewrite "refs_fill") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (use "pure_refs") (("1" (ground) (("1" (inst?) (("1" (expand "refs" -) (("1" (use "pure_refs") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "contextPurefill") (("2" (expand "pureLetRedex?") (("2" (ground) (("2" (expand "contextPure?" +) (("2" (rewrite "pure_contextPure") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "pureLetRedex?") (("3" (ground) (("3" (skeep) (("3" (rewrite "vars_decompose") (("3" (ground) (("1" (typepred "K!1") (("1" (typepred "gS!1") (("1" (typepred "gS!1`expr") (("1" (inst?) (("1" (inst - "i") (("1" (replace -3 :hide? t) (("1" (rewrite "vars_decompose") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`expr") (("2" (hide -1 -2) (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst - "i") (("2" (rewrite "vars_decompose") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "A!1") (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((contextPurefill formula-decl nil intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (Stack type-eq-decl nil intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (pure_refs formula-decl nil intermediateLanguage nil) (refs_fill formula-decl nil intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (pure_contextPure formula-decl nil intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC3 0 (letReduce_TCC3-1 nil 3645245508 ("" (skosimp*) (("" (typepred "gS!1`stack") (("" (typepred "gS!1`expr") (("" (typepred "gS!1") (("" (replace - :hide? t) (("" (rewrite "popdepth_fill") (("" (typepred "A!1") (("" (hide -3) (("" (inst - "index(letrhs(A!1)) - popDepth(K!1)") (("1" (rewrite "vars_decompose") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (vars def-decl "bool" intermediateLanguage nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (atom? const-decl "bool" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC4 0 (letReduce_TCC4-1 nil 3645245508 ("" (skosimp*) (("" (typepred "A!1") (("" (grind) nil nil)) nil)) nil) ((pureLetRedex? const-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage letReduce_TCC5 0 (letReduce_TCC5-1 nil 3645477565 ("" (skosimp*) (("" (ground) (("1" (typepred "gS!1`stack") (("1" (rewrite "popdepth_fill") (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (rewrite "popdepth_fill") (("1" (rewrite "popDepth" +) (("1" (typepred "A!1") (("1" (expand "pureLetRedex?") (("1" (ground) (("1" (forward-chain "purePopDepth") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "i!1") (("2" (lift-if) (("2" (ground) (("1" (expand "push") (("1" (ground) (("1" (typepred "gS!1`stack") (("1" (expand "get") (("1" (inst?) (("1" (typepred "A!1") (("1" (typepred "gS!1`expr") (("1" (hide -1 -2) (("1" (typepred "gS!1") (("1" (replace - :hide? t) (("1" (assert) (("1" (inst - "index(letrhs(A!1)) - gS!1`stack`length") (("1" (rewrite "vars_decompose") (("1" (ground) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (typepred "gS!1`stack") (("2" (grind) (("2" (typepred "gS!1`expr") (("2" (typepred "gS!1") (("2" (replace - :hide? t) (("2" (inst?) (("2" (rewrite "refs_fill") (("2" (ground) (("2" (typepred "A!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((body adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (letexpr? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (pop adt-constructor-decl "[IExpression -> (pop?)]" IExpression_adt nil) (pop? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (push const-decl "Stack" intermediateLanguage nil) (get const-decl "(value?)" intermediateLanguage nil) (letRedex? const-decl "bool" intermediateLanguage nil) (atom? const-decl "bool" intermediateLanguage nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (pureLetRedex? const-decl "bool" intermediateLanguage nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (letrhs adt-accessor-decl "[(letexpr?) -> IExpression]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (gS!1 skolem-const-decl "{gS | gS`expr = fill(K!1, A!1)}" intermediateLanguage nil) (A!1 skolem-const-decl "(pureLetRedex?)" intermediateLanguage nil) (K!1 skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs_fill formula-decl nil intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC1 0 (updateReduce_TCC1-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (IExpression type-decl nil IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (vars def-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC2 0 (updateReduce_TCC2-1 nil 3645791010 ("" (skeep* :preds? t) (("" (replace -6 :hide? t) (("" (hide -2) (("" (inst - "index(target(A)) - stack`length") (("1" (replace -8 :hide? t) (("1" (rewrite "vars_decompose") (("1" (hide -5) (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (domainValue? const-decl "bool" intermediateLanguage nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (vars def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (popDepth def-decl "nat" intermediateLanguage nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil intermediateLanguage nil) (value? const-decl "bool" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (target adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC3 0 (updateReduce_TCC3-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3) (("" (replace -6) (("" (replace -11) (("" (inst - "index(lhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (lhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC4 0 (updateReduce_TCC4-1 nil 3645791010 ("" (skeep* :preds? t) (("" (hide -3 -4 10) (("" (replace -6 :hide? t) (("" (replace -10 :hide? t) (("" (inst - "index(rhs(A)) - stack`length") (("1" (rewrite "vars_decompose") (("1" (rewrite "popdepth_fill") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vars_decompose formula-decl nil intermediateLanguage nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (get const-decl "(value?)" intermediateLanguage nil) (popdepth_fill formula-decl nil intermediateLanguage nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (update? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (rhs adt-accessor-decl "[(update?) -> (variable?)]" IExpression_adt nil) (updateRedex? const-decl "bool" intermediateLanguage nil) (A skolem-const-decl "(updateRedex?)" intermediateLanguage nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" intermediateLanguage nil) (Stack type-eq-decl nil intermediateLanguage nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (popDepth def-decl "nat" intermediateLanguage nil) (Store type-eq-decl nil intermediateLanguage nil) (contextPure? def-decl "bool" intermediateLanguage nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" intermediateLanguage nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars def-decl "bool" intermediateLanguage nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" intermediateLanguage nil) (estate type-eq-decl nil intermediateLanguage nil) (goodstate type-eq-decl nil intermediateLanguage nil) (IContext type-decl nil intermediateLanguage nil) (fill def-decl "IExpression" intermediateLanguage nil) (pure? def-decl "bool" intermediateLanguage nil) (K skolem-const-decl "{K | pure?(K)}" intermediateLanguage nil) (gS skolem-const-decl "{gS | gS`expr = fill(K, A)}" intermediateLanguage nil) (stack skolem-const-decl "{S: Stack |
   popDepth(gS`expr) = S`length AND
    (FORALL (i: below(S`length)): domainValue?(gS`store`domain)(S`seq(i)))}" intermediateLanguage nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC5 0 (updateReduce_TCC5-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC6 0 (updateReduce_TCC6-1 nil 3645791010 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC7 0 (updateReduce_TCC7-1 nil 3645791010 ("" (skeep* :preds? t) (("" (inst - "refindex(aval)") (("" (assert) (("" (replace -14) (("" (replace -9) (("" (rewrite "refs_fill") (("" (hide-all-but (-8 2 4 -11 -15)) (("" (grind :if-match nil) (("" (inst?) (("1" (ground) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get const-decl "(value?)" intermediateLanguage nil) (add const-decl "(nonempty?)" sets nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC8 0 (updateReduce_TCC8-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC9 0 (updateReduce_TCC9-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC10 0 (updateReduce_TCC10-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("intermediateLanguage" intermediateLanguage updateReduce_TCC11 0 (updateReduce_TCC11-1 nil 3645791010 ("" (subtype-tcc) nil nil) nil nil))("IL" IL popDepth_TCC1 0 (popDepth_TCC1-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL refcount_TCC2 0 (refcount_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_fill_TCC1 0 (refs_fill_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "contextPurefill") (("" (ground) nil nil)) nil)) nil) ((IContext type-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (contextPurefill formula-decl nil IL nil)) nil))("IL" IL pure_refs_TCC1 0 (pure_refs_TCC1-1 nil 3646033320 ("" (skeep) (("" (rewrite "pure_contextPure") nil nil)) nil) ((IExpression type-decl nil IExpression_adt nil) (pure_contextPure formula-decl nil IL nil)) nil))("IL" IL refs_TCC9 0 (refs_TCC9-1 nil 3646130633 ("" (termination-tcc) nil nil) nil nil))("IL" IL refs_TCC8 0 (refs_TCC8-1 nil 3646130633 ("" (subtype-tcc) nil nil) nil nil))("IL" IL refs_TCC7 0 (refs_TCC7-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC6 0 (refs_TCC6-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC5 0 (refs_TCC5-1 nil 3646033320 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL refs_TCC4 0 (refs_TCC4-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL refs_TCC3 0 (refs_TCC3-1 nil 3646033320 ("" (skeep :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" IL nil)) nil))("IL" IL refs_TCC2 0 (refs_TCC2-1 nil 3646033320 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (restrict const-decl "R" restrict nil)) nil))("IL" IL push_TCC2 0 (push_TCC2-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("IL" IL push_TCC1 0 (push_TCC1-1 nil 3646033320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("finite_set_theorems" finite_set_theorems nat_fullset_infinite 0 (nat_fullset_infinite-1 nil 3649860953 ("" (induct "n") (("1" (skeep) (("1" (typepred "f(0)") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (inst + "LAMBDA (i: nat): IF f(i + 1) = 0 THEN f(0) - 1 ELSE f(i + 1) - 1 ENDIF") (("1" (expand "injective?") (("1" (skeep) (("1" (apply (repeat (lift-if))) (("1" (ground) (("1" (inst - "x1 + 1" "x2 + 1") (("1" (ground) nil nil)) nil) ("2" (inst - 0 "x2 + 1") (("2" (assert) nil nil)) nil) ("3" (inst - 0 "x1 + 1") (("3" (assert) nil nil)) nil) ("4" (inst - "x1 + 1" "x2 + 1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (j skolem-const-decl "nat" finite_set_theorems nil) (f skolem-const-decl "(injective?[nat, below(1 + j)])" finite_set_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak))("finite_set_theorems" finite_set_theorems least_out_rec_TCC5 0 (least_out_rec_TCC5-1 nil 3649907982 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems least_out_rec_TCC4 0 (least_out_rec_TCC4-1 nil 3649901266 ("" (skeep :preds? t) (("" (ground) (("" (skeep :preds? t) (("" (typepred "v(NS, 1 + i)") (("" (inst?) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (pick_new const-decl "{j | NOT NS(j)}" finite_set_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3647118642 ("" (grind) nil nil) ((bool nonempty-type-eq-decl nil booleans nil) (Store type-eq-decl nil reduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (updateRedex? const-decl "bool" IL nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (get const-decl "(value?)" IL nil) (refs def-decl "bool" IL nil) (vars def-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction" reduction pushlist_TCC1 0 (pushlist_TCC1-1 nil 3650126116 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (value? const-decl "bool" IL nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("IL" IL vars_decompose_TCC1 0 (vars_decompose_TCC1-1 nil 3650427978 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650427820 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction updateReduce_TCC12 0 (updateReduce_TCC12-1 nil 3650549580 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcount_TCC1 0 (refcount_TCC1-1 nil 3650675711 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3650550591 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("IL" IL vars_TCC10 0 (vars_TCC10-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC25 0 (mark_TCC25-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC24 0 (mark_TCC24-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC23 0 (mark_TCC23-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC22 0 (mark_TCC22-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC21 0 (mark_TCC21-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC20 0 (mark_TCC20-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC19 0 (mark_TCC19-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC18 0 (mark_TCC18-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC17 0 (mark_TCC17-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC16 0 (mark_TCC16-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC15 0 (mark_TCC15-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC14 0 (mark_TCC14-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC13 0 (mark_TCC13-1 nil 3655095779 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC12 0 (mark_TCC12-1 nil 3655095779 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655095779 ("" (grind) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC9 0 (vars_TCC9-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC8 0 (vars_TCC8-1 nil 3650647638 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC7 0 (vars_TCC7-1 nil 3650256398 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC6 0 (vars_TCC6-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC5 0 (vars_TCC5-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("IL" IL vars_TCC4 0 (vars_TCC4-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction" reduction newrefReduce_TCC6 0 (newrefReduce_TCC6-1 nil 3655657128 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (value? const-decl "bool" IL nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (domainValue? const-decl "bool" IL nil)) nil))("preprocess" preprocess markc_TCC3 0 (markc_TCC3-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC11 0 (mark_TCC11-1 nil 3655657330 ("" (termination-tcc) nil nil) nil nil))("preprocess" preprocess mark_TCC10 0 (mark_TCC10-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC9 0 (mark_TCC9-1 nil 3655095779 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3655095779 ("" (skeep*) (("" (lemma "vars_finite") (("" (inst? :if-match all) (("" (rewrite "finite_difference[nat]") nil nil)) nil)) nil)) nil) ((vars_finite formula-decl nil IL nil) (finite_difference judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3655327556 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" finite_set_theorems finite_set_induction_TCC1 0 (finite_set_induction_TCC1-1 nil 3656130778 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_TCC3 0 (vars_TCC3-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess mark_fill_TCC1 0 (mark_fill_TCC1-1 nil 3656268735 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess drop_TCC1 0 (drop_TCC1-1 nil 3656388994 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (grind :if-match nil) (("" (forward-chain -) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC2 0 (bump_TCC2-1 nil 3655508728 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (X!1 skolem-const-decl "finite_set[nat]" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (finite_set type-eq-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil)) nil))("preprocess" preprocess bump_TCC1 0 (bump_TCC1-1 nil 3655508728 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_TCC2 0 (bump_TCC2-1 nil 3656390208 ("" (grind :if-match nil) (("" (inst + "N!1" "LAMBDA (i | i > 0 AND X!1(i - 1)): f!1(i - 1)") (("1" (skeep) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (X!1 skolem-const-decl "finite_set[nat]" IL nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil))("IL" IL bump_TCC1 0 (bump_TCC1-1 nil 3656390208 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("IL" IL bump_drop 0 (bump_drop-1 nil 3656520497 ("" (skeep) (("" (apply-extensionality) (("" (hide 2) (("" (grind :if-match nil) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("finite_set_theorems" finite_set_theorems bump_finite 0 (bump_finite-1 nil 3655675856 ("" (skeep) (("" (typepred "X") (("" (expand "is_finite") (("" (skosimp) (("" (inst + "N!1" "LAMBDA (i: (bump(X))): f!1(i+1)") (("1" (grind :if-match nil) (("1" (forward-chain -) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (injective? const-decl "bool" functions nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (bump const-decl "bool" finite_set_theorems nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("preprocess" preprocess wellformed?_TCC1 0 (wellformed?_TCC1-1 nil 3656737588 ("" (skeep) (("" (rewrite "every_nth") (("" (skeep) (("" (expand "<<") (("" (ground) (("" (rewrite "some_nth") (("" (inst + "i") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (some_nth formula-decl nil finseq_theorems nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (args adt-accessor-decl "[(application?) -> list[(variable?)]]" IExpression_adt nil) (restrict const-decl "R" restrict nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (A skolem-const-decl "IExpression" preprocess nil) (i skolem-const-decl "below(length(args))" preprocess nil) (args skolem-const-decl "list[(variable?)]" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("preprocess" preprocess wellformed_mark_TCC14 0 (wellformed_mark_TCC14-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markvar const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC13 0 (wellformed_mark_TCC13-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("preprocess" preprocess wellformed_mark_TCC12 0 (wellformed_mark_TCC12-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((bump const-decl "finite_set[nat]" IL nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC11 0 (wellformed_mark_TCC11-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC10 0 (wellformed_mark_TCC10-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC9 0 (wellformed_mark_TCC9-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC8 0 (wellformed_mark_TCC8-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC7 0 (wellformed_mark_TCC7-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC6 0 (wellformed_mark_TCC6-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (countable_union application-judgement "countable_set[nat]" finite_set_theorems nil) (injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil))("preprocess" preprocess wellformed_mark_TCC5 0 (wellformed_mark_TCC5-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) nil nil))("preprocess" preprocess wellformed_mark_TCC4 0 (wellformed_mark_TCC4-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC3 0 (wellformed_mark_TCC3-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC2 0 (wellformed_mark_TCC2-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((wellformed? def-decl "bool" preprocess nil)) nil))("preprocess" preprocess wellformed_mark_TCC1 0 (wellformed_mark_TCC1-1 nil 3656867445 ("" (recursive-judgement-tcc) nil nil) ((markv const-decl "(variable?)" preprocess nil) (wellformed? def-decl "bool" preprocess nil)) nil))("IL" IL buildcontextPure_TCC5 0 (buildcontextPure_TCC5-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((cpure? def-decl "bool" IL nil)) nil))("IL" IL buildcontextPure_TCC4 0 (buildcontextPure_TCC4-1 nil 3646033320 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (contextPure? def-decl "bool" IL nil) (cpure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems compose_append 0 (compose_append-1 nil 3676394329 ("" (postpone) nil nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list2finseq 0 (finseq2list2finseq-1 nil 3676394691 ("" (induct-and-simplify "L") (("" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append 0 (finseq2list_append-1 nil 3676428779 ("" (induct "l") (("1" (grind) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil) nil shostak))("finseq_theorems" finseq_theorems finseq2list_append_TCC3 0 (finseq2list_append_TCC3-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC2 0 (finseq2list_append_TCC2-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseq2list_append_TCC1 0 (finseq2list_append_TCC1-1 nil 3676428777 ("" (subtype-tcc) nil nil) nil nil))("finseq_theorems" finseq_theorems finseqtolist_TCC2 0 (finseqtolist_TCC2-1 nil 3676433703 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC2 0 (addroundlist_TCC2-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan addroundlist_TCC1 0 (addroundlist_TCC1-1 nil 3677707205 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[lrlist])" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan treelevel_monotone 0 (treelevel_monotone-1 nil 3677729690 ("" (induct-and-simplify "X") (("" (postpone) nil nil)) nil) nil shostak))("lindstrom_scan" lindstrom_scan scan_TCC7 0 (scan_TCC7-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC6 0 (scan_TCC6-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (labeleq def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (treelevel def-decl "bool" lindstrom_scan nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC5 0 (scan_TCC5-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC4 0 (scan_TCC4-1 nil 3677642327 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (tree type-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan scan_TCC3 0 (scan_TCC3-1 nil 3677642327 ("" (termination-tcc) nil nil) ((restrict const-decl "R" restrict nil) (<< adt-def-decl "(strict_well_founded?[tree])" lindstrom_scan nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (uint32 type-eq-decl nil lindstrom_scan nil) (<= const-decl "bool" reals nil) (treelevel def-decl "bool" lindstrom_scan nil) (tree type-decl nil lindstrom_scan nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC28 0 (sscan_correct_TCC28-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC27 0 (sscan_correct_TCC27-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC26 0 (sscan_correct_TCC26-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC25 0 (sscan_correct_TCC25-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC24 0 (sscan_correct_TCC24-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC23 0 (sscan_correct_TCC23-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC22 0 (sscan_correct_TCC22-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC21 0 (sscan_correct_TCC21-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC20 0 (sscan_correct_TCC20-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC19 0 (sscan_correct_TCC19-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC18 0 (sscan_correct_TCC18-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC17 0 (sscan_correct_TCC17-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC16 0 (sscan_correct_TCC16-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC15 0 (sscan_correct_TCC15-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC14 0 (sscan_correct_TCC14-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC13 0 (sscan_correct_TCC13-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC12 0 (sscan_correct_TCC12-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC11 0 (sscan_correct_TCC11-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC10 0 (sscan_correct_TCC10-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC9 0 (sscan_correct_TCC9-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC8 0 (sscan_correct_TCC8-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC7 0 (sscan_correct_TCC7-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC6 0 (sscan_correct_TCC6-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC5 0 (sscan_correct_TCC5-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC4 0 (sscan_correct_TCC4-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC3 0 (sscan_correct_TCC3-1 nil 3677897058 ("" (recursive-judgement-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC2 0 (sscan_correct_TCC2-1 nil 3677897058 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (tree type-decl nil lindstrom_scan nil) (goodtree def-decl "bool" lindstrom_scan nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (uint32 type-eq-decl nil lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_correct_TCC1 0 (sscan_correct_TCC1-1 nil 3677897058 ("" (skeep :preds? t) (("" (expand "goodtree" -) (("" (assert) (("" (ground) (("1" (expand "goodtree") (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((goodtree def-decl "bool" lindstrom_scan nil) (treelevel def-decl "bool" lindstrom_scan nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("lindstrom_scan" lindstrom_scan sscan_TCC35 0 (sscan_TCC35-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC34 0 (sscan_TCC34-1 nil 3677897058 ("" (termination-tcc) nil nil) nil nil))("lindstrom_scan" lindstrom_scan sscan_TCC33 0 (sscan_TCC33-1 nil 3677897058 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC7 0 (letApply_TCC7-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC6 0 (letApply_TCC6-1 nil 3683776766 ("" (termination-tcc) nil nil) nil nil))("reduction" reduction letApply_TCC5 0 (letApply_TCC5-1 nil 3683776766 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction applyReduce_TCC4 0 (applyReduce_TCC4-1 nil 3650158977 ("" (skeeps :preds? t) (("" (typepred "popit(arity)(body)") (("" (ground) (("1" (lazy-grind) nil nil) ("2" (lazy-grind) nil nil) ("3" (rewrite "popit_popDepth") (("3" (expand "pushlist" +) (("3" (expand "o") (("3" (expand "list2finseq") (("3" (rewrite "map_length") (("3" (forward-chain "purePopDepth") (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refs def-decl "bool" IL nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Definition type-eq-decl nil reduction nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (popit def-decl "IExpression" reduction nil) (vars def-decl "finite_set[nat]" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (popit_pure rec-application-judgement "{B | (forall j: NOT refs(B)(j))}" reduction nil) (popitContextPure rec-application-judgement "(contextPure?)" reduction nil) (popit_var rec-application-judgement "{B | (forall j: vars(B)(j) = vars(A)(j + i))}" reduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (popit_popDepth formula-decl nil reduction nil) (map_length formula-decl nil more_map_props nil) (get const-decl "(value?)" IL nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (drop const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (purePopDepth formula-decl nil IL nil) (below type-eq-decl nil nat_types nil) (Defs type-eq-decl nil reduction nil) (application? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (fun adt-accessor-decl "[(application?) -> nat]" IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (goodstate type-eq-decl nil reduction nil) (pushlist const-decl "Stack" reduction nil) (O const-decl "finseq" finite_sequences nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (popDepth def-decl "nat" IL nil) (in_varlist const-decl "finite_set[nat]" IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction pure_letApply_TCC2 0 (pure_letApply_TCC2-1 nil 3683818064 ("" (recursive-judgement-tcc) nil nil) nil nil))("reduction" reduction vars_letApply_TCC1 0 (vars_letApply_TCC1-1 nil 3683816779 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IExpression type-decl nil IExpression_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (in_varlist const-decl "finite_set[nat]" IL nil)) nil))("refcount" refcount applyReduce_TCC7 0 (applyReduce_TCC7-1 nil 3682124599 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil)) nil))("refcount" refcount applyReduce_TCC6 0 (applyReduce_TCC6-1 nil 3682124599 ("" (skeep*) (("" (expand "refcount") (("" (expand "refcountStack") (("" (expand "pushlist") (("" (rewrite "count_compose") (("" (typepred "grS`count(i)") (("" (expand "refcount") (("" (replace -5) (("" (replace -1) (("" (expand "refcountStack") (("" (expand "refcountExpr" +) (("" (typepred "grS") (("" (rewrite "popit_refs") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") (("1" (assert) nil nil)) nil) ("2" (rewrite "pureApplyRedex") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((refcountStack const-decl "nat" refcount nil) (count_compose formula-decl nil finseq_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (< const-decl "bool" reals nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (Stack type-eq-decl nil IL nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (map adt-def-decl "list[T1]" list_adt_map nil) (get const-decl "(value?)" IL nil) (IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (value? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refcountExpr const-decl "nat" refcount nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil) (popit_refs formula-decl nil reduction nil) (pureApplyRedex formula-decl nil IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pure_refs formula-decl nil IL nil) (pushlist const-decl "Stack" reduction nil) (refcount const-decl "nat" refcount nil)) nil))("refcount" refcount applyReduce_TCC5 0 (applyReduce_TCC5-1 nil 3676345135 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil refcount nil) (applyRedex? const-decl "bool" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (Definition type-eq-decl nil refcount nil) (pure? def-decl "bool" IL nil)) nil))("finseq_theorems" finseq_theorems count_update_TCC1 0 (count_update_TCC1-1 nil 3684271525 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC2 0 (refcountStore_ref_TCC2-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_ref_TCC1 0 (refcountStore_ref_TCC1-1 nil 3685183231 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount refcountStore_update_TCC1 0 (refcountStore_update_TCC1-1 nil 3692670917 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount store_update_TCC3 0 (store_update_TCC3-1 nil 3692717400 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount finite_enumeration_inverse_TCC2 0 (finite_enumeration_inverse_TCC2-1 nil 3692735784 ("" (existence-tcc) nil nil) nil nil))("refcount" refcount decr_TCC16 0 (decr_TCC16-1 nil 3685624183 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC15 0 (decr_TCC15-1 nil 3685569175 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC14 0 (decr_TCC14-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC13 0 (decr_TCC13-2 "" 3692915495 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (lift-if) (("" (ground) (("" (expand "allcountStore") (("" (hide 3) (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "o") (("2" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (hide -1) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (decr_TCC13-1 nil 3685100066 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC12 0 (decr_TCC12-1 nil 3685100066 ("" (skeep*) (("" (lift-if) (("" (ground) (("1" (typepred "v(rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1],
                     refindex(subref), rS`store(refindex(subref))`length)") (("1" (inst?) (("1" (ground) nil nil)) nil) ("2" (ground) (("1" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (skeep :preds? t) (("2" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("2" (typepred "v(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (skeep) (("1" (inst - "r") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (replace -6 :hide? t) (("1" (typepred "i") (("1" (inst - "j") (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (inst - "j") (("2" (replace -8 :hide? t) (("2" (replace -2 :hide? t) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "decr_TCC9") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") (("2" (inst - "rS
                 WITH [`store(r)`seq(i - 1) := nil,
                       `count(refindex(subref))
                         := rS`count(refindex(subref)) - 1]") (("1" (assert) nil nil) ("2" (assert) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (inst - "rS`count(refindex(subref)) - 1") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (skeep) (("3" (inst - "j") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (subref skolem-const-decl "(domainValue?(rS`domain))" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (decr_TCC9 subtype-tcc nil refcount nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" refcount nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("refcount" refcount decr_TCC11 0 (decr_TCC11-2 "" 3685584855 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) shostak) (decr_TCC11-1 nil 3685100066 ("" (termination-tcc) nil nil) nil nil))("refcount" refcount decr_TCC10 0 (decr_TCC10-1 nil 3684597206 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 3) (("" (ground) (("" (hide 1) (("" (expand "allcountStore") (("" (expand "allcount") (("" (lift-if) (("" (ground) (("1" (use "card_is_0") (("1" (grind) (("1" (expand "emptyset") (("1" (typepred "r") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (replace -6 :hide? t) (("2" (assert) (("2" (expand "o") (("2" (case "(LAMBDA (x: below[card(newrS`domain)]):
                              rS WITH [`store(r)`seq(i - 1) := nil, `count(subrefindex) := newsubrefcount]`count
                                  (finite_enumeration(rS`domain)(x))) = (LAMBDA (x: below[card(rS`domain)]):
                               rS`count(finite_enumeration(rS`domain)(x))) WITH [(inverse(finite_enumeration(rS`domain))(subrefindex)) := rS`count(subrefindex) - 1]") (("1" (replace -1 :hide? t) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))
                                 WITH [(inverse(finite_enumeration(rS`domain))(subrefindex))
                                         := rS`count(subrefindex) - 1]" "(lambda (x: below[card(rS`domain)]):
                                  rS`count(finite_enumeration(rS`domain)(x)))" "rS`count(subrefindex) - 1" "card(rS`domain) - 1" "inverse(finite_enumeration(rS`domain))(subrefindex)" "0") (("1" (ground) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (apply-extensionality :hide? t) (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_injective") (("1" (use "finite_enumeration_bij") (("1" (expand "bijective?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "decr_TCC7") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst - "subrefindex") (("2" (assert) (("2" (inst?) (("2" (ground) (("2" (rewrite "inverse_surjective") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "decr_TCC7") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (assert) nil nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (use "decr_TCC7") (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (allcountStore const-decl "nat" refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (allcount const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (card_is_0 formula-decl nil finite_sets nil) (O const-decl "T3" function_props nil) (decr_TCC7 subtype-tcc nil refcount nil) (inverse_injective formula-decl nil function_inverse nil) (injective? const-decl "bool" functions nil) (newrS skolem-const-decl "rstate" refcount nil) (rS skolem-const-decl "rstate" refcount nil) (newsubrefcount skolem-const-decl "int" refcount nil) (r skolem-const-decl "(rS`domain)" refcount nil) (i skolem-const-decl "{i: upto(rS`store(r)`length) |
   forall (j: below(rS`store(r)`length)):
     j >= i IMPLIES NOT ref?(rS`store(r)`seq(j))}" refcount nil) (subrefindex skolem-const-decl "(rS`domain)" refcount nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (bijective? const-decl "bool" functions nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (sigma_with formula-decl nil sigma "reals/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC9 0 (decr_TCC9-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep*) (("2" (assert) (("2" (typepred "j") (("2" (assert) (("2" (case "r = subrefindex") (("1" (replace*) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil)) nil))("refcount" refcount decr_TCC8 0 (decr_TCC8-1 nil 3684597206 ("" (skeep*) (("" (ground) (("" (case "r = subrefindex") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "rS`store(r)`seq(i - 1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC7 0 (decr_TCC7-1 nil 3684597206 ("" (skeep*) (("" (ground) (("1" (typepred "rS`count(subrefindex)") (("1" (expand "refcount") (("1" (use "refcountStore_ref") (("1" (ground) (("1" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(subrefindex)") (("2" (expand "refcount") (("2" (expand "refcountStore") (("2" (lift-if) (("2" (ground) (("1" (typepred "subref") (("1" (grind) nil nil)) nil) ("2" (expand "o") (("2" (expand "refcountArray") (("2" (case-replace "(LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store WITH [(r)`seq(i - 1) := nil]
                               (finite_enumeration(rS`domain)(x)))) = ((LAMBDA (x: below[card(rS`domain)]):
                     count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(finite_enumeration(rS`domain)(x)))) WITH [(inverse(finite_enumeration(rS`domain))(r)) := count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                           rS`store(r)) - 1])") (("1" (hide -1) (("1" (lemma "sigma_with[below(card(rS`domain))]") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                           count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                 rS`store(finite_enumeration(rS`domain)(x))))
                          WITH [(inverse(finite_enumeration(rS`domain))(r))
                                  := count(lambda u:
                                             ref?(u) AND refindex(u) = subrefindex,
                                           rS`store(r))
                                      - 1]" "_" "_" "_" "_" "_") (("1" (inst - "(lambda (x: below[card(rS`domain)]):
                             count(lambda u: ref?(u) AND refindex(u) = subrefindex,
                                   rS`store(finite_enumeration(rS`domain)(x))))" "count(lambda u:
                                               ref?(u) AND refindex(u) = subrefindex,
                                             rS`store(r))
                                        - 1" "card(rS`domain) - 1" "(inverse(finite_enumeration(rS`domain))(r))" "0") (("1" (ground) (("1" (replace -1 :hide? t) (("1" (rewrite "inverse_surjective") (("1" (assert) nil nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) (("1" (case "inverse(finite_enumeration(rS`domain))(r) = x!1") (("1" (assert) (("1" (replace -1 :dir RL) (("1" (rewrite "inverse_surjective") (("1" (assert) (("1" (rewrite "count_update") (("1" (expand "value?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "injective_inverse") (("2" (use "finite_enumeration_bij") (("2" (expand "bijective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "count_elem[(value?)]") (("2" (ground) (("2" (inst + "i - 1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil) ("3" (use "count_elem[(value?)]") (("3" (ground) (("3" (inst + "i - 1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refcountStore_ref formula-decl nil refcount nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (O const-decl "T3" function_props nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (finite_enumeration const-decl "[below[card(X)] -> (X)]" finite_enumeration "sigma_set/") (inverse const-decl "D" function_inverse nil) (sigma_with formula-decl nil sigma "reals/") (integer nonempty-type-from-decl nil integers nil) (T_low type-eq-decl nil sigma "reals/") (T_high type-eq-decl nil sigma "reals/") (OR const-decl "[bool, bool -> bool]" booleans nil) (finite_enumeration_bij formula-decl nil finite_enumeration "sigma_set/") (bijective? const-decl "bool" functions nil) (inverse_surjective formula-decl nil function_inverse nil) (surjective? const-decl "bool" functions nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (sigma def-decl "real" sigma "reals/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count_elem formula-decl nil finseq_theorems nil) (count_update formula-decl nil finseq_theorems nil) (injective_inverse formula-decl nil function_inverse nil) (refcountArray const-decl "nat" refcount nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (refcountExpr const-decl "nat" refcount nil) (count const-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" refcount nil) (sigma_nat application-judgement "nat" sigma "reals/") (refcountStore const-decl "nat" refcount nil)) nil))("refcount" refcount decr_TCC6 0 (decr_TCC6-1 nil 3684597206 ("" (termination-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil)) nil))("refcount" refcount decr_TCC5 0 (decr_TCC5-1 nil 3684597206 ("" (skeep*) (("" (typepred "subref") (("" (grind) nil nil)) nil)) nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (below type-eq-decl nil nat_types nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC4 0 (decr_TCC4-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (refcount const-decl "nat" refcount nil) (rstate type-eq-decl nil refcount nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("refcount" refcount decr_TCC3 0 (decr_TCC3-1 nil 3684597206 ("" (subtype-tcc) nil nil) nil nil))("refcount" refcount decr_TCC2 0 (decr_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("refcount" refcount decr_TCC1 0 (decr_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((rstate type-eq-decl nil refcount nil) (refcount const-decl "nat" refcount nil) (= const-decl "[T, T -> boolean]" equalities nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("IL" IL vars_TCC2 0 (vars_TCC2-1 nil 3646033415 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess markvar_TCC2 0 (markvar_TCC2-1 nil 3683170974 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC2 0 (markvars_markX_TCC2-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess markvars_markX_TCC1 0 (markvars_markX_TCC1-1 nil 3693198804 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_idem_subset 0 (mark_idem_subset-1 nil 3693496691 ("" (induct "A") (("1" (skeep*) (("1" (expand "mark") (("1" (expand "markv") (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak))("refreduction" refreduction lookupReduce_TCC26 0 (lookupReduce_TCC26-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC25 0 (lookupReduce_TCC25-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("refreduction" refreduction lookupReduce_TCC24 0 (lookupReduce_TCC24-1 nil 3696824033 ("" (subtype-tcc) nil nil) nil nil))("finite_set_theorems" |finite_set_theorems| |sigma_sigma_set| 0 (|sigma_sigma_set-1| NIL 3698607396 NIL ("" (INDUCT "X" :NAME "finite_set_induction") (("1" (GRIND :REWRITES "sigma_empty") NIL NIL) ("2" (SKEEP*) (("2" (EXPAND "Sigma" 1 1) (("2" (EXPAND "nonempty?") (("2" (ASSERT) (("2" (INST?) (("2" (REWRITE "sigma_remove") (("2" (LIFT-IF) (("2" (GROUND) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (SKEEP) (("3" (USE "sigma_sigma_set_TCC1") NIL NIL)) NIL)) NIL)) NIL) NIL ((SIGMA_SIGMA_SET_TCC1 SUBTYPE-TCC NIL FINITE_SET_THEOREMS NIL) (NONEMPTY? CONST-DECL "bool" SETS NIL) (REAL_MINUS_REAL_IS_REAL APPLICATION-JUDGEMENT "real" REALS NIL) (SIGMA_REMOVE FORMULA-DECL NIL SIGMA_SET "sigma_set/") (CHOOSE CONST-DECL "(p)" SETS NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (FINITE_REMOVE APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" SIGMA_SET "sigma_set/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (SIGMA_EMPTY FORMULA-DECL NIL SIGMA_SET "sigma_set/") (EMPTY? CONST-DECL "bool" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (FINITE_SET_INDUCTION FORMULA-DECL NIL FINITE_SET_THEOREMS NIL) (SIGMA CONST-DECL "real" SIGMA_SET "sigma_set/") (SIGMA DEF-DECL "nat" FINITE_SET_THEOREMS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/")) NIL NIL NIL SHOSTAK))("finite_set_theorems" |finite_set_theorems| |sigma_sigma_set_TCC1| 0 (|sigma_sigma_set_TCC1-1| NIL 3698607394 NIL ("" (SKEEP) (("" (EXPAND "convergent?") (("" (GROUND) (("1" (USE "countable_props[nat].finite_countable") (("1" (LEMMA "countable_props[nat].finite_countable") (("1" (INST? :POLARITY? T) (("1" (USE "finite_nonzero_elts") NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "convergent?") (("2" (GROUND) (("2" (USE "finite_nonzero_elts") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/") (CONVERGENT? CONST-DECL "bool" COUNTABLE_CONVERGENCE "sigma_set/") (FINITE_COUNTABLE JUDGEMENT-TCC NIL COUNTABLE_PROPS "sets_aux/") (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (X SKOLEM-CONST-DECL "finite_set[nat]" FINITE_SET_THEOREMS NIL) (F SKOLEM-CONST-DECL "[nat -> nat]" FINITE_SET_THEOREMS NIL) (FINITE_NONZERO_ELTS FORMULA-DECL NIL FINITE_SET_THEOREMS NIL)) NIL NIL NIL NIL))("finite_set_theorems" |finite_set_theorems| |finite_nonzero_elts| 0 (|finite_nonzero_elts-1| NIL 3698607891 NIL ("" (SKEEP) (("" (CASE "subset?(nonzero_elts(f, X), X)") (("1" (FORWARD-CHAIN "finite_subset") NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) NIL ((FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (SUBSET? CONST-DECL "bool" SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (FINITE_SUBSET FORMULA-DECL NIL FINITE_SETS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (/= CONST-DECL "boolean" NOTEQUAL NIL) (SUBSET_IS_PARTIAL_ORDER NAME-JUDGEMENT "(partial_order?[set[T]])" SETS_LEMMAS NIL)) NIL NIL NIL SHOSTAK))("preprocess" |preprocess| |mark_idem_subset| 0 (|mark_idem_subset-1| NIL 3693496691 NIL ("" (INDUCT "A") (("1" (SKEEP*) (("1" (EXPAND "mark") (("1" (EXPAND "markv") (("1" (GRIND) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL) ("4" (POSTPONE) NIL NIL) ("5" (POSTPONE) NIL NIL) ("6" (POSTPONE) NIL NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (POSTPONE) NIL NIL) ("11" (POSTPONE) NIL NIL) ("12" (POSTPONE) NIL NIL) ("13" (POSTPONE) NIL NIL)) NIL) NIL NIL NIL NIL NIL SHOSTAK))("rreduction" |rreduction| |allcount_TCC2| 0 (|allcount_TCC2-1| NIL 3684597206 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |allcount_TCC1| 0 (|allcount_TCC1-1| NIL 3684597206 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |refcountStore_TCC2| 0 (|refcountStore_TCC2-1| NIL 3650675711 NIL ("" (SKEEP) (("" (POSTPONE) NIL NIL)) NIL) NIL ((EMPTY_CARD FORMULA-DECL NIL FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |refcountStore_TCC1| 0 (|refcountStore_TCC1-1| NIL 3650675711 NIL ("" (SKEEP :PREDS? T) (("" (EXPAND "convergent?") (("" (GROUND) (("1" (USE "finite_countable") (("1" (CASE "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (FORWARD-CHAIN "countable_subset[(dom)]") NIL NIL) ("2" (HIDE -1 -2 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "convergent?") (("2" (FLATTEN) (("2" (HIDE 2) (("2" (CASE "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (FORWARD-CHAIN "finite_subset[(dom)]") NIL NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((CONVERGENT? CONST-DECL "bool" CONVERGENCE_SET "sigma_set/") (CONVERGENT? CONST-DECL "bool" COUNTABLE_CONVERGENCE "sigma_set/") (FINITE_SUBSET FORMULA-DECL NIL FINITE_SETS NIL) (FINITE_COUNTABLE JUDGEMENT-TCC NIL COUNTABLE_PROPS "sets_aux/") (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (SUBSET_IS_PARTIAL_ORDER NAME-JUDGEMENT "(partial_order?[set[T]])" SETS_LEMMAS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (/= CONST-DECL "boolean" NOTEQUAL NIL) (COUNT CONST-DECL "nat" FINSEQ_THEOREMS NIL) (COUNTABLE_SUBSET FORMULA-DECL NIL COUNTABILITY "sets_aux/") (IS_COUNTABLE CONST-DECL "bool" COUNTABILITY "sets_aux/") (COUNTABLE_SET NONEMPTY-TYPE-EQ-DECL NIL COUNTABILITY "sets_aux/") (SUBSET? CONST-DECL "bool" SETS NIL) (NONZERO_ELTS CONST-DECL "set[T]" CONVERGENCE_SET "sigma_set/") (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (REFCOUNTARRAY CONST-DECL "nat" RREDUCTION NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (RESTRICT CONST-DECL "R" RESTRICT NIL) (FINITE_RESTRICT APPLICATION-JUDGEMENT "finite_set[S]" RESTRICT_SET_PROPS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC13| 0 (|lookupReduce_TCC13-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC12| 0 (|lookupReduce_TCC12-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC11| 0 (|lookupReduce_TCC11-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((GET CONST-DECL "(value?)" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC10| 0 (|lookupReduce_TCC10-1| NIL 3696570131 NIL ("" (SKEEP* :PREDS? T) (("" (GROUND) (("1" (TYPEPRED "grS`count(avalindex)") (("1" (EXPAND "refcount") (("1" (EXPAND "refcountStack") (("1" (USE "count_elem[(IL.value?)]") (("1" (GROUND) (("1" (INST + "stack`length - 1 - index(avar)") (("1" (ASSERT) (("1" (EXPAND "get") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (USE "lookupReduce_TCC7") (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST - "pos") (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) (("2" (GROUND) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "refcount") (("2" (EXPAND "refcountStack") (("2" (REWRITE "count_update") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "grS`count(avalindex)") (("1" (EXPAND "refcount") (("1" (EXPAND "refcountStack") (("1" (ASSERT) (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL) ("3" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC9| 0 (|lookupReduce_TCC9-1| NIL 3696570131 NIL ("" (SKEEP* :PREDS? T) (("" (USE "reduction.lookupReduce_TCC6") (("" (INST - "rstate2estate(grS)" "stack") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST - "pos") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (GROUND) (("1" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (LAZY-GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND :IF-MATCH NIL) NIL NIL)) NIL) ("3" (HIDE 3) (("3" (GRIND :IF-MATCH NIL) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((LOOKUPREDUCE_TCC6 SUBTYPE-TCC NIL REDUCTION NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (GET CONST-DECL "(value?)" IL NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (ADD CONST-DECL "(nonempty?)" SETS NIL) (NONEMPTY_ADD_FINITE APPLICATION-JUDGEMENT "non_empty_finite_set[nat]" COUNTABILITY "sets_aux/") (MARKV CONST-DECL "(variable?)" PREPROCESS NIL) (CONSTANT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (VALUE ADT-ACCESSOR-DECL "[(constant?) -> int]" IEXPRESSION_ADT NIL) (POSITION ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]" IEXPRESSION_ADT NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" SIGMA_SET "sigma_set/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (REFINDEX ADT-ACCESSOR-DECL "[(ref?) -> nat]" IEXPRESSION_ADT NIL) (ARRAYVALUE ADT-ACCESSOR-DECL "[(lookup?) -> (variable?)]" IEXPRESSION_ADT NIL) (LOOKUP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EXPR SKOLEM-CONST-DECL "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" RREDUCTION NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (STORE SKOLEM-CONST-DECL "Store(grS`domain)" RREDUCTION NIL) (IFF CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (GOODSTATE TYPE-EQ-DECL NIL REDUCTION NIL) (STACK SKOLEM-CONST-DECL "{S: Stack | every(domainValue?(grS`domain))(S)}" RREDUCTION NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (< CONST-DECL "bool" REALS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" REALS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (ESTATE TYPE-EQ-DECL NIL REDUCTION NIL) (RSTATE2ESTATE CONST-DECL "estate" RREDUCTION NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (GRS SKOLEM-CONST-DECL "{grS | lookupRedex?(grS`redex)}" RREDUCTION NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |lookupReduce_TCC8| 0 (|lookupReduce_TCC8-1| NIL 3696570131 NIL ("" (SUBTYPE-TCC) NIL NIL) NIL ((GET CONST-DECL "(value?)" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |ifReduce_TCC8| 0 (|ifReduce_TCC8-1| NIL 3696194804 NIL ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "grS`count(x1)") (("" (EXPAND "refcount") (("" (EXPAND "pureIftRedex?") (("" (EXPAND "iftRedex?") (("" (GROUND) (("" (EXPAND "refcountExpr") (("" (REWRITE "pure_refs") (("1" (REWRITE "pure_refs") NIL NIL) ("2" (EXPAND "pure?" +) (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL ((PUREIFTREDEX? CONST-DECL "bool" IL NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (<= CONST-DECL "bool" REALS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (< CONST-DECL "bool" REALS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (REFS DEF-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (PURE_REFS FORMULA-DECL NIL IL NIL) (PURE? DEF-DECL "bool" IL NIL) (REFCOUNTEXPR CONST-DECL "nat" RREDUCTION NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("rreduction" |rreduction| |ifReduce_TCC7| 0 (|ifReduce_TCC7-1| NIL 3696194804 NIL ("" (SKEEP* :PREDS? T) (("" (USE "reduction.ifReduce_TCC4") (("" (INST - "rstate2estate(grS)" "stack") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (INST - "thenexpr") (("1" (SPLIT) (("1" (INST?) (("1" (SPLIT) (("1" (GROUND) (("1" (LAZY-GRIND :REWRITES "purePopDepth") NIL NIL) ("2" (LAZY-GRIND :REWRITES "purePopDepth") NIL NIL) ("3" (GRIND :REWRITES "purePopDepth" :IF-MATCH NIL) NIL NIL) ("4" (EXPAND "pureIftRedex?") (("4" (EXPAND "iftRedex?") (("4" (GROUND) (("4" (EXPAND "mark" -) (("4" (DECOMPOSE-EQUALITY -) (("4" (REPLACE -22) (("4" (REPLACE -2 :DIR RL) (("4" (REWRITE "mark_release_set") (("1" (REWRITE "mark_idem") NIL NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND :REWRITES "vars_mark") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (INST -12 "i") (("5" (GROUND) (("5" (EXPAND "pureIftRedex?") (("5" (EXPAND "iftRedex?") (("5" (GROUND) (("5" (EXPAND "mark" -) (("5" (DECOMPOSE-EQUALITY -) (("5" (REPLACE -23) (("5" (REPLACE -2 :DIR RL) (("5" (REWRITE "vars_release_set") (("5" (HIDE-ALL-BUT (-1 -4 -22 2 3 5)) (("5" (GRIND :REWRITES "vars_mark") (("5" (REPLACE -1 :DIR RL) (("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE 5) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL ((IFREDUCE_TCC4 SUBTYPE-TCC NIL REDUCTION NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARS_RELEASE_SET FORMULA-DECL NIL PREPROCESS NIL) (ADD CONST-DECL "(nonempty?)" SETS NIL) (NONEMPTY_ADD_FINITE APPLICATION-JUDGEMENT "non_empty_finite_set[nat]" COUNTABILITY "sets_aux/") (DIFFERENCE CONST-DECL "set" SETS NIL) (RELEASE_SET DEF-DECL "IExpression" PREPROCESS NIL) (ELSEEXPR ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" IEXPRESSION_ADT NIL) (THENEXPR ADT-ACCESSOR-DECL "[(ift?) -> IExpression]" IEXPRESSION_ADT NIL) (UNION CONST-DECL "set" SETS NIL) (MARKV CONST-DECL "(variable?)" PREPROCESS NIL) (IFT ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression, IExpression] -> (ift?)]" IEXPRESSION_ADT NIL) (CONDITION ADT-ACCESSOR-DECL "[(ift?) -> (variable?)]" IEXPRESSION_ADT NIL) (IFT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (FINITE_DIFFERENCE APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_INTERSECTION1 APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (VARS_MARK FORMULA-DECL NIL PREPROCESS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (INTERSECTION CONST-DECL "set" SETS NIL) (EMPTY? CONST-DECL "bool" SETS NIL) (DISJOINT? CONST-DECL "bool" SETS NIL) (MARK_IDEM FORMULA-DECL NIL PREPROCESS NIL) (MARK_RELEASE_SET FORMULA-DECL NIL PREPROCESS NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (GET CONST-DECL "(value?)" IL NIL) (VARS_MARK_TYPE APPLICATION-JUDGEMENT "{C | vars(C) = vars(B)}" PREPROCESS NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EXPR SKOLEM-CONST-DECL "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" RREDUCTION NIL) (REAL_LE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (STORE SKOLEM-CONST-DECL "Store(grS`domain)" RREDUCTION NIL) (IFF CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (GOODSTATE TYPE-EQ-DECL NIL REDUCTION NIL) (STACK SKOLEM-CONST-DECL "{S: Stack | every(domainValue?(grS`domain))(S)}" RREDUCTION NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (FINSEQ TYPE-EQ-DECL NIL FINITE_SEQUENCES NIL) (EVERY CONST-DECL "bool" FINSEQ_THEOREMS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (DOMAINVALUE? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (< CONST-DECL "bool" REALS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (<= CONST-DECL "bool" REALS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (MARK DEF-DECL "IExpression" PREPROCESS NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (STORE TYPE-EQ-DECL NIL REDUCTION NIL) (REFCOUNT CONST-DECL "nat" RREDUCTION NIL) (RSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (ESTATE TYPE-EQ-DECL NIL REDUCTION NIL) (RSTATE2ESTATE CONST-DECL "estate" RREDUCTION NIL) (GOODRSTATE TYPE-EQ-DECL NIL RREDUCTION NIL) (PUREIFTREDEX? CONST-DECL "bool" IL NIL) (GRS SKOLEM-CONST-DECL "{grS | pureIftRedex?(grS`redex)}" RREDUCTION NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL NIL NIL NIL))("IL" IL VARS_FINITE 0 (VARS_FINITE-2 "" 3655616144 ("" (INDUCT "A") (("1" (GRIND :IF-MATCH NIL) (("1" (INST + 1 "(LAMBDA (i: (vars(variable(variable1_var!1, variable2_var!1)))): 0)") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND :IF-MATCH NIL) (("2" (INST + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND :IF-MATCH NIL) (("3" (INST + 0 "LAMBDA (i: (vars(nil))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (EXPAND "vars" +) (("4" (EXPAND "is_finite" +) (("4" (INST + "length(application2_var)" "(LAMBDA (i | in_varlist(application2_var)(i)): locate(LAMBDA x: index(x) = i, application2_var))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x1, application2_var)") (("1" (ASSERT) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x2, application2_var)") (("1" (ASSERT) (("1" (REPLACE -6 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "i") (("2" (EXPAND "in_varlist") (("2" (REWRITE "some_nth") (("2" (SKEEP) (("2" (INST?) (("2" (REWRITE "member_nth") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (EXPAND "vars" +) (("5" (LEMMA "finite_union" ("A" "vars(letexpr1_var)" "B" "(LAMBDA i: vars(letexpr2_var)(1 + i))")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (EXPAND "is_finite") (("2" (SKEEP) (("2" (INST + "N" "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (FORWARD-CHAIN -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (EXPAND "vars" +) (("6" (LEMMA "finite_union" ("A" "vars(ift1_var)" "B" "vars(ift2_var)")) (("1" (LEMMA "finite_union" ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B" "vars(ift3_var)")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (EXPAND "vars") (("7" (EXPAND "vars") (("7" (EXPAND "is_finite" +) (("7" (INST + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                         (i = index(update2_var)) OR
                          (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)") (("7" (EXPAND "injective?") (("7" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (EXPAND "vars" +) (("8" (EXPAND "is_finite" +) (("8" (INST + 2 "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF") (("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (EXPAND "vars") (("9" (EXPAND "is_finite") (("9" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (EXPAND "vars") (("10" (EXPAND "is_finite") (("10" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (EXPAND "vars" +) (("11" (EXPAND "is_finite") (("11" (SKEEP) (("11" (INST + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)") (("11" (EXPAND "injective?") (("11" (SKEEP) (("11" (FORWARD-CHAIN -1) (("11" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (EXPAND "vars") (("12" (EXPAND "is_finite") (("12" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (EXPAND "vars" +) (("13" (EXPAND "is_finite") (("13" (SKEEP*) (("13" (INST + "N!1 + 1" "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release2_var)(i) THEN f!1(i) ELSE N!1 ENDIF") (("1" (GRIND :IF-MATCH NIL) (("1" (FORWARD-CHAIN -4) NIL NIL) ("2" (FORWARD-CHAIN -4) NIL NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK) (VARS_FINITE-1 NIL 3652888177 ("" (INDUCT "A") (("1" (GRIND :IF-MATCH NIL) (("1" (INST + 1 "(LAMBDA (i: (vars(variable(variable1_var!1)))): 0)") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND :IF-MATCH NIL) (("2" (INST + 0 "LAMBDA (i: (vars(constant(constant1_var!1)))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND :IF-MATCH NIL) (("3" (INST + 0 "LAMBDA (i: (vars(nil))): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (EXPAND "vars" +) (("4" (EXPAND "is_finite" +) (("4" (INST + "length(application2_var)" "(LAMBDA (i | member(variable(i), application2_var)): locate(LAMBDA x: index(x) = i, application2_var))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x1, application2_var)") (("1" (ASSERT) (("1" (TYPEPRED "locate(LAMBDA x: index(x) = x2, application2_var)") (("1" (ASSERT) (("1" (REPLACE -6 :HIDE? T) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (INST + "variable(i)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (EXPAND "vars" +) (("5" (LEMMA "finite_union" ("A" "vars(letexpr1_var)" "B" "(LAMBDA i: vars(letexpr2_var)(1 + i))")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (EXPAND "is_finite") (("2" (SKEEP) (("2" (INST + "N" "(LAMBDA (j | vars(letexpr2_var)(1 + j)): f(1 + j))") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (FORWARD-CHAIN -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (EXPAND "vars" +) (("6" (LEMMA "finite_union" ("A" "vars(ift1_var)" "B" "vars(ift2_var)")) (("1" (LEMMA "finite_union" ("A" "union[nat](vars(ift1_var), vars(ift2_var))" "B" "vars(ift3_var)")) (("1" (EXPAND "union") (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL) ("2" (PROPAX) NIL NIL) ("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (EXPAND "vars") (("7" (EXPAND "vars") (("7" (EXPAND "is_finite" +) (("7" (INST + 3 "(LAMBDA (i | (i = index(update1_var)) OR
                     (i = index(update2_var)) OR
                      (i = index(update3_var))): IF (i = index(update1_var)) THEN 0 ELSIF (i = index(update2_var)) THEN 1 ELSE 2 ENDIF)") (("7" (EXPAND "injective?") (("7" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (EXPAND "vars" +) (("8" (EXPAND "is_finite" +) (("8" (INST + 2 "LAMBDA (i | vars(lookup1_var)(i) OR vars(lookup2_var)(i)): IF index(lookup1_var) = i THEN 0 ELSE 1 ENDIF") (("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (EXPAND "vars") (("9" (EXPAND "is_finite") (("9" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (EXPAND "vars") (("10" (EXPAND "is_finite") (("10" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (EXPAND "vars" +) (("11" (EXPAND "is_finite") (("11" (SKEEP) (("11" (INST + "N" "LAMBDA (i | vars(pop1_var)(1 + i)): f(i+1)") (("11" (EXPAND "injective?") (("11" (SKEEP) (("11" (FORWARD-CHAIN -1) (("11" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (EXPAND "vars") (("12" (EXPAND "is_finite") (("12" (INST + 0 "LAMBDA (i | FALSE): 0") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (EXPAND "vars" +) (("13" (EXPAND "is_finite") (("13" (SKEEP*) (("13" (INST + "N + 1" "LAMBDA (i | vars(release1_var)(i) OR vars(release2_var)(i)): IF vars(release1_var)(i) THEN f(i) ELSE N ENDIF") (("1" (GRIND :IF-MATCH NIL) (("1" (FORWARD-CHAIN -3) NIL NIL) ("2" (FORWARD-CHAIN -3) NIL NIL)) NIL) ("2" (SKEEP*) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("14" (SKEEP) (("14" (EXPAND "is_finite" +) (("14" (INST + 1 "LAMBDA (i | vars(mark(mark1_var))(i)): 0") (("14" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (< CONST-DECL "bool" REALS NIL) (VARIABLE ADT-CONSTRUCTOR-DECL "[[nat, bool] -> (variable?)]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (CONSTANT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (CONSTANT ADT-CONSTRUCTOR-DECL "[int -> (constant?)]" IEXPRESSION_ADT NIL) (FALSE CONST-DECL "bool" BOOLEANS NIL) (NIL? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NIL ADT-CONSTRUCTOR-DECL "(nil?)" IEXPRESSION_ADT NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (MEMBER DEF-DECL "bool" LIST_PROPS NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (LENGTH DEF-DECL "nat" LIST_PROPS NIL) (BELOW TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (NTH DEF-DECL "T" LIST_PROPS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (LOCATE DEF-DECL "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}" FINSEQ_THEOREMS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (UNION CONST-DECL "set" SETS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (FINITE_UNION JUDGEMENT-TCC NIL FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (IF CONST-DECL "[boolean, T, T -> T]" IF_DEF NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (RESTRICT CONST-DECL "R" RESTRICT NIL)) SHOSTAK))("IL" IL VARS_DECOMPOSE 0 (VARS_DECOMPOSE-1 NIL 3646034443 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (VARS DEF-DECL "finite_set[nat]" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL) (EMPTYSET CONST-DECL "set" SETS NIL) (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set[T]" COUNTABLE_PROPS "sets_aux/") (FINITE_EMPTYSET NAME-JUDGEMENT "finite_set" FINITE_SETS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/") (MEMBER CONST-DECL "bool" SETS NIL) (DROP CONST-DECL "finite_set[nat]" IL NIL) (UNION CONST-DECL "set" SETS NIL)) SHOSTAK))("IL" IL VARS_TCC1 0 (VARS_TCC1-1 NIL 3646033415 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUMPN_BUMP 0 (BUMPN_BUMP-1 NIL 3656631410 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_PLUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BUMP CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL BUMPN_UNION 0 (BUMPN_UNION-1 NIL 3656567110 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (MEMBER CONST-DECL "bool" SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL) (UNION CONST-DECL "set" SETS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (FINITE_UNION APPLICATION-JUDGEMENT "finite_set[nat]" COUNTABILITY "sets_aux/")) SHOSTAK))("IL" IL DROP_BUMP 0 (DROP_BUMP-1 NIL 3656520613 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL) (DROP CONST-DECL "finite_set[nat]" IL NIL) (BUMP CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL DROP_TCC1 0 (DROP_TCC1-1 NIL 3656390208 ("" (GRIND :IF-MATCH NIL) (("" (INST + "N!1" "LAMBDA (i | X!1(i + 1)): f!1(i+1)") (("" (GRIND :IF-MATCH NIL) (("" (FORWARD-CHAIN -) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((NNINT_PLUS_POSINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (< CONST-DECL "bool" REALS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL BUMPN_ZERO 0 (BUMPN_ZERO-1 NIL 3656521531 ("" (GRIND-WITH-EXT) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BUMPN CONST-DECL "finite_set[nat]" IL NIL)) SHOSTAK))("IL" IL BUMPN_TCC2 0 (BUMPN_TCC2-1 NIL 3656517434 ("" (GRIND :IF-MATCH NIL) (("" (INST + "N!1" "LAMBDA (i | i >= j!1 AND X!1(i - j!1)): f!1(i - j!1)") (("1" (SKEEPS :PREDS? T) (("1" (FORWARD-CHAIN -) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL) ((IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (J!1 SKOLEM-CONST-DECL "nat" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (< CONST-DECL "bool" REALS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (X!1 SKOLEM-CONST-DECL "finite_set[nat]" IL NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (SET TYPE-EQ-DECL NIL SETS NIL) (FINITE_SET TYPE-EQ-DECL NIL FINITE_SETS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL BUMPN_TCC1 0 (BUMPN_TCC1-1 NIL 3656517434 ("" (SUBTYPE-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (>= CONST-DECL "bool" REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL)) NIL))("IL" IL IN_VARLIST_TCC1 0 (IN_VARLIST_TCC1-1 NIL 3656276690 ("" (GRIND :IF-MATCH NIL) (("" (INST + "length(L!1)" "LAMBDA (i | some[(variable?)]
                           (LAMBDA (v: (variable?)): index(v) = i)(L!1)): locate[(variable?)]((LAMBDA (v: (variable?)): index(v) = i), L!1)") (("1" (SKEEP) (("1" (TYPEPRED "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x1, L!1)") (("1" (TYPEPRED "locate[(variable?)](LAMBDA (v: (variable?)): index(v) = x2, L!1)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (REWRITE "some_nth") (("2" (SKEEP) (("2" (INST?) (("2" (REWRITE "member_nth") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL) (MEMBER DEF-DECL "bool" LIST_PROPS NIL) (L!1 SKOLEM-CONST-DECL "list[(variable?)]" IL NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (SOME ADT-DEF-DECL "boolean" LIST_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (LENGTH DEF-DECL "nat" LIST_PROPS NIL) (< CONST-DECL "bool" REALS NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (BELOW TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (NTH DEF-DECL "T" LIST_PROPS NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (- CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (LOCATE DEF-DECL "{i: below(length(L)) | P(nth(L, length(L) - i - 1))}" FINSEQ_THEOREMS NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (SOME_NTH FORMULA-DECL NIL FINSEQ_THEOREMS NIL) (I_1 SKOLEM-CONST-DECL "below(length(L!1))" IL NIL) (I SKOLEM-CONST-DECL "{i | some[(variable?)](lambda (v: (variable?)): index(v) = i)(L!1)}" IL NIL) (MEMBER_NTH FORMULA-DECL NIL FINSEQ_THEOREMS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (EVERY ADT-DEF-DECL "boolean" LIST_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (IS_FINITE CONST-DECL "bool" FINITE_SETS NIL) (INJECTIVE? CONST-DECL "bool" FUNCTIONS NIL)) NIL))("IL" IL PUREPOPDEPTH 0 (PUREPOPDEPTH-1 NIL 3646034411 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL POPDEPTH_FILL 0 (POPDEPTH_FILL-1 NIL 3646034392 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (NUMFIELD NONEMPTY-TYPE-EQ-DECL NIL NUMBER_FIELDS NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" NUMBER_FIELDS NIL) (POPDEPTH DEF-DECL "nat" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL) (POSINT_PLUS_NNINT_IS_POSINT APPLICATION-JUDGEMENT "posint" INTEGERS NIL)) SHOSTAK))("IL" IL GET_TCC1 0 (GET_TCC1-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (< CONST-DECL "bool" REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INDEX ADT-ACCESSOR-DECL "[(variable?) -> nat]" IEXPRESSION_ADT NIL) (BELOW TYPE-EQ-DECL NIL NAT_TYPES NIL) (VALUE? CONST-DECL "bool" IL NIL) (STACK TYPE-EQ-DECL NIL IL NIL) (REAL_LT_IS_STRICT_TOTAL_ORDER NAME-JUDGEMENT "(strict_total_order?[real])" REAL_PROPS NIL) (INT_MINUS_INT_IS_INT APPLICATION-JUDGEMENT "int" INTEGERS NIL)) NIL))("IL" IL POP_TCC2 0 (POP_TCC2-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("IL" IL POP_TCC1 0 (POP_TCC1-1 NIL 3646033415 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL))("IL" IL REFCOUNT_PURE 0 (REFCOUNT_PURE-1 NIL 3676382439 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REFCOUNT DEF-DECL "nat" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (NNINT_PLUS_NNINT_IS_NNINT APPLICATION-JUDGEMENT "nonneg_int" INTEGERS NIL)) SHOSTAK))("IL" IL REFCOUNT_TCC1 0 (REFCOUNT_TCC1-1 NIL 3646033320 ("" (GRIND) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL REFS_FILL 0 (REFS_FILL-1 NIL 3646034363 ("" (INDUCT-AND-SIMPLIFY "K") (("1" (APPLY-EXTENSIONALITY) NIL NIL) ("2" (APPLY-EXTENSIONALITY) NIL NIL) ("3" (REWRITE "contextPurefill") NIL NIL)) NIL) ((POP ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" IEXPRESSION_ADT NIL) (POP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LETEXPR ADT-CONSTRUCTOR-DECL "[[IExpression, IExpression] -> (letexpr?)]" IEXPRESSION_ADT NIL) (LETEXPR? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REFS DEF-DECL "bool" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL PURE_REFS 0 (PURE_REFS-1 NIL 3646034342 ("" (INDUCT-AND-SIMPLIFY "A") (("" (REWRITE "pure_contextPure") NIL NIL)) NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (>= CONST-DECL "bool" REALS NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (REFS DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL REFS_TCC1 0 (REFS_TCC1-1 NIL 3646033320 ("" (TYPEPRED "IExpression_adt.<<") (("" (EXPAND "strict_well_founded?") (("" (EXPAND "strict_order?") (("" (GROUND) (("" (HIDE -1 -2) (("" (GRIND :IF-MATCH NIL) (("" (INST - "p!1") (("" (GROUND) (("1" (SKOSIMP*) (("1" (INST + "y!2") (("1" (SKEEP) (("1" (INST?) (("1" (TYPEPRED "x_1") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "y!2") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST + "y!1") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (REAL_GE_IS_TOTAL_ORDER NAME-JUDGEMENT "(total_order?[real])" REAL_PROPS NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (>= CONST-DECL "bool" REALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (STRICT_ORDER? CONST-DECL "bool" ORDERS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXTPUREPUREREDEX 0 (CONTEXTPUREPUREREDEX-1 NIL 3682299553 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (SKEEP*) (("4" (GRIND) NIL NIL)) NIL) ("5" (SKEEP*) (("5" (GRIND) NIL NIL)) NIL) ("6" (SKEEP*) (("6" (HIDE (-1 -2 -3)) (("6" (GRIND) (("1" (POSTPONE) NIL NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) ("7" (POSTPONE) NIL NIL) ("8" (POSTPONE) NIL NIL) ("9" (POSTPONE) NIL NIL) ("10" (POSTPONE) NIL NIL) ("11" (POSTPONE) NIL NIL) ("12" (POSTPONE) NIL NIL) ("13" (POSTPONE) NIL NIL)) NIL) NIL SHOSTAK))("IL" IL PUREREDEXCONTEXTPURE 0 (PUREREDEXCONTEXTPURE-1 NIL 3646130634 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (SKEEP) (("6" (EXPAND "contextPure?" +) (("6" (EXPAND "pureRedex?" -4) (("6" (SPLIT -4) (("1" (EXPAND "pureLetRedex?") (("1" (EXPAND "letRedex?") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (EXPAND "applyRedex?") (("2" (PROPAX) NIL NIL)) NIL) ("3" (EXPAND "pureIftRedex?") (("3" (EXPAND "iftRedex?") (("3" (FLATTEN) (("3" (REWRITE "pure_contextPure" +) (("3" (REWRITE "pure_contextPure" +) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (GRIND) NIL NIL) ("5" (GRIND) NIL NIL) ("6" (GRIND) NIL NIL) ("7" (GRIND) NIL NIL) ("8" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("7" (GRIND) NIL NIL) ("8" (GRIND) NIL NIL) ("9" (GRIND) NIL NIL) ("10" (GRIND) NIL NIL) ("11" (GRIND) NIL NIL) ("12" (GRIND) NIL NIL) ("13" (GRIND) NIL NIL) ("14" (GRIND) NIL NIL)) NIL) ((PURE? DEF-DECL "bool" IL NIL) (PURERELEASEREDEX? CONST-DECL "bool" IL NIL) (RELEASEREDEX? CONST-DECL "bool" IL NIL) (POPREDEX? CONST-DECL "bool" IL NIL) (NEWREFREDEX? CONST-DECL "bool" IL NIL) (NEWINTREDEX? CONST-DECL "bool" IL NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (UPDATEREDEX? CONST-DECL "bool" IL NIL) (PUREIFTREDEX? CONST-DECL "bool" IL NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (PURELETREDEX? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (PUREREDEX? CONST-DECL "bool" IL NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL PURERELEASEREDEX?_TCC1 0 (PURERELEASEREDEX?_TCC1-1 NIL 3693185170 ("" (GRIND) NIL NIL) ((RELEASEREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PUREIFTREDEX?_TCC1 0 (PUREIFTREDEX?_TCC1-1 NIL 3646033320 ("" (SUBTYPE-TCC) NIL NIL) ((IFTREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PURELETREDEX?_TCC1 0 (PURELETREDEX?_TCC1-1 NIL 3646033320 ("" (SUBTYPE-TCC) NIL NIL) ((VALUE? CONST-DECL "bool" IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL)) NIL))("IL" IL PUREAPPLYREDEX 0 (PUREAPPLYREDEX-1 NIL 3682268823 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (PURE? DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL CONTEXTPUREFILL 0 (CONTEXTPUREFILL-1 NIL 3646034319 ("" (INDUCT-AND-SIMPLIFY "K") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (FILL DEF-DECL "IExpression" IL NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL BUILDCONTEXTPURE_TCC5 0 (BUILDCONTEXTPURE_TCC5-1 NIL 3693185170 ("" (GRIND) NIL NIL) ((CPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC4 0 (BUILDCONTEXTPURE_TCC4-1 NIL 3693185170 ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "v(B)") (("" (GRIND) NIL NIL)) NIL)) NIL) ((AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC3 0 (BUILDCONTEXTPURE_TCC3-1 NIL 3646033320 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC2 0 (BUILDCONTEXTPURE_TCC2-1 NIL 3646033320 ("" (SKEEP* :PREDS? T) (("" (TYPEPRED "v(B)") (("" (GRIND) NIL NIL)) NIL)) NIL) ((AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CPURE? DEF-DECL "bool" IL NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL)) NIL))("IL" IL BUILDCONTEXTPURE_TCC1 0 (BUILDCONTEXTPURE_TCC1-1 NIL 3646033320 ("" (RECURSIVE-JUDGEMENT-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL)) NIL))("IL" IL PURE_CONTEXTPURE 0 (PURE_CONTEXTPURE-1 NIL 3646034299 ("" (INDUCT-AND-SIMPLIFY "A") NIL NIL) ((IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (PURE? DEF-DECL "bool" IL NIL) (CONTEXTPURE? DEF-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL PURE?_TCC4 0 (PURE?_TCC4-1 NIL 3693185170 ("" (SKEEP) (("" (REPLACE -1) (("" (GRIND) NIL NIL)) NIL)) NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC3 0 (PURE?_TCC3-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC2 0 (PURE?_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL PURE?_TCC1 0 (PURE?_TCC1-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXT_COMPOSITION 0 (CONTEXT_COMPOSITION-1 NIL 3646034275 ("" (INDUCT-AND-SIMPLIFY "K1") NIL NIL) ((ICONTEXT TYPE-DECL NIL IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (FILL DEF-DECL "IExpression" IL NIL) (COMPOSE DEF-DECL "IContext" IL NIL) (ICONTEXT_INDUCTION FORMULA-DECL NIL IL NIL)) SHOSTAK))("IL" IL BUILDCONTEXT_TCC5 0 (BUILDCONTEXT_TCC5-1 NIL 3646033320 ("" (GRIND) NIL NIL) ((FILL DEF-DECL "IExpression" IL NIL)) NIL))("IL" IL BUILDCONTEXT_TCC4 0 (BUILDCONTEXT_TCC4-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC3 0 (BUILDCONTEXT_TCC3-1 NIL 3646033320 ("" (SKOSIMP*) (("" (EXPAND "fill" +) (("" (TYPEPRED "v!1(B!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((FILL DEF-DECL "IExpression" IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC2 0 (BUILDCONTEXT_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL BUILDCONTEXT_TCC1 0 (BUILDCONTEXT_TCC1-1 NIL 3646033320 ("" (SKOSIMP*) (("" (EXPAND "fill" +) (("" (TYPEPRED "v!1(B!1)") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((FILL DEF-DECL "IExpression" IL NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (NOT CONST-DECL "[bool -> bool]" BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (STRICT_WELL_FOUNDED? CONST-DECL "bool" ORDERS NIL) (<< ADT-DEF-DECL "(strict_well_founded?[IExpression])" IEXPRESSION_ADT NIL)) NIL))("IL" IL CONTEXT_LEMMA 0 (CONTEXT_LEMMA-1 NIL 3646034052 ("" (INDUCT "A") (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL) ("4" (SKEEP) (("4" (INST + "hole" "application(application1_var, application2_var)") (("4" (GRIND) NIL NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (GROUND) (("1" (INST + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (INST + "hole" "letexpr(letexpr1_var, letexpr2_var)") (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (INST + "letc(K, letexpr2_var)" "B") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (INST + "letc(K!1, letexpr2_var)" "B!1") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (INST + "hole" "ift(ift1_var, ift2_var, ift3_var)") (("6" (GRIND) NIL NIL)) NIL)) NIL) ("7" (SKEEP) (("7" (INST + "hole" "update(update1_var, update2_var, update3_var)") (("7" (GRIND) NIL NIL)) NIL)) NIL) ("8" (SKEEP) (("8" (INST + "hole" "lookup(lookup1_var, lookup2_var)") (("8" (GRIND) NIL NIL)) NIL)) NIL) ("9" (SKEEP) (("9" (INST + "hole" "newint(newint1_var)") (("9" (GRIND) NIL NIL)) NIL)) NIL) ("10" (SKEEP) (("10" (INST + "hole" "newref(newref1_var)") (("10" (GRIND) NIL NIL)) NIL)) NIL) ("11" (SKEEP) (("11" (GROUND) (("1" (INST + "hole" "pop(pop1_var)") (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (INST + "popc(K)" "B") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("12" (SKEEP) (("12" (INST + "hole" "ref(ref1_var)") (("12" (GRIND) NIL NIL)) NIL)) NIL) ("13" (SKEEP) (("13" (INST + "hole" "release(release1_var, release2_var)") (("13" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((RELEASE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (RELEASE ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression] -> (release?)]" IEXPRESSION_ADT NIL) (REF ADT-CONSTRUCTOR-DECL "[nat -> (ref?)]" IEXPRESSION_ADT NIL) (REF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (POPC? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (POPC ADT-CONSTRUCTOR-DECL "[IContext -> (popc?)]" IL NIL) (POP ADT-CONSTRUCTOR-DECL "[IExpression -> (pop?)]" IEXPRESSION_ADT NIL) (POP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NEWREF ADT-CONSTRUCTOR-DECL "[nat -> (newref?)]" IEXPRESSION_ADT NIL) (NEWREF? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (NEWINT ADT-CONSTRUCTOR-DECL "[nat -> (newint?)]" IEXPRESSION_ADT NIL) (NEWINT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LOOKUP? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (LOOKUP ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?)] -> (lookup?)]" IEXPRESSION_ADT NIL) (UPDATE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (UPDATE ADT-CONSTRUCTOR-DECL "[[(variable?), (variable?), (variable?)] -> (update?)]" IEXPRESSION_ADT NIL) (IFT? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (IFT ADT-CONSTRUCTOR-DECL "[[(variable?), IExpression, IExpression] -> (ift?)]" IEXPRESSION_ADT NIL) (LETC? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (LETC ADT-CONSTRUCTOR-DECL "[[IContext, IExpression] -> (letc?)]" IL NIL) (LETEXPR ADT-CONSTRUCTOR-DECL "[[IExpression, IExpression] -> (letexpr?)]" IEXPRESSION_ADT NIL) (LETEXPR? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (APPLICATION ADT-CONSTRUCTOR-DECL "[[nat, list[(variable?)]] -> (application?)]" IEXPRESSION_ADT NIL) (APPLICATION? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (VARIABLE? ADT-RECOGNIZER-DECL "[IExpression -> boolean]" IEXPRESSION_ADT NIL) (EVERY ADT-DEF-DECL "boolean" LIST_ADT NIL) (PRED TYPE-EQ-DECL NIL DEFINED_TYPES NIL) (LIST TYPE-DECL NIL LIST_ADT NIL) (NAT NONEMPTY-TYPE-EQ-DECL NIL NATURALNUMBERS NIL) (>= CONST-DECL "bool" REALS NIL) (INT NONEMPTY-TYPE-EQ-DECL NIL INTEGERS NIL) (INTEGER_PRED CONST-DECL "[rational -> boolean]" INTEGERS NIL) (RATIONAL NONEMPTY-TYPE-FROM-DECL NIL RATIONALS NIL) (RATIONAL_PRED CONST-DECL "[real -> boolean]" RATIONALS NIL) (REAL NONEMPTY-TYPE-FROM-DECL NIL REALS NIL) (REAL_PRED CONST-DECL "[number_field -> boolean]" REALS NIL) (NUMBER_FIELD NONEMPTY-TYPE-FROM-DECL NIL NUMBER_FIELDS NIL) (NUMBER_FIELD_PRED CONST-DECL "[number -> boolean]" NUMBER_FIELDS NIL) (NUMBER NONEMPTY-TYPE-DECL NIL NUMBERS NIL) (HOLE ADT-CONSTRUCTOR-DECL "(hole?)" IL NIL) (HOLE? ADT-RECOGNIZER-DECL "[IContext -> boolean]" IL NIL) (RELEASEREDEX? CONST-DECL "bool" IL NIL) (POPREDEX? CONST-DECL "bool" IL NIL) (NEWREFREDEX? CONST-DECL "bool" IL NIL) (NEWINTREDEX? CONST-DECL "bool" IL NIL) (LOOKUPREDEX? CONST-DECL "bool" IL NIL) (UPDATEREDEX? CONST-DECL "bool" IL NIL) (IFTREDEX? CONST-DECL "bool" IL NIL) (APPLYREDEX? CONST-DECL "bool" IL NIL) (LETREDEX? CONST-DECL "bool" IL NIL) (VALUE? CONST-DECL "bool" IL NIL) (IEXPRESSION_INDUCTION FORMULA-DECL NIL IEXPRESSION_ADT NIL) (FILL DEF-DECL "IExpression" IL NIL) (= CONST-DECL "[T, T -> boolean]" EQUALITIES NIL) (REDEX? CONST-DECL "bool" IL NIL) (AND CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (ICONTEXT TYPE-DECL NIL IL NIL) (ATOM? CONST-DECL "bool" IL NIL) (OR CONST-DECL "[bool, bool -> bool]" BOOLEANS NIL) (BOOL NONEMPTY-TYPE-EQ-DECL NIL BOOLEANS NIL) (BOOLEAN NONEMPTY-TYPE-DECL NIL BOOLEANS NIL) (IEXPRESSION TYPE-DECL NIL IEXPRESSION_ADT NIL)) SHOSTAK))("IL" IL FILL_TCC2 0 (FILL_TCC2-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IContext])" IL NIL)) NIL))("IL" IL FILL_TCC1 0 (FILL_TCC1-1 NIL 3646033320 ("" (TERMINATION-TCC) NIL NIL) ((<< ADT-DEF-DECL "(strict_well_founded?[IContext])" IL NIL)) NIL))("rreduction" rreduction lookupReduce_TCC13 0 (lookupReduce_TCC13-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction lookupReduce_TCC12 0 (lookupReduce_TCC12-1 nil 3696570131 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction lookupReduce_TCC11 0 (lookupReduce_TCC11-1 nil 3696570131 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction lookupReduce_TCC10 0 (lookupReduce_TCC10-1 nil 3696570131 ("" (skeep* :preds? t) (("" (ground) (("1" (typepred "grS`count(avalindex)") (("1" (expand "refcount") (("1" (expand "refcountStack") (("1" (use "count_elem[(IL.value?)]") (("1" (ground) (("1" (inst + "stack`length - 1 - index(avar)") (("1" (assert) (("1" (expand "get") (("1" (assert) nil nil)) nil)) nil) ("2" (use "lookupReduce_TCC7") (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst - "pos") (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "refcount") (("2" (expand "refcountStack") (("2" (rewrite "count_update") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "grS`count(avalindex)") (("1" (expand "refcount") (("1" (expand "refcountStack") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil))("rreduction" rreduction lookupReduce_TCC9 0 (lookupReduce_TCC9-1 nil 3696570131 ("" (skeep* :preds? t) (("" (use "reduction.lookupReduce_TCC6") (("" (inst - "rstate2estate(grS)" "stack") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst - "pos") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (ground) (("1" (lazy-grind) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lazy-grind) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind :if-match nil) nil nil)) nil) ("3" (hide 3) (("3" (grind :if-match nil) nil nil)) nil)) nil)) nil)) nil) ((lookupReduce_TCC6 subtype-tcc nil reduction nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (get const-decl "(value?)" IL nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (markv const-decl "(variable?)" preprocess nil) (constant? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (value adt-accessor-decl "[(constant?) -> int]" IExpression_adt nil) (position adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (finite_emptyset name-judgement "finite_set[nat]" countability "sets_aux/") (finite_emptyset name-judgement "finite_set[T]" sigma_set "sigma_set/") (finite_emptyset name-judgement "finite_set[T]" countable_props "sets_aux/") (finite_emptyset name-judgement "finite_set" finite_sets nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (arrayvalue adt-accessor-decl "[(lookup?) -> (variable?)]" IExpression_adt nil) (lookup? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (store skolem-const-decl "Store(grS`domain)" rreduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (mark def-decl "IExpression" preprocess nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (estate type-eq-decl nil reduction nil) (rstate2estate const-decl "estate" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (lookupRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | lookupRedex?(grS`redex)}" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction lookupReduce_TCC8 0 (lookupReduce_TCC8-1 nil 3696570131 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction ifReduce_TCC8 0 (ifReduce_TCC8-1 nil 3696194804 ("" (skeep* :preds? t) (("" (typepred "grS`count(x1)") (("" (expand "refcount") (("" (expand "pureIftRedex?") (("" (expand "iftRedex?") (("" (ground) (("" (expand "refcountExpr") (("" (rewrite "pure_refs") (("1" (rewrite "pure_refs") nil nil) ("2" (expand "pure?" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pureIftRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (pure_refs formula-decl nil IL nil) (pure? def-decl "bool" IL nil) (refcountExpr const-decl "nat" rreduction nil) (iftRedex? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction ifReduce_TCC7 0 (ifReduce_TCC7-1 nil 3696194804 ("" (skeep* :preds? t) (("" (use "reduction.ifReduce_TCC4") (("" (inst - "rstate2estate(grS)" "stack") (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst?) (("1" (split) (("1" (inst - "thenexpr") (("1" (split) (("1" (inst?) (("1" (split) (("1" (ground) (("1" (lazy-grind :rewrites "purePopDepth") nil nil) ("2" (lazy-grind :rewrites "purePopDepth") nil nil) ("3" (grind :rewrites "purePopDepth" :if-match nil) nil nil) ("4" (expand "pureIftRedex?") (("4" (expand "iftRedex?") (("4" (ground) (("4" (expand "mark" -) (("4" (decompose-equality -) (("4" (replace -22) (("4" (replace -2 :dir RL) (("4" (rewrite "mark_release_set") (("1" (rewrite "mark_idem") nil nil) ("2" (hide-all-but 1) (("2" (grind :rewrites "vars_mark") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (inst -12 "i") (("5" (ground) (("5" (expand "pureIftRedex?") (("5" (expand "iftRedex?") (("5" (ground) (("5" (expand "mark" -) (("5" (decompose-equality -) (("5" (replace -23) (("5" (replace -2 :dir RL) (("5" (rewrite "vars_release_set") (("5" (hide-all-but (-1 -4 -22 2 3 5)) (("5" (grind :rewrites "vars_mark") (("5" (replace -1 :dir RL) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 5) (("2" (grind) nil nil)) nil) ("3" (hide 5) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((ifReduce_TCC4 subtype-tcc nil reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_release_set formula-decl nil preprocess nil) (add const-decl "(nonempty?)" sets nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (difference const-decl "set" sets nil) (release_set def-decl "IExpression" preprocess nil) (elseexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (thenexpr adt-accessor-decl "[(ift?) -> IExpression]" IExpression_adt nil) (union const-decl "set" sets nil) (markv const-decl "(variable?)" preprocess nil) (ift adt-constructor-decl "[[(variable?), IExpression, IExpression] -> (ift?)]" IExpression_adt nil) (condition adt-accessor-decl "[(ift?) -> (variable?)]" IExpression_adt nil) (ift? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (finite_difference application-judgement "finite_set[nat]" countability "sets_aux/") (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (finite_intersection1 application-judgement "finite_set[nat]" countability "sets_aux/") (vars_mark formula-decl nil preprocess nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (mark_idem formula-decl nil preprocess nil) (mark_release_set formula-decl nil preprocess nil) (iftRedex? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (expr skolem-const-decl "{A |
        forall i: refs(A)(i) IMPLIES grS`domain(i)
    AND forall i: vars(A)(i) IMPLIES i + popDepth(A) < grS`stack`length
    AND popDepth(A) <= grS`stack`length AND contextPure?(A)
    AND mark(grS`contextvars)(A) = A
    AND forall i:
          i >= grS`stack`length OR
           vars(A)(i) OR
            grS`contextvars(i) OR
             NOT ref?(grS`stack`seq(grS`stack`length - 1 - i))}" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (store skolem-const-decl "Store(grS`domain)" rreduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (stack skolem-const-decl "{S: Stack | every(domainValue?(grS`domain))(S)}" rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (mark def-decl "IExpression" preprocess nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (estate type-eq-decl nil reduction nil) (rstate2estate const-decl "estate" rreduction nil) (goodrstate type-eq-decl nil rreduction nil) (pureIftRedex? const-decl "bool" IL nil) (grS skolem-const-decl "{grS | pureIftRedex?(grS`redex)}" rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction allcount_TCC2 0 (allcount_TCC2-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("rreduction" rreduction allcount_TCC1 0 (allcount_TCC1-1 nil 3684597206 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("rreduction" rreduction refcountStore_TCC2 0 (refcountStore_TCC2-1 nil 3650675711 ("" (skeep) (("" (postpone) nil nil)) nil) ((empty_card formula-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("rreduction" rreduction refcountStore_TCC1 0 (refcountStore_TCC1-1 nil 3650675711 ("" (skeep :preds? t) (("" (expand "convergent?") (("" (ground) (("1" (use "finite_countable") (("1" (case "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (forward-chain "countable_subset[(dom)]") nil nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "convergent?") (("2" (flatten) (("2" (hide 2) (("2" (case "subset?[(dom)](nonzero_elts(lambda (j: (dom)): refcountArray(R(j))(i),
                                restrict[nat, (dom), boolean](dom)), dom)") (("1" (forward-chain "finite_subset[(dom)]") nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((convergent? const-decl "bool" convergence_set "sigma_set/") (convergent? const-decl "bool" countable_convergence "sigma_set/") (finite_subset formula-decl nil finite_sets nil) (finite_countable judgement-tcc nil countable_props "sets_aux/") (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (count const-decl "nat" finseq_theorems nil) (countable_subset formula-decl nil countability "sets_aux/") (is_countable const-decl "bool" countability "sets_aux/") (countable_set nonempty-type-eq-decl nil countability "sets_aux/") (subset? const-decl "bool" sets nil) (nonzero_elts const-decl "set[T]" convergence_set "sigma_set/") (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (refcountArray const-decl "nat" rreduction nil) (domainValue? const-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (restrict const-decl "R" restrict nil) (finite_restrict application-judgement "finite_set[S]" restrict_set_props nil)) nil))("rreduction" rreduction check_marked_TCC7 0 (check_marked_TCC7-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction rstate_TCC1 0 (rstate_TCC1-1 nil 3693496106 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_noDangling 0 (decref_noDangling-1 nil 3698761544 ("" (postpone) nil nil) nil shostak))("preprocess" preprocess mark_TCC8 0 (mark_TCC8-1 nil 3683842373 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("preprocess" preprocess releaset_set_top_mark 0 (releaset_set_top_mark-1 nil 3698777829 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (grind) nil nil) ("12" (grind) nil nil) ("13" (grind) nil nil)) nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (difference const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_difference application-judgement "finite_set[nat]" countability "sets_aux/") (bump const-decl "finite_set[nat]" IL nil) (markv const-decl "(variable?)" preprocess nil) (IExpression_induction formula-decl nil IExpression_adt nil) (mark def-decl "IExpression" preprocess nil) (top_releases def-decl "nat" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("rreduction" rreduction lookupReduce_TCC8 0 (lookupReduce_TCC8-1 nil 3698757037 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_decompose_TCC1 0 (vars_decompose_TCC1-1 nil 3699041070 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("reduction" reduction popReduce_TCC6 0 (popReduce_TCC6-1 nil 3699115446 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction letReduce_TCC6 0 (letReduce_TCC6-1 nil 3699115446 ("" (subtype-tcc) nil nil) nil nil))("IL" IL vars_context_finite 0 (vars_context_finite-1 nil 3699126124 ("" (induct "K") (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction noDanglingRefs?_TCC2 0 (noDanglingRefs?_TCC2-1 nil 3699126721 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess mark_empty 0 (mark_empty-1 nil 3699192140 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (skeep*) (("4" (expand mark 1) (("4" (expand vars -2) (("4" (decompose-equality 1) (("4" (case-replace "application2_var = null") (("1" (grind) nil nil) ("2" (delete 2) (("2" (expand in_varlist -2) (("2" (expand some -2) (("2" (case-replace "application2_var = cons(car(application2_var), cdr(application2_var))") (("1" (simplify) (("1" (inst -3 "index(car(application2_var))") nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand mark 1) (("5" (expand vars -3) (("5" (expand union -3) (("5" (expand drop -3) (("5" (expand member -3) (("5" (decompose-equality 1) (("1" (rewrite vars_mark) (("1" (expand vars 1 3) (("1" (expand drop 1 2) (("1" (expand add 1) (("1" (expand drop 1 1) (("1" (expand member 1) (("1" (rewrite vars_mark) (("1" (simplify) (("1" (expand drop) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction mark_letApply_cons_TCC4 0 (mark_letApply_cons_TCC4-1 nil 3699212334 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction mark_letApply_cons_TCC3 0 (mark_letApply_cons_TCC3-1 nil 3699212334 ("" (subtype-tcc) nil nil) ((in_varlist const-decl "finite_set[nat]" IL nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("rreduction" rreduction updateReduce_TCC55 0 (updateReduce_TCC55-1 nil 3699381161 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction check_marked_TCC7 0 (check_marked_TCC7-1 nil 3698762473 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC6 0 (check_marked_TCC6-1 nil 3698692883 ("" (skeep*) (("" (ground) (("1" (typepred "rS`count(refindex(vx))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountStack) (("1" (lemma "finseq_theorems[(IL.value?)].count_elem") (("1" (inst?) (("1" (inst?) (("1" (ground) (("1" (expand get) (("1" (inst 1 "stack`length - 1 - index(x)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(refindex(vx))") (("2" (rewrite -1) (("2" (expand refcount) (("2" (expand refcountStack) (("2" (use "finseq_theorems[(IL.value?)].count_update") (("1" (rewrite -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil))("rreduction" rreduction check_marked_TCC5 0 (check_marked_TCC5-1 nil 3698692883 ("" (skeep*) (("" (expand refcount) (("" (typepred "rS`count(refindex(vx))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (split) (("1" (expand refcountStack) (("1" (use "finseq_theorems[(IL.value?)].count_elem") (("1" (ground) (("1" (inst 1 "rS`stack`length - 1 - index(x)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand refcountStack) (("2" (rewrite "finseq_theorems[(IL.value?)].count_update") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (typepred "rS`stack") (("2" (grind) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (refcount const-decl "nat" rreduction nil) (count_elem formula-decl nil finseq_theorems nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (get const-decl "(value?)" IL nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (count_update formula-decl nil finseq_theorems nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (rstate type-eq-decl nil rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction check_marked_TCC4 0 (check_marked_TCC4-1 nil 3698692883 ("" (skeep* :preds? t) (("" (ground) (("" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC3 0 (check_marked_TCC3-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((get const-decl "(value?)" IL nil) (value? const-decl "bool" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC2 0 (check_marked_TCC2-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (get const-decl "(value?)" IL nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction check_marked_TCC1 0 (check_marked_TCC1-1 nil 3698692883 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("rreduction" rreduction updateReduce_ndr 0 (updateReduce_ndr-1 nil 3699648459 ("" (judgement-tcc) nil nil) nil nil))("rreduction" rreduction reduce_wfStore 0 (reduce_wfStore-1 nil 3699730151 ("" (skeep* :preds? t) (("" (simplify) (("" (ground) (("" (ground) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("rreduction" rreduction update_wfStore 0 (update_wfStore-1 nil 3699730594 ("" (skeep* :preds? t) (("" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction update_wfStore_TCC1 0 (update_wfStore_TCC1-1 nil 3699730594 ("" (subtype-tcc) nil nil) nil nil))("preprocess" preprocess cvars_TCC1 0 (cvars_TCC1-1 nil 3683843116 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))("preprocess" preprocess markc_TCC2 0 (markc_TCC2-1 nil 3655657330 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IContext])" IL nil)) nil))("preprocess" preprocess markc_TCC1 0 (markc_TCC1-1 nil 3655657330 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (<< adt-def-decl "(strict_well_founded?[IContext])" IL nil) (injective? const-decl "bool" functions nil) (bump const-decl "finite_set[nat]" IL nil)) nil))("reduction_props" reduction_props testlemma 0 (testlemma-1 nil 3699903711 ("" (postpone) nil nil) nil shostak))("reduction_props" reduction_props translate_refs_restrict_TCC4 0 (translate_refs_restrict_TCC4-1 nil 3699908338 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props stack_stillmatch_TCC8 0 (stack_stillmatch_TCC8-1 nil 3699975962 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props top_releases_reduce_TCC1 0 (top_releases_reduce_TCC1-1 nil 3699900445 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props release_marked_match_TCC7 0 (release_marked_match_TCC7-1 nil 3700234159 ("" (grind) nil nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props release_marked_match_TCC6 0 (release_marked_match_TCC6-1 nil 3700234159 ("" (with-labels (skeep* :preds? t) ((x2pos xvar sl_index markh stm tsr obj))) (("" (expand release_marked) (("" (simplify) (("" (propax) nil nil)) nil)) nil)) nil) ((release_marked const-decl "rstate" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props release_marked_match_TCC5 0 (release_marked_match_TCC5-1 nil 3700234159 ("" (grind) nil nil) ((variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (member const-decl "bool" sets nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props release_marked_match_TCC4 0 (release_marked_match_TCC4-1 nil 3700234159 ("" (grind) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (state_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (stack_matches const-decl "boolean" reduction_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil)) nil))("reduction_props" reduction_props top_releases_ct_TCC3 0 (top_releases_ct_TCC3-1 nil 3699898987 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props top_releases_ct_TCC2 0 (top_releases_ct_TCC2-1 nil 3699898987 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction_props" reduction_props top_releases_ct_TCC1 0 (top_releases_ct_TCC1-1 nil 3699898987 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC8 0 (stack_stillmatch_TCC8-1 nil 3699980803 ("" (skeep* :preds? t) (("" (replace -3) (("" (use extend_finite) nil nil)) nil)) nil) ((extend_finite formula-decl nil reduction_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (pred type-eq-decl nil defined_types nil) (> const-decl "bool" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC7 0 (stack_stillmatch_TCC7-1 nil 3699975962 ("" (skeep* :preds? t) (("" (typepred "rS2`stack") (("" (expand every) (("" (expand domainValue?) (("" (skeep*) (("" (inst? -1) (("" (assert) (("" (replace -4) (("" (expand extend) (("" (typepred "rS2`count(refindex(rS2`stack`seq(i)))") (("" (replace -1) (("" (expand refcount) (("" (expand refcountStack) (("" (use "count_elem[(value?)]") (("" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (below type-eq-decl nil naturalnumbers nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (count_elem formula-decl nil finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (injective? const-decl "bool" functions nil) (stack_matches const-decl "boolean" reduction_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (estate type-eq-decl nil reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (refcountStack const-decl "nat" rreduction nil) (extend const-decl "R" extend nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC6 0 (stack_stillmatch_TCC6-1 nil 3699975962 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (stack_matches const-decl "boolean" reduction_props nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (extend const-decl "R" extend nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (estate type-eq-decl nil reduction nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC5 0 (stack_stillmatch_TCC5-1 nil 3699975962 ("" (skeep* :preds? t) (("" (use extend_finite) (("" (replace -3) (("" (propax) nil nil)) nil)) nil)) nil) ((extend_finite formula-decl nil reduction_props nil) (> const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC4 0 (stack_stillmatch_TCC4-1 nil 3699975962 ("" (skeep* :preds? t) (("" (typepred "rS`stack") (("" (expand every) (("" (skeep*) (("" (inst -1 i) (("" (expand domainValue?) (("" (flatten) (("" (assert) (("" (replace -3) (("" (expand extend) (("" (typepred "rS`count(refindex(rS`stack`seq(i)))") (("" (rewrite -1) (("" (expand refcount) (("" (expand refcountStack) (("" (use "count_elem[(value?)]") (("" (split -1) (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Stack type-eq-decl nil IL nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (extend const-decl "R" extend nil) (refcountStack const-decl "nat" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (injective? const-decl "bool" functions nil) (count_elem formula-decl nil finseq_theorems nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props stack_stillmatch_TCC3 0 (stack_stillmatch_TCC3-1 nil 3699975962 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch 0 (redex_stillmatch-1 nil 3699981686 ("" (skeep* :preds? t) (("" (simplify :let-reduce? t) (("" (skeep* :preds? t) (("" (lemma translate_refs_restrict) (("" (inst -1 "unmark(rS`redex)" "extend[nat, (rS`domain), bool, FALSE]
                         ({r: (rS`domain) | rS`count(r) > 0})" "eS`domain" "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})") (("" (split -1) (("1" (rewrite -1) (("1" (case-replace "translate2 = lambda (i:
                               (extend[nat, (rS2`domain), bool, FALSE]
                                    ({r: (rS2`domain) |
                                      rS2`count(r) > 0}))):
                       translate(i)") (("1" (grind) nil nil) ("2" (delete 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (grind) nil nil)) nil) ("3" (skeep* :preds? t) (("3" (rewrite unmark_refs) (("3" (case "rS2`domain(i)") (("1" (typepred "rS2`count(i)") (("1" (expand extend) (("1" (assert) (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountExpr) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (typepred "rS`redex") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (rewrite unmark_contextPure) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (IExpression type-decl nil IExpression_adt nil) (unmark def-decl "IExpression" preprocess nil) (IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (> const-decl "bool" reals nil) (estate type-eq-decl nil reduction nil) (unmark_contextPure recursive-judgement-axiom nil preprocess nil) (refcountExpr const-decl "nat" rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (unmark_refs formula-decl nil preprocess nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (translate_refs_restrict formula-decl nil reduction_props nil)) shostak))("reduction_props" reduction_props redex_stillmatch_TCC6 0 (redex_stillmatch_TCC6-1 nil 3699975962 ("" (skeep* :preds? t) (("" (typepred "rS2`domain") (("" (expand is_finite) (("" (skeep*) (("" (inst 1 N "LAMBDA (x: (dom2)): f(x)") (("1" (expand injective?) (("1" (skeep*) (("1" (inst -1 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (extend const-decl "R" extend nil) (injective? const-decl "bool" functions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC5 0 (redex_stillmatch_TCC5-1 nil 3699975962 ("" (skeep* :preds? t) (("" (split 1) (("1" (rewrite unmark_contextPure) nil nil) ("2" (rewrite unmark_refs) (("2" (skeep) (("2" (typepred "rS2`redex") (("2" (inst -1 i) (("2" (replace -9) (("2" (expand extend) (("2" (assert) (("2" (typepred "rS2`count(i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (contextPure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (unmark_contextPure recursive-judgement-axiom nil preprocess nil) (extend const-decl "R" extend nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (unmark_refs formula-decl nil preprocess nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC4 0 (redex_stillmatch_TCC4-1 nil 3699975962 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (extend const-decl "R" extend nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC3 0 (redex_stillmatch_TCC3-1 nil 3699975962 ("" (skeep* :preds? t) (("" (expand is_finite) (("" (typepred "rS`domain") (("" (expand is_finite) (("" (skeep) (("" (inst 1 N "LAMBDA (x: (dom)): f(x)") (("1" (expand injective?) (("1" (skeep) (("1" (inst -1 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (extend const-decl "R" extend nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC2 0 (redex_stillmatch_TCC2-1 nil 3699975962 ("" (skeep* :preds? t) (("" (split) (("1" (rewrite unmark_contextPure) nil nil) ("2" (skeep*) (("2" (rewrite unmark_refs) (("2" (typepred "rS`redex") (("2" (inst -1 i) (("2" (replace -8) (("2" (expand extend) (("2" (assert) (("2" (typepred "rS`count(i)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (contextPure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (unmark_contextPure recursive-judgement-axiom nil preprocess nil) (unmark_refs formula-decl nil preprocess nil) (extend const-decl "R" extend nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props redex_stillmatch_TCC1 0 (redex_stillmatch_TCC1-1 nil 3699975962 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props extend_finite 0 (extend_finite-1 nil 3699992903 ("" (skeep* :preds? t) (("" (expand is_finite) (("" (skeep*) (("" (inst 1 N "LAMBDA (x: (extend[nat, (dom), bool, FALSE]
                      ({r: (dom) | dom_pred(r)}))): f(x)") (("1" (expand injective?) (("1" (skeep* :preds? t) (("1" (inst -3 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (pred type-eq-decl nil defined_types nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (injective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("reduction_props" reduction_props state_matches_TCC6 0 (state_matches_TCC6-1 nil 3699884471 ("" (skeep* :preds? t) (("" (typepred "rS`store(r1)`seq(x1)") (("" (expand domainValue?) (("" (ground) (("" (replace -9) (("" (expand extend) (("" (match 1 "rS`count(%1)" 1 step (typepred "rS`count(%1)")) (("" (rewrite -1) (("" (expand refcount) (("" (use refcountStore_ref) (("" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (member const-decl "bool" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (union const-decl "set" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (count def-decl "nat" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (head const-decl "T" finseq_theorems nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (stack_matches const-decl "boolean" reduction_props nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (extend const-decl "R" extend nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props state_matches_TCC5 0 (state_matches_TCC5-1 nil 3699880315 ("" (subtype-tcc) nil nil) ((member const-decl "bool" sets nil) (bumpn const-decl "finite_set[nat]" IL nil) (union const-decl "set" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (stack_matches const-decl "boolean" reduction_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IExpression type-decl nil IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (extend const-decl "R" extend nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props state_matches_TCC4 0 (state_matches_TCC4-1 nil 3699880315 ("" (skeep* :preds? t) (("" (typepred "rS`stack") (("" (expand every) (("" (skeep* :preds? t) (("" (inst -2 i) (("" (expand domainValue?) (("" (ground) (("" (typepred "rS`count(refindex(rS`stack`seq(i)))") (("" (expand refcount) (("" (expand refcountStack) (("" (use "finseq_theorems[(value?)].count_elem") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (count_elem formula-decl nil finseq_theorems nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (head const-decl "T" finseq_theorems nil) (tail const-decl "finseq[T]" finseq_theorems nil) (finseqtolist def-decl "list[T]" finseq_theorems nil) (count def-decl "nat" finseq_theorems nil) (count const-decl "nat" finseq_theorems nil) (refcountExpr const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (extend const-decl "R" extend nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refcountStack const-decl "nat" rreduction nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (domainValue? const-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (Stack type-eq-decl nil IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props state_matches_TCC3 0 (state_matches_TCC3-1 nil 3699880315 ("" (skeep* :preds? t) (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (extend const-decl "R" extend nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("reduction_props" reduction_props state_matches_TCC2 0 (state_matches_TCC2-1 nil 3699880315 ("" (skeep* :preds? t) (("" (typepred "rS`domain") (("" (expand is_finite) (("" (skeep*) (("" (inst 1 "N" "LAMBDA (x: (dom)): f(x)") (("1" (expand injective?) (("1" (skeep*) (("1" (inst -1 x1 x2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (injective? const-decl "bool" functions nil) (extend const-decl "R" extend nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props state_matches_TCC1 0 (state_matches_TCC1-1 nil 3699880315 ("" (skeep* :preds? t) (("" (typepred "rS`redex") (("" (split) (("1" (grind) nil nil) ("2" (rewrite unmark_refs) (("2" (skeep*) (("2" (replace -9) (("2" (simplify) (("2" (expand extend) (("2" (simplify) (("2" (split) (("1" (flatten) (("1" (typepred "rS`count(i)") (("1" (rewrite -1) (("1" (expand refcount) (("1" (expand refcountExpr) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (refcountExpr const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountStack const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (extend const-decl "R" extend nil) (unmark_refs formula-decl nil preprocess nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil)) nil))("reduction_props" reduction_props store_matches_TCC2 0 (store_matches_TCC2-1 nil 3699881750 ("" (subtype-tcc) nil nil) ((< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (finseq type-eq-decl nil finite_sequences nil) (Store type-eq-decl nil reduction nil) (below type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props stack_matches_TCC3 0 (stack_matches_TCC3-1 nil 3699880315 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (Stack type-eq-decl nil IL nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_restrict2 0 (translate_refs_restrict2-1 nil 3700248597 ("" (skeep*) (("" (lemma translate_refs_restrict) (("" (inst -1 A dom dom1 dom2) (("" (split -1) (("1" (rewrite -1) (("1" (case-replace "translation2 = lambda (i: (dom2)): translation(i)") (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil) ((translate_refs_restrict formula-decl nil reduction_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil)) shostak))("reduction_props" reduction_props translate_refs_restrict 0 (translate_refs_restrict-1 nil 3699908338 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (skeep* :preds? t) (("5" (expand translate_refs 1) (("5" (inst -4 dom dom1 dom2) (("5" (inst -5 dom dom1 dom2) (("5" (split -4) (("1" (split -5) (("1" (rewrite -1) (("1" (rewrite -2) nil nil)) nil) ("2" (propax) nil nil) ("3" (skeep) (("3" (rewrite pure_refs) (("3" (grind) nil nil)) nil)) nil) ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep* :preds? t) (("6" (expand translate_refs 1) (("6" (inst -6 dom dom1 dom2) (("6" (inst -7 dom dom1 dom2) (("6" (split -6) (("1" (split -7) (("1" (rewrite -1) (("1" (rewrite -2) nil nil)) nil) ("2" (propax) nil nil) ("3" (expand refs -8) (("3" (delete 2) (("3" (delete -6) (("3" (skeep*) (("3" (inst? -8) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (skeep*) (("3" (inst -9 i) (("3" (grind) nil nil)) nil)) nil) ("4" (use pure_contextPure) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (grind) nil nil) ("8" (grind) nil nil) ("9" (grind) nil nil) ("10" (grind) nil nil) ("11" (skeep* :preds? t) (("11" (expand translate_refs 1) (("11" (inst -4 dom dom1 dom2) (("11" (split -4) (("1" (rewrite -1) nil nil) ("2" (propax) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("12" (grind) nil nil) ("13" (skeep* :preds? t) (("13" (expand translate_refs 1) (("13" (inst -6 dom dom1 dom2) (("13" (split -6) (("1" (grind) nil nil) ("2" (propax) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("14" (grind) nil nil) ("15" (grind) nil nil) ("16" (delete 2) (("16" (skeep* :preds? t) (("16" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (inst? -5) (("2" (inst? -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((contextPure? def-decl "bool" IL nil) (refs def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IExpression type-decl nil IExpression_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (translate_refs def-decl "IExpression" reduction_props nil) (IExpression_induction formula-decl nil IExpression_adt nil) (pure_refs formula-decl nil IL nil) (injective? const-decl "bool" functions nil) (pure_contextPure formula-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak))("reduction_props" reduction_props translate_refs_restrict_TCC3 0 (translate_refs_restrict_TCC3-1 nil 3699908338 ("" (subtype-tcc) nil nil) ((injective? const-decl "bool" functions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_restrict_TCC2 0 (translate_refs_restrict_TCC2-1 nil 3699908338 ("" (subtype-tcc) nil nil) ((finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_restrict_TCC1 0 (translate_refs_restrict_TCC1-1 nil 3699908338 ("" (skeep* :preds? t) (("" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (inst?) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil)) nil))("reduction_props" reduction_props translate_refs_TCC13 0 (translate_refs_TCC13-1 nil 3699971591 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_TCC12 0 (translate_refs_TCC12-1 nil 3699971591 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((contextPure? def-decl "bool" IL nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (refs def-decl "bool" IL nil)) nil))("reduction_props" reduction_props translate_refs_TCC11 0 (translate_refs_TCC11-1 nil 3699880315 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_TCC10 0 (translate_refs_TCC10-1 nil 3699880315 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((refs def-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (contextPure? def-decl "bool" IL nil)) nil))("reduction_props" reduction_props translate_refs_TCC9 0 (translate_refs_TCC9-1 nil 3699880315 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props translate_refs_TCC8 0 (translate_refs_TCC8-1 nil 3699880315 ("" (skeep* :preds? t) (("" (split 1) (("1" (use pure_contextPure) (("1" (grind) nil nil)) nil) ("2" (use pure_refs) (("2" (grind) nil nil)) nil)) nil)) nil) ((pure_refs formula-decl nil IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (pure_contextPure formula-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (refs def-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (contextPure? def-decl "bool" IL nil)) nil))("reduction_props" reduction_props translate_refs_TCC7 0 (translate_refs_TCC7-1 nil 3699880315 ("" (termination-tcc) nil nil) ((injective? const-decl "bool" functions nil) (<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (contextPure? def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props rupdate_wfStore 0 (rupdate_wfStore-1 nil 3699793059 ("" (with-labels (skeep* :preds? t) ((grds_err grds_ndr grds_upd grds_wfs red_wfs))) (("" (expand updateReduce :assert? nil) (("" (simplify :let-reduce? nil) (("" (with-labels (split red_wfs) ((red_wfs) (red_wfs))) (("1" (with-labels (flatten) ((ref_target lhs_constant lhs_ge_0 lhs_lt_length red_wfs))) (("1" (with-labels (split red_wfs) ((red_wfs) (red_wfs))) (("1" (with-labels (flatten) ((copy_hyp red_wfs))) (("1" (expand has_wfStore?) (("1" (use wfStore_add) (("1" (grind) nil nil) ("2" (typepred "grdS`stack") (("2" (hide (red_wfs grds_wfs copy_hyp)) (("2" (case "index(rhs(grdS`redex)) < grdS`stack`length") (("1" (grind) nil nil) ("2" (typepred "grdS`redex") (("2" (inst -2 "index(rhs(grdS`redex))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (with-labels (flatten) ((refcnt_1 target_marked rval_not_aval red_upd))) (("2" (split red_upd) (("1" (with-labels (flatten) ((ref_old red_wft))) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props rupdate_wfStore_TCC1 0 (rupdate_wfStore_TCC1-1 nil 3699731469 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props wfStore_add 0 (wfStore_add-1 nil 3699813466 ("" (with-labels (skeep* :preds? t) ((dom_finite r_nat h_wf dom_r n_wf))) (("" (expand wfStore?) (("" (expand well_founded?) (("" (with-labels (skeep* n_wf :preds? t) ((dom_y p_y n_wf))) (("" (inst h_wf "LAMBDA (t: (dom)): p(t)") (("1" (with-labels (split h_wf) ((h_wf) (h_wf))) (("1" (with-labels (skolem h_wf "z" t) ((dom_z p_z h_wf))) (("1" (inst n_wf z) (("1" (skeep* 2) (("1" (inst h_wf x) (("1" (expand store_order) (("1" (simplify) (("1" (skeep* n_wf) (("1" (lift-if n_wf) (("1" (case "z = r") (("1" (grind) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand store_order) (("2" (skeep* n_wf) (("2" (lift-if n_wf) (("2" (case "z = r") (("1" (grind) nil nil) ("2" (assert) (("2" (typepred "store(z)`seq(k)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy h_wf) (("2" (inst 1 y) (("2" (case-replace "y = r") (("1" (inst n_wf r) (("1" (skeep n_wf :preds? t) (("1" (expand store_order) (("1" (skeep n_wf) (("1" (typepred "T`seq(k)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((wfStore? const-decl "bool" rreduction nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/") (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (Store type-eq-decl nil reduction nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (store_order const-decl "bool" rreduction nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (nonempty? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (well_founded? const-decl "bool" orders nil)) shostak))("reduction_props" reduction_props wfStore_add_TCC2 0 (wfStore_add_TCC2-1 nil 3699813392 ("" (skeep* :preds? t) (("" (typepred "T`seq(x1)") (("" (grind) nil nil)) nil)) nil) ((< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (domainValue? const-decl "bool" IL nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (wfStore? const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_add_finite application-judgement "non_empty_finite_set[nat]" countability "sets_aux/")) nil))("reduction_props" reduction_props wfStore_add_TCC1 0 (wfStore_add_TCC1-1 nil 3699813392 ("" (subtype-tcc) nil nil) ((add const-decl "(nonempty?)" sets nil) (wfStore? const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil)) nil))("reduction_props" reduction_props decref_has_wfStore 0 (decref_has_wfStore-1 nil 3699815730 ("" (skeep* :preds? t) (("" (expand has_wfStore?) (("" (use decref_wfStore) nil nil)) nil)) nil) ((has_wfStore? const-decl "bool" reduction_props nil) (decref_wfStore recursive-judgement-axiom nil reduction_props nil) (IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (wfStore? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak))("reduction_props" reduction_props decref_wfStore_TCC10 0 (decref_wfStore_TCC10-1 nil 3699731469 ("" (skeep* :preds? t) (("" (case-replace "newrS`store(r)`length = rS`store(r)`length") (("1" (grind) nil nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if) (("2" (ground) (("2" (replace -11) (("2" (simplify) (("2" (typepred " decref(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil) ("2" (delete 2) (("2" (grind) nil nil)) nil) ("3" (delete 2) (("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (split) (("1" (expand refcount) (("1" (use refcountStore_ref) (("1" (grind) nil nil)) nil)) nil) ("2" (expand refcount) (("2" (rewrite refcountStore_update) (("2" (delete 2) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (delete 3) (("3" (grind) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (wfStore? const-decl "bool" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refcountStore_update formula-decl nil rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC9 0 (decref_wfStore_TCC9-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (wfStore? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC8 0 (decref_wfStore_TCC8-1 nil 3699731469 ("" (skeep* :preds? t) (("" (split 2) (("1" (replace -10) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (replace -9) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -10) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (simplify) (("1" (ground) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC7 0 (decref_wfStore_TCC7-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC6 0 (decref_wfStore_TCC6-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC5 0 (decref_wfStore_TCC5-1 nil 3699731469 ("" (skeep* :preds? t) (("" (split) (("1" (expand noDanglingRefs?) (("1" (skeep* :preds? t) (("1" (inst -7 "i!1") (("1" (grind) nil nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -15) (("2" (simplify) (("2" (hide-all-but (-6 1 2 -8)) (("2" (expand wfStore?) (("2" (expand well_founded?) (("2" (skeep* :preds? t) (("2" (inst -3 p) (("2" (split -3) (("1" (skeep -1) (("1" (inst 1 "y!1") (("1" (skeep*) (("1" (inst -1 x) (("1" (expand store_order) (("1" (skeep -3 :preds? t) (("1" (inst 1 k) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pred type-eq-decl nil defined_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wfStore? const-decl "bool" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC4 0 (decref_wfStore_TCC4-1 nil 3699731469 ("" (skeep* :preds? t) (("" (replace -14) (("" (typepred "rS`count(subrefindex)") (("" (rewrite -1) (("" (expand refcount) (("" (use refcountStore_ref) (("1" (split 2) (("1" (split -1) (("1" (grind) nil nil) ("2" (delete 2) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (rewrite refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_order const-decl "bool" rreduction nil) (well_founded? const-decl "bool" orders nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (refcountStore_update formula-decl nil rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC3 0 (decref_wfStore_TCC3-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC2 0 (decref_wfStore_TCC2-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_wfStore_TCC1 0 (decref_wfStore_TCC1-1 nil 3699731469 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves rec-application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (well_founded? const-decl "bool" orders nil) (store_order const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (wfStore? const-decl "bool" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC11 0 (decref_preserves_TCC11-1 nil 3699733220 ("" (skeep* :preds? t) (("" (case-replace "rS`redex = newrS`redex") (("1" (case-replace "rS`stack = newrS`stack") (("1" (case-replace "rS`context = newrS`context") (("1" (case-replace "rS`error = newrS`error") (("1" (typepred "v(newrS, r, i-1)") (("1" (grind) nil nil) ("2" (case-replace "newrS`store(r)`length = rS`store(r)`length") (("1" (grind) nil nil) ("2" (delete 4) (("2" (replace -13) (("2" (delete 2) (("2" (lift-if) (("2" (ground) (("2" (replace -18) (("2" (simplify) (("2" (typepred "decref(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (delete 2) (("3" (expand refcount) (("3" (split 1) (("1" (use refcountStore_ref) (("1" (hide-all-but (1 2 -20 -1 -2)) (("1" (grind-with-ext) nil nil)) nil)) nil) ("2" (rewrite refcountStore_update) (("2" (hide-all-but (1 3 -19 -1)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "newrS`domain = rS`domain") (("3" (delete 2 3 4 5) (("3" (replace -13) (("3" (lift-if) (("3" (ground) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (delete 3) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil) ("2" (delete 3) (("2" (replace -12) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -11) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -9) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((IExpression type-decl nil IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (allcountStore const-decl "nat" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC10 0 (decref_preserves_TCC10-1 nil 3699733220 ("" (skeep* :preds? t) (("" (case-replace "newrS`store(r)`length = rS`store(r)`length") (("1" (grind) nil nil) ("2" (delete 3) (("2" (replace -9) (("2" (lift-if) (("2" (ground) (("2" (replace -10) (("2" (simplify) (("2" (typepred "decref(rS
               WITH [`store(r)`seq(i - 1) := nil,
                     `count(refindex(subref))
                       := rS`count(refindex(subref)) - 1],
             refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (delete 2) (("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (expand refcount) (("3" (split 1) (("1" (use refcountStore_ref) (("1" (grind-with-ext) nil nil)) nil) ("2" (use refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC9 0 (decref_preserves_TCC9-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC8 0 (decref_preserves_TCC8-1 nil 3699733220 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (skolem 2 "i1") (("" (inst -3 "i1") (("1" (case-replace "newrS`stack = rS`stack") (("1" (case-replace "newrS`redex = rS`redex") (("1" (case-replace "newrS`context = rS`context") (("1" (delete 3) (("1" (replace -11) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (simplify) (("1" (delete -12 -2 -3) (("1" (delete -4) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -10) (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (delete 3) (("2" (replace -9) (("2" (lift-if 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred i1) (("2" (case-replace "newrS`stack = rS`stack") (("2" (delete 4) (("2" (replace -9) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC7 0 (decref_preserves_TCC7-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC6 0 (decref_preserves_TCC6-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC5 0 (decref_preserves_TCC5-1 nil 3699733220 ("" (skeep* :preds? t) (("" (expand noDanglingRefs?) (("" (replace -14) (("" (simplify) (("" (assert) (("" (skeep) (("" (inst -5 "i_1") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC4 0 (decref_preserves_TCC4-1 nil 3699733220 ("" (skeep* :preds? t) (("" (replace -13) (("" (typepred "rS`count(subrefindex)") (("" (rewrite -1) (("" (expand refcount) (("" (split 2) (("1" (use refcountStore_ref) (("1" (grind-with-ext) nil nil) ("2" (grind) nil nil)) nil) ("2" (rewrite refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_preserves_TCC3 0 (decref_preserves_TCC3-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (domainValue? const-decl "bool" IL nil) (value? const-decl "bool" IL nil)) nil))("reduction_props" reduction_props decref_preserves_TCC2 0 (decref_preserves_TCC2-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_preserves_TCC1 0 (decref_preserves_TCC1-1 nil 3699733220 ("" (recursive-judgement-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_match_TCC13 0 (decref_match_TCC13-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (state_matches? const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (stack_matches const-decl "boolean" reduction_props nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props decref_match_TCC12 0 (decref_match_TCC12-1 nil 3699904294 ("" (skeep* :preds? t) (("" (typepred "v(newrS, r, i-1)") (("1" (inst -1 eS) (("1" (assert) (("1" (delete 3) (("1" (replace -9) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "v(rS
                         WITH [`store(r)`seq(i - 1) := nil,
                               `count(refindex(subref))
                                 := rS`count(refindex(subref)) - 1],
                       refindex(subref), rS`store(refindex(subref))`length)") (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (delete 2) (("2" (expand state_matches?) (("2" (skeep) (("2" (inst 1 "LAMBDA (k | rS`domain(k) AND rS`count(k) > (IF k = refindex(subref) THEN 1 ELSE 0 ENDIF)): translate(k)") (("1" (name "rS2" "rS
                      WITH [`store(r)`seq(i - 1) := nil,
                            `count(refindex(subref))
                              := rS`count(refindex(subref)) - 1]") (("1" (replace -1) (("1" (expand state_matches) (("1" (split) (("1" (grind) nil nil) ("2" (lemma redex_stillmatch) (("2" (inst -1 eS rS rS2) (("2" (simplify :let-reduce? t) (("2" (inst? -1) (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (flatten) nil nil) ("6" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 -1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (lemma stack_stillmatch) (("4" (inst -1 "union(cvars(rS`redex),
                               bumpn(cvars(rS`context),
                                     popDepth(rS`redex)))" eS rS rS2) (("4" (simplify :let-reduce? t) (("4" (inst -1 translate "lambda (k: nat
                                | rS`domain(k) AND
                                   rS`count(k) >
                                    (IF k = refindex(subref)
                                     THEN 1
                                     ELSE 0
                                     ENDIF)):
                      translate(k)") (("1" (split -1) (("1" (hide-all-but (1 -1 -2)) (("1" (replace -2 :dir RL) (("1" (simplify) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (typepred "rS`redex") (("4" (skolem 1 j) (("4" (split) (("1" (typepred j) (("1" (expand union) (("1" (expand member) (("1" (expand bumpn) (("1" (split -1) (("1" (lemma cvars_vars) (("1" (inst -1 "rS`redex" "j - popDepth(rS`redex)") (("1" (inst -4 "j - popDepth(rS`redex)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (lemma cvars_vars_ctx) (("2" (inst -1 "rS`context" "j - popDepth(rS`redex) - popDepth(rS`context)") (("1" (inst -5 "j - popDepth(rS`redex) - popDepth(rS`context)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("5" (replace -1 :dir RL) (("5" (grind) nil nil)) nil) ("6" (grind) nil nil) ("7" (grind) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (expand store_matches) (("5" (skeep* :preds? t) (("5" (case "r_2 = r") (("1" (case "rS2`count(r) = 0") (("1" (grind) nil nil) ("2" (replace -3 :dir RL) (("2" (delete 2) (("2" (lift-if) (("2" (simplify) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (case-replace "rS2`store(r_2) = rS`store(r_2)") (("1" (inst -18 r_2) (("1" (flatten) (("1" (split) (("1" (propax) nil nil) ("2" (skeep* :preds? t) (("2" (inst -20 j) (("1" (lemma translate_refs_restrict) (("1" (inst -1 "rS`store(r_2)`seq(j)" "extend[nat, (rS`domain), bool, FALSE]
                         ({r: (rS`domain) | rS`count(r) > 0})" "eS`domain" "extend[nat, (rS2`domain), bool, FALSE]
                         ({r: (rS2`domain) | rS2`count(r) > 0})") (("1" (split -1) (("1" (inst -1 translate) (("1" (case-replace "(lambda (k: nat
                                 | rS`domain(k) AND
                                    rS`count(k)
                                    >
                                    (IF k = refindex(subref)
                                     THEN 1
                                     ELSE 0
                                     ENDIF)):
                       translate(k)) = lambda (i:
                                (extend[nat, (rS2`domain), bool, FALSE]
                                     ({r: (rS2`domain) |
                                       rS2`count(r) > 0}))):
                        translate(i)") (("1" (grind) nil nil) ("2" (delete 2) (("2" (decompose-equality) (("1" (delete -1 -21) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (skeep* :preds? t) (("3" (typepred "rS`store(r_2)`seq(j)") (("3" (typepred "rS`count(i!1)") (("1" (expand refcount) (("1" (use refcountStore_ref) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (typepred "rS`store(r_2)`seq(j)") (("4" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (delete 3) (("2" (grind) nil nil)) nil) ("3" (delete 3) (("3" (grind) nil nil)) nil) ("4" (delete 3) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (split) (("1" (ground) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil) ("2" (ground) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred "rS`count(refindex(subref))") (("3" (rewrite -1) (("3" (delete 2) (("3" (expand refcount) (("3" (split) (("1" (use refcountStore_ref) (("1" (split -1) (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil)) nil)) nil) ("2" (rewrite refcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (refcountStore_update formula-decl nil rreduction nil) (state_matches const-decl "boolean" reduction_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (translate_refs def-decl "IExpression" reduction_props nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (refcountStore_ref formula-decl nil rreduction nil) (stack_stillmatch formula-decl nil reduction_props nil) (vars_mark_type application-judgement "{C | vars(C) = vars(B)}" preprocess nil) (member const-decl "bool" sets nil) (int_plus_int_is_int application-judgement "int" integers nil) (cvars_vars formula-decl nil preprocess nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (cvars_vars_ctx formula-decl nil preprocess nil) (union const-decl "set" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (bumpn const-decl "finite_set[nat]" IL nil) (store_matches const-decl "boolean" reduction_props nil) (stack_matches const-decl "boolean" reduction_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (finite_union application-judgement "finite_set[nat]" countability "sets_aux/") (IFF const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (mark def-decl "IExpression" preprocess nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (state_matches? const-decl "boolean" reduction_props nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil))("reduction_props" reduction_props decref_match_TCC11 0 (decref_match_TCC11-1 nil 3699904294 ("" (use decref_preserves_TCC10) (("" (skeep*) (("" (inst? -1) (("" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (replace -2) (("2" (beta) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC10 0 (decref_match_TCC10-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rS!1 skolem-const-decl "(noDanglingRefs?)" reduction_props nil) (r!1 skolem-const-decl "(rS!1`domain)" reduction_props nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC9 0 (decref_match_TCC9-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (rS!1 skolem-const-decl "(noDanglingRefs?)" reduction_props nil) (i!2 skolem-const-decl "below(newrS!1`stack`length)" reduction_props nil) (newrS!1 skolem-const-decl "rstate" reduction_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC8 0 (decref_match_TCC8-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (r!1 skolem-const-decl "(rS!1`domain)" reduction_props nil) (rS!1 skolem-const-decl "(noDanglingRefs?)" reduction_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC7 0 (decref_match_TCC7-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC6 0 (decref_match_TCC6-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC5 0 (decref_match_TCC5-1 nil 3699904294 ("" (use decref_preserves_TCC4) (("" (skeep*) (("" (inst? -1) (("" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (inst? -1) (("1" (split -1) (("1" (inst? -1) (("1" (grind) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((decref def-decl "{rS1 |
   allcountStore(rS1) <= allcountStore(rS) AND
    rS1`domain = rS`domain AND
     (forall (s: (rS`domain)):
        rS1`store(s)`length = rS`store(s)`length AND
         rS1`count(s) <= rS`count(s) AND
          (rS1`count(s) = 0 OR rS1`store(s) = rS`store(s)))
      AND noDanglingRefs?(rS1)}" rreduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (allcountStore const-decl "nat" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC4 0 (decref_match_TCC4-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC3 0 (decref_match_TCC3-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC2 0 (decref_match_TCC2-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (decref_preserves_jdg application-judgement "{rS2 |
   rS2`redex = rS`redex AND
    rS2`stack = rS`stack AND
     rS2`context = rS`context AND rS2`error = rS`error}" reduction_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props decref_match_TCC1 0 (decref_match_TCC1-1 nil 3699904294 ("" (recursive-judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props stack_set_test_TCC3 0 (stack_set_test_TCC3-1 nil 3700484430 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props stack_set_test_TCC2 0 (stack_set_test_TCC2-1 nil 3700484430 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props stack_set_test_TCC1 0 (stack_set_test_TCC1-1 nil 3700484430 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil)) nil))("rreduction" rreduction stack_update_correct_TCC1 0 (stack_update_correct_TCC1-1 nil 3700487299 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props subredex_stillmatch 0 (subredex_stillmatch-1 nil 3700482773 ("" (with-labels (skeep*) ((stm domeq storeeq stackeq countimp subref subvar depth2 depth obj))) (("" (expand state_matches) (("" (with-labels (flatten) ((err trr unm stam stom))) (("" (split obj) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props subredex_stillmatch_TCC2 0 (subredex_stillmatch_TCC2-1 nil 3700426643 ("" (subtype-tcc) nil nil) ((rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props subredex_stillmatch_TCC1 0 (subredex_stillmatch_TCC1-1 nil 3700426643 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (translate_refs_contextPure rec-application-judgement "(contextPure?)" reduction_props nil) (unmark_contextPure rec-application-judgement "(contextPure?)" preprocess nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props false_thm 0 (false_thm-1 nil 3700570379 ("" (lemma att_test) (("" (inst -1 "def(1)") (("" (grind) nil nil)) nil)) nil) ((test2 type-decl nil reduction_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (def? adt-recognizer-decl "[test2 -> boolean]" reduction_props nil) (def adt-constructor-decl "[nat -> (def?)]" reduction_props nil) (tttt const-decl "nat" reduction_props nil) (att_test formula-decl nil reduction_props nil)) shostak))("reduction_props" reduction_props att_test 0 (att_test-1 nil 3700570299 ("" (skeep* :preds? t) (("" (expand tttt) (("" (all-typepreds) (("" (grind) nil nil)) nil)) nil)) nil) ((tttt const-decl "nat" reduction_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (abc_var adt-accessor-decl "[(abc?) -> {i | i + 1 = i}]" reduction_props nil) (abc? adt-recognizer-decl "[test2 -> boolean]" reduction_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (def_var adt-accessor-decl "[(def?) -> nat]" reduction_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (def? adt-recognizer-decl "[test2 -> boolean]" reduction_props nil) (test2 type-decl nil reduction_props nil) (>= const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("reduction_props" reduction_props tttt_TCC1 0 (tttt_TCC1-1 nil 3700570299 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props test2_ord_defaxiom_TCC1 0 (test2_ord_defaxiom_TCC1-1 nil 3700570299 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_match_TCC2 0 (updateReduce_match_TCC2-1 nil 3700234159 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodstate type-eq-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (goodrstate type-eq-decl nil reduction_props nil) (updateRedex? const-decl "bool" IL nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (stack_matches const-decl "boolean" reduction_props nil) (store_matches const-decl "boolean" reduction_props nil) (state_matches const-decl "boolean" reduction_props nil) (state_matches? const-decl "boolean" reduction_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("reduction_props" reduction_props updateReduce_nocount_same 0 (updateReduce_nocount_same-1 nil 3700931347 ("" (skeep) (("" (use count_redundant) (("" (split -1) (("1" (propax) nil nil) ("2" (delete 2) (("2" (postpone) nil nil)) nil) ("3" (delete 2) (("3" (postpone) nil nil)) nil) ("4" (delete 2) (("4" (postpone) nil nil)) nil) ("5" (delete 2) (("5" (postpone) nil nil)) nil) ("6" (delete 2) (("6" (case-replace "updateReduce(D)(grS)`context = grS`context") (("1" (expand updateReduce_nocount) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (split) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (postpone) nil nil)) nil)) nil)) nil) ("7" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props updateReduce_nocount_same_TCC1 0 (updateReduce_nocount_same_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil reduction_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction_props" reduction_props updateReduce_nocount_TCC22 0 (updateReduce_nocount_TCC22-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC21 0 (updateReduce_nocount_TCC21-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC20 0 (updateReduce_nocount_TCC20-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC19 0 (updateReduce_nocount_TCC19-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC18 0 (updateReduce_nocount_TCC18-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC17 0 (updateReduce_nocount_TCC17-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC16 0 (updateReduce_nocount_TCC16-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC15 0 (updateReduce_nocount_TCC15-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC14 0 (updateReduce_nocount_TCC14-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC13 0 (updateReduce_nocount_TCC13-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC12 0 (updateReduce_nocount_TCC12-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC11 0 (updateReduce_nocount_TCC11-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC10 0 (updateReduce_nocount_TCC10-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC9 0 (updateReduce_nocount_TCC9-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC8 0 (updateReduce_nocount_TCC8-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC7 0 (updateReduce_nocount_TCC7-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC6 0 (updateReduce_nocount_TCC6-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC5 0 (updateReduce_nocount_TCC5-1 nil 3700931213 ("" (skeep* :preds? t) (("" (typepred "grS`stack") (("" (postpone) nil nil)) nil)) nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC4 0 (updateReduce_nocount_TCC4-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC3 0 (updateReduce_nocount_TCC3-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC2 0 (updateReduce_nocount_TCC2-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props updateReduce_nocount_TCC1 0 (updateReduce_nocount_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (updateRedex? const-decl "bool" IL nil) (goodrstate type-eq-decl nil reduction_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction_props" reduction_props stack_clear_if_marked_ref_TCC2 0 (stack_clear_if_marked_ref_TCC2-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (value? const-decl "bool" IL nil) (get const-decl "(value?)" IL nil)) nil))("reduction_props" reduction_props stack_clear_if_marked_ref_TCC1 0 (stack_clear_if_marked_ref_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (get const-decl "(value?)" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (index adt-accessor-decl "[(variable?) -> nat]" IExpression_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("reduction_props" reduction_props count_redundant_TCC1 0 (count_redundant_TCC1-1 nil 3700931213 ("" (subtype-tcc) nil nil) nil nil))("falso" falso att_test 0 (att_test-1 nil 3700571090 ("" (skeep) (("" (expand tttt) (("" (all-typepreds) (("" (grind) nil nil)) nil)) nil)) nil) ((tttt const-decl "nat" falso nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (abc_var adt-accessor-decl "[(abc?) -> {i | i + 1 = i}]" falso nil) (abc? adt-recognizer-decl "[test2 -> boolean]" falso nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (def_var adt-accessor-decl "[(def?) -> nat]" falso nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (def? adt-recognizer-decl "[test2 -> boolean]" falso nil) (test2 type-decl nil falso nil) (>= const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("falso" falso tttt_TCC1 0 (tttt_TCC1-1 nil 3700571083 ("" (subtype-tcc) nil nil) nil nil))("falso" falso test2_ord_defaxiom_TCC1 0 (test2_ord_defaxiom_TCC1-1 nil 3700571083 ("" (subtype-tcc) nil nil) nil nil))("falso" falso tccf_test 0 (tccf_test-1 nil 3701028640 ("" (skeep) (("" (name "v" "x WITH [`aa := 1, `bb := x`bb WITH [(0) |-> 1]]") (("" (name "v2" "x WITH [`aa := 1, `bb(0) |-> 1]") (("" (name "w" "v`bb") (("" (expand v -1) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("rreduction" rreduction reduce_TCC13 0 (reduce_TCC13-1 nil 3699714517 ("" (skeep* :preds? t) (("" (typepred "buildRedex(t`redex)") (("" (case "pureRedex?(redex)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((atom? const-decl "bool" IL nil) (pureRedex? const-decl "bool" IL nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (rtopstate type-eq-decl nil rreduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (cvars def-decl "finite_set[nat]" preprocess nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (vars def-decl "finite_set[nat]" IL nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (buildRedex def-decl "{K, B | fill(K, B) = A}" IL nil) (fill def-decl "IExpression" IL nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (IExpression type-decl nil IExpression_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (to_topstate_dangling application-judgement "(noDanglingRefs?)" rreduction nil) (to_topstate const-decl "rtopstate" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (pureReleaseRedex? const-decl "bool" IL nil) (releaseRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction reduce_TCC12 0 (reduce_TCC12-1 nil 3699648459 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (popRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction reduce_TCC11 0 (reduce_TCC11-1 nil 3699648459 ("" (subtype-tcc) nil nil) ((IContext type-decl nil IL nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (vars def-decl "finite_set[nat]" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (popDepth def-decl "nat" IL nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (cvars def-decl "finite_set[nat]" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (goodrstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (rtopstate type-eq-decl nil rreduction nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil) (value? const-decl "bool" IL nil) (atom? const-decl "bool" IL nil) (to_topstate const-decl "rtopstate" rreduction nil) (newrefRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (pureLetRedex? const-decl "bool" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction make_redex_ndr_TCC1 0 (make_redex_ndr_TCC1-1 nil 3701199310 ("" (subtype-tcc) nil nil) nil nil))("reduction" reduction reduce_TCC10 0 (reduce_TCC10-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (popRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction" reduction reduce_TCC9 0 (reduce_TCC9-1 nil 3699115446 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pureLetRedex? const-decl "bool" IL nil) (letRedex? const-decl "bool" IL nil) (applyRedex? const-decl "bool" IL nil) (pureIftRedex? const-decl "bool" IL nil) (iftRedex? const-decl "bool" IL nil) (updateRedex? const-decl "bool" IL nil) (lookupRedex? const-decl "bool" IL nil) (newintRedex? const-decl "bool" IL nil) (newrefRedex? const-decl "bool" IL nil) (to_topstate const-decl "topstate" reduction nil) (atom? const-decl "bool" IL nil) (value? const-decl "bool" IL nil) (buildRedexPure rec-application-judgement "{K, B |
   fill(K, B) = A AND
    ((cpure?(K) AND pureRedex?(B)) OR (K = hole AND atom?(B)))}" IL nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (goodstate type-eq-decl nil reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil)) nil))("reduction_props" reduction_props bisimulation_theorem 0 (bisimulation_theorem-1 nil 3701439594 ("" (measure-induct+ "top_releases_ct(grS`redex)" ("grS")) (("" (name-replace grS "x!1") (("" (label hrec -1) (("" (with-labels (skeep) ((ndr arm armc stm obj))) (("" (inst obj "top_releases_ct(grS`redex) + 1") (("" (case "top_releases_ct(grS`redex) > 0") (("1" (inst hrec "reduce(D)(grS)") (("1" (inst hrec D gS) (("1" (split hrec) (("1" (postpone) nil nil) ("2" (use reduce_ndr) nil nil) ("3" (use reduce_arm) (("1" (assert) nil nil) ("2" (prop) nil nil)) nil) ("4" (use reduce_arm) (("1" (prop) nil nil) ("2" (prop) nil nil)) nil) ("5" (delete obj) (("5" (expand reduce) (("5" (case "atom?(to_topstate(grS)`redex)") (("1" (delete hrec) (("1" (expand to_topstate) (("1" (case "top_releases_ct(fill(grS`context, grS`redex)) > 0") (("1" (grind) nil nil) ("2" (rewrite top_releases_ct_fill) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "pureReleaseRedex?(make_redex(to_topstate(grS))`redex)") (("1" (name-replace rS "make_redex(to_topstate(grS))") (("1" (case "pureReleaseRedex?(rS`redex)") (("1" (case "noDanglingRefs?(rS)") (("1" (case "allReleaseMarked?(rS`redex)") (("1" (lemma releaseReduce_match) (("1" (inst -1 D gS rS) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("reduction_props" reduction_props make_redex_matches 0 (make_redex_matches-1 nil 3701452316 ("" (postpone) nil nil) nil shostak))("reduction_props" reduction_props make_redex_matches_TCC2 0 (make_redex_matches_TCC2-1 nil 3701452316 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_TCC1 0 (make_redex_matches_TCC1-1 nil 3701452316 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_aux_TCC2 0 (make_redex_matches_aux_TCC2-1 nil 3701452895 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_aux_TCC1 0 (make_redex_matches_aux_TCC1-1 nil 3701452895 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props make_redex_matches_aux 0 (make_redex_matches_aux-2 "" 3701454322 ("" (induct A) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (with-labels (skeep* :preds? t) ((esc rsc ap1 ap2 ap2h rsreq atr ate relr stm obj))) (("4" (case-replace "make_redex(rS) = rS") (("1" (case-replace "make_redex_e(eS) = eS") (("1" (case "application?(eS`redex)") (("1" (hide-all-but (1 -1 esc)) (("1" (expand make_redex_e) (("1" (expand buildRedex) (("1" (assert) (("1" (replace esc :dir RL) (("1" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 rsreq rsc)) (("2" (grind) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil)) nil) nil shostak) (make_redex_matches_aux-1 nil 3701452895 ("" (induct A) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (postpone) nil nil) ("11" (postpone) nil nil) ("12" (postpone) nil nil) ("13" (postpone) nil nil) ("14" (postpone) nil nil) ("15" (postpone) nil nil) ("16" (postpone) nil nil)) nil) nil shostak))("rreduction" rreduction reduce_ndr_TCC1 0 (reduce_ndr_TCC1-1 nil 3701438337 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction is_well_typed_TCC43 0 (is_well_typed_TCC43-1 nil 3701611553 ("" (termination-tcc) nil nil) nil nil))("typed_reduction" typed_reduction is_well_typed_TCC44 0 (is_well_typed_TCC44-1 nil 3701626353 ("" (skeep :preds? t) (("" (skeep) (("" (replace -9) (("" (expand <<) (("" (rewrite some_nth) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((<< adt-def-decl "(strict_well_founded?[IExpression])" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (contextPure? def-decl "bool" IL nil) (popDepth def-decl "nat" IL nil) (vars def-decl "finite_set[nat]" IL nil) (cvars def-decl "finite_set[nat]" preprocess nil) (in_varlist const-decl "finite_set[nat]" IL nil) (variable? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (boolean nonempty-type-decl nil booleans nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (some_nth formula-decl nil finseq_theorems nil)) nil))("typed_reduction" typed_reduction ctx_type_TCC1 0 (ctx_type_TCC1-1 nil 3701633858 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[typeinfo_ctx])" typed_reduction nil)) nil))("reduction_props" reduction_props record_update_self 0 (record_update_self-1 nil 3701454374 ("" (skeep) (("" (grind) nil nil)) nil) ((estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cpure? def-decl "bool" IL nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak))("reduction_props" reduction_props record_update_self_TCC2 0 (record_update_self_TCC2-1 nil 3701454430 ("" (skeep) (("" (typepred "eS`redex") (("" (grind) nil nil)) nil)) nil) ((topstate type-eq-decl nil reduction nil) (hole adt-constructor-decl "(hole?)" IL nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (estate type-eq-decl nil reduction nil) (Store type-eq-decl nil reduction nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) nil nil nil (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (below type-eq-decl nil nat_types nil) (finite_set type-eq-decl nil finite_sets nil) (cpure? def-decl "bool" IL nil) (IContext type-decl nil IL nil) (refs def-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (emptyset const-decl "set" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("reduction_props" reduction_props record_update_self_TCC1 0 (record_update_self_TCC1-1 nil 3701454430 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (domainValue? const-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) nil (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) nil nil nil (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (Store type-eq-decl nil reduction nil) (estate type-eq-decl nil reduction nil) (hole? adt-recognizer-decl "[IContext -> boolean]" IL nil) (hole adt-constructor-decl "(hole?)" IL nil) (topstate type-eq-decl nil reduction nil)) nil))("typed_reduction" typed_reduction if_well_typed_letApply 0 (if_well_typed_letApply-1 nil 3702729592 ("" (induct arity) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (delete 2) (("3" (skeep* :preds? t) (("3" (postpone) nil nil)) nil)) nil) ("4" (delete 2) (("4" (skeep* :preds? t) (("4" (use pure_contextPure) (("4" (use pure_letApply) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (delete 2) (("5" (skeep* :preds? t) (("5" (case-replace "list2finseq[nat](args_type)`length = length(args_type)") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil)) nil) nil shostak))("typed_reduction" typed_reduction if_well_typed_letApply_TCC8 0 (if_well_typed_letApply_TCC8-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC7 0 (if_well_typed_letApply_TCC7-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC6 0 (if_well_typed_letApply_TCC6-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC5 0 (if_well_typed_letApply_TCC5-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC4 0 (if_well_typed_letApply_TCC4-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC3 0 (if_well_typed_letApply_TCC3-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC2 0 (if_well_typed_letApply_TCC2-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_reduction" typed_reduction if_well_typed_letApply_TCC1 0 (if_well_typed_letApply_TCC1-1 nil 3702672884 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction make_redex_typed_TCC7 0 (make_redex_typed_TCC7-1 nil 3702819277 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction decref_new_values_TCC3 0 (decref_new_values_TCC3-1 nil 3702831701 ("" (subtype-tcc) nil nil) nil nil))("rreduction" rreduction decref_TCC17 0 (decref_TCC17-1 nil 3698762473 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (allcount const-decl "nat" rreduction nil) (allcountStore const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC16 0 (decref_TCC16-1 nil 3698762473 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_TCC15 0 (decref_TCC15-1 nil 3692972887 ("" (skeep*) (("" (ground) (("1" (lift-if) (("1" (ground) (("1" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (replace -6 :dir RL) (("1" (case "allcountStore(newrS) <= allcountStore(rS)") (("1" (typepred "v(newrS, r, i - 1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (use allcountStore_update) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred rS) (("3" (grind) nil nil)) nil) ("4" (use allcountStore_update_TCC1) (("4" (grind-with-ext) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (ground) nil nil)) nil) ("3" (lift-if) (("3" (skeep*) (("3" (split -3) (("1" (flatten) (("1" (name-replace "newrS2" "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (typepred newrS2) (("1" (inst -3 s) (("1" (typepred "v(newrS, r, i - 1)") (("1" (inst -3 s) (("1" (hide (-8 -5 -4 -2 -1)) (("1" (flatten) (("1" (rewrite -9) (("1" (rewrite -1) (("1" (rewrite -4) (("1" (split 1) (("1" (grind) nil nil) ("2" (hide (-2 -3 -5)) (("2" (hide -4) (("2" (hide (-3 -4)) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (delete 2) (("2" (hide-all-but (1 -5 -9)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (rewrite -6) (("2" (delete 2) (("2" (use allcountStore_update) (("2" (delete -4) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("3" (rewrite -6) (("3" (delete -1 -2 -3) (("3" (typepred newrS2) (("3" (inst -3 r) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (rewrite -6) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred rS) (("3" (grind) nil nil)) nil) ("4" (use allcountStore_update_TCC1) (("4" (grind-with-ext) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (typepred "v(rS, r, i - 1)") (("1" (ground) (("1" (grind) nil nil) ("2" (inst -3 s) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (allcountStore_update_TCC1 subtype-tcc nil rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (allcountStore_update formula-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (bumpn const-decl "finite_set[nat]" IL nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (allcountStore const-decl "nat" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC14 0 (decref_TCC14-1 nil 3692915538 ("" (skeep*) (("" (lift-if) (("" (prop) (("1" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (delete -2 -3 -4) (("1" (replace -3 -1 :dir RL) (("1" (lemma allcountStore_decrease) (("1" (inst -1 "rS" "rS
                       WITH [`store(r)`seq(i - 1) := nil,
                             `count(refindex(subref))
                               := rS`count(refindex(subref)) - 1]" "refindex(subref)") (("1" (ground) (("1" (grind) nil nil)) nil) ("2" (expand refcount) (("2" (rewrite refcountStore_update) (("1" (typepred "rS`count(refindex(subref))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (lemma refcountStore_ref) (("1" (delete -4 3) (("1" (delete -2) (("1" (inst -1 "rS" "r" "refindex(subref)" "i - 1") (("1" (grind) (("1" (delete 3) (("1" (grind) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2 -5)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred rS) (("3" (grind) nil nil)) nil) ("4" (expand refcount) (("4" (rewrite refcountStore_update) (("1" (typepred "rS`count(refindex(subref))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (lemma refcountStore_ref) (("1" (inst -1 "rS" "r" "refindex(subref)" "i - 1") (("1" (delete -3) (("1" (delete 3) (("1" (grind) (("1" (delete 3) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-with-ext) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (allcountStore const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (allcount const-decl "nat" rreduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (refcountStore_update formula-decl nil rreduction nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountArray const-decl "nat" rreduction nil) (count const-decl "nat" finseq_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (allcountStore_decrease formula-decl nil rreduction nil) (bumpn const-decl "finite_set[nat]" IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC13 0 (decref_TCC13-1 nil 3692915538 ("" (skeep*) (("" (ground) (("" (lift-if) (("" (ground) (("" (typepred "v(rS
                           WITH [`store(r)`seq(i - 1) := nil,
                                 `count(refindex(subref))
                                   := rS`count(refindex(subref)) - 1],
                         refindex(subref), rS`store(refindex(subref))`length)") (("1" (hide -2 -3) (("1" (lemma "allcountStore_decrease") (("1" (inst - "rS" "rS
                                   WITH [`store(r)`seq(i - 1) := nil,
                                         `count(refindex(subref))
                                           := rS`count(refindex(subref)) - 1]" "refindex(subref)") (("1" (ground) (("1" (typepred i) (("1" (typepred "v(rS
           WITH [`store(r)`seq(i - 1) := nil,
                 `count(refindex(subref))
                   := rS`count(refindex(subref)) - 1],
         refindex(subref), rS`store(refindex(subref))`length)") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (use "decref_TCC6") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "r = refindex(subref)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (use "decref_TCC6") (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (assert) (("3" (inst?) (("3" (expand noDanglingRefs?) (("3" (typepred rS) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand refcount) (("4" (rewrite refcountStore_update) (("1" (typepred "rS`count(refindex(subref))") (("1" (rewrite -1) (("1" (expand refcount) (("1" (use refcountStore_ref) (("1" (ground) (("1" (hide-all-but (1 -4 -1)) (("1" (rewrite -2) (("1" (grind-with-ext) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 -4)) (("2" (grind-with-ext) nil nil)) nil)) nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refcountStore_ref formula-decl nil rreduction nil) (refcountStore_update formula-decl nil rreduction nil) (below type-eq-decl nil naturalnumbers nil) (count const-decl "nat" finseq_theorems nil) (refcountArray const-decl "nat" rreduction nil) (refcountStore const-decl "nat" rreduction nil) (refcountStack const-decl "nat" rreduction nil) (refcountExpr const-decl "nat" rreduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (decref_TCC6 subtype-tcc nil rreduction nil) (allcountStore_decrease formula-decl nil rreduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (allcountStore const-decl "nat" rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nil? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (nil adt-constructor-decl "(nil?)" IExpression_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC12 0 (decref_TCC12-1 nil 3692915538 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC11 0 (decref_TCC11-1 nil 3692915538 ("" (skeep*) (("" (lift-if) (("" (ground) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC10 0 (decref_TCC10-1 nil 3692915538 ("" (skeep*) (("" (rewrite -6) (("" (use allcountStore_update) (("1" (ground) (("1" (grind) nil nil) ("2" (grind-with-ext) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (< def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (allcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil naturalnumbers nil) (allcountStore_update formula-decl nil rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC9 0 (decref_TCC9-1 nil 3692915538 ("" (skeep*) (("" (lemma "allcountStore_decrease") (("" (inst?) (("" (ground) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((allcountStore_decrease formula-decl nil rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (allcountStore const-decl "nat" rreduction nil) (allcount const-decl "nat" rreduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (refcount const-decl "nat" rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC8 0 (decref_TCC8-1 nil 3692915538 ("" (skeep*) (("" (replace -6 :hide? t) (("" (assert) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC7 0 (decref_TCC7-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (noDanglingRefs? const-decl "bool" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_TCC6 0 (decref_TCC6-1 nil 3692915538 ("" (skeep*) (("" (expand "refcount") (("" (rewrite "refcountStore_update") (("1" (ground) (("1" (typepred "rS`count(subrefindex)") (("1" (replace -1 :hide? t) (("1" (expand "refcount") (("1" (use "refcountStore_ref") (("1" (ground) (("1" (case "ref(refindex(subref)) = subref") (("1" (assert) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "rS`count(subrefindex)") (("2" (expand "refcount") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (case "ref(refindex(subref)) = subref") (("1" (assert) nil nil) ("2" (apply-extensionality :hide? t) nil nil)) nil)) nil)) nil)) nil) ((refcount const-decl "nat" rreduction nil) (int_plus_int_is_int application-judgement "int" integers nil) (refcountStore_ref formula-decl nil rreduction nil) (ref? adt-recognizer-decl "[IExpression -> boolean]" IExpression_adt nil) (ref adt-constructor-decl "[nat -> (ref?)]" IExpression_adt nil) (refindex adt-accessor-decl "[(ref?) -> nat]" IExpression_adt nil) (IExpression_ref_extensionality formula-decl nil IExpression_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (noDanglingRefs? const-decl "bool" rreduction nil) (rstate type-eq-decl nil rreduction nil) (Store type-eq-decl nil reduction nil) (mark def-decl "IExpression" preprocess nil) (contextPure? def-decl "bool" IL nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (refs def-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (domainValue? const-decl "bool" IL nil) (every const-decl "bool" finseq_theorems nil) (finseq type-eq-decl nil finite_sequences nil) (Stack type-eq-decl nil IL nil) (value? const-decl "bool" IL nil) (IExpression type-decl nil IExpression_adt nil) (below type-eq-decl nil nat_types nil) (emptyset const-decl "set" sets nil) (markc def-decl "IContext" preprocess nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (cpure? def-decl "bool" IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IContext type-decl nil IL nil) (refcountStore_update formula-decl nil rreduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("rreduction" rreduction decref_TCC5 0 (decref_TCC5-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((value? const-decl "bool" IL nil) (domainValue? const-decl "bool" IL nil)) nil))("rreduction" rreduction decref_TCC4 0 (decref_TCC4-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bumpn const-decl "finite_set[nat]" IL nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil))("rreduction" rreduction decref_TCC3 0 (decref_TCC3-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (bumpn const-decl "finite_set[nat]" IL nil)) nil))("rreduction" rreduction decref_TCC2 0 (decref_TCC2-1 nil 3692915538 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IContext type-decl nil IL nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cpure? def-decl "bool" IL nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (markc def-decl "IContext" preprocess nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil nat_types nil) (IExpression type-decl nil IExpression_adt nil) (value? const-decl "bool" IL nil) (Stack type-eq-decl nil IL nil) (finseq type-eq-decl nil finite_sequences nil) (every const-decl "bool" finseq_theorems nil) (domainValue? const-decl "bool" IL nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (refs def-decl "bool" IL nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (contextPure? def-decl "bool" IL nil) (mark def-decl "IExpression" preprocess nil) (Store type-eq-decl nil reduction nil) (refcount const-decl "nat" rreduction nil) (rstate type-eq-decl nil rreduction nil) (noDanglingRefs? const-decl "bool" rreduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bumpn const-decl "finite_set[nat]" IL nil) (allcount const-decl "nat" rreduction nil) (allcountStore const-decl "nat" rreduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("typed_rreduction" typed_rreduction decref1_preserves_store_TCC2 0 (decref1_preserves_store_TCC2-1 nil 3702994821 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC11 0 (updateReduce_new_store_TCC11-1 nil 3702995511 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC10 0 (updateReduce_new_store_TCC10-1 nil 3702995511 ("" (subtype-tcc) nil nil) nil nil))("typed_rreduction" typed_rreduction updateReduce_new_store_TCC9 0 (updateReduce_new_store_TCC9-1 nil 3702993203 ("" (subtype-tcc) nil nil) nil nil))("reduction_props" reduction_props releaseReduce_reduce_match_TCC1 0 (releaseReduce_reduce_match_TCC1-1 nil 3703360180 ("" (subtype-tcc) nil nil) nil nil))("creduction" creduction nth_cdr_TCC2 0 (nth_cdr_TCC2-1 nil 3703618864 ("" (subtype-tcc) nil nil) nil nil))("creduction" creduction stack_size_at_TCC8 0 (stack_size_at_TCC8-1 nil 3703854481 ("" (skeep* :preds? t) (("" (replace -2) (("" (expand clength -) (("" (lift-if) (("" (split -) (("1" (grind) nil nil) ("2" (flatten) (("2" (split) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clength def-decl "nat" creduction nil)) nil))("rreduction" rreduction reduce_stack_length 0 (reduce_stack_length-1 nil 3703860789 ("" (skeep* :preds? t) (("" (expand reduce :assert? none) (("" (name-replace t "to_topstate(grS)") (("" (case "atom?(t`redex)") (("1" (assert) (("1" (expand t) (("1" (expand to_topstate) (("1" (rewrite popdepth_fill) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (simplify :let-reduce? t) (("2" (name-replace nS "make_redex(t)") (("2" (lift-if) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand letReduce) (("1" (assert) (("1" (expand popDepth 1 (3 4 5)) (("1" (expand popDepth 1 3) (("1" (expand push) (("1" (expand add) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand applyReduce) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (rewrite popdepth_letApply) (("1" (rewrite popDepth_mark) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand ifReduce) (("1" (expand release_marked) (("1" (assert) (("1" (expand popDepth + (3 5)) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand lookupReduce) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand release_marked) (("1" (expand setRedex) (("1" (assert) (("1" (expand popDepth + 3) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand newintReduce) (("1" (postpone) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand newrefReduce) (("1" (postpone) nil nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (flatten) (("1" (expand popReduce) (("1" (lift-if) (("1" (expand pop) (("1" (split) (("1" (flatten) (("1" (postpone) nil nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak))("creduction" creduction is_fun_call_at_TCC1 0 (is_fun_call_at_TCC1-1 nil 3703956313 ("" (subtype-tcc) nil nil) nil nil))("creduction" creduction extract_stat_TCC8 0 (extract_stat_TCC8-1 nil 3703876546 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (below type-eq-decl nil naturalnumbers nil) (executable_stat? const-decl "bool" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("creduction" creduction next_pc_TCC11 0 (next_pc_TCC11-1 nil 3703872785 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil))("creduction" creduction next_pc_TCC12 0 (next_pc_TCC12-1 nil 3703872785 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil) (clength def-decl "nat" creduction nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil)) nil))("creduction" creduction next_pc_TCC13 0 (next_pc_TCC13-1 nil 3703872785 ("" (skeep* :preds? t) (("" (lemma measure_stat_car) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_car formula-decl nil creduction nil) (clength def-decl "nat" creduction nil) (measure_stat def-decl "posnat" creduction nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (finseq2list const-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil))("creduction" creduction next_pc_TCC14 0 (next_pc_TCC14-1 nil 3703872785 ("" (skeep* :preds? t) (("" (typepred "v(car[cstat](finseq2list[cstat](stats)))(i)") (("" (replace -4) (("" (expand clength +) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq2list const-decl "list[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (below type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_stat def-decl "posnat" creduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (cstat type-decl nil creduction nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("creduction" creduction next_pc_TCC15 0 (next_pc_TCC15-1 nil 3703872785 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil)) nil))("creduction" creduction next_pc_TCC16 0 (next_pc_TCC16-1 nil 3703872785 ("" (skeep* :preds? t) (("" (split) (("1" (grind) nil nil) ("2" (replace -2) (("2" (expand clength -1) (("2" (lift-if -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq2list const-decl "list[T]" list2finseq nil) (clength def-decl "nat" creduction nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil))("creduction" creduction next_pc_TCC17 0 (next_pc_TCC17-1 nil 3703872785 ("" (skeep* :preds? t) (("" (lemma measure_stat_cdr) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_cdr formula-decl nil creduction nil) (clength def-decl "nat" creduction nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (measure_stat def-decl "posnat" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil))("creduction" creduction next_pc_TCC18 0 (next_pc_TCC18-1 nil 3703872785 ("" (skeep* :preds? t) (("" (replace -2) (("" (expand clength 3 3) (("" (typepred "v(sblock(list2finseq[cstat](cdr[cstat](finseq2list[cstat](stats)))))
       (i - clength(car[cstat](finseq2list[cstat](stats))))") (("1" (lift-if) (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (finseq2list const-decl "list[T]" list2finseq nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (list type-decl nil list_adt nil) (sblock adt-constructor-decl "[finseq[cstat] -> (sblock?)]" creduction nil) (sblock? adt-recognizer-decl "[cstat -> boolean]" creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_stat def-decl "posnat" creduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (cstat type-decl nil creduction nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clength def-decl "nat" creduction nil)) nil))("creduction" creduction next_pc_TCC19 0 (next_pc_TCC19-1 nil 3703872785 ("" (skeep* :preds? t) (("" (grind) nil nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil))("creduction" creduction reduce_TCC24 0 (reduce_TCC24-1 nil 3704041017 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "below(cS`cdefs`length)")))("creduction" creduction reduce_TCC28 0 (reduce_TCC28-1 nil 3704041017 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cfun(e1)" "below(cS`cdefs`length)")))("creduction" creduction Definition_TCC1 0 (Definition_TCC1-1 nil 3703956313 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Definition subtype "clength(s1) - 1" "below(clength(s1))")))("creduction" creduction next_pc_no_overflow_TCC1 0 (next_pc_no_overflow_TCC1-1 nil 3704119039 ("" (subtype-tcc) nil nil) nil nil (next_pc_no_overflow subtype "clength(s1) - 1" "below(clength(s1))")))("creduction" creduction is_return_at_end_clength_TCC1 0 (is_return_at_end_clength_TCC1-1 nil 3704126932 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil)) shostak (is_return_at_end_clength_ subtype "s2" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC2 0 (is_return_at_end_clength_TCC2-1 nil 3704126938 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil)) shostak (is_return_at_end_clength_ subtype "thenc" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC3 0 (is_return_at_end_clength_TCC3-1 nil 3704126942 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil)) shostak (is_return_at_end_clength_ subtype "elsec" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC4 0 (is_return_at_end_clength_TCC4-1 nil 3704126945 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil)) shostak (is_return_at_end_clength_ subtype "0" "posnat")))("creduction" creduction is_return_at_end_clength_TCC5 0 (is_return_at_end_clength_TCC5-1 nil 3704126949 ("" (postpone) nil nil) nil shostak (is_return_at_end_clength_ subtype "car(finseq2list[cstat](stats))" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction is_return_at_end_clength_TCC6 0 (is_return_at_end_clength_TCC6-1 nil 3704126877 ("" (skeep* :preds? t) (("" (postpone) nil nil)) nil) nil shostak (is_return_at_end_clength_ subtype "sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats))))" "{s1 | is_return_at_end?(s1)}")))("creduction" creduction reduce_TCC65 0 (reduce_TCC65-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (cstack_frame type-eq-decl nil creduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "lf`fdepth - 1" "nat")))("creduction" creduction stack_size_at_next_pc_TCC1 0 (stack_size_at_next_pc_TCC1-1 nil 3704131088 ("" (subtype-tcc) nil nil) nil nil (stack_size_at_next_pc subtype "next_pc(s1)(i)" "below(clength(s1))")))("creduction" creduction reduce_TCC18 0 (reduce_TCC15-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC19 0 (reduce_TCC19-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC22 0 (reduce_TCC18-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC23 0 (reduce_TCC23-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC27 0 (reduce_TCC22-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC28 0 (reduce_TCC28-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC31 0 (reduce_TCC25-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "lf`fpc + 1" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC32 0 (reduce_TCC32-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc))}")))("creduction" creduction reduce_TCC37 0 (reduce_TCC30-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "lf`fpc + 1" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC38 0 (reduce_TCC38-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(1 + lf`fpc))}")))("creduction" creduction reduce_TCC43 0 (reduce_TCC35-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC44 0 (reduce_TCC44-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC46 0 (reduce_TCC37-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC47 0 (reduce_TCC47-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC51 0 (reduce_TCC41-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC52 0 (reduce_TCC52-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC54 0 (reduce_TCC43-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC55 0 (reduce_TCC55-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC60 0 (reduce_TCC48-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC61 0 (reduce_TCC61-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC64 0 (reduce_TCC51-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC65 0 (reduce_TCC65-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC69 0 (reduce_TCC55-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC70 0 (reduce_TCC70-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC75 0 (reduce_TCC60-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC76 0 (reduce_TCC76-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC79 0 (reduce_TCC63-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(fbody)(lf`fpc)" "below(clength(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC80 0 (reduce_TCC80-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`callstack`seq(cS`callstack`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) OR (k <= cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)) AND is_return?(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(next_pc(fbody)(lf`fpc)))}")))("creduction" creduction reduce_TCC81 0 (reduce_TCC64-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (cstack_frame type-eq-decl nil creduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC84 0 (reduce_TCC67-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)" "below(clength(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body))")))("creduction" creduction reduce_TCC85 0 (reduce_TCC85-1 nil 3704129060 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "nc`seq(nc`length - 1)`fdepth" "{k: nat | k = cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body)(next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)) OR (k <= cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`arity + stack_size_at(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body)(next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)) AND is_return?(cS`cdefs`seq(nc`seq(nc`length - 1)`ffct)`body)(next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)))}")))("creduction" creduction reduce_TCC86 0 (reduce_TCC68-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "nc WITH [`seq(nc`length - 1)`fpc := next_pc(cS`cdefs`seq(nlf`ffct)`body)(nlf`fpc)]" "{C: finseq[cstack_frame(cS`cdefs)] | FORALL (i: nat | i < C`length - 1): is_fun_call_at(cS`cdefs`seq(C`seq(i)`ffct)`body)(C`seq(i)`fpc, C`seq(1 + i)`ffct)}")))("creduction" creduction stack_size_at2_alt_TCC4 0 (stack_size_at2_alt_TCC4-1 nil 3705156410 ("" (subtype-tcc) nil nil) nil nil (stack_size_at2_alt subtype "finseq2list[cstat](stats)" "(cons?[cstat])")))("creduction" creduction reduce_TCC29 0 (reduce_TCC28-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "{f: below(cS`cdefs`length) | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction reduce_TCC34 0 (reduce_TCC33-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cfun(e1)" "{f: below(cS`cdefs`length) | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction reduce_TCC5 0 (reduce_TCC6-1 nil 3704127090 ("" (skeep* :preds? t) (("" (delete 4) (("" (typepred "lf`fdepth") (("" (split) (("1" (replace -1) (("1" (assert) (("1" (lemma stack_size_at_next_pc_decl_begin) (("1" (inst?) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (use next_pc_decl_begin_no_overflow) (("3" (split) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (next_pc_decl_begin_no_overflow formula-decl nil creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_size_at_next_pc_decl_begin formula-decl nil creduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil)) nil (reduce subtype "lf`fdepth - 1" "nat")))("creduction" creduction reduce_TCC6 0 (reduce_TCC5-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC11 0 (reduce_TCC10-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC14 0 (reduce_TCC12-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC18 0 (reduce_TCC14-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (lvalue type-decl nil creduction nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC22 0 (reduce_TCC17-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC25 0 (reduce_TCC21-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC30 0 (reduce_TCC24-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC35 0 (reduce_TCC29-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC37 0 (reduce_TCC34-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC41 0 (reduce_TCC36-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (builtin_num const-decl "nat" creduction nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC43 0 (reduce_TCC40-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (lvalue type-decl nil creduction nil) (lrvalue? const-decl "bool" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC48 0 (reduce_TCC42-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (lrvalue? const-decl "bool" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC51 0 (reduce_TCC47-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (lrvalue? const-decl "bool" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC55 0 (reduce_TCC50-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC60 0 (reduce_TCC54-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC63 0 (reduce_TCC59-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC65 0 (reduce_TCC62-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (clength def-decl "nat" creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (reduce subtype "cS`callstack`length - 1" "below[cS`callstack`length]")))("creduction" creduction reduce_TCC16 0 (reduce_TCC20-1 nil 3704127090 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cS`store" "Store(IF x = cnil THEN cS`domain ELSE remove(crefindex(x), cS`domain) ENDIF)")))("creduction" creduction reduce_TCC20 0 (reduce_TCC26-1 nil 3704127090 ("" (skeep* :preds? t) (("" (case "cindex(args`seq(i)) + i < cS`stack`length") (("1" (grind) nil nil) ("2" (hide 4) (("2" (postpone) nil nil)) nil) ("3" (postpone) nil nil)) nil)) nil) nil nil (reduce subtype "cS`stack`length - 1 - i - cindex(args`seq(i))" "below[length(cS`stack)]")))("creduction" creduction reduce_TCC26 0 (reduce_TCC31-1 nil 3704127090 ("" (skeep* :preds? t) (("" (case "cindex(cargs(e1)`seq(i)) < cS`stack`length") (("1" (case "cindex(cargs(e1)`seq(i)) + i < cS`stack`length") (("1" (grind) nil nil) ("2" (hide 4) (("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) nil nil (reduce subtype "cS`stack`length - 1 - i - cindex(cargs(e1)`seq(i))" "below[length(cS`stack)]")))("creduction" creduction extra_size_at_expand_TCC1 0 (extra_size_at_expand_TCC1-1 nil 3705336017 ("" (subtype-tcc) nil nil) nil nil (extra_size_at_expand subtype "i - 1" "below(clength(s2))")))("creduction" creduction reduce_TCC32 0 (reduce_TCC29-1 nil 3705167090 ("" (skeep* :preds? t) (("" (replace -6 :dir RL) (("" (replace -7 :dir RL) (("" (expand is_fun_call_at +) (("" (flatten) (("" (replace* -8 -9 :dir RL) (("" (case "i < clength(s1)") (("1" (grind) nil nil) ("2" (typepred "extract_stat(fbody)(lf`fpc)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_fun_call_at const-decl "bool" creduction nil) (cstate type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Stack type-eq-decl nil creduction nil) (cvalue type-decl nil creduction nil) (finite_set type-eq-decl nil finite_sets nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (> const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (extract_stat def-decl "{s2, j | j < clength(s2) AND executable_stat?(s2, j)}" creduction nil) (executable_stat? const-decl "bool" creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil)) nil (reduce subtype "f" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction reduce_TCC40 0 (reduce_TCC34-1 nil 3705167090 ("" (skeep* :preds? t) (("" (case-replace "i = 2 * cargs(e1)`length") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil) ((mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (cexpr type-decl nil creduction nil) (ecall? adt-recognizer-decl "[cexpr -> boolean]" creduction nil) (below type-eq-decl nil nat_types nil) (lvalue type-decl nil creduction nil) (cvar? adt-recognizer-decl "[lvalue -> boolean]" creduction nil) (finseq type-eq-decl nil finite_sequences nil) (cargs adt-accessor-decl "[(ecall?) -> finseq[(cvar?)]]" creduction nil) (is_fun_call_at const-decl "bool" creduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (reduce subtype "cfun(e1)" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f)}")))("creduction" creduction make_call_TCC2 0 (make_call_TCC2-1 nil 3705349460 ("" (subtype-tcc) nil nil) nil nil (make_call subtype "f" "below[cS`cdefs`length]")))("creduction" creduction reduce_TCC32 0 (reduce_TCC32-1 nil 3705349460 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity}")))("creduction" creduction reduce_TCC40 0 (reduce_TCC40-1 nil 3705349460 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "cfun(e1)" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity}")))("creduction" creduction expected_stack_size_TCC1 0 (expected_stack_size_TCC1-1 nil 3705328350 ("" (skeep*) (("" (use below_finite) nil nil)) nil) ((cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (clength def-decl "nat" creduction nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below_finite formula-decl nil finite_set_theorems nil)) nil (expected_stack_size subtype "(LAMBDA i: i < C`length)" "finite_set[nat]")))("creduction" creduction reduce_TCC71 0 (reduce_TCC71-1 nil 3705328350 ("" (skeep* :preds? t) (("" (typepred "cS`stack") (("" (rewrite -1) (("" (expand expected_stack_size) (("" (use fdepth_sum_eq) (("1" (split) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "cS`stack" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1)`fdepth := lf`fdepth - 1])}")))("finite_set_theorems" finite_set_theorems pick_new_TCC2 0 (pick_new_TCC2-1 nil 3649901266 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (complement const-decl "set" sets nil)) nil (pick_new subtype "(choose! j: complement(NS)(j))" "{j | NOT NS(j)}")))("creduction" creduction clength_TCC6 0 (clength_TCC6-1 nil 3703617429 ("" (skeep*) (("" (lemma measure_stat_cdr) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_cdr formula-decl nil creduction nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (measure_stat def-decl "posnat" creduction nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil (clength termination "clength(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats)))))" "nil")))("creduction" creduction stack_size_at_TCC6 0 (stack_size_at_TCC6-1 nil 3703854481 ("" (skeep* :preds? t) (("" (lemma measure_stat_cdr) (("" (inst -1 s1) (("" (grind) nil nil)) nil)) nil)) nil) ((measure_stat_cdr formula-decl nil creduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (clength def-decl "nat" creduction nil) (finseq2list const-decl "list[T]" list2finseq nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (measure_stat def-decl "posnat" creduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Sigma def-decl "nat" finite_set_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cstat type-decl nil creduction nil)) nil (stack_size_at termination "stack_size_at(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats)))))" "nil")))("creduction" creduction stack_size_at_TCC7 0 (stack_size_at_TCC7-1 nil 3703854481 ("" (skeep* :preds? t) (("" (replace -2) (("" (expand clength -) (("" (lift-if -) (("" (split -) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clength def-decl "nat" creduction nil)) nil (stack_size_at subtype "i - clength(car(finseq2list[cstat](stats)))" "below(clength(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats))))))")))("creduction" creduction next_pc_TCC9 0 (next_pc_TCC9-1 nil 3703872785 ("" (skeep* :preds? t) (("" (typepred "v(sblock(list2finseq[cstat](cdr[cstat](finseq2list[cstat](stats)))))
        (i - clength(car[cstat](finseq2list[cstat](stats))))") (("1" (replace -3) (("1" (expand clength 2 3) (("1" (lift-if) (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (finseq2list const-decl "list[T]" list2finseq nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (list type-decl nil list_adt nil) (sblock adt-constructor-decl "[finseq[cstat] -> (sblock?)]" creduction nil) (sblock? adt-recognizer-decl "[cstat -> boolean]" creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_stat def-decl "posnat" creduction nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (cstat type-decl nil creduction nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq2list_rec def-decl "list[T]" list2finseq nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (next_pc subtype "clength(car(finseq2list[cstat](stats))) + next_pc(sblock(list2finseq[cstat](cdr(finseq2list[cstat](stats)))))(i - clength(car(finseq2list[cstat](stats))))" "upto(clength(s1))")))("creduction" creduction make_call_TCC2 0 (make_call_TCC1-1 nil 3704041017 ("" (skeep* :preds? t) (("" (case-replace "x1 = cS`callstack`length") (("1" (expand add) (("1" (typepred "cS`cdefs`seq(f)`body") (("1" (split) (("1" (split) (("1" (grind) nil nil) ("2" (propax) nil nil) ("3" (rewrite stack_size_at_zero) nil nil)) nil) ("2" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (expand add) (("2" (assert) (("2" (typepred "cS`callstack`seq(x1)`fpc") (("2" (split) (("1" (propax) nil nil) ("2" (typepred "cS`callstack`seq(x1)`fdepth") (("2" (grind) nil nil)) nil) ("3" (typepred "cS`callstack`seq(x1)`fdepth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (seq type-eq-decl nil more_finseq nil) (finseq type-eq-decl nil finite_sequences nil) (add const-decl "finseq[T]" more_finseq nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (clength def-decl "nat" creduction nil) (below type-eq-decl nil naturalnumbers nil) (is_fun_call_at const-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (> const-decl "bool" reals nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (extra_size_at const-decl "nat" creduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_size_at_zero formula-decl nil creduction nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (make_call subtype "add((# ffct := f, fpc := 0, fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)" "finseq[cstack_frame(cS`cdefs)]")))("creduction" creduction make_call_TCC3 0 (make_call_TCC3-1 nil 3704118130 ("" (skeep* :preds? t) (("" (split) (("1" (split) (("1" (skeep* :preds? t) (("1" (expand add) (("1" (assert) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (assert) (("1" (split) (("1" (grind) nil nil) ("2" (rewrite stack_size_at_zero) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "cS`callstack`seq(x1)`fdepth") (("1" (typepred "cS`callstack`seq(x1)`fpc") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep* :preds? t) (("2" (expand add) (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (simplify) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (typepred "cS`callstack") (("2" (inst -1 i) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ((rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even? const-decl "bool" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) nil nil nil (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (stack_size_at_zero formula-decl nil creduction nil) (cstat type-decl nil creduction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (clength def-decl "nat" creduction nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (vars def-decl "bool" creduction nil) (< const-decl "bool" reals nil) (is_return_at_end? def-decl "bool" creduction nil) (Definition type-eq-decl nil creduction nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (stack_size_at def-decl "nat" creduction nil) (<= const-decl "bool" reals nil) (is_return? const-decl "bool" creduction nil) (cstack_frame type-eq-decl nil creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_fun_call_at const-decl "bool" creduction nil) (finite_set type-eq-decl nil finite_sets nil) (cvalue type-decl nil creduction nil) (Stack type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Store type-eq-decl nil creduction nil) (cstate type-eq-decl nil creduction nil) (extra_size_at const-decl "nat" creduction nil) (seq type-eq-decl nil more_finseq nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (add const-decl "finseq[T]" more_finseq nil)) nil (make_call subtype "add((# ffct := f, fpc := 0, fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)" "{C: finseq[cstack_frame(cS`cdefs)] | FORALL (i: nat | i < C`length - 1): is_fun_call_at(cS`cdefs`seq(C`seq(i)`ffct)`body)(C`seq(i)`fpc, C`seq(1 + i)`ffct)}")))("creduction" creduction make_call_TCC4 0 (make_call_TCC4-1 nil 3705328350 ("" (skeep* :preds? t) (("" (typepred "cS`stack") (("" (rewrite -1) (("" (expand expected_stack_size) (("" (assert) (("" (expand add) (("" (case-replace "extra_size_at(cS`cdefs`seq
                        (cS`callstack`seq
                             (cS`callstack`length - 1)`ffct)`body)
                   (cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity") (("" (rewrite extra_size_at_zero) (("" (expand fdepth_sum) (("" (lemma sigma_add) (("" (inst -1 "LAMBDA i: i < 1 + cS`callstack`length" "LAMBDA i:
               IF i < 1 + cS`callstack`length
                 THEN add((# ffct := f,
                                      fpc := 0,
                                      fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)`seq
                          (i)`fdepth
               ELSE 0
               ENDIF" "cS`callstack`length") (("1" (split) (("1" (expand add) (("1" (rewrite -1) (("1" (assert) (("1" (case-replace "remove(cS`callstack`length,
                    LAMBDA i: i < 1 + cS`callstack`length) = LAMBDA i: i < cS`callstack`length") (("1" (lemma sigma_eq) (("1" (inst -1 "LAMBDA i: i < cS`callstack`length" "LAMBDA i:
              IF i < cS`callstack`length THEN cS`callstack`seq(i)`fdepth
              ELSE 0
              ENDIF" _) (("1" (inst -1 "LAMBDA i:
               IF i < 1 + cS`callstack`length
                 THEN add((# ffct := f,
                                      fpc := 0,
                                      fdepth := cS`cdefs`seq(f)`arity #), cS`callstack)`seq
                          (i)`fdepth
               ELSE 0
               ENDIF") (("1" (split) (("1" (expand add) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use below_finite) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (use below_finite) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cstate type-eq-decl nil creduction nil) (Store type-eq-decl nil creduction nil) (expected_stack_size const-decl "nat" creduction nil) (Stack type-eq-decl nil creduction nil) (cvalue type-decl nil creduction nil) (finite_set type-eq-decl nil finite_sets nil) (is_fun_call_at const-decl "bool" creduction nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cstack_frame type-eq-decl nil creduction nil) (is_return? const-decl "bool" creduction nil) (<= const-decl "bool" reals nil) (stack_size_at def-decl "nat" creduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (Definition type-eq-decl nil creduction nil) (is_return_at_end? def-decl "bool" creduction nil) (clength def-decl "nat" creduction nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vars def-decl "bool" creduction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cstat type-decl nil creduction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (add const-decl "finseq[T]" more_finseq nil) (extra_size_at_zero formula-decl nil creduction nil) (sigma_add formula-decl nil finite_set_theorems nil) (remove const-decl "set" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (even? const-decl "bool" integers nil) (below_finite formula-decl nil finite_set_theorems nil) (sigma_eq formula-decl nil finite_set_theorems nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (/= const-decl "boolean" notequal nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) nil (seq type-eq-decl nil more_finseq nil) nil (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (fdepth_sum const-decl "nat" creduction nil) (extra_size_at const-decl "nat" creduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (make_call subtype "cS`stack" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(add((# ffct := f, fpc := 0, fdepth := cS`cdefs`seq(f)`arity #), cS`callstack))}")))("creduction" creduction reduce_TCC5 0 (reduce_TCC5-1 nil 3705328350 ("" (skeep* :preds? t) (("" (expand add) (("" (typepred "cS`stack") (("" (rewrite -1) (("" (expand expected_stack_size) (("" (assert) (("" (replace* (-5 -6 -7 -8) :dir RL) (("" (assert) (("" (rewrite extra_size_at_next_pc) (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "add(cundef, cS`stack)" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1) := lf WITH [`fdepth := 1 + lf`fdepth, `fpc := next_pc(fbody)(lf`fpc)]])}")))("creduction" creduction reduce_TCC24 0 (reduce_TCC23-1 nil 3704127090 ("" (subtype-tcc) nil nil) ((least_out const-decl "{n | NOT NS(n)}" finite_set_theorems nil) (add const-decl "(nonempty?)" sets nil)) nil (reduce subtype "least_out(cS`domain)" "(add(least_out(cS`domain), cS`domain))")))("creduction" creduction reduce_TCC28 0 (reduce_TCC28-1 nil 3705328350 ("" (skeep* :preds? t) (("" (expand expected_stack_size) (("" (expand fdepth_sum) (("" (assert) (("" (postpone) nil nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "add(finseq_appl(cS`stack)(cS`stack`length - 1 - (i / 2) - cindex(args`seq(i / 2))), cS`stack)" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1) := cframe_next_pc(cS`cdefs)(lf)])}")))("creduction" creduction reduce_TCC36 0 (reduce_TCC36-1 nil 3705328350 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "add(finseq_appl(cS`stack)(cS`stack`length - 1 - (i / 2) - cindex(cargs(e1)`seq(i / 2))), cS`stack)" "{S: Stack | S`length = expected_stack_size(cS`cdefs)(cS`callstack WITH [`seq(cS`callstack`length - 1) := cframe_next_pc(cS`cdefs)(lf)])}")))("creduction" creduction expected_stack_size_TCC1 0 (expected_stack_size_TCC2-1 nil 3705328350 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (expected_stack_size subtype "C`length - 1" "below[C`length]")))("creduction" creduction reduce_TCC32 0 (reduce_TCC32-1 nil 3705431130 ("" (subtype-tcc) nil nil) nil nil (reduce subtype "f" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND (f < cS`cdefs`length IMPLIES extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity)}")))("creduction" creduction reduce_TCC40 0 (reduce_TCC40-1 nil 3705431130 ("" (skeep* :preds? t) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand extra_size_at) (("2" (replace* (-6 -7 -8 -9) :dir RL) (("2" (assert) (("2" (replace -12) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (reduce subtype "cfun(e1)" "{f: nat | is_fun_call_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc, f) AND (f < cS`cdefs`length IMPLIES extra_size_at(cS`cdefs`seq(cS`callstack`seq(cS`callstack`length - 1)`ffct)`body)(cS`callstack`seq(cS`callstack`length - 1)`fpc) = cS`cdefs`seq(f)`arity)}")))